<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml" lang="en">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>pyunicorn.core.data &#8212; pyunicorn 0.6.0.post1 documentation</title>
    
    <link rel="stylesheet" href="../../../_static/sphinxdoc.css" type="text/css" />
    <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../../',
        VERSION:     '0.6.0.post1',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true,
        SOURCELINK_SUFFIX: '.txt'
      };
    </script>
    <script type="text/javascript" src="../../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../../_static/doctools.js"></script>
    <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 
  </head>
  <body role="document">

<div style="background-color: white; text-align: left; padding: 10px 10px 15px 15px">
<a href="../../../index.html"><img src="../../../_static/logo.png" border="0" alt="py4sci"/></a>
</div>

    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li><a href="../../../index.html">home</a>|&nbsp;</li>
        <li><a href="../../../search.html">search</a>|&nbsp;</li>

          <li class="nav-item nav-item-1"><a href="../../index.html" accesskey="U">Module code</a> &#187;</li> 
      </ul>
    </div>

      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="../../../sitemap.html">
              <img class="logo" src="../../../_static/logo.png" alt="Logo"/>
            </a></p>
<h3><a href="../../../sitemap.html">Table Of Contents</a></h3>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../index.html">Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../download.html">Download</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../tutorials.html">Tutorials</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../methods.html">Methods</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api_doc.html">API</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../development.html">Development</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../changelog.html">Changelog</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../publications.html">Publications</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../license.html">License</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../contact.html">Contact</a></li>
</ul>

<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="../../../search.html" method="get">
      <div><input type="text" name="q" /></div>
      <div><input type="submit" value="Go" /></div>
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for pyunicorn.core.data</h1><div class="highlight"><pre>
<span></span><span class="ch">#!/usr/bin/python</span>
<span class="c1"># -*- coding: utf-8 -*-</span>
<span class="c1">#</span>
<span class="c1"># This file is part of pyunicorn.</span>
<span class="c1"># Copyright (C) 2008--2019 Jonathan F. Donges and pyunicorn authors</span>
<span class="c1"># URL: &lt;http://www.pik-potsdam.de/members/donges/software&gt;</span>
<span class="c1"># License: BSD (3-clause)</span>

<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Provides classes for analyzing spatially embedded complex networks, handling</span>
<span class="sd">multivariate data and generating time series surrogates.</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="c1">#</span>
<span class="c1">#  Imports</span>
<span class="c1">#</span>

<span class="c1">#  Import NumPy for the array object and fast numerics</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>

<span class="c1">#  Import netCDF4 for a NetCDF4 reader</span>
<span class="k">try</span><span class="p">:</span>
    <span class="kn">import</span> <span class="nn">netCDF4</span>
<span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;pyunicorn: Package netCDF4 could not be loaded. Some &quot;</span>
          <span class="s2">&quot;functionality in class Data might not be available!&quot;</span><span class="p">)</span>


<span class="kn">from</span> <span class="nn">.grid</span> <span class="k">import</span> <span class="n">Grid</span>


<span class="c1">#</span>
<span class="c1">#  Define class Data</span>
<span class="c1">#</span>

<div class="viewcode-block" id="Data"><a class="viewcode-back" href="../../../api/core/data.html#pyunicorn.core.data.Data">[docs]</a><span class="k">class</span> <span class="nc">Data</span><span class="p">:</span>

    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Encapsulates general spatio-temporal data.</span>

<span class="sd">    Also contains methods to load data from various file formats</span>
<span class="sd">    (currently NetCDF and ASCII).</span>

<span class="sd">    Mainly an abstract class.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1">#</span>
    <span class="c1">#  Define internal methods</span>
    <span class="c1">#</span>

<div class="viewcode-block" id="Data.__init__"><a class="viewcode-back" href="../../../api/core/data.html#pyunicorn.core.data.Data.__init__">[docs]</a>    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">observable</span><span class="p">,</span> <span class="n">grid</span><span class="p">,</span> <span class="n">observable_name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">observable_long_name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">window</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">silence_level</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Initialize an instance of Data.</span>

<span class="sd">        The spatio-temporal window is described by the following dictionary::</span>

<span class="sd">            window = {&quot;time_min&quot;: 0., &quot;time_max&quot;: 0., &quot;lat_min&quot;: 0.,</span>
<span class="sd">                      &quot;lat_max&quot;: 0., &quot;lon_min&quot;: 0., &quot;lon_max&quot;: 0.}</span>

<span class="sd">        :type observable: 2D array [time, index]</span>
<span class="sd">        :arg observable: The array of time series to be represented by the</span>
<span class="sd">            :class:`Data` instance.</span>
<span class="sd">        :type grid: :class:`.Grid` instance</span>
<span class="sd">        :arg grid: The Grid representing the spatial coordinates associated to</span>
<span class="sd">            the time series and their temporal sampling.</span>
<span class="sd">        :arg str observable_name: A short name for the observable.</span>
<span class="sd">        :arg str observable_long_name: A long name for the observable.</span>
<span class="sd">        :arg dict window: Spatio-temporal window to select a view on the data.</span>
<span class="sd">        :arg int silence_level: The inverse level of verbosity of the object.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">silence_level</span> <span class="o">=</span> <span class="n">silence_level</span>
        <span class="sd">&quot;&quot;&quot;(int) - The inverse level of verbosity of the object.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_full_observable</span> <span class="o">=</span> <span class="n">observable</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_full_grid</span> <span class="o">=</span> <span class="n">grid</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">grid</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="sd">&quot;&quot;&quot;The :class:`.Grid` object associated with the data.&quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">observable_name</span> <span class="o">=</span> <span class="n">observable_name</span>
        <span class="sd">&quot;&quot;&quot;(str) - The short name of the observable within</span>
<span class="sd">                      data file (particularly relevant for NetCDF).&quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">observable_long_name</span> <span class="o">=</span> <span class="n">observable_long_name</span>
        <span class="sd">&quot;&quot;&quot;(str) - The long name of the observable within data file.&quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_observable</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="sd">&quot;&quot;&quot;Current spatio-temporal view on the data.&quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">file_name</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">file_type</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">vertical_level</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="c1">#  Select a spatio-temporal window to look at the data, can later be</span>
        <span class="c1">#  changed in run time without having to reload data from a file.</span>
        <span class="c1">#  Force the calling of the Data.setWindow method, since child classes</span>
        <span class="c1">#  may overwrite this method.</span>
        <span class="k">if</span> <span class="n">window</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">Data</span><span class="o">.</span><span class="n">set_global_window</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">Data</span><span class="o">.</span><span class="n">set_window</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">window</span><span class="p">)</span></div>

<div class="viewcode-block" id="Data.__str__"><a class="viewcode-back" href="../../../api/core/data.html#pyunicorn.core.data.Data.__str__">[docs]</a>    <span class="k">def</span> <span class="nf">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return a string representation of the object.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">file_name</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">print_data_info</span><span class="p">()</span>

        <span class="k">return</span> <span class="p">(</span><span class="s1">&#39;Data: </span><span class="si">%i</span><span class="s1"> grid points, </span><span class="si">%i</span><span class="s1"> measurements.</span><span class="se">\n</span><span class="s1">&#39;</span>
                <span class="s1">&#39;Geographical boundaries:</span><span class="se">\n</span><span class="si">%s</span><span class="s1">&#39;</span><span class="p">)</span> <span class="o">%</span> <span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">N</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">n_grid_points</span><span class="p">,</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">print_boundaries</span><span class="p">())</span></div>

<div class="viewcode-block" id="Data.set_silence_level"><a class="viewcode-back" href="../../../api/core/data.html#pyunicorn.core.data.Data.set_silence_level">[docs]</a>    <span class="k">def</span> <span class="nf">set_silence_level</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">silence_level</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set the silence level.</span>

<span class="sd">        Includes dependent objects such as :attr:`grid`.</span>

<span class="sd">        :type silence_level: number (int)</span>
<span class="sd">        :arg silence_level: The inverse level of verbosity of the object.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">silence_level</span> <span class="o">=</span> <span class="n">silence_level</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">silence_level</span> <span class="o">=</span> <span class="n">silence_level</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_full_grid</span><span class="o">.</span><span class="n">silence_level</span> <span class="o">=</span> <span class="n">silence_level</span></div>

<div class="viewcode-block" id="Data.clear_cache"><a class="viewcode-back" href="../../../api/core/data.html#pyunicorn.core.data.Data.clear_cache">[docs]</a>    <span class="k">def</span> <span class="nf">clear_cache</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Clean up cache.</span>

<span class="sd">        Is reversible, since all cached information can be recalculated from</span>
<span class="sd">        basic data.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">clear_cache</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_full_grid</span><span class="o">.</span><span class="n">clear_cache</span><span class="p">()</span></div>

    <span class="c1">#</span>
    <span class="c1">#  Methods for creating Data objects and alternative constructors</span>
    <span class="c1">#</span>

    <span class="nd">@classmethod</span>
<div class="viewcode-block" id="Data.Load"><a class="viewcode-back" href="../../../api/core/data.html#pyunicorn.core.data.Data.Load">[docs]</a>    <span class="k">def</span> <span class="nf">Load</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">file_name</span><span class="p">,</span> <span class="n">observable_name</span><span class="p">,</span> <span class="n">file_type</span><span class="p">,</span> <span class="n">dimension_names</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
             <span class="n">window</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">vertical_level</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">silence_level</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Initialize an instance of Data.</span>

<span class="sd">        Supported file types ``file_type`` are:</span>
<span class="sd">          - &quot;NetCDF&quot; for regular (rectangular) grids</span>
<span class="sd">          - &quot;iNetCDF&quot; for irregular (e.g. geodesic) grids or station data.</span>

<span class="sd">        The :index:`spatio-temporal window` is described by the following</span>
<span class="sd">        dictionary::</span>

<span class="sd">            window = {&quot;time_min&quot;: 0., &quot;time_max&quot;: 0., &quot;lat_min&quot;: 0.,</span>
<span class="sd">                      &quot;lat_max&quot;: 0., &quot;lon_min&quot;: 0., &quot;lon_max&quot;: 0.}</span>

<span class="sd">        .. note::</span>
<span class="sd">            It is assumed that the NetCDF file to be loaded uses the following</span>
<span class="sd">            dimension names: lat, lon, time (e.g., as is the case for</span>
<span class="sd">            `NCEP/NCAR reanalysis 1 data &lt;http://www.esrl.noaa.</span>
<span class="sd">            gov/psd/data/gridded/data.ncep.reanalysis.html&gt;`_). These standard</span>
<span class="sd">            dimension names can be modified using the dimension_names argument.</span>
<span class="sd">            Alternatively, the standard class constructor :meth:`__init__`</span>
<span class="sd">            needs to be used after loading the data manually, e.g., employing</span>
<span class="sd">            netcdf4-python or scipy.io.netcdf functionality.</span>

<span class="sd">        :arg str file_name: The name of the data file.</span>
<span class="sd">        :arg str observable_name: The short name of the observable within data</span>
<span class="sd">            file (particularly relevant for NetCDF).</span>
<span class="sd">        :arg str file_type: The type of the data file.</span>
<span class="sd">        :arg dict dimension_names: The names of the dimensions as used in the</span>
<span class="sd">            NetCDF file. Default: {&quot;lat&quot;: &quot;lat&quot;, &quot;lon&quot;: &quot;lon&quot;, &quot;time&quot;: &quot;time&quot;}</span>
<span class="sd">        :arg dict window: Spatio-temporal window to select a view on the data.</span>
<span class="sd">        :arg int vertical_level: The vertical level to be extracted from the</span>
<span class="sd">            data file. Is ignored for horizontal data sets. If None, the first</span>
<span class="sd">            level in the data file is chosen.</span>
<span class="sd">        :arg int silence_level: The inverse level of verbosity of the object.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">dimension_names</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">dimension_names</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;lat&quot;</span><span class="p">:</span> <span class="s2">&quot;lat&quot;</span><span class="p">,</span> <span class="s2">&quot;lon&quot;</span><span class="p">:</span> <span class="s2">&quot;lon&quot;</span><span class="p">,</span> <span class="s2">&quot;time&quot;</span><span class="p">:</span> <span class="s2">&quot;time&quot;</span><span class="p">}</span>

        <span class="c1"># Import data from given file</span>
        <span class="n">res</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="n">_load_data</span><span class="p">(</span><span class="n">file_name</span><span class="p">,</span> <span class="n">file_type</span><span class="p">,</span> <span class="n">observable_name</span><span class="p">,</span>
                             <span class="n">dimension_names</span><span class="p">,</span> <span class="n">vertical_level</span><span class="p">)</span>

        <span class="c1"># Create instance of Data</span>
        <span class="n">data</span> <span class="o">=</span> <span class="bp">cls</span><span class="p">(</span><span class="n">observable</span><span class="o">=</span><span class="n">res</span><span class="p">[</span><span class="s2">&quot;observable&quot;</span><span class="p">],</span> <span class="n">grid</span><span class="o">=</span><span class="n">res</span><span class="p">[</span><span class="s2">&quot;grid&quot;</span><span class="p">],</span>
                   <span class="n">observable_name</span><span class="o">=</span><span class="n">res</span><span class="p">[</span><span class="s2">&quot;observable_name&quot;</span><span class="p">],</span>
                   <span class="n">observable_long_name</span><span class="o">=</span><span class="n">res</span><span class="p">[</span><span class="s2">&quot;observable_long_name&quot;</span><span class="p">],</span>
                   <span class="n">window</span><span class="o">=</span><span class="n">window</span><span class="p">,</span> <span class="n">silence_level</span><span class="o">=</span><span class="n">silence_level</span><span class="p">)</span>

        <span class="c1"># Set some variables</span>
        <span class="n">data</span><span class="o">.</span><span class="n">file_name</span> <span class="o">=</span> <span class="n">file_name</span>
        <span class="n">data</span><span class="o">.</span><span class="n">file_type</span> <span class="o">=</span> <span class="n">file_type</span>
        <span class="n">data</span><span class="o">.</span><span class="n">vertical_level</span> <span class="o">=</span> <span class="n">vertical_level</span>

        <span class="k">return</span> <span class="n">data</span></div>

    <span class="nd">@staticmethod</span>
<div class="viewcode-block" id="Data.SmallTestData"><a class="viewcode-back" href="../../../api/core/data.html#pyunicorn.core.data.Data.SmallTestData">[docs]</a>    <span class="k">def</span> <span class="nf">SmallTestData</span><span class="p">():</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return test data set of 6 time series with 10 sampling points each.</span>

<span class="sd">        **Example:**</span>

<span class="sd">        &gt;&gt;&gt; Data.SmallTestData().observable()</span>
<span class="sd">        array([[  0.00000000e+00,   1.00000000e+00,   1.22464680e-16,</span>
<span class="sd">                 -1.00000000e+00,  -2.44929360e-16,   1.00000000e+00],</span>
<span class="sd">               [  3.09016994e-01,   9.51056516e-01,  -3.09016994e-01,</span>
<span class="sd">                 -9.51056516e-01,   3.09016994e-01,   9.51056516e-01],</span>
<span class="sd">               [  5.87785252e-01,   8.09016994e-01,  -5.87785252e-01,</span>
<span class="sd">                 -8.09016994e-01,   5.87785252e-01,   8.09016994e-01],</span>
<span class="sd">               [  8.09016994e-01,   5.87785252e-01,  -8.09016994e-01,</span>
<span class="sd">                 -5.87785252e-01,   8.09016994e-01,   5.87785252e-01],</span>
<span class="sd">               [  9.51056516e-01,   3.09016994e-01,  -9.51056516e-01,</span>
<span class="sd">                 -3.09016994e-01,   9.51056516e-01,   3.09016994e-01],</span>
<span class="sd">               [  1.00000000e+00,   1.22464680e-16,  -1.00000000e+00,</span>
<span class="sd">                 -2.44929360e-16,   1.00000000e+00,   3.67394040e-16],</span>
<span class="sd">               [  9.51056516e-01,  -3.09016994e-01,  -9.51056516e-01,</span>
<span class="sd">                  3.09016994e-01,   9.51056516e-01,  -3.09016994e-01],</span>
<span class="sd">               [  8.09016994e-01,  -5.87785252e-01,  -8.09016994e-01,</span>
<span class="sd">                  5.87785252e-01,   8.09016994e-01,  -5.87785252e-01],</span>
<span class="sd">               [  5.87785252e-01,  -8.09016994e-01,  -5.87785252e-01,</span>
<span class="sd">                  8.09016994e-01,   5.87785252e-01,  -8.09016994e-01],</span>
<span class="sd">               [  3.09016994e-01,  -9.51056516e-01,  -3.09016994e-01,</span>
<span class="sd">                  9.51056516e-01,   3.09016994e-01,  -9.51056516e-01]])</span>

<span class="sd">        :rtype: Data instance</span>
<span class="sd">        :return: a Data instance for testing purposes.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1">#  Create time series</span>
        <span class="n">ts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">10</span><span class="p">,</span> <span class="mi">6</span><span class="p">))</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">6</span><span class="p">):</span>
            <span class="n">ts</span><span class="p">[:,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="mf">10.</span> <span class="o">+</span> <span class="n">i</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="mf">2.</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">Data</span><span class="p">(</span><span class="n">observable</span><span class="o">=</span><span class="n">ts</span><span class="p">,</span> <span class="n">grid</span><span class="o">=</span><span class="n">Grid</span><span class="o">.</span><span class="n">SmallTestGrid</span><span class="p">(),</span> <span class="n">silence_level</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span></div>

    <span class="c1">#</span>
    <span class="c1">#  Defines methods to load data from files and display related information</span>
    <span class="c1">#</span>

    <span class="nd">@classmethod</span>
<div class="viewcode-block" id="Data._get_netcdf_data"><a class="viewcode-back" href="../../../api/core/data.html#pyunicorn.core.data.Data._get_netcdf_data">[docs]</a>    <span class="k">def</span> <span class="nf">_get_netcdf_data</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">file_name</span><span class="p">,</span> <span class="n">file_type</span><span class="p">,</span> <span class="n">observable_name</span><span class="p">,</span>
                         <span class="n">dimension_names</span><span class="p">,</span> <span class="n">vertical_level</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                         <span class="n">silence_level</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Import data from a NetCDF file with a regular and rectangular grid.</span>

<span class="sd">        Supported file types ``file_type`` are:</span>
<span class="sd">          - &quot;NetCDF&quot; for regular (rectangular) grids</span>
<span class="sd">          - &quot;iNetCDF&quot; for irregular (e.g. geodesic) grids or station data</span>

<span class="sd">        :arg str file_name: The name of the data file.</span>
<span class="sd">        :arg str file_type: The format of the data file.</span>
<span class="sd">        :arg str observable_name: The short name of the observable within data</span>
<span class="sd">            file (particularly relevant for NetCDF).</span>
<span class="sd">        :arg dict dimension_names: The names of the dimensions as used in the</span>
<span class="sd">            NetCDF file. E.g., dimension_names = {&quot;lat&quot;: &quot;lat&quot;, &quot;lon&quot;: &quot;lon&quot;,</span>
<span class="sd">            &quot;time&quot;: &quot;time&quot;}.</span>
<span class="sd">        :arg int vertical_level: The vertical level to be extracted from the</span>
<span class="sd">            data file. Is ignored for horizontal data sets. If None, the first</span>
<span class="sd">            level in the data file is chosen.</span>
<span class="sd">        :arg int silence_level: The inverse level of verbosity of the object.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">silence_level</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Reading NetCDF File and converting data to NumPy array...&quot;</span><span class="p">)</span>

        <span class="c1"># Initialize dictionary of results</span>
        <span class="n">res</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="c1"># Open netCDF3 or netCDF4 file</span>
        <span class="n">f</span> <span class="o">=</span> <span class="n">netCDF4</span><span class="o">.</span><span class="n">Dataset</span><span class="p">(</span><span class="n">file_name</span><span class="p">,</span> <span class="s2">&quot;r&quot;</span><span class="p">)</span>

        <span class="c1"># Create reference to observable</span>
        <span class="n">observable</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">variables</span><span class="p">[</span><span class="n">observable_name</span><span class="p">][:]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s2">&quot;float32&quot;</span><span class="p">)</span>

        <span class="c1"># Get time axis from NetCDF file</span>
        <span class="n">time</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">variables</span><span class="p">[</span><span class="n">dimension_names</span><span class="p">[</span><span class="s2">&quot;time&quot;</span><span class="p">]][:]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s2">&quot;float32&quot;</span><span class="p">)</span>

        <span class="c1"># Get number of dimensions of data</span>
        <span class="n">n_dim</span> <span class="o">=</span> <span class="n">observable</span><span class="o">.</span><span class="n">ndim</span>

        <span class="c1"># Distinguish between regular and irregular grids</span>
        <span class="k">if</span> <span class="n">file_type</span> <span class="o">==</span> <span class="s2">&quot;NetCDF&quot;</span><span class="p">:</span>
            <span class="c1"># Create Grid instance</span>
            <span class="n">lat_grid</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">variables</span><span class="p">[</span><span class="n">dimension_names</span><span class="p">[</span><span class="s2">&quot;lat&quot;</span><span class="p">]][:]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s2">&quot;float32&quot;</span><span class="p">)</span>
            <span class="n">lon_grid</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">variables</span><span class="p">[</span><span class="n">dimension_names</span><span class="p">[</span><span class="s2">&quot;lon&quot;</span><span class="p">]][:]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s2">&quot;float32&quot;</span><span class="p">)</span>
            <span class="n">res</span><span class="p">[</span><span class="s2">&quot;grid&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">Grid</span><span class="o">.</span><span class="n">RegularGrid</span><span class="p">(</span><span class="n">time</span><span class="p">,</span> <span class="n">lat_grid</span><span class="p">,</span> <span class="n">lon_grid</span><span class="p">,</span>
                                           <span class="n">silence_level</span><span class="p">)</span>

            <span class="c1"># If 3D data set (time, lat, lon), select whole data set</span>
            <span class="k">if</span> <span class="n">n_dim</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
                <span class="n">res</span><span class="p">[</span><span class="s2">&quot;observable&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">observable</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="c1"># If 4D data set (time, level, lat, lon), select certain vertical</span>
            <span class="c1"># level.</span>
            <span class="k">elif</span> <span class="n">n_dim</span> <span class="o">==</span> <span class="mi">4</span><span class="p">:</span>
                <span class="c1"># Handle selected vertical level</span>
                <span class="k">if</span> <span class="n">vertical_level</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">level</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">level</span> <span class="o">=</span> <span class="n">vertical_level</span>

                <span class="n">res</span><span class="p">[</span><span class="s2">&quot;observable&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">observable</span><span class="p">[:,</span> <span class="n">level</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Regular NetCDF data sets with dimensions other than &quot;</span>
                      <span class="s2">&quot;3 (time, lat, lon) or 4 (time, level, lat, lon) are &quot;</span>
                      <span class="s2">&quot;not supported by Data class!&quot;</span><span class="p">)</span>

        <span class="k">elif</span> <span class="n">file_type</span> <span class="o">==</span> <span class="s2">&quot;iNetCDF&quot;</span><span class="p">:</span>
            <span class="c1"># Create Grid instance</span>
            <span class="n">lat_seq</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">variables</span><span class="p">[</span><span class="s2">&quot;grid_center_lat&quot;</span><span class="p">][:]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s2">&quot;float32&quot;</span><span class="p">)</span>
            <span class="n">lon_seq</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">variables</span><span class="p">[</span><span class="s2">&quot;grid_center_lon&quot;</span><span class="p">][:]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s2">&quot;float32&quot;</span><span class="p">)</span>
            <span class="n">res</span><span class="p">[</span><span class="s2">&quot;grid&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">Grid</span><span class="p">(</span><span class="n">time</span><span class="p">,</span> <span class="n">lat_seq</span><span class="p">,</span> <span class="n">lon_seq</span><span class="p">,</span> <span class="n">silence_level</span><span class="p">)</span>

            <span class="c1"># If 2D data set (time, index), select whole data set</span>
            <span class="k">if</span> <span class="n">n_dim</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                <span class="n">res</span><span class="p">[</span><span class="s2">&quot;observable&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">observable</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="c1"># If 3D data set (time, level, index), select certain vertical</span>
            <span class="c1"># level.</span>
            <span class="k">elif</span> <span class="n">n_dim</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
                <span class="c1"># Handle selected vertical level</span>
                <span class="k">if</span> <span class="n">vertical_level</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">level</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">level</span> <span class="o">=</span> <span class="n">vertical_level</span>

                <span class="n">res</span><span class="p">[</span><span class="s2">&quot;observable&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">observable</span><span class="p">[:,</span> <span class="n">level</span><span class="p">,</span> <span class="p">:]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Irregular NetCDF data sets with dimensions other than &quot;</span>
                      <span class="s2">&quot;2 (time, index) or 3 (time, level, index) are not &quot;</span>
                      <span class="s2">&quot;supported by Data class!&quot;</span><span class="p">)</span>

        <span class="c1"># Get length of raw data time axis</span>
        <span class="n">n_time</span> <span class="o">=</span> <span class="n">res</span><span class="p">[</span><span class="s2">&quot;observable&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="c1"># Reshape observable to comply with the standard shape (time, index)</span>
        <span class="n">res</span><span class="p">[</span><span class="s2">&quot;observable&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="n">n_time</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>

        <span class="c1"># Get long name of observable</span>
        <span class="n">res</span><span class="p">[</span><span class="s2">&quot;observable_long_name&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">variables</span><span class="p">[</span><span class="n">observable_name</span><span class="p">]</span><span class="o">.</span><span class="n">long_name</span>

        <span class="c1"># Store name of observable</span>
        <span class="n">res</span><span class="p">[</span><span class="s2">&quot;observable_name&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">observable_name</span>

        <span class="n">f</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">res</span></div>

    <span class="nd">@classmethod</span>
<div class="viewcode-block" id="Data._load_data"><a class="viewcode-back" href="../../../api/core/data.html#pyunicorn.core.data.Data._load_data">[docs]</a>    <span class="k">def</span> <span class="nf">_load_data</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">file_name</span><span class="p">,</span> <span class="n">file_type</span><span class="p">,</span> <span class="n">observable_name</span><span class="p">,</span>
                   <span class="n">dimension_names</span><span class="p">,</span> <span class="n">vertical_level</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">silence_level</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Load data into a Numpy array and create a corresponding Grid object.</span>

<span class="sd">        Supported file types ``file_type`` are:</span>
<span class="sd">          - &quot;NetCDF&quot; for regular (rectangular) grids</span>
<span class="sd">          - &quot;iNetCDF&quot; for irregular (e.g. geodesic) grids or station data</span>

<span class="sd">        :arg str file_name: The name of the data file.</span>
<span class="sd">        :arg str file_type: The format of the data file.</span>
<span class="sd">        :arg str observable_name: The short name of the observable within data</span>
<span class="sd">            file (particularly relevant for NetCDF).</span>
<span class="sd">        :arg dict dimension_names: The names of the dimensions as used in the</span>
<span class="sd">            NetCDF file. E.g., dimension_names = {&quot;lat&quot;: &quot;lat&quot;, &quot;lon&quot;: &quot;lon&quot;,</span>
<span class="sd">            &quot;time&quot;: &quot;time&quot;}.</span>
<span class="sd">        :arg int vertical_level: The vertical level to be extracted from the</span>
<span class="sd">            data file. Is ignored for horizontal data sets. If None, the first</span>
<span class="sd">            level in the data file is chosen.</span>
<span class="sd">        :arg int silence_level: The inverse level of verbosity of the object.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">file_type</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;NetCDF&quot;</span><span class="p">,</span> <span class="s2">&quot;iNetCDF&quot;</span><span class="p">]:</span>
            <span class="k">return</span> <span class="bp">cls</span><span class="o">.</span><span class="n">_get_netcdf_data</span><span class="p">(</span><span class="n">file_name</span><span class="p">,</span> <span class="n">file_type</span><span class="p">,</span> <span class="n">observable_name</span><span class="p">,</span>
                                        <span class="n">dimension_names</span><span class="p">,</span> <span class="n">vertical_level</span><span class="p">,</span>
                                        <span class="n">silence_level</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">silence_level</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;This file type can currently not be read &quot;</span>
                      <span class="s2">&quot;by pyunicorn.&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="kc">None</span></div>

<div class="viewcode-block" id="Data.print_data_info"><a class="viewcode-back" href="../../../api/core/data.html#pyunicorn.core.data.Data.print_data_info">[docs]</a>    <span class="k">def</span> <span class="nf">print_data_info</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Print information on the data encapsulated by the Data object.&quot;&quot;&quot;</span>
        <span class="c1"># Open netCDF3 or netCDF4 file</span>
        <span class="n">f</span> <span class="o">=</span> <span class="n">netCDF4</span><span class="o">.</span><span class="n">Dataset</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">file_name</span><span class="p">,</span> <span class="s2">&quot;r&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;File format:&quot;</span><span class="p">,</span> <span class="n">f</span><span class="o">.</span><span class="n">file_format</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Global attributes:&quot;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">f</span><span class="o">.</span><span class="n">ncattrs</span><span class="p">():</span>
            <span class="nb">print</span><span class="p">(</span><span class="n">name</span> <span class="o">+</span> <span class="s2">&quot;:&quot;</span><span class="p">,</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">name</span><span class="p">))</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Variables (size):&quot;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">obj</span> <span class="ow">in</span> <span class="n">f</span><span class="o">.</span><span class="n">variables</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2"> (</span><span class="si">%i</span><span class="s2">)&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">obj</span><span class="p">)))</span>
        <span class="n">f</span><span class="o">.</span><span class="n">close</span><span class="p">()</span></div>

<div class="viewcode-block" id="Data.observable"><a class="viewcode-back" href="../../../api/core/data.html#pyunicorn.core.data.Data.observable">[docs]</a>    <span class="k">def</span> <span class="nf">observable</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the current spatio-temporal view on the data.</span>

<span class="sd">        **Example:**</span>

<span class="sd">        &gt;&gt;&gt; Data.SmallTestData().observable()[0,:]</span>
<span class="sd">        array([  0.00000000e+00,   1.00000000e+00,   1.22464680e-16,</span>
<span class="sd">                -1.00000000e+00,  -2.44929360e-16,   1.00000000e+00])</span>

<span class="sd">        :rtype: 2D Numpy array [time, space]</span>
<span class="sd">        :return: the current spatio-temporal view on the data.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_observable</span></div>

    <span class="c1">#</span>
    <span class="c1">#  Defines methods for windowing the data</span>
    <span class="c1">#</span>

<div class="viewcode-block" id="Data.window"><a class="viewcode-back" href="../../../api/core/data.html#pyunicorn.core.data.Data.window">[docs]</a>    <span class="k">def</span> <span class="nf">window</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the current spatio-temporal window.</span>

<span class="sd">        **Examples:**</span>

<span class="sd">        &gt;&gt;&gt; Data.SmallTestData().window()[&quot;lon_min&quot;]</span>
<span class="sd">        2.5</span>

<span class="sd">        &gt;&gt;&gt; Data.SmallTestData().window()[&quot;lon_max&quot;]</span>
<span class="sd">        15.0</span>

<span class="sd">        :rtype: dictionary</span>
<span class="sd">        :return: the current spatio-temporal window.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">boundaries</span><span class="p">()</span></div>

<div class="viewcode-block" id="Data.set_window"><a class="viewcode-back" href="../../../api/core/data.html#pyunicorn.core.data.Data.set_window">[docs]</a>    <span class="k">def</span> <span class="nf">set_window</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">window</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Select a rectangular spatio-temporal region from the data set.</span>

<span class="sd">        Create a data array as well as a corresponding Grid object to access</span>
<span class="sd">        this window.</span>

<span class="sd">        The time axis of the underlying raw data is assumed to be ordered and</span>
<span class="sd">        increasing. The latitude and longitude sequences can be arbitrarily</span>
<span class="sd">        chosen, i.e., no ordering and no regular grid is required.</span>

<span class="sd">        The spatio-temporal window is described by the following dictionary::</span>

<span class="sd">           window = {&quot;time_min&quot;: 0., &quot;time_max&quot;: 0., &quot;lat_min&quot;: 0.,</span>
<span class="sd">                     &quot;lat_max&quot;: 0., &quot;lon_min&quot;: 0., &quot;lon_max&quot;: 0.}</span>

<span class="sd">        If the temporal boundaries are equal, the data&#39;s full time range is</span>
<span class="sd">        selected. If any of the two corresponding spatial boundaries are</span>
<span class="sd">        equal, the data&#39;s full spatial extension is included.</span>

<span class="sd">        **Example:**</span>

<span class="sd">        &gt;&gt;&gt; data = Data.SmallTestData()</span>
<span class="sd">        &gt;&gt;&gt; data.set_window(window={</span>
<span class="sd">        ...     &quot;time_min&quot;: 0., &quot;time_max&quot;: 4., &quot;lat_min&quot;: 10.,</span>
<span class="sd">        ...     &quot;lat_max&quot;: 20., &quot;lon_min&quot;: 5., &quot;lon_max&quot;: 10.})</span>
<span class="sd">        &gt;&gt;&gt; data.observable()</span>
<span class="sd">        array([[  1.22464680e-16,  -1.00000000e+00],</span>
<span class="sd">               [ -3.09016994e-01,  -9.51056516e-01],</span>
<span class="sd">               [ -5.87785252e-01,  -8.09016994e-01],</span>
<span class="sd">               [ -8.09016994e-01,  -5.87785252e-01],</span>
<span class="sd">               [ -9.51056516e-01,  -3.09016994e-01]])</span>

<span class="sd">        :type window: dictionary</span>
<span class="sd">        :arg window: A spatio-temporal window to select a view on the data.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Collect arrays</span>
        <span class="n">full_time</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_full_grid</span><span class="o">.</span><span class="n">grid</span><span class="p">()[</span><span class="s2">&quot;time&quot;</span><span class="p">]</span>
        <span class="n">full_lat_seq</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_full_grid</span><span class="o">.</span><span class="n">grid</span><span class="p">()[</span><span class="s2">&quot;lat&quot;</span><span class="p">]</span>
        <span class="n">full_lon_seq</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_full_grid</span><span class="o">.</span><span class="n">grid</span><span class="p">()[</span><span class="s2">&quot;lon&quot;</span><span class="p">]</span>

        <span class="c1"># Get time indices for temporal window boundaries</span>
        <span class="k">if</span> <span class="n">window</span><span class="p">[</span><span class="s2">&quot;time_min&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="n">window</span><span class="p">[</span><span class="s2">&quot;time_max&quot;</span><span class="p">]:</span>
            <span class="c1"># If boundaries time are equal, use all available time points</span>
            <span class="n">time_indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="kc">True</span><span class="p">,</span>
                                     <span class="bp">self</span><span class="o">.</span><span class="n">_full_grid</span><span class="o">.</span><span class="n">grid_size</span><span class="p">()[</span><span class="s2">&quot;time&quot;</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Get indices for chosen time boundaries</span>
            <span class="n">time_indices</span> <span class="o">=</span> <span class="p">(</span><span class="n">full_time</span> <span class="o">&gt;=</span> <span class="n">window</span><span class="p">[</span><span class="s2">&quot;time_min&quot;</span><span class="p">])</span> <span class="o">&amp;</span> \
                           <span class="p">(</span><span class="n">full_time</span> <span class="o">&lt;=</span> <span class="n">window</span><span class="p">[</span><span class="s2">&quot;time_max&quot;</span><span class="p">])</span>

        <span class="c1"># Get indices of nodes lying within the prescribed spatial</span>
        <span class="c1"># window boundaries</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">window</span><span class="p">[</span><span class="s2">&quot;lat_min&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="n">window</span><span class="p">[</span><span class="s2">&quot;lat_max&quot;</span><span class="p">])</span> \
           <span class="ow">or</span> <span class="p">(</span><span class="n">window</span><span class="p">[</span><span class="s2">&quot;lon_min&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="n">window</span><span class="p">[</span><span class="s2">&quot;lon_max&quot;</span><span class="p">]):</span>
            <span class="c1"># If boundaries in latitude or longitude are equal, use all nodes</span>
            <span class="c1"># from the full spatial grid.</span>
            <span class="c1"># space_indices is an array of bool indicating whether a node</span>
            <span class="c1"># lies within the window or not.</span>
            <span class="n">space_indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="kc">True</span><span class="p">,</span>
                                      <span class="bp">self</span><span class="o">.</span><span class="n">_full_grid</span><span class="o">.</span><span class="n">grid_size</span><span class="p">()[</span><span class="s2">&quot;space&quot;</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># space_indices is an array of bool indicating whether a node</span>
            <span class="c1"># lies within the window or not.</span>
            <span class="n">space_indices</span> <span class="o">=</span> <span class="p">(</span><span class="n">full_lat_seq</span> <span class="o">&gt;=</span> <span class="n">window</span><span class="p">[</span><span class="s2">&quot;lat_min&quot;</span><span class="p">])</span> <span class="o">&amp;</span> \
                            <span class="p">(</span><span class="n">full_lat_seq</span> <span class="o">&lt;=</span> <span class="n">window</span><span class="p">[</span><span class="s2">&quot;lat_max&quot;</span><span class="p">])</span> <span class="o">&amp;</span> \
                            <span class="p">(</span><span class="n">full_lon_seq</span> <span class="o">&gt;=</span> <span class="n">window</span><span class="p">[</span><span class="s2">&quot;lon_min&quot;</span><span class="p">])</span> <span class="o">&amp;</span> \
                            <span class="p">(</span><span class="n">full_lon_seq</span> <span class="o">&lt;=</span> <span class="n">window</span><span class="p">[</span><span class="s2">&quot;lon_max&quot;</span><span class="p">])</span>

        <span class="c1"># Set windowed observable and grid object</span>
        <span class="n">time</span> <span class="o">=</span> <span class="n">full_time</span><span class="p">[</span><span class="n">time_indices</span><span class="p">]</span>
        <span class="n">lat_seq</span> <span class="o">=</span> <span class="n">full_lat_seq</span><span class="p">[</span><span class="n">space_indices</span><span class="p">]</span>
        <span class="n">lon_seq</span> <span class="o">=</span> <span class="n">full_lon_seq</span><span class="p">[</span><span class="n">space_indices</span><span class="p">]</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_observable</span> <span class="o">=</span> \
            <span class="bp">self</span><span class="o">.</span><span class="n">_full_observable</span><span class="p">[</span><span class="n">time_indices</span><span class="p">,</span> <span class="p">:][:,</span> <span class="n">space_indices</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">grid</span> <span class="o">=</span> <span class="n">Grid</span><span class="p">(</span><span class="n">time</span><span class="p">,</span> <span class="n">lat_seq</span><span class="p">,</span> <span class="n">lon_seq</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">silence_level</span><span class="p">)</span></div>

<div class="viewcode-block" id="Data.set_global_window"><a class="viewcode-back" href="../../../api/core/data.html#pyunicorn.core.data.Data.set_global_window">[docs]</a>    <span class="k">def</span> <span class="nf">set_global_window</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set the view on the whole data set.</span>

<span class="sd">        Select the full data set and creates a data array as well as</span>
<span class="sd">        a corresponding Grid object to access this window from outside.</span>

<span class="sd">        **Example** (Set smaller window and subsequently restore global</span>
<span class="sd">        window):</span>

<span class="sd">        &gt;&gt;&gt; data = Data.SmallTestData()</span>
<span class="sd">        &gt;&gt;&gt; data.set_window(window={&quot;time_min&quot;: 0., &quot;time_max&quot;: 4.,</span>
<span class="sd">        ...                 &quot;lat_min&quot;: 10., &quot;lat_max&quot;: 20., &quot;lon_min&quot;: 5.,</span>
<span class="sd">        ...                 &quot;lon_max&quot;: 10.})</span>
<span class="sd">        &gt;&gt;&gt; data.grid.grid()[&quot;lat&quot;]</span>
<span class="sd">        array([ 10.,  15.], dtype=float32)</span>
<span class="sd">        &gt;&gt;&gt; data.set_global_window()</span>
<span class="sd">        &gt;&gt;&gt; data.grid.grid()[&quot;lat&quot;]</span>
<span class="sd">        array([  0.,   5.,  10.,  15.,  20.,  25.], dtype=float32)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">global_window</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;time_min&quot;</span><span class="p">:</span> <span class="mf">0.</span><span class="p">,</span> <span class="s2">&quot;time_max&quot;</span><span class="p">:</span> <span class="mf">0.</span><span class="p">,</span> <span class="s2">&quot;lat_min&quot;</span><span class="p">:</span> <span class="mf">0.</span><span class="p">,</span>
                         <span class="s2">&quot;lat_max&quot;</span><span class="p">:</span> <span class="mf">0.</span><span class="p">,</span> <span class="s2">&quot;lon_min&quot;</span><span class="p">:</span> <span class="mf">0.</span><span class="p">,</span> <span class="s2">&quot;lon_max&quot;</span><span class="p">:</span> <span class="mf">0.</span><span class="p">}</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">set_window</span><span class="p">(</span><span class="n">global_window</span><span class="p">)</span></div>

    <span class="c1">#</span>
    <span class="c1"># Define methods for reformatting data</span>
    <span class="c1">#</span>

    <span class="c1"># TODO: Documentation.</span>
    <span class="nd">@staticmethod</span>
<div class="viewcode-block" id="Data.rescale"><a class="viewcode-back" href="../../../api/core/data.html#pyunicorn.core.data.Data.rescale">[docs]</a>    <span class="k">def</span> <span class="nf">rescale</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="n">var_type</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Rescale an array to a given data type.</span>

<span class="sd">        Returns the tuple</span>
<span class="sd">        (scaled_array, scale_factor, add_offset, actual_range).</span>
<span class="sd">        Allows flexible handling of final amount of</span>
<span class="sd">        used storage volume for the file.</span>

<span class="sd">        :type array:</span>
<span class="sd">        :arg array:</span>

<span class="sd">        :arg str var_type: Determines the desired final data type of the array.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># TODO: Add example</span>

        <span class="n">ar_max</span> <span class="o">=</span> <span class="n">array</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>
        <span class="n">ar_min</span> <span class="o">=</span> <span class="n">array</span><span class="o">.</span><span class="n">min</span><span class="p">()</span>
        <span class="n">actual_range</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">ar_min</span><span class="p">,</span> <span class="n">ar_max</span><span class="p">])</span>

        <span class="k">if</span> <span class="n">var_type</span> <span class="o">==</span> <span class="s1">&#39;float64&#39;</span><span class="p">:</span>
            <span class="n">scaled_array</span> <span class="o">=</span> <span class="n">array</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;float64&#39;</span><span class="p">)</span>
            <span class="n">scale_factor</span> <span class="o">=</span> <span class="mf">1.</span>
            <span class="n">add_offset</span> <span class="o">=</span> <span class="mf">0.</span>
        <span class="k">elif</span> <span class="n">var_type</span> <span class="o">==</span> <span class="s1">&#39;float32&#39;</span><span class="p">:</span>
            <span class="n">scaled_array</span> <span class="o">=</span> <span class="n">array</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;float32&#39;</span><span class="p">)</span>
            <span class="n">scale_factor</span> <span class="o">=</span> <span class="mf">1.</span>
            <span class="n">add_offset</span> <span class="o">=</span> <span class="mf">0.</span>
        <span class="k">elif</span> <span class="n">var_type</span> <span class="o">==</span> <span class="s1">&#39;int32&#39;</span><span class="p">:</span>
            <span class="n">scale_factor</span> <span class="o">=</span> <span class="p">(</span><span class="n">ar_max</span> <span class="o">-</span> <span class="n">ar_min</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="mf">2.</span> <span class="o">*</span> <span class="mf">2.</span> <span class="o">**</span> <span class="mi">31</span> <span class="o">-</span> <span class="mf">2.</span><span class="p">)</span>
            <span class="n">add_offset</span> <span class="o">=</span> <span class="p">(</span><span class="n">ar_max</span> <span class="o">+</span> <span class="n">ar_min</span><span class="p">)</span> <span class="o">/</span> <span class="mf">2.</span>
            <span class="n">array</span> <span class="o">-=</span> <span class="n">add_offset</span>
            <span class="n">array</span> <span class="o">/=</span> <span class="n">scale_factor</span>
            <span class="n">scaled_array</span> <span class="o">=</span> <span class="n">array</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s2">&quot;int32&quot;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">var_type</span> <span class="o">==</span> <span class="s1">&#39;int16&#39;</span><span class="p">:</span>
            <span class="n">scale_factor</span> <span class="o">=</span> <span class="p">(</span><span class="n">ar_max</span> <span class="o">-</span> <span class="n">ar_min</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="mf">2.</span> <span class="o">*</span> <span class="mf">2.</span> <span class="o">**</span> <span class="mi">15</span> <span class="o">-</span> <span class="mf">2.</span><span class="p">)</span>
            <span class="n">add_offset</span> <span class="o">=</span> <span class="p">(</span><span class="n">ar_max</span> <span class="o">+</span> <span class="n">ar_min</span><span class="p">)</span> <span class="o">/</span> <span class="mf">2.</span>
            <span class="n">array</span> <span class="o">-=</span> <span class="n">add_offset</span>
            <span class="n">array</span> <span class="o">/=</span> <span class="n">scale_factor</span>
            <span class="n">scaled_array</span> <span class="o">=</span> <span class="n">array</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;int16&#39;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">var_type</span> <span class="o">==</span> <span class="s1">&#39;uint8&#39;</span><span class="p">:</span>
            <span class="n">scale_factor</span> <span class="o">=</span> <span class="p">(</span><span class="n">ar_max</span> <span class="o">-</span> <span class="n">ar_min</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="mf">2.</span> <span class="o">**</span> <span class="mi">8</span> <span class="o">-</span> <span class="mf">1.</span><span class="p">)</span>
            <span class="n">add_offset</span> <span class="o">=</span> <span class="n">ar_min</span>
            <span class="n">array</span> <span class="o">-=</span> <span class="n">add_offset</span>
            <span class="n">array</span> <span class="o">/=</span> <span class="n">scale_factor</span>
            <span class="n">scaled_array</span> <span class="o">=</span> <span class="n">array</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;uint8&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Data type </span><span class="si">%s</span><span class="s2"> variable </span><span class="si">%s</span><span class="s2"> for rescaling array &quot;</span>
                  <span class="s2">&quot;not supported!&quot;</span> <span class="o">%</span> <span class="n">var_type</span><span class="p">)</span>
            <span class="n">scale_factor</span> <span class="o">=</span> <span class="mf">1.</span>
            <span class="n">add_offset</span> <span class="o">=</span> <span class="mf">0.</span>

        <span class="k">return</span> <span class="p">(</span><span class="n">scaled_array</span><span class="p">,</span> <span class="n">scale_factor</span><span class="p">,</span> <span class="n">add_offset</span><span class="p">,</span> <span class="n">actual_range</span><span class="p">)</span></div>

    <span class="c1">#</span>
    <span class="c1">#  Define methods to prepare data for similarity measure calculation</span>
    <span class="c1">#</span>

    <span class="nd">@staticmethod</span>
<div class="viewcode-block" id="Data.normalize_time_series_array"><a class="viewcode-back" href="../../../api/core/data.html#pyunicorn.core.data.Data.normalize_time_series_array">[docs]</a>    <span class="k">def</span> <span class="nf">normalize_time_series_array</span><span class="p">(</span><span class="n">time_series_array</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :index:`Normalize &lt;pair: normalize; time series array&gt;` an array of</span>
<span class="sd">        time series to zero mean and unit variance individually for each</span>
<span class="sd">        individual time series.</span>

<span class="sd">        Works also for complex valued time series.</span>

<span class="sd">        **Modifies the given array in place!**</span>

<span class="sd">        **Example:**</span>

<span class="sd">        &gt;&gt;&gt; ts = np.arange(16).reshape(4,4).astype(&quot;float&quot;)</span>
<span class="sd">        &gt;&gt;&gt; Data.normalize_time_series_array(ts)</span>
<span class="sd">        &gt;&gt;&gt; ts.mean(axis=0)</span>
<span class="sd">        array([ 0.,  0.,  0.,  0.])</span>
<span class="sd">        &gt;&gt;&gt; ts.std(axis=0)</span>
<span class="sd">        array([ 1.,  1.,  1.,  1.])</span>
<span class="sd">        &gt;&gt;&gt; ts[:,0]</span>
<span class="sd">        array([-1.34164079, -0.4472136 ,  0.4472136 ,  1.34164079])</span>

<span class="sd">        :type time_series_array: 2D Numpy array [time, index]</span>
<span class="sd">        :arg time_series_array: The time series array to be normalized.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1">#  Remove mean value from time series at each node (grid point)</span>
        <span class="n">time_series_array</span> <span class="o">-=</span> <span class="n">time_series_array</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

        <span class="c1">#  Normalize the variance of anomalies to one</span>
        <span class="n">time_series_array</span> <span class="o">/=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span>
            <span class="p">(</span><span class="n">time_series_array</span> <span class="o">*</span> <span class="n">time_series_array</span><span class="o">.</span><span class="n">conjugate</span><span class="p">())</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">))</span>

        <span class="c1">#  Correct for grid points with zero variance in their time series</span>
        <span class="n">time_series_array</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">time_series_array</span><span class="p">)]</span> <span class="o">=</span> <span class="mi">0</span></div>

    <span class="nd">@staticmethod</span>
<div class="viewcode-block" id="Data.next_power_2"><a class="viewcode-back" href="../../../api/core/data.html#pyunicorn.core.data.Data.next_power_2">[docs]</a>    <span class="k">def</span> <span class="nf">next_power_2</span><span class="p">(</span><span class="n">i</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the power of two 2^n, that is greater or equal than i.</span>

<span class="sd">        **Example:**</span>

<span class="sd">        &gt;&gt;&gt; Data.next_power_2(253)</span>
<span class="sd">        256</span>

<span class="sd">        :type i: number (float)</span>
<span class="sd">        :arg i: Some real number.</span>

<span class="sd">        :rtype: number (float)</span>
<span class="sd">        :return: the power of two greater of equal than a given value.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">n</span> <span class="o">=</span> <span class="mi">2</span>
        <span class="k">while</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="n">i</span><span class="p">:</span>
            <span class="n">n</span> <span class="o">=</span> <span class="n">n</span> <span class="o">*</span> <span class="mi">2</span>

        <span class="k">return</span> <span class="n">n</span></div>

    <span class="nd">@staticmethod</span>
<div class="viewcode-block" id="Data.zero_pad_data"><a class="viewcode-back" href="../../../api/core/data.html#pyunicorn.core.data.Data.zero_pad_data">[docs]</a>    <span class="k">def</span> <span class="nf">zero_pad_data</span><span class="p">(</span><span class="n">data</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return :index:`zero padded data`, such that the length of individual</span>
<span class="sd">        time series is a power of 2.</span>

<span class="sd">        **Example:**</span>

<span class="sd">        &gt;&gt;&gt; ts = np.arange(20).reshape(5,4)</span>
<span class="sd">        &gt;&gt;&gt; Data.zero_pad_data(ts)</span>
<span class="sd">        array([[  0.,   0.,   0.,   0.], [  0.,   1.,   2.,   3.],</span>
<span class="sd">               [  4.,   5.,   6.,   7.], [  8.,   9.,  10.,  11.],</span>
<span class="sd">               [ 12.,  13.,  14.,  15.], [ 16.,  17.,  18.,  19.],</span>
<span class="sd">               [  0.,   0.,   0.,   0.], [  0.,   0.,   0.,   0.]])</span>

<span class="sd">        :type data: 2D Numpy array [time, index]</span>
<span class="sd">        :arg data: The data array to be zero padded.</span>

<span class="sd">        :rtype: 2D Numpy array [time, index]</span>
<span class="sd">        :return: the zero padded data array.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="p">(</span><span class="n">n_time</span><span class="p">,</span> <span class="n">n_nodes</span><span class="p">)</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span>

        <span class="c1">#  Get the power of n that is larger or equal than the length of</span>
        <span class="c1">#  individual time series.</span>
        <span class="n">n</span> <span class="o">=</span> <span class="n">Data</span><span class="o">.</span><span class="n">next_power_2</span><span class="p">(</span><span class="n">n_time</span><span class="p">)</span>

        <span class="n">zeros_before</span> <span class="o">=</span> <span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="n">n_time</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span>
        <span class="n">zeros_after</span> <span class="o">=</span> <span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="n">n_time</span><span class="p">)</span> <span class="o">-</span> <span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="n">n_time</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span>

        <span class="n">before</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">zeros_before</span><span class="p">,</span> <span class="n">n_nodes</span><span class="p">))</span>
        <span class="n">after</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">zeros_after</span><span class="p">,</span> <span class="n">n_nodes</span><span class="p">))</span>

        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">before</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">after</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span></div>

    <span class="nd">@staticmethod</span>
<div class="viewcode-block" id="Data.cos_window"><a class="viewcode-back" href="../../../api/core/data.html#pyunicorn.core.data.Data.cos_window">[docs]</a>    <span class="k">def</span> <span class="nf">cos_window</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">gamma</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a cosine window fitting the shape of the data argument.</span>

<span class="sd">        The window is one for most of the time and goes to zero at the</span>
<span class="sd">        boundaries of each time series in the data array.</span>

<span class="sd">        The width of the cosine shaped decay region is controlled by the shape</span>
<span class="sd">        parameter gamma:</span>

<span class="sd">          - Gamma=1 means, that each of the two decay regions extends over</span>
<span class="sd">            half of the time series.</span>
<span class="sd">          - Gamma=0 means, that the decay regions vanish and the window</span>
<span class="sd">            transformation becomes the identity.</span>

<span class="sd">        **Example:**</span>

<span class="sd">        &gt;&gt;&gt; ts = np.arange(24).reshape(12,2)</span>
<span class="sd">        &gt;&gt;&gt; Data.cos_window(data=ts, gamma=0.75)</span>
<span class="sd">        array([[ 0.        ,  0.        ], [ 0.14644661,  0.14644661],</span>
<span class="sd">               [ 0.5       ,  0.5       ], [ 0.85355339,  0.85355339],</span>
<span class="sd">               [ 1.        ,  1.        ], [ 1.        ,  1.        ],</span>
<span class="sd">               [ 1.        ,  1.        ], [ 1.        ,  1.        ],</span>
<span class="sd">               [ 0.85355339,  0.85355339], [ 0.5       ,  0.5       ],</span>
<span class="sd">               [ 0.14644661,  0.14644661], [ 0.        ,  0.        ]])</span>

<span class="sd">        :type data: 2D Numpy array [time, index]</span>
<span class="sd">        :arg data: The data array to be fitted by cosine window.</span>

<span class="sd">        :type gamma: number (float)</span>
<span class="sd">        :arg gamma: The cosine window shape parameter.</span>

<span class="sd">        :rtype: 2D Numpy array [time, index]</span>
<span class="sd">        :return: the cosine window fitting data array.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="p">(</span><span class="n">n_time</span><span class="p">,</span> <span class="n">n_nodes</span><span class="p">)</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span>

        <span class="c1">#  Calculate length of decay regions</span>
        <span class="n">decay_length</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">gamma</span> <span class="o">*</span> <span class="n">n_time</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span>

        <span class="c1">#  Calculate decay and growth regions</span>
        <span class="n">growth_region</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">decay_length</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="nb">float</span><span class="p">(</span><span class="n">decay_length</span><span class="p">)</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">))</span>
        <span class="n">growth_region</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="n">growth_region</span><span class="p">,</span> <span class="p">(</span><span class="n">n_nodes</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
        <span class="n">growth_region</span> <span class="o">=</span> <span class="n">growth_region</span><span class="o">.</span><span class="n">transpose</span><span class="p">()</span>

        <span class="n">decay_region</span> <span class="o">=</span> <span class="n">growth_region</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">growth_region</span><span class="p">,</span>
                               <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="n">n_time</span> <span class="o">-</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">decay_length</span><span class="p">,</span> <span class="n">n_nodes</span><span class="p">)),</span>
                               <span class="n">decay_region</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span></div></div>
</pre></div>

          </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li><a href="../../../index.html">home</a>|&nbsp;</li>
        <li><a href="../../../search.html">search</a>|&nbsp;</li>

          <li class="nav-item nav-item-1"><a href="../../index.html" >Module code</a> &#187;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2008-2019, Jonathan F. Donges and pyunicorn authors.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.5.6.
    </div>
  </body>
</html>