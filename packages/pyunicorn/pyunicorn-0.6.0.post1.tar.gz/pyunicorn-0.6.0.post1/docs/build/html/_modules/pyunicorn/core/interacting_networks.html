<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml" lang="en">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>pyunicorn.core.interacting_networks &#8212; pyunicorn 0.6.0.post1 documentation</title>
    
    <link rel="stylesheet" href="../../../_static/sphinxdoc.css" type="text/css" />
    <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../../',
        VERSION:     '0.6.0.post1',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true,
        SOURCELINK_SUFFIX: '.txt'
      };
    </script>
    <script type="text/javascript" src="../../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../../_static/doctools.js"></script>
    <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 
  </head>
  <body role="document">

<div style="background-color: white; text-align: left; padding: 10px 10px 15px 15px">
<a href="../../../index.html"><img src="../../../_static/logo.png" border="0" alt="py4sci"/></a>
</div>

    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li><a href="../../../index.html">home</a>|&nbsp;</li>
        <li><a href="../../../search.html">search</a>|&nbsp;</li>

          <li class="nav-item nav-item-1"><a href="../../index.html" accesskey="U">Module code</a> &#187;</li> 
      </ul>
    </div>

      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="../../../sitemap.html">
              <img class="logo" src="../../../_static/logo.png" alt="Logo"/>
            </a></p>
<h3><a href="../../../sitemap.html">Table Of Contents</a></h3>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../index.html">Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../download.html">Download</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../tutorials.html">Tutorials</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../methods.html">Methods</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api_doc.html">API</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../development.html">Development</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../changelog.html">Changelog</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../publications.html">Publications</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../license.html">License</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../contact.html">Contact</a></li>
</ul>

<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="../../../search.html" method="get">
      <div><input type="text" name="q" /></div>
      <div><input type="submit" value="Go" /></div>
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for pyunicorn.core.interacting_networks</h1><div class="highlight"><pre>
<span></span><span class="ch">#!/usr/bin/python</span>
<span class="c1"># -*- coding: utf-8 -*-</span>
<span class="c1">#</span>
<span class="c1"># This file is part of pyunicorn.</span>
<span class="c1"># Copyright (C) 2008--2019 Jonathan F. Donges and pyunicorn authors</span>
<span class="c1"># URL: &lt;http://www.pik-potsdam.de/members/donges/software&gt;</span>
<span class="c1"># License: BSD (3-clause)</span>

<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Provides classes for analyzing spatially embedded complex networks, handling</span>
<span class="sd">multivariate data and generating time series surrogates.</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="c1">#  Import NumPy for the array object and fast numerics</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">numpy</span> <span class="k">import</span> <span class="n">random</span>

<span class="kn">from</span> <span class="nn">._ext.numerics</span> <span class="k">import</span> <span class="n">_randomlySetCrossLinks</span><span class="p">,</span> <span class="n">_randomlyRewireCrossLinks</span><span class="p">,</span> \
    <span class="n">_cross_transitivity</span><span class="p">,</span> <span class="n">_nsi_cross_transitivity</span><span class="p">,</span> <span class="n">_cross_local_clustering</span><span class="p">,</span> \
    <span class="n">_nsi_cross_local_clustering</span>

<span class="c1">#  Import Network base class</span>
<span class="kn">from</span> <span class="nn">.network</span> <span class="k">import</span> <span class="n">Network</span><span class="p">,</span> <span class="n">NetworkError</span>


<span class="c1">#</span>
<span class="c1">#  Define class InteractingNetworks</span>
<span class="c1">#</span>

<div class="viewcode-block" id="InteractingNetworks"><a class="viewcode-back" href="../../../api/core/interacting_networks.html#pyunicorn.core.interacting_networks.InteractingNetworks">[docs]</a><span class="k">class</span> <span class="nc">InteractingNetworks</span><span class="p">(</span><span class="n">Network</span><span class="p">):</span>

    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Encapsulates an ensemble of interacting networks.</span>

<span class="sd">    Provides measures to analyze the interaction topology of different pairs of</span>
<span class="sd">    subnetworks (groups of vertices).</span>

<span class="sd">    So far, most methods only give meaningful results for undirected networks!</span>

<span class="sd">    The idea of interacting networks and measures for their analysis are</span>
<span class="sd">    described in [Donges2011a]_.</span>

<span class="sd">    Consistently node-weighted measures for interacting network topologies are</span>
<span class="sd">    derived, described and applied in [Wiedermann2011]_.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1">#</span>
    <span class="c1">#  Definitions of internal methods</span>
    <span class="c1">#</span>

<div class="viewcode-block" id="InteractingNetworks.__init__"><a class="viewcode-back" href="../../../api/core/interacting_networks.html#pyunicorn.core.interacting_networks.InteractingNetworks.__init__">[docs]</a>    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">adjacency</span><span class="p">,</span> <span class="n">directed</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">node_weights</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">silence_level</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Initialize an instance of InteractingNetworks.</span>

<span class="sd">        :type adjacency: square numpy array or list [node,node] of 0s and 1s</span>
<span class="sd">        :arg  adjacency: Adjacency matrix of the new network.  Entry [i,j]</span>
<span class="sd">            indicates whether node i links to node j.  Its diagonal must be</span>
<span class="sd">            zero.  Must be symmetric if directed=False.</span>
<span class="sd">        :arg bool directed: Indicates whether the network shall be considered</span>
<span class="sd">            as directed. If False, adjacency must be symmetric.</span>
<span class="sd">        :type node_weights: 1d numpy array or list [node] of floats &gt;= 0</span>
<span class="sd">        :arg  node_weights: Optional array or list of node weights to be used</span>
<span class="sd">            for node splitting invariant network measures.  Entry [i] is the</span>
<span class="sd">            weight of node i.  (Default: list of ones)</span>
<span class="sd">        :arg int silence_level: The inverse level of verbosity of the object.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1">#  Call constructor of parent class Network</span>
        <span class="n">Network</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">adjacency</span><span class="o">=</span><span class="n">adjacency</span><span class="p">,</span> <span class="n">directed</span><span class="o">=</span><span class="n">directed</span><span class="p">,</span>
                         <span class="n">node_weights</span><span class="o">=</span><span class="n">node_weights</span><span class="p">,</span>
                         <span class="n">silence_level</span><span class="o">=</span><span class="n">silence_level</span><span class="p">)</span></div>

<div class="viewcode-block" id="InteractingNetworks.__str__"><a class="viewcode-back" href="../../../api/core/interacting_networks.html#pyunicorn.core.interacting_networks.InteractingNetworks.__str__">[docs]</a>    <span class="k">def</span> <span class="nf">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a string representation of InteractingNetworks object.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="s1">&#39;InteractingNetworks:</span><span class="se">\n</span><span class="s1">&#39;</span> <span class="o">+</span> <span class="n">Network</span><span class="o">.</span><span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span></div>

    <span class="c1">#</span>
    <span class="c1">#  Graph generation methods</span>
    <span class="c1">#</span>

    <span class="nd">@staticmethod</span>
<div class="viewcode-block" id="InteractingNetworks.SmallTestNetwork"><a class="viewcode-back" href="../../../api/core/interacting_networks.html#pyunicorn.core.interacting_networks.InteractingNetworks.SmallTestNetwork">[docs]</a>    <span class="k">def</span> <span class="nf">SmallTestNetwork</span><span class="p">():</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a 6-node undirected test network.</span>

<span class="sd">        The network looks like this::</span>

<span class="sd">                3 - 1</span>
<span class="sd">                |   | \\</span>
<span class="sd">            5 - 0 - 4 - 2</span>

<span class="sd">        :rtype: InteractingNetworks instance</span>
<span class="sd">        :return: an InteractingNetworks instance for testing purposes.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">nw</span> <span class="o">=</span> <span class="n">InteractingNetworks</span><span class="p">(</span><span class="n">adjacency</span><span class="o">=</span><span class="p">[[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span>
                                            <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
                                            <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
                                            <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
                                            <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
                                            <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]],</span>
                                 <span class="n">directed</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                 <span class="n">node_weights</span><span class="o">=</span><span class="p">[</span><span class="mf">0.6</span><span class="p">,</span> <span class="mf">0.8</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">1.2</span><span class="p">,</span> <span class="mf">1.4</span><span class="p">,</span> <span class="mf">1.6</span><span class="p">],</span>
                                 <span class="n">silence_level</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
        <span class="n">link_weights</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mf">1.3</span><span class="p">,</span> <span class="mf">2.5</span><span class="p">,</span> <span class="mf">1.1</span><span class="p">],</span>
                                 <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mf">2.3</span><span class="p">,</span> <span class="mf">2.9</span><span class="p">,</span> <span class="mf">2.7</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
                                 <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mf">2.3</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mf">1.5</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
                                 <span class="p">[</span><span class="mf">1.3</span><span class="p">,</span> <span class="mf">2.9</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
                                 <span class="p">[</span><span class="mf">2.5</span><span class="p">,</span> <span class="mf">2.7</span><span class="p">,</span> <span class="mf">1.5</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
                                 <span class="p">[</span><span class="mf">1.1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]])</span>
        <span class="n">nw</span><span class="o">.</span><span class="n">set_link_attribute</span><span class="p">(</span><span class="s2">&quot;link_weights&quot;</span><span class="p">,</span> <span class="n">link_weights</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">nw</span></div>

    <span class="nd">@staticmethod</span>
<div class="viewcode-block" id="InteractingNetworks.SmallDirectedTestNetwork"><a class="viewcode-back" href="../../../api/core/interacting_networks.html#pyunicorn.core.interacting_networks.InteractingNetworks.SmallDirectedTestNetwork">[docs]</a>    <span class="k">def</span> <span class="nf">SmallDirectedTestNetwork</span><span class="p">():</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a 6-node directed test network with node and edge weights.</span>

<span class="sd">        The node weights are [1.5, 1.7, 1.9, 2.1, 2.3, 2.5],</span>
<span class="sd">        a typical node weight for corrected n.s.i. measures would be 2.0.</span>

<span class="sd">        :rtype: InteractingNetworks instance</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">nw</span> <span class="o">=</span> <span class="n">InteractingNetworks</span><span class="p">(</span><span class="n">adjacency</span><span class="o">=</span><span class="p">[[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
                                            <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
                                            <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
                                            <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
                                            <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
                                            <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]],</span>
                                 <span class="n">directed</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                                 <span class="n">node_weights</span><span class="o">=</span><span class="p">[</span><span class="mf">0.6</span><span class="p">,</span> <span class="mf">0.8</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">1.2</span><span class="p">,</span> <span class="mf">1.4</span><span class="p">,</span> <span class="mf">1.6</span><span class="p">],</span>
                                 <span class="n">silence_level</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">nw</span><span class="o">.</span><span class="n">set_link_attribute</span><span class="p">(</span><span class="s2">&quot;link_weights&quot;</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="mf">1.3</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mf">2.5</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
                                                        <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mf">1.9</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
                                                        <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
                                                        <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mf">3.0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
                                                        <span class="p">[</span><span class="mf">2.1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mf">2.7</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
                                                        <span class="p">[</span><span class="mf">1.5</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]]))</span>
        <span class="k">return</span> <span class="n">nw</span></div>

    <span class="nd">@staticmethod</span>
<div class="viewcode-block" id="InteractingNetworks.RandomlySetCrossLinks"><a class="viewcode-back" href="../../../api/core/interacting_networks.html#pyunicorn.core.interacting_networks.InteractingNetworks.RandomlySetCrossLinks">[docs]</a>    <span class="k">def</span> <span class="nf">RandomlySetCrossLinks</span><span class="p">(</span><span class="n">network</span><span class="p">,</span> <span class="n">node_list1</span><span class="p">,</span> <span class="n">node_list2</span><span class="p">,</span>
                              <span class="n">cross_link_density</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                              <span class="n">number_cross_links</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Creates a set of random cross links between the considered</span>
<span class="sd">        interacting subnetworks. The number of cross links to be set</span>
<span class="sd">        can be chosen either explicitly or via a predefined cross link density.</span>
<span class="sd">        By not choosing any of either, a null model is created under</span>
<span class="sd">        preservation of the cross link density of the initial network.</span>

<span class="sd">        Implementation:</span>

<span class="sd">        Determines the number of cross links to be set.</span>
<span class="sd">        Creates an empty cross adjacency matrix.</span>
<span class="sd">        Randomly picks the coordinates of an entry and sets it to one.</span>
<span class="sd">        Repeats the procedure until the desired cross link density</span>
<span class="sd">        is reached.</span>

<span class="sd">        :type network: InteractingNetworks instance</span>
<span class="sd">        :arg network: The base network for setting random cross links.</span>
<span class="sd">        :arg [int] node_list1: list of node indices describing the first</span>
<span class="sd">            subnetwork</span>
<span class="sd">        :arg [int] node_list2: list of node indices describing the second</span>
<span class="sd">            subnetwork</span>
<span class="sd">        :rtype:  :class:`InteractingNetworks`</span>
<span class="sd">        :return: The initial InteractingNetworks with random cross links</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1">#  store node lists as arrays</span>
        <span class="n">nodes1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">node_list1</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
        <span class="n">nodes2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">node_list2</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
        <span class="c1">#  retrieve number of nodes</span>
        <span class="n">N1</span><span class="p">,</span> <span class="n">N2</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">nodes1</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">nodes2</span><span class="p">)</span>
        <span class="c1">#  retrieve cross adjacency matrix</span>
        <span class="n">cross_A</span> <span class="o">=</span> <span class="n">network</span><span class="o">.</span><span class="n">cross_adjacency</span><span class="p">(</span><span class="n">nodes1</span><span class="p">,</span> <span class="n">nodes2</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>

        <span class="c1">#  determine number of cross links</span>
        <span class="k">if</span> <span class="n">cross_link_density</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">number_cross_links</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">cross_link_density</span> <span class="o">*</span> <span class="p">(</span><span class="n">N1</span> <span class="o">*</span> <span class="n">N2</span><span class="p">))</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Setting number of cross links according to &quot;</span>
                  <span class="s2">&quot;chosen link density.&quot;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">cross_link_density</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">number_cross_links</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">number_cross_links</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">cross_A</span><span class="o">.</span><span class="n">sum</span><span class="p">())</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Creating a null model for the given interacting networks.&quot;</span><span class="p">)</span>
        <span class="c1">#  else: take the explicitly chosen number of cross links</span>
        <span class="k">if</span> <span class="n">number_cross_links</span> <span class="o">&gt;</span> <span class="p">(</span><span class="n">N1</span> <span class="o">*</span> <span class="n">N2</span><span class="p">):</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;The number of cross links exceeds maximum.&quot;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Setting link density of initial interacting network.&quot;</span><span class="p">)</span>
            <span class="n">number_cross_links</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">cross_A</span><span class="o">.</span><span class="n">sum</span><span class="p">())</span>

        <span class="c1">#  retrieve adjacency matrix of the full interacting network</span>
        <span class="n">A_new</span> <span class="o">=</span> <span class="n">network</span><span class="o">.</span><span class="n">adjacency</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
        <span class="c1">#  create new empty cross adjacency matrix</span>
        <span class="n">cross_A_new</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">N1</span><span class="p">,</span> <span class="n">N2</span><span class="p">))</span>

        <span class="n">_randomlySetCrossLinks</span><span class="p">(</span><span class="n">A_new</span><span class="p">,</span> <span class="n">cross_A_new</span><span class="p">,</span> <span class="n">number_cross_links</span><span class="p">,</span>
                               <span class="n">nodes1</span><span class="p">,</span> <span class="n">nodes2</span><span class="p">,</span> <span class="n">N1</span><span class="p">,</span> <span class="n">N2</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">InteractingNetworks</span><span class="p">(</span><span class="n">adjacency</span><span class="o">=</span><span class="n">A_new</span><span class="p">,</span>
                                   <span class="n">directed</span><span class="o">=</span><span class="n">network</span><span class="o">.</span><span class="n">directed</span><span class="p">,</span>
                                   <span class="n">node_weights</span><span class="o">=</span><span class="n">network</span><span class="o">.</span><span class="n">node_weights</span><span class="p">,</span>
                                   <span class="n">silence_level</span><span class="o">=</span><span class="n">network</span><span class="o">.</span><span class="n">silence_level</span><span class="p">)</span></div>

    <span class="nd">@staticmethod</span>
<div class="viewcode-block" id="InteractingNetworks.RandomlySetCrossLinks_sparse"><a class="viewcode-back" href="../../../api/core/interacting_networks.html#pyunicorn.core.interacting_networks.InteractingNetworks.RandomlySetCrossLinks_sparse">[docs]</a>    <span class="k">def</span> <span class="nf">RandomlySetCrossLinks_sparse</span><span class="p">(</span><span class="n">network</span><span class="p">,</span> <span class="n">node_list1</span><span class="p">,</span> <span class="n">node_list2</span><span class="p">,</span>
                                     <span class="n">cross_link_density</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                                     <span class="n">number_cross_links</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Creates a set of random cross links between the considered</span>
<span class="sd">        interacting subnetworks. The number of cross links to be set</span>
<span class="sd">        can be chosen either explicitly or via a predefined cross link density.</span>
<span class="sd">        By not choosing any of either, a null model is created under</span>
<span class="sd">        preservation of the cross link density of the initial network.</span>

<span class="sd">        Implementation:</span>

<span class="sd">        Determines the number of cross links to be set.</span>
<span class="sd">        Creates an empty cross adjacency matrix.</span>
<span class="sd">        Randomly picks the coordinates of an entry and sets it to one.</span>
<span class="sd">        Repeats the procedure until the desired cross link density</span>
<span class="sd">        is reached.</span>

<span class="sd">        :type network: InteractingNetworks instance</span>
<span class="sd">        :arg network: The base network for setting random cross links.</span>
<span class="sd">        :arg [int] node_list1: list of node indices describing the first</span>
<span class="sd">            subnetwork</span>
<span class="sd">        :arg [int] node_list2: list of node indices describing the second</span>
<span class="sd">            subnetwork</span>
<span class="sd">        :rtype:  :class:`InteractingNetworks`</span>
<span class="sd">        :return: The initial InteractingNetworks with random cross links</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1">#  store node lists as arrays</span>
        <span class="n">nodes1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">node_list1</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
        <span class="n">nodes2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">node_list2</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
        <span class="c1">#  retrieve number of nodes</span>
        <span class="n">N1</span><span class="p">,</span> <span class="n">N2</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">nodes1</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">nodes2</span><span class="p">)</span>
        <span class="c1">#  retrieve cross adjacency matrix</span>
        <span class="n">cross_A</span> <span class="o">=</span> <span class="n">network</span><span class="o">.</span><span class="n">cross_adjacency_sparse</span><span class="p">(</span><span class="n">nodes1</span><span class="p">,</span> <span class="n">nodes2</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>

        <span class="c1">#  determine number of cross links</span>
        <span class="k">if</span> <span class="n">cross_link_density</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">number_cross_links</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">cross_link_density</span> <span class="o">*</span> <span class="p">(</span><span class="n">N1</span> <span class="o">*</span> <span class="n">N2</span><span class="p">))</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Setting number of cross links according to chosen </span><span class="se">\</span>
<span class="s2">                  link density.&quot;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">cross_link_density</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">number_cross_links</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">number_cross_links</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">sum</span><span class="p">(</span><span class="n">cross_A</span><span class="o">.</span><span class="n">values</span><span class="p">()))</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Creating a null model for the given interacting networks.&quot;</span><span class="p">)</span>
        <span class="c1">#  else: take the explicitly chosen number of cross links</span>

        <span class="k">if</span> <span class="n">number_cross_links</span> <span class="o">&gt;</span> <span class="p">(</span><span class="n">N1</span> <span class="o">*</span> <span class="n">N2</span><span class="p">):</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;The number of cross links exceeds maximum.&quot;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Setting link density of initial interacting network.&quot;</span><span class="p">)</span>
            <span class="n">number_cross_links</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">sum</span><span class="p">(</span><span class="n">cross_A</span><span class="o">.</span><span class="n">values</span><span class="p">()))</span>

        <span class="c1">#  retrieve adjacency matrix of the full interacting network</span>
        <span class="n">A_new</span> <span class="o">=</span> <span class="n">network</span><span class="o">.</span><span class="n">sp_A</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
        <span class="c1">#  create new empty cross adjacency matrix</span>
        <span class="n">cross_A_new</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">N1</span><span class="p">,</span> <span class="n">N2</span><span class="p">))</span>

        <span class="n">n_1</span><span class="p">,</span> <span class="n">n_2</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span>
        <span class="n">node1</span><span class="p">,</span> <span class="n">node2</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">number_cross_links</span><span class="p">):</span>
            <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
                <span class="n">n_1</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="p">()</span> <span class="o">*</span> <span class="n">N1</span><span class="p">)</span>
                <span class="n">n_2</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="p">()</span> <span class="o">*</span> <span class="n">N2</span><span class="p">)</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">cross_A_new</span><span class="p">[</span><span class="n">n_1</span><span class="p">,</span> <span class="n">n_2</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">):</span>
                    <span class="k">break</span>
            <span class="n">cross_A_new</span><span class="p">[</span><span class="n">n_1</span><span class="p">,</span> <span class="n">n_2</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N1</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N2</span><span class="p">):</span>
                <span class="n">node1</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">nodes1</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
                <span class="n">node2</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">nodes2</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>
                <span class="n">A_new</span><span class="p">[</span><span class="n">node1</span><span class="p">,</span> <span class="n">node2</span><span class="p">]</span> <span class="o">=</span> <span class="n">cross_A_new</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span>
                <span class="n">A_new</span><span class="p">[</span><span class="n">node2</span><span class="p">,</span> <span class="n">node1</span><span class="p">]</span> <span class="o">=</span> <span class="n">cross_A_new</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">InteractingNetworks</span><span class="p">(</span><span class="n">adjacency</span><span class="o">=</span><span class="n">A_new</span><span class="p">,</span>
                                   <span class="n">directed</span><span class="o">=</span><span class="n">network</span><span class="o">.</span><span class="n">directed</span><span class="p">,</span>
                                   <span class="n">node_weights</span><span class="o">=</span><span class="n">network</span><span class="o">.</span><span class="n">node_weights</span><span class="p">,</span>
                                   <span class="n">silence_level</span><span class="o">=</span><span class="n">network</span><span class="o">.</span><span class="n">silence_level</span><span class="p">)</span></div>

    <span class="nd">@staticmethod</span>
<div class="viewcode-block" id="InteractingNetworks.RandomlyRewireCrossLinks"><a class="viewcode-back" href="../../../api/core/interacting_networks.html#pyunicorn.core.interacting_networks.InteractingNetworks.RandomlyRewireCrossLinks">[docs]</a>    <span class="k">def</span> <span class="nf">RandomlyRewireCrossLinks</span><span class="p">(</span><span class="n">network</span><span class="p">,</span> <span class="n">node_list1</span><span class="p">,</span> <span class="n">node_list2</span><span class="p">,</span> <span class="n">swaps</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Randomize the cross links between two subnetworks under preservation of</span>
<span class="sd">        cross degree centrality of both subnetworks.</span>

<span class="sd">        Chooses randomly two cross links and swaps their ending points in</span>
<span class="sd">        subnetwork 2.</span>

<span class="sd">        Implementation:</span>

<span class="sd">        Stores the coordinates of the &quot;1&quot;-entries of the cross adjacency matrix</span>
<span class="sd">        in a tuple. Chooses randomly two entries of the tuple (ergo two cross</span>
<span class="sd">        links) allowing for the constraints that</span>

<span class="sd">        (1) the chosen links have distinct starting points in subnetwork 1 and</span>
<span class="sd">            distinct ending points in subnetwork 2</span>
<span class="sd">        (2) there do not exist intermediate links such that starting point of</span>
<span class="sd">            link 1 is connected to ending point of link 2 and vice versa.</span>

<span class="sd">        [In case two links have the same starting point or / and the same</span>
<span class="sd">        ending point, condition (2) is never satisfied. Therefore only</span>
<span class="sd">        condition (2) is implemented.]</span>

<span class="sd">        Swaps the ending points of the links in subnetwork 2 and overwrites the</span>
<span class="sd">        coordinates of the initial links in the tuple. The number of</span>
<span class="sd">        permutation procedures is determined by the &quot;swaps&quot; argument and the</span>
<span class="sd">        initial number of cross links. Creates a new adjacency matrix out of</span>
<span class="sd">        the altered tuple of coordinates.</span>

<span class="sd">        **Example** (Degree and cross degree sequences should be the same after</span>
<span class="sd">        rewiring):</span>

<span class="sd">        &gt;&gt;&gt; net = InteractingNetworks.SmallTestNetwork()</span>
<span class="sd">        &gt;&gt;&gt; print(&quot;Degree:&quot;, net.degree())</span>
<span class="sd">        Degree: [3 3 2 2 3 1]</span>
<span class="sd">        &gt;&gt;&gt; print(&quot;Cross degree:&quot;, net.cross_degree(</span>
<span class="sd">        ...     node_list1=[0,3,5], node_list2=[1,2,4]))</span>
<span class="sd">        Cross degree: [1 1 0]</span>
<span class="sd">        &gt;&gt;&gt; rewired_net = net.RandomlyRewireCrossLinks(</span>
<span class="sd">        ...     network=net, node_list1=[0,3,5],</span>
<span class="sd">        ...     node_list2=[1,2,4], swaps=10.)</span>
<span class="sd">        &gt;&gt;&gt; print(&quot;Degree:&quot;, rewired_net.degree())</span>
<span class="sd">        Degree: [3 3 2 2 3 1]</span>
<span class="sd">        &gt;&gt;&gt; print(&quot;Cross degree:&quot;, rewired_net.cross_degree(</span>
<span class="sd">        ...     node_list1=[0,3,5], node_list2=[1,2,4]))</span>
<span class="sd">        Cross degree: [1 1 0]</span>

<span class="sd">        :type network: :class:`InteractingNetworks` instance</span>
<span class="sd">        :arg network: The base network for rewiring cross links.</span>
<span class="sd">        :arg [int] node_list1: list of node indices describing the first</span>
<span class="sd">            subnetwork</span>
<span class="sd">        :arg [int] node_list2: list of node indices describing the second</span>
<span class="sd">            subnetwork</span>
<span class="sd">        :arg float internal: Gives the fraction number_swaps /</span>
<span class="sd">            number_cross_links.</span>
<span class="sd">        :rtype:  :class:`InteractingNetworks`</span>
<span class="sd">        :return: The initial InteractingNetworks with swapped cross links</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1">#  retrieve cross adjacency matrix of the considered interacting</span>
        <span class="c1">#  network</span>
        <span class="n">cross_A</span> <span class="o">=</span> <span class="n">network</span><span class="o">.</span><span class="n">cross_adjacency</span><span class="p">(</span><span class="n">node_list1</span><span class="p">,</span> <span class="n">node_list2</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
        <span class="c1">#  determine number of cross links</span>
        <span class="n">number_cross_links</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">cross_A</span><span class="o">.</span><span class="n">sum</span><span class="p">())</span>
        <span class="c1">#  Store node lists as arrays</span>
        <span class="n">nodes1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">node_list1</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
        <span class="n">nodes2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">node_list2</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
        <span class="c1">#  retrieve adjacency matrix of the full interacting network</span>
        <span class="n">A_new</span> <span class="o">=</span> <span class="n">network</span><span class="o">.</span><span class="n">adjacency</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
        <span class="c1">#  determine number of cross link permutations that will be performed</span>
        <span class="n">number_swaps</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">swaps</span> <span class="o">*</span> <span class="n">number_cross_links</span><span class="p">)</span>
        <span class="c1">#  Create list of cross links</span>
        <span class="n">cross_links</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">cross_A</span><span class="o">.</span><span class="n">nonzero</span><span class="p">())</span><span class="o">.</span><span class="n">transpose</span><span class="p">()</span>

        <span class="n">_randomlyRewireCrossLinks</span><span class="p">(</span><span class="n">A_new</span><span class="p">,</span> <span class="n">cross_A</span><span class="p">,</span> <span class="n">cross_links</span><span class="p">,</span> <span class="n">nodes1</span><span class="p">,</span> <span class="n">nodes2</span><span class="p">,</span>
                                  <span class="n">number_cross_links</span><span class="p">,</span> <span class="n">number_swaps</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">InteractingNetworks</span><span class="p">(</span><span class="n">adjacency</span><span class="o">=</span><span class="n">A_new</span><span class="p">,</span>
                                   <span class="n">directed</span><span class="o">=</span><span class="n">network</span><span class="o">.</span><span class="n">directed</span><span class="p">,</span>
                                   <span class="n">node_weights</span><span class="o">=</span><span class="n">network</span><span class="o">.</span><span class="n">node_weights</span><span class="p">,</span>
                                   <span class="n">silence_level</span><span class="o">=</span><span class="n">network</span><span class="o">.</span><span class="n">silence_level</span><span class="p">)</span></div>

    <span class="c1">#</span>
    <span class="c1">#  Define methods for handling the interacting networks</span>
    <span class="c1">#</span>

<div class="viewcode-block" id="InteractingNetworks.subnetwork"><a class="viewcode-back" href="../../../api/core/interacting_networks.html#pyunicorn.core.interacting_networks.InteractingNetworks.subnetwork">[docs]</a>    <span class="k">def</span> <span class="nf">subnetwork</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node_list</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the subnetwork induced by a subset of nodes as a Network object.</span>

<span class="sd">        This can be used to conveniently analyze the subnetwork separately,</span>
<span class="sd">        e.g., for calculation network measures solely this subnetwork.</span>

<span class="sd">        :arg [int] node_list: list of node indices describing the subnetwork</span>
<span class="sd">        :rtype: Network</span>
<span class="sd">        :return: the subnetwork induced by the nodes in node_list.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">Network</span><span class="p">(</span><span class="n">adjacency</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">internal_adjacency</span><span class="p">(</span><span class="n">node_list</span><span class="p">),</span>
                       <span class="n">directed</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">directed</span><span class="p">,</span>
                       <span class="n">node_weights</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">node_weights</span><span class="p">[</span><span class="n">node_list</span><span class="p">],</span>
                       <span class="n">silence_level</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">silence_level</span><span class="p">)</span></div>

<div class="viewcode-block" id="InteractingNetworks.internal_adjacency"><a class="viewcode-back" href="../../../api/core/interacting_networks.html#pyunicorn.core.interacting_networks.InteractingNetworks.internal_adjacency">[docs]</a>    <span class="k">def</span> <span class="nf">internal_adjacency</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node_list</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the adjacency matrix of a subnetwork induced by a subset of</span>
<span class="sd">        nodes.</span>

<span class="sd">        **Examples:**</span>

<span class="sd">        &gt;&gt;&gt; InteractingNetworks.SmallTestNetwork().\</span>
<span class="sd">                internal_adjacency([0,3,5])</span>
<span class="sd">        array([[0, 1, 1], [1, 0, 0], [1, 0, 0]], dtype=int8)</span>
<span class="sd">        &gt;&gt;&gt; InteractingNetworks.SmallTestNetwork().\</span>
<span class="sd">                internal_adjacency([1,2,4])</span>
<span class="sd">        array([[0, 1, 1], [1, 0, 1], [1, 1, 0]], dtype=int8)</span>

<span class="sd">        :arg [int] node_list: list of node indices describing the subnetwork</span>
<span class="sd">        :rtype: 2D array [node index, node index]</span>
<span class="sd">        :return: the subnetwork&#39;s adjacency matrix.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1">#  Create igraph Graph object describing the subgraph</span>
        <span class="n">subgraph</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">graph</span><span class="o">.</span><span class="n">subgraph</span><span class="p">(</span><span class="n">node_list</span><span class="p">)</span>
        <span class="c1">#  Get adjacency matrix</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">subgraph</span><span class="o">.</span><span class="n">get_adjacency</span><span class="p">(</span><span class="nb">type</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">data</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int8</span><span class="p">)</span></div>

<div class="viewcode-block" id="InteractingNetworks.cross_adjacency"><a class="viewcode-back" href="../../../api/core/interacting_networks.html#pyunicorn.core.interacting_networks.InteractingNetworks.cross_adjacency">[docs]</a>    <span class="k">def</span> <span class="nf">cross_adjacency</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node_list1</span><span class="p">,</span> <span class="n">node_list2</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return cross adjacency matrix describing the interaction of two</span>
<span class="sd">        subnetworks.</span>

<span class="sd">        The cross adjacency matrix entry :math:`CA_{ij} = 1` describes that</span>
<span class="sd">        node i in the first subnetwork is linked to node j in the second</span>
<span class="sd">        subnetwork.  Vice versa, :math:`CA_{ji} = 1` indicates that node j in</span>
<span class="sd">        the first subnetwork is linked to node i in the second subnetwork.</span>

<span class="sd">        .. note::</span>
<span class="sd">           The Cross adjacency matrix is NEITHER square NOR symmetric in</span>
<span class="sd">           general!</span>

<span class="sd">        **Examples:**</span>

<span class="sd">        &gt;&gt;&gt; r(InteractingNetworks.SmallTestNetwork().\</span>
<span class="sd">                cross_adjacency([1,2,4], [0,3,5]))</span>
<span class="sd">        array([[0, 1, 0], [0, 0, 0], [1, 0, 0]])</span>
<span class="sd">        &gt;&gt;&gt; r(InteractingNetworks.SmallTestNetwork().\</span>
<span class="sd">                cross_adjacency([1,2,3,4], [0,5]))</span>
<span class="sd">        array([[0, 0], [0, 0], [1, 0], [1, 0]])</span>

<span class="sd">        :arg [int] node_list1: list of node indices describing the first</span>
<span class="sd">            subnetwork</span>
<span class="sd">        :arg [int] node_list2: list of node indices describing the second</span>
<span class="sd">            subnetwork</span>
<span class="sd">        :rtype: 2D array [node index_1, node index_2]</span>
<span class="sd">        :return: the cross adjacency matrix.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">adjacency</span><span class="p">[</span><span class="n">node_list1</span><span class="p">,</span> <span class="p">:][:,</span> <span class="n">node_list2</span><span class="p">]</span></div>

<div class="viewcode-block" id="InteractingNetworks.cross_adjacency_sparse"><a class="viewcode-back" href="../../../api/core/interacting_networks.html#pyunicorn.core.interacting_networks.InteractingNetworks.cross_adjacency_sparse">[docs]</a>    <span class="k">def</span> <span class="nf">cross_adjacency_sparse</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node_list1</span><span class="p">,</span> <span class="n">node_list2</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return cross adjacency matrix describing the interaction of two</span>
<span class="sd">        subnetworks.</span>

<span class="sd">        The cross adjacency matrix entry M{CA_ij = 1} describes that node i</span>
<span class="sd">        in the first subnetwork is linked to node j in the second subnetwork.</span>
<span class="sd">        Vice versa, M{CA_ji = 1} indicates that node j in the first subnetwork</span>
<span class="sd">        is linked to node i in the second subnetwork.</span>

<span class="sd">        .. note::</span>

<span class="sd">           The Cross adjacency matrix is NEITHER square NOR symmetric in</span>
<span class="sd">           general!</span>

<span class="sd">        Examples:</span>

<span class="sd">        &gt;&gt;&gt; print(InteractingNetworks.SmallTestNetwork().\</span>
<span class="sd">                cross_adjacency_sparse([1,2,4], [0,3,5]))</span>
<span class="sd">        [[0 1 0] [0 0 0] [1 0 0]]</span>

<span class="sd">        :arg [int] node_list1: list of node indices describing the first</span>
<span class="sd">            subnetwork</span>
<span class="sd">        :arg [int] node_list2: list of node indices describing the second</span>
<span class="sd">            subnetwork</span>
<span class="sd">        :rtype: 2D array [node index_1, node index_2]</span>
<span class="sd">        :return: the cross adjacency matrix.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">sp_A</span><span class="p">[</span><span class="n">node_list1</span><span class="p">,</span> <span class="p">:][:,</span> <span class="n">node_list2</span><span class="p">]</span><span class="o">.</span><span class="n">A</span></div>

<div class="viewcode-block" id="InteractingNetworks.internal_link_attribute"><a class="viewcode-back" href="../../../api/core/interacting_networks.html#pyunicorn.core.interacting_networks.InteractingNetworks.internal_link_attribute">[docs]</a>    <span class="k">def</span> <span class="nf">internal_link_attribute</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">attribute_name</span><span class="p">,</span> <span class="n">node_list</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a like attribute matrix of a subnetwork induced by a subset of</span>
<span class="sd">        nodes.</span>

<span class="sd">        **Example:**</span>

<span class="sd">        &gt;&gt;&gt; net = InteractingNetworks.SmallTestNetwork()</span>
<span class="sd">        &gt;&gt;&gt; r(net.internal_link_attribute(&quot;link_weights&quot;, [1,2,3]))</span>
<span class="sd">        array([[ 0. ,  2.3,  2.9],</span>
<span class="sd">               [ 2.3,  0. ,  0. ],</span>
<span class="sd">               [ 2.9,  0. ,  0. ]])</span>

<span class="sd">        :arg str attribute_name: _name of link attribute to be used</span>
<span class="sd">        :arg [int] node_list: list of node indices describing the subnetwork</span>
<span class="sd">        :rtype: square numpy array [node_index, node_index]</span>
<span class="sd">        :return: link weights submatrix</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">weights</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">node_list</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">node_list</span><span class="p">)))</span>
        <span class="n">subgraph</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">graph</span><span class="o">.</span><span class="n">subgraph</span><span class="p">(</span><span class="n">node_list</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">directed</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">subgraph</span><span class="o">.</span><span class="n">es</span><span class="p">:</span>
                <span class="n">weights</span><span class="p">[</span><span class="n">e</span><span class="o">.</span><span class="n">tuple</span><span class="p">]</span> <span class="o">=</span> <span class="n">e</span><span class="p">[</span><span class="n">attribute_name</span><span class="p">]</span>
        <span class="c1">#  Symmetrize if subgraph is undirected</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">subgraph</span><span class="o">.</span><span class="n">es</span><span class="p">:</span>
                <span class="n">weights</span><span class="p">[</span><span class="n">e</span><span class="o">.</span><span class="n">tuple</span><span class="p">]</span> <span class="o">=</span> <span class="n">e</span><span class="p">[</span><span class="n">attribute_name</span><span class="p">]</span>
                <span class="n">weights</span><span class="p">[</span><span class="n">e</span><span class="o">.</span><span class="n">tuple</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">e</span><span class="o">.</span><span class="n">tuple</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">=</span> <span class="n">e</span><span class="p">[</span><span class="n">attribute_name</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">weights</span></div>

<div class="viewcode-block" id="InteractingNetworks.cross_link_attribute"><a class="viewcode-back" href="../../../api/core/interacting_networks.html#pyunicorn.core.interacting_networks.InteractingNetworks.cross_link_attribute">[docs]</a>    <span class="k">def</span> <span class="nf">cross_link_attribute</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">attribute_name</span><span class="p">,</span> <span class="n">node_list1</span><span class="p">,</span> <span class="n">node_list2</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a cross link weights matrix describing the interaction of two</span>
<span class="sd">        subnetworks.</span>

<span class="sd">        The cross link weights matrix entry :math:`CW_{ij} = w` describes that</span>
<span class="sd">        node i in the first subnetwork is linked to node j in the second</span>
<span class="sd">        subnetwork with weights :math:`w`.</span>

<span class="sd">        .. note::</span>

<span class="sd">           The cross link weights matrix is NEITHER square NOR symmetric in</span>
<span class="sd">           general!</span>

<span class="sd">        Example:</span>

<span class="sd">        &gt;&gt;&gt; net = InteractingNetworks.SmallTestNetwork()</span>
<span class="sd">        &gt;&gt;&gt; r(net.cross_link_attribute(&quot;link_weights&quot;, [1,2,3], [0,4]))</span>
<span class="sd">        array([[ 0. ,  2.7],</span>
<span class="sd">               [ 0. ,  1.5],</span>
<span class="sd">               [ 1.3,  0. ]])</span>

<span class="sd">        :arg str attribute_name: _name of link attribute to be used</span>
<span class="sd">        :arg [int] node_list1: list of node indices describing the first</span>
<span class="sd">            subnetwork</span>
<span class="sd">        :arg [int] node_list2: list of node indices describing the second</span>
<span class="sd">            subnetwork</span>
<span class="sd">        :rtype: 2D array [node index_1, node index_2]</span>
<span class="sd">        :return: the cross adjacency matrix.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">W</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">link_attribute</span><span class="p">(</span><span class="n">attribute_name</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">W</span><span class="p">[</span><span class="n">node_list1</span><span class="p">,</span> <span class="p">:][:,</span> <span class="n">node_list2</span><span class="p">]</span></div>

<div class="viewcode-block" id="InteractingNetworks.internal_path_lengths"><a class="viewcode-back" href="../../../api/core/interacting_networks.html#pyunicorn.core.interacting_networks.InteractingNetworks.internal_path_lengths">[docs]</a>    <span class="k">def</span> <span class="nf">internal_path_lengths</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node_list</span><span class="p">,</span> <span class="n">link_attribute</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return internal path length matrix of an induced subnetwork.</span>

<span class="sd">        Contains the paths length between all pairs of nodes within the</span>
<span class="sd">        subnetwork. However, the paths themselves will generally contain nodes</span>
<span class="sd">        from the full network. To avoid this and only consider paths lying</span>
<span class="sd">        within the subnetwork, do the following:</span>

<span class="sd">        &gt;&gt;&gt; InteractingNetworks.SmallTestNetwork().\</span>
<span class="sd">                subnetwork([0,3,5]).path_lengths()</span>
<span class="sd">        array([[ 0., 1., 1.], [ 1., 0., 2.], [ 1., 2., 0.]])</span>

<span class="sd">        **Examples:**</span>

<span class="sd">        &gt;&gt;&gt; InteractingNetworks.SmallTestNetwork().\</span>
<span class="sd">                internal_path_lengths([0,3,5], None)</span>
<span class="sd">        array([[ 0., 1., 1.], [ 1., 0., 2.], [ 1., 2., 0.]])</span>
<span class="sd">        &gt;&gt;&gt; InteractingNetworks.SmallTestNetwork().\</span>
<span class="sd">                internal_path_lengths([1,2,4], None)</span>
<span class="sd">        array([[ 0., 1., 1.], [ 1., 0., 1.], [ 1., 1., 0.]])</span>

<span class="sd">        :arg [int] node_list: list of node indices describing the subnetwork</span>
<span class="sd">        :arg str link_attribute: Optional name of the link attribute to be used</span>
<span class="sd">            as the links&#39; length. If None, links have length 1. (Default: None)</span>
<span class="sd">        :rtype: 2D array [node index, node index]</span>
<span class="sd">        :return: the internal path length matrix of an induced subnetwork.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span>\
            <span class="n">path_lengths</span><span class="p">(</span><span class="n">link_attribute</span><span class="p">)[</span><span class="n">node_list</span><span class="p">,</span> <span class="p">:][:,</span> <span class="n">node_list</span><span class="p">]</span></div>

<div class="viewcode-block" id="InteractingNetworks.cross_path_lengths"><a class="viewcode-back" href="../../../api/core/interacting_networks.html#pyunicorn.core.interacting_networks.InteractingNetworks.cross_path_lengths">[docs]</a>    <span class="k">def</span> <span class="nf">cross_path_lengths</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node_list1</span><span class="p">,</span> <span class="n">node_list2</span><span class="p">,</span> <span class="n">link_attribute</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return cross path length matrix for a pair of subnetworks.</span>

<span class="sd">        Contains the path length between nodes from different subnetworks. The</span>
<span class="sd">        paths may generally contain nodes from the full network.</span>

<span class="sd">        **Examples:**</span>

<span class="sd">        &gt;&gt;&gt; InteractingNetworks.SmallTestNetwork().\</span>
<span class="sd">                cross_path_lengths([0,3,5], [1,2,4], None)</span>
<span class="sd">        array([[ 2.,  2.,  1.], [ 1.,  2.,  2.], [ 3.,  3.,  2.]])</span>
<span class="sd">        &gt;&gt;&gt; InteractingNetworks.SmallTestNetwork().\</span>
<span class="sd">                cross_path_lengths([0,5], [1,2,3,4], None)</span>
<span class="sd">        array([[ 2.,  2.,  1.,  1.], [ 3.,  3.,  2.,  2.]])</span>

<span class="sd">        :arg [int] node_list1: list of node indices describing the first</span>
<span class="sd">            subnetwork</span>
<span class="sd">        :arg [int] node_list2: list of node indices describing the second</span>
<span class="sd">            subnetwork</span>
<span class="sd">        :arg str link_attribute: Optional name of the link attribute to be used</span>
<span class="sd">            as the links&#39; length. If None, links have length 1. (Default: None)</span>
<span class="sd">        :rtype: 2D array [index1, index2]</span>
<span class="sd">        :return: the cross path length matrix for a pair of subnetworks.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">path_lengths</span><span class="p">(</span><span class="n">link_attribute</span><span class="p">)[</span><span class="n">node_list1</span><span class="p">,</span> <span class="p">:][:,</span> <span class="n">node_list2</span><span class="p">]</span></div>

    <span class="c1">#</span>
    <span class="c1">#  Define scalar statistics for interacting networks</span>
    <span class="c1">#</span>

<div class="viewcode-block" id="InteractingNetworks.number_cross_links"><a class="viewcode-back" href="../../../api/core/interacting_networks.html#pyunicorn.core.interacting_networks.InteractingNetworks.number_cross_links">[docs]</a>    <span class="k">def</span> <span class="nf">number_cross_links</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node_list1</span><span class="p">,</span> <span class="n">node_list2</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the number of links connecting the two subnetworks.</span>

<span class="sd">        **Examples:**</span>

<span class="sd">        &gt;&gt;&gt; InteractingNetworks.SmallTestNetwork().\</span>
<span class="sd">                number_cross_links([0,3,5], [1,2,4])</span>
<span class="sd">        2</span>
<span class="sd">        &gt;&gt;&gt; InteractingNetworks.SmallTestNetwork().\</span>
<span class="sd">                number_cross_links([0,5], [1,2,3,4])</span>
<span class="sd">        2</span>

<span class="sd">        :arg [int] node_list1: list of node indices describing the first</span>
<span class="sd">            subnetwork</span>
<span class="sd">        :arg [int] node_list2: list of node indices describing the second</span>
<span class="sd">            subnetwork</span>
<span class="sd">        :return int: the number of links between nodes from different</span>
<span class="sd">            subnetworks.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">directed</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">NetworkError</span><span class="p">(</span><span class="s2">&quot;Not implemented yet...&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">cross_adjacency</span><span class="p">(</span><span class="n">node_list1</span><span class="p">,</span> <span class="n">node_list2</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span></div>

<div class="viewcode-block" id="InteractingNetworks.number_internal_links"><a class="viewcode-back" href="../../../api/core/interacting_networks.html#pyunicorn.core.interacting_networks.InteractingNetworks.number_internal_links">[docs]</a>    <span class="k">def</span> <span class="nf">number_internal_links</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node_list</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the number of links within an induced subnetwork.</span>

<span class="sd">        **Examples:**</span>

<span class="sd">        &gt;&gt;&gt; InteractingNetworks.SmallTestNetwork().\</span>
<span class="sd">                number_internal_links([0,3,5])</span>
<span class="sd">        2</span>
<span class="sd">        &gt;&gt;&gt; InteractingNetworks.SmallTestNetwork().\</span>
<span class="sd">                number_internal_links([1,2,4])</span>
<span class="sd">        3</span>

<span class="sd">        :arg [int] node_list: list of node indices describing the subnetwork</span>
<span class="sd">        :return int: the number of links within a given subnetwork.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">n_links</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">internal_adjacency</span><span class="p">(</span><span class="n">node_list</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">directed</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">n_links</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">n_links</span> <span class="o">//</span> <span class="mi">2</span></div>

<div class="viewcode-block" id="InteractingNetworks.cross_link_density"><a class="viewcode-back" href="../../../api/core/interacting_networks.html#pyunicorn.core.interacting_networks.InteractingNetworks.cross_link_density">[docs]</a>    <span class="k">def</span> <span class="nf">cross_link_density</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node_list1</span><span class="p">,</span> <span class="n">node_list2</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the density of links between two subnetworks.</span>

<span class="sd">        **Examples:**</span>

<span class="sd">        &gt;&gt;&gt; r(InteractingNetworks.SmallTestNetwork().\</span>
<span class="sd">                cross_link_density([0,3,5], [1,2,4]))</span>
<span class="sd">        0.2222</span>
<span class="sd">        &gt;&gt;&gt; InteractingNetworks.SmallTestNetwork().\</span>
<span class="sd">                cross_link_density([0,5], [1,2,3,4])</span>
<span class="sd">        0.25</span>

<span class="sd">        :arg [int] node_list1: list of node indices describing the first</span>
<span class="sd">            subnetwork</span>
<span class="sd">        :arg [int] node_list2: list of node indices describing the second</span>
<span class="sd">            subnetwork</span>
<span class="sd">        :return float: the density of links between two subnetworks.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">N1</span><span class="p">,</span> <span class="n">N2</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">node_list1</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">node_list2</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">directed</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">NetworkError</span><span class="p">(</span><span class="s2">&quot;Not implemented yet...&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">n_cl</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">number_cross_links</span><span class="p">(</span><span class="n">node_list1</span><span class="p">,</span> <span class="n">node_list2</span><span class="p">)</span>
            <span class="k">return</span> <span class="nb">float</span><span class="p">(</span><span class="n">n_cl</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">N1</span> <span class="o">*</span> <span class="n">N2</span><span class="p">)</span></div>

<div class="viewcode-block" id="InteractingNetworks.internal_link_density"><a class="viewcode-back" href="../../../api/core/interacting_networks.html#pyunicorn.core.interacting_networks.InteractingNetworks.internal_link_density">[docs]</a>    <span class="k">def</span> <span class="nf">internal_link_density</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node_list</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the density of links within an induced subnetwork.</span>

<span class="sd">        **Examples:**</span>

<span class="sd">        &gt;&gt;&gt; r(InteractingNetworks.SmallTestNetwork().\</span>
<span class="sd">                internal_link_density([0,3,5]))</span>
<span class="sd">        0.6667</span>
<span class="sd">        &gt;&gt;&gt; r(InteractingNetworks.SmallTestNetwork().\</span>
<span class="sd">                internal_link_density([1,2,3,4]))</span>
<span class="sd">        0.6667</span>

<span class="sd">        :arg [int] node_list: list of node indices describing the subnetwork</span>
<span class="sd">        :return float: the density of links within a subnetwork.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">N</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">node_list</span><span class="p">)</span>
        <span class="n">n_links</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">number_internal_links</span><span class="p">(</span><span class="n">node_list</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">directed</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">float</span><span class="p">(</span><span class="n">n_links</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">N</span> <span class="o">*</span> <span class="p">(</span><span class="n">N</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="mi">2</span> <span class="o">*</span> <span class="nb">float</span><span class="p">(</span><span class="n">n_links</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">N</span> <span class="o">*</span> <span class="p">(</span><span class="n">N</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span></div>

<div class="viewcode-block" id="InteractingNetworks.internal_global_clustering"><a class="viewcode-back" href="../../../api/core/interacting_networks.html#pyunicorn.core.interacting_networks.InteractingNetworks.internal_global_clustering">[docs]</a>    <span class="k">def</span> <span class="nf">internal_global_clustering</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node_list</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return internal global clustering coefficients for an induced</span>
<span class="sd">        subnetwork.</span>

<span class="sd">        Internal global clustering coefficients are calculated as mean values</span>
<span class="sd">        from the local clustering sequence of the whole network. This</span>
<span class="sd">        implies that triangles spanning different subnetworks will generally</span>
<span class="sd">        contribute to the internal clustering coefficient.</span>

<span class="sd">        To avoid this and consider only triangles lying within the subnetwork:</span>

<span class="sd">        &gt;&gt;&gt; r(InteractingNetworks.SmallTestNetwork().\</span>
<span class="sd">                subnetwork([0,3,5]).global_clustering())</span>
<span class="sd">        0.0</span>

<span class="sd">        **Examples:**</span>

<span class="sd">        &gt;&gt;&gt; r(InteractingNetworks.SmallTestNetwork().\</span>
<span class="sd">                internal_global_clustering([0,3,5]))</span>
<span class="sd">        0.0</span>
<span class="sd">        &gt;&gt;&gt; r(InteractingNetworks.SmallTestNetwork().\</span>
<span class="sd">                internal_global_clustering([1,2,4]))</span>
<span class="sd">        0.5556</span>

<span class="sd">        :arg [int] node_list: list of node indices describing the subnetwork</span>
<span class="sd">        :return float: the internal global clustering coefficient for a</span>
<span class="sd">            subnetwork.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">clustering</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">local_clustering</span><span class="p">()</span>
        <span class="n">internal_clustering</span> <span class="o">=</span> <span class="n">clustering</span><span class="p">[</span><span class="n">node_list</span><span class="p">]</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">internal_clustering</span></div>

<div class="viewcode-block" id="InteractingNetworks.cross_global_clustering"><a class="viewcode-back" href="../../../api/core/interacting_networks.html#pyunicorn.core.interacting_networks.InteractingNetworks.cross_global_clustering">[docs]</a>    <span class="k">def</span> <span class="nf">cross_global_clustering</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node_list1</span><span class="p">,</span> <span class="n">node_list2</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return global cross clustering for a pair of subnetworks.</span>

<span class="sd">        The global cross clustering coefficient C_v gives the average</span>
<span class="sd">        probability, that two randomly drawn neighbors in subnetwork 2 of node</span>
<span class="sd">        v in subnetwork 1 are also neighbors and vice versa. It counts</span>
<span class="sd">        triangles having one vertex in subnetwork 1 and two vertices in</span>
<span class="sd">        subnetwork 2 and vice versa.</span>

<span class="sd">        **Examples:**</span>

<span class="sd">        &gt;&gt;&gt; InteractingNetworks.SmallTestNetwork().\</span>
<span class="sd">                cross_global_clustering([0,3,5], [1,2,4])</span>
<span class="sd">        0.0</span>
<span class="sd">        &gt;&gt;&gt; InteractingNetworks.SmallTestNetwork().\</span>
<span class="sd">                cross_global_clustering([2], [1,3,4])</span>
<span class="sd">        1.0</span>
<span class="sd">        &gt;&gt;&gt; InteractingNetworks.SmallTestNetwork().\</span>
<span class="sd">                cross_global_clustering([3,4], [1,2])</span>
<span class="sd">        0.5</span>

<span class="sd">        :arg [int] node_list1: list of node indices describing the first</span>
<span class="sd">            subnetwork</span>
<span class="sd">        :arg [int] node_list2: list of node indices describing the second</span>
<span class="sd">            subnetwork</span>
<span class="sd">        :return float: the cross global clustering coefficient for a pair of</span>
<span class="sd">            subnetworks.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1">#  Get cross local clustering sequences</span>
        <span class="n">cc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cross_local_clustering</span><span class="p">(</span><span class="n">node_list1</span><span class="p">,</span> <span class="n">node_list2</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">cc</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span></div>

<div class="viewcode-block" id="InteractingNetworks.cross_global_clustering_sparse"><a class="viewcode-back" href="../../../api/core/interacting_networks.html#pyunicorn.core.interacting_networks.InteractingNetworks.cross_global_clustering_sparse">[docs]</a>    <span class="k">def</span> <span class="nf">cross_global_clustering_sparse</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node_list1</span><span class="p">,</span> <span class="n">node_list2</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return global cross clustering for a pair of subnetworks.</span>

<span class="sd">        The global cross clustering coefficient C_v gives the average</span>
<span class="sd">        probability, that two randomly drawn neighbors in subnetwork 2 of node</span>
<span class="sd">        v in subnetwork 1 are also neighbors and vice versa. It counts</span>
<span class="sd">        triangles having one vertex in subnetwork 1 and two vertices in</span>
<span class="sd">        subnetwork 2 and vice versa.</span>

<span class="sd">        Examples:</span>

<span class="sd">        &gt;&gt;&gt; InteractingNetworks.SmallTestNetwork().cross_global_clustering(</span>
<span class="sd">        ...                                                   [0,3,5], [1,2,4])</span>
<span class="sd">        0.0</span>

<span class="sd">        &gt;&gt;&gt; InteractingNetworks.SmallTestNetwork().cross_global_clustering(</span>
<span class="sd">        ...                                                       [2], [1,3,4])</span>
<span class="sd">        1.0</span>

<span class="sd">        &gt;&gt;&gt; InteractingNetworks.SmallTestNetwork().cross_global_clustering(</span>
<span class="sd">        ...                                                       [3,4], [1,2])</span>
<span class="sd">        0.5</span>

<span class="sd">        :arg [int] node_list1: list of node indices describing the first</span>
<span class="sd">            subnetwork</span>
<span class="sd">        :arg [int] node_list2: list of node indices describing the second</span>
<span class="sd">            subnetwork</span>
<span class="sd">        :return float: the cross global clustering coefficient for a pair of</span>
<span class="sd">            subnetworks.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1">#  Get cross local clustering sequences</span>
        <span class="n">cc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cross_local_clustering_sparse</span><span class="p">(</span><span class="n">node_list1</span><span class="p">,</span> <span class="n">node_list2</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">cc</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span></div>

<div class="viewcode-block" id="InteractingNetworks.cross_transitivity"><a class="viewcode-back" href="../../../api/core/interacting_networks.html#pyunicorn.core.interacting_networks.InteractingNetworks.cross_transitivity">[docs]</a>    <span class="k">def</span> <span class="nf">cross_transitivity</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node_list1</span><span class="p">,</span> <span class="n">node_list2</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return cross transitivity for a pair of subnetworks.</span>

<span class="sd">        The cross transitivity is the probability, that two randomly drawn</span>
<span class="sd">        neighbors in subnetwork 2 of node v in subnetwork 1 are also neighbors.</span>
<span class="sd">        It counts triangles having one vertex in subnetwork 1 and two vertices</span>
<span class="sd">        in subnetwork 2. Cross transitivity tends to weight low cross degree</span>
<span class="sd">        vertices less strongly when compared to the global cross clustering</span>
<span class="sd">        coefficient (see [Newman2003]_).</span>

<span class="sd">        **Examples:**</span>

<span class="sd">        &gt;&gt;&gt; InteractingNetworks.SmallTestNetwork().\</span>
<span class="sd">                cross_transitivity([0,3,5], [1,2,4])</span>
<span class="sd">        0.0</span>
<span class="sd">        &gt;&gt;&gt; InteractingNetworks.SmallTestNetwork().\</span>
<span class="sd">                cross_transitivity([2], [1,3,4])</span>
<span class="sd">        1.0</span>
<span class="sd">        &gt;&gt;&gt; InteractingNetworks.SmallTestNetwork().\</span>
<span class="sd">                cross_transitivity([3,4], [1,2])</span>
<span class="sd">        1.0</span>

<span class="sd">        :arg [int] node_list1: list of node indices describing the first</span>
<span class="sd">            subnetwork</span>
<span class="sd">        :arg [int] node_list2: list of node indices describing the second</span>
<span class="sd">            subnetwork</span>
<span class="sd">        :return float: the cross transitivity for a pair of subnetworks.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_cross_transitivity</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">adjacency</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">),</span>
                                   <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">node_list1</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">node_list2</span><span class="p">))</span></div>

<div class="viewcode-block" id="InteractingNetworks.cross_transitivity_sparse"><a class="viewcode-back" href="../../../api/core/interacting_networks.html#pyunicorn.core.interacting_networks.InteractingNetworks.cross_transitivity_sparse">[docs]</a>    <span class="k">def</span> <span class="nf">cross_transitivity_sparse</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node_list1</span><span class="p">,</span> <span class="n">node_list2</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return cross transitivity for a pair of subnetworks.</span>

<span class="sd">        The cross transitivity is the probability, that two randomly drawn</span>
<span class="sd">        neighbors in subnetwork 2 of node v in subnetwork 1 are also</span>
<span class="sd">        neighbors. It counts triangles having one vertex in</span>
<span class="sd">        subnetwork 1 and two vertices in subnetwork 2. Cross</span>
<span class="sd">        transitivity tends to weight low cross degree vertices less strongly</span>
<span class="sd">        when compared to the global cross clustering coefficient (see Newman,</span>
<span class="sd">        SIAM Review, 2003).</span>

<span class="sd">        Examples:</span>

<span class="sd">        &gt;&gt;&gt; InteractingNetworks.SmallTestNetwork().\</span>
<span class="sd">                cross_transitivity_sparse([0,3,5], [1,2,4])</span>
<span class="sd">        0.0</span>
<span class="sd">        &gt;&gt;&gt; InteractingNetworks.SmallTestNetwork().\</span>
<span class="sd">                cross_transitivity_sparse([3,4], [1,2])</span>
<span class="sd">        1.0</span>

<span class="sd">        :arg [int] node_list1: list of node indices describing the first</span>
<span class="sd">            subnetwork</span>
<span class="sd">        :arg [int] node_list2: list of node indices describing the second</span>
<span class="sd">            subnetwork</span>
<span class="sd">        :return float: the cross transitivity for a pair of subnetworks.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">cross_degree</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cross_degree</span><span class="p">(</span><span class="n">node_list1</span><span class="p">,</span> <span class="n">node_list2</span><span class="p">)</span>

        <span class="c1">#  Get sparse adjacency matrix</span>
        <span class="n">A</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sp_A</span><span class="p">[</span><span class="n">node_list1</span><span class="o">+</span><span class="n">node_list2</span><span class="p">,</span> <span class="p">:][:,</span> <span class="n">node_list1</span><span class="o">+</span><span class="n">node_list2</span><span class="p">]</span>
        <span class="c1">#  Get subnetwork sizes</span>
        <span class="n">N1</span><span class="p">,</span> <span class="n">N2</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">node_list1</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">node_list2</span><span class="p">)</span>
        <span class="c1">#  Initialize</span>
        <span class="n">cross_transitivity</span> <span class="o">=</span> <span class="mf">0.0</span>
        <span class="c1">#  Set counter</span>
        <span class="n">counter_triangles</span> <span class="o">=</span> <span class="mf">0.0</span>
        <span class="n">counter_triples</span> <span class="o">=</span> <span class="mf">0.0</span>
        <span class="c1">#  Calculate cross transitivity from subnetwork 1 to subnetwork 2</span>
        <span class="c1">#  Loop over nodes in subnetwork 1</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N1</span><span class="p">):</span>
            <span class="n">node1</span> <span class="o">=</span> <span class="n">i</span>
            <span class="k">if</span> <span class="n">cross_degree</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="c1">#  Loop over unique pairs of nodes in subnetwork 2</span>
                <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N1</span><span class="p">,</span> <span class="n">N1</span><span class="o">+</span><span class="n">N2</span><span class="p">):</span>
                    <span class="n">node2</span> <span class="o">=</span> <span class="n">j</span>
                    <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N1</span><span class="p">,</span> <span class="n">j</span><span class="p">):</span>
                        <span class="n">node3</span> <span class="o">=</span> <span class="n">k</span>
                        <span class="k">if</span> <span class="n">A</span><span class="p">[</span><span class="n">node1</span><span class="p">,</span> <span class="n">node2</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">A</span><span class="p">[</span><span class="n">node1</span><span class="p">,</span> <span class="n">node3</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                            <span class="n">counter_triples</span> <span class="o">+=</span> <span class="mi">1</span>
                            <span class="k">if</span> <span class="n">A</span><span class="p">[</span><span class="n">node2</span><span class="p">,</span> <span class="n">node3</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                                <span class="n">counter_triangles</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="k">if</span> <span class="n">counter_triples</span><span class="p">:</span>
            <span class="n">cross_transitivity</span> <span class="o">=</span> <span class="n">counter_triangles</span> <span class="o">/</span> <span class="n">counter_triples</span>
        <span class="k">return</span> <span class="n">cross_transitivity</span></div>

    <span class="nd">@staticmethod</span>
<div class="viewcode-block" id="InteractingNetworks._calculate_general_average_path_length"><a class="viewcode-back" href="../../../api/core/interacting_networks.html#pyunicorn.core.interacting_networks.InteractingNetworks._calculate_general_average_path_length">[docs]</a>    <span class="k">def</span> <span class="nf">_calculate_general_average_path_length</span><span class="p">(</span><span class="n">path_lengths</span><span class="p">,</span> <span class="n">internal</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculate general average path length for interacting networks.</span>

<span class="sd">        :type path_lengths: 2D array [index, index]</span>
<span class="sd">        :arg path_lengths: The path length matrix.</span>
<span class="sd">        :arg bool internal: Indicates, whether internal or cross average path</span>
<span class="sd">            length shall be calculated.</span>
<span class="sd">        :return float: the general average path length.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1">#  Get shape of path lengths array for normalization</span>
        <span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="n">M</span><span class="p">)</span> <span class="o">=</span> <span class="n">path_lengths</span><span class="o">.</span><span class="n">shape</span>

        <span class="c1">#  Identify unconnected pairs and save in binary array isinf</span>
        <span class="n">unconnected_pairs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">isinf</span><span class="p">(</span><span class="n">path_lengths</span><span class="p">)</span>
        <span class="c1">#  Count the number of unconnected pairs</span>
        <span class="n">n_unconnected_pairs</span> <span class="o">=</span> <span class="n">unconnected_pairs</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
        <span class="c1">#  Set infinite entries corresponding to unconnected pairs to zero</span>
        <span class="n">path_lengths</span><span class="p">[</span><span class="n">unconnected_pairs</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="c1">#  Take average of shortest geographical path length matrix optionally</span>
        <span class="c1">#  excluding the diagonal, since it is always zero, and all unconnected</span>
        <span class="c1">#  pairs. The diagonal should never contain infinities, so that should</span>
        <span class="c1">#  not be a problem.</span>
        <span class="k">if</span> <span class="n">internal</span><span class="p">:</span>
            <span class="n">norm</span> <span class="o">=</span> <span class="nb">float</span><span class="p">((</span><span class="n">N</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">M</span> <span class="o">-</span> <span class="n">n_unconnected_pairs</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">norm</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">N</span> <span class="o">*</span> <span class="n">M</span> <span class="o">-</span> <span class="n">n_unconnected_pairs</span><span class="p">)</span>

        <span class="n">average_path_length</span> <span class="o">=</span> <span class="n">path_lengths</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="o">/</span> <span class="n">norm</span>

        <span class="c1">#  Reverse changes to path_lengths</span>
        <span class="n">path_lengths</span><span class="p">[</span><span class="n">unconnected_pairs</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span>
        <span class="k">return</span> <span class="n">average_path_length</span></div>

<div class="viewcode-block" id="InteractingNetworks.cross_average_path_length"><a class="viewcode-back" href="../../../api/core/interacting_networks.html#pyunicorn.core.interacting_networks.InteractingNetworks.cross_average_path_length">[docs]</a>    <span class="k">def</span> <span class="nf">cross_average_path_length</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node_list1</span><span class="p">,</span> <span class="n">node_list2</span><span class="p">,</span>
                                  <span class="n">link_attribute</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return cross average path length.</span>

<span class="sd">        Return the average (weighted) shortest path length between two induced</span>
<span class="sd">        subnetworks.</span>

<span class="sd">        **Examples:**</span>

<span class="sd">        &gt;&gt;&gt; InteractingNetworks.SmallTestNetwork().\</span>
<span class="sd">                cross_average_path_length([0,3,5], [1,2,4], None)</span>
<span class="sd">        2.0</span>
<span class="sd">        &gt;&gt;&gt; InteractingNetworks.SmallTestNetwork().\</span>
<span class="sd">                cross_average_path_length([0,5], [1,2,3,4], None)</span>
<span class="sd">        2.0</span>

<span class="sd">        :arg [int] node_list1: list of node indices describing the first</span>
<span class="sd">            subnetwork</span>
<span class="sd">        :arg [int] node_list2: list of node indices describing the second</span>
<span class="sd">            subnetwork</span>
<span class="sd">        :arg str link_attribute: Optional name of the link attribute to be used</span>
<span class="sd">            as the links&#39; length. If None, links have length 1. (Default: None)</span>
<span class="sd">        :return float: the cross average path length between a pair of</span>
<span class="sd">            subnetworks.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">path_lengths</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cross_path_lengths</span><span class="p">(</span><span class="n">node_list1</span><span class="p">,</span> <span class="n">node_list2</span><span class="p">,</span>
                                               <span class="n">link_attribute</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_calculate_general_average_path_length</span><span class="p">(</span><span class="n">path_lengths</span><span class="p">,</span>
                                                           <span class="n">internal</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span></div>

<div class="viewcode-block" id="InteractingNetworks.internal_average_path_length"><a class="viewcode-back" href="../../../api/core/interacting_networks.html#pyunicorn.core.interacting_networks.InteractingNetworks.internal_average_path_length">[docs]</a>    <span class="k">def</span> <span class="nf">internal_average_path_length</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node_list</span><span class="p">,</span> <span class="n">link_attribute</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return internal average path length for an induced subnetwork.</span>

<span class="sd">        Return the average (weighted) shortest path length between all pairs</span>
<span class="sd">        of nodes within a subnetwork separately for which a path exists. Paths</span>
<span class="sd">        between nodes from different subnetworks are not included in the</span>
<span class="sd">        average!</span>

<span class="sd">        However, even if the end points lie within the same layer, the paths</span>
<span class="sd">        themselves will generally contain nodes from the whole network. To</span>
<span class="sd">        avoid this and only consider paths lying within the subnetwork, do the</span>
<span class="sd">        following:</span>

<span class="sd">        &gt;&gt;&gt; r(InteractingNetworks.SmallTestNetwork().\</span>
<span class="sd">                subnetwork([0,3,5]).average_path_length(None))</span>
<span class="sd">        1.3333</span>

<span class="sd">        **Examples:**</span>

<span class="sd">        &gt;&gt;&gt; r(InteractingNetworks.SmallTestNetwork().\</span>
<span class="sd">                internal_average_path_length([0,3,5], None))</span>
<span class="sd">        1.3333</span>
<span class="sd">        &gt;&gt;&gt; r(InteractingNetworks.SmallTestNetwork().\</span>
<span class="sd">                internal_average_path_length([1,2,4], None))</span>
<span class="sd">        1.0</span>

<span class="sd">        :arg [int] node_list: list of node indices describing the subnetwork</span>
<span class="sd">        :arg str link_attribute: Optional name of the link attribute to be used</span>
<span class="sd">            as the links&#39; length. If None, links have length 1. (Default: None)</span>
<span class="sd">        :return float: the internal average path length.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">path_lengths</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">internal_path_lengths</span><span class="p">(</span><span class="n">node_list</span><span class="p">,</span> <span class="n">link_attribute</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_calculate_general_average_path_length</span><span class="p">(</span><span class="n">path_lengths</span><span class="p">,</span>
                                                           <span class="n">internal</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span></div>

    <span class="c1">#</span>
    <span class="c1">#  Define local measures for interacting networks</span>
    <span class="c1">#</span>

<div class="viewcode-block" id="InteractingNetworks.cross_degree"><a class="viewcode-back" href="../../../api/core/interacting_networks.html#pyunicorn.core.interacting_networks.InteractingNetworks.cross_degree">[docs]</a>    <span class="k">def</span> <span class="nf">cross_degree</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node_list1</span><span class="p">,</span> <span class="n">node_list2</span><span class="p">,</span> <span class="n">link_attribute</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the cross degree sequence for one subnetwork with respect to a</span>
<span class="sd">        second subnetwork.</span>

<span class="sd">        Gives the number of links from a specific node in the first subnetwork</span>
<span class="sd">        projecting to the second subnetwork. If a link attribute is specified,</span>
<span class="sd">        return the associated strength</span>

<span class="sd">        **Examples:**</span>

<span class="sd">        &gt;&gt;&gt; InteractingNetworks.SmallTestNetwork().\</span>
<span class="sd">                cross_degree([0,3,5], [1,2,4])</span>
<span class="sd">        array([1, 1, 0])</span>
<span class="sd">        &gt;&gt;&gt; InteractingNetworks.SmallTestNetwork().\</span>
<span class="sd">                cross_degree([1,2,4], [0,3,5])</span>
<span class="sd">        array([1, 0, 1])</span>
<span class="sd">        &gt;&gt;&gt; InteractingNetworks.SmallTestNetwork().\</span>
<span class="sd">                cross_degree([1,2,3,4], [0,5])</span>
<span class="sd">        array([0, 0, 1, 1])</span>

<span class="sd">        :arg [int] node_list1: list of node indices describing the first</span>
<span class="sd">            subnetwork</span>
<span class="sd">        :arg [int] node_list2: list of node indices describing the second</span>
<span class="sd">            subnetwork</span>
<span class="sd">        :arg str key: link attribute key (optional)</span>
<span class="sd">        :rtype: 1D array [node index]</span>
<span class="sd">        :return: the cross degree sequence.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">directed</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cross_indegree</span><span class="p">(</span><span class="n">node_list1</span><span class="p">,</span> <span class="n">node_list2</span><span class="p">,</span>
                                        <span class="n">link_attribute</span><span class="p">)</span>
                    <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">cross_outdegree</span><span class="p">(</span><span class="n">node_list1</span><span class="p">,</span> <span class="n">node_list2</span><span class="p">,</span>
                                           <span class="n">link_attribute</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">cross_outdegree</span><span class="p">(</span><span class="n">node_list1</span><span class="p">,</span> <span class="n">node_list2</span><span class="p">,</span>
                                        <span class="n">link_attribute</span><span class="p">)</span></div>

<div class="viewcode-block" id="InteractingNetworks.cross_indegree"><a class="viewcode-back" href="../../../api/core/interacting_networks.html#pyunicorn.core.interacting_networks.InteractingNetworks.cross_indegree">[docs]</a>    <span class="k">def</span> <span class="nf">cross_indegree</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node_list1</span><span class="p">,</span> <span class="n">node_list2</span><span class="p">,</span> <span class="n">link_attribute</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the cross indegree sequence for the first given subnetwork with</span>
<span class="sd">        respect to the second given subnetwork</span>

<span class="sd">        Gives the number of links from nodes in subnetwork two to a specific</span>
<span class="sd">        node from subnetwork one. If a link attribute is specified,</span>
<span class="sd">        return the associated in strength.</span>


<span class="sd">        **Example:**</span>

<span class="sd">        &gt;&gt;&gt; net = InteractingNetworks.SmallDirectedTestNetwork()</span>
<span class="sd">        &gt;&gt;&gt; net.cross_indegree([1, 2], [0, 3, 4])</span>
<span class="sd">        array([2, 1])</span>

<span class="sd">        :arg [int] node_list1: list of node indices describing the first</span>
<span class="sd">            subnetwork</span>
<span class="sd">        :arg [int] node_list2: list of node indices describing the second</span>
<span class="sd">            subnetwork</span>
<span class="sd">        :arg str key: link attribute key (optional)</span>
<span class="sd">        :rtype: 1D array [node index]</span>
<span class="sd">        :return: the cross in degree sequence.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">link_attribute</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cross_adjacency</span><span class="p">(</span><span class="n">node_list2</span><span class="p">,</span> <span class="n">node_list1</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cross_link_attribute</span><span class="p">(</span><span class="n">link_attribute</span><span class="p">,</span> <span class="n">node_list2</span><span class="p">,</span>
                                                    <span class="n">node_list1</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span></div>

<div class="viewcode-block" id="InteractingNetworks.cross_outdegree"><a class="viewcode-back" href="../../../api/core/interacting_networks.html#pyunicorn.core.interacting_networks.InteractingNetworks.cross_outdegree">[docs]</a>    <span class="k">def</span> <span class="nf">cross_outdegree</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node_list1</span><span class="p">,</span> <span class="n">node_list2</span><span class="p">,</span> <span class="n">link_attribute</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the cross outdegree sequence for the first given subnetwork with</span>
<span class="sd">        respect to the second given subnetwork</span>

<span class="sd">        Gives the number of links from a specific node in subnetwork one to</span>
<span class="sd">        nodes in subnetwork two. If a link attribute is specified,</span>
<span class="sd">        return the associated out strength.</span>

<span class="sd">        **Example:**</span>

<span class="sd">        &gt;&gt;&gt; net = InteractingNetworks.SmallDirectedTestNetwork()</span>
<span class="sd">        &gt;&gt;&gt; net.cross_outdegree([1, 2], [0, 3, 4])</span>
<span class="sd">        array([1, 0])</span>

<span class="sd">        :arg [int] node_list1: list of node indices describing the first</span>
<span class="sd">            subnetwork</span>
<span class="sd">        :arg [int] node_list2: list of node indices describing the second</span>
<span class="sd">            subnetwork</span>
<span class="sd">        :arg str key: link attribute key (optional)</span>
<span class="sd">        :rtype: 1D array [node index]</span>
<span class="sd">        :return: the cross out degree sequence.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">link_attribute</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cross_adjacency</span><span class="p">(</span><span class="n">node_list1</span><span class="p">,</span> <span class="n">node_list2</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cross_link_attribute</span><span class="p">(</span><span class="n">link_attribute</span><span class="p">,</span> <span class="n">node_list1</span><span class="p">,</span>
                                                    <span class="n">node_list2</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span></div>

<div class="viewcode-block" id="InteractingNetworks.internal_degree"><a class="viewcode-back" href="../../../api/core/interacting_networks.html#pyunicorn.core.interacting_networks.InteractingNetworks.internal_degree">[docs]</a>    <span class="k">def</span> <span class="nf">internal_degree</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node_list</span><span class="p">,</span> <span class="n">link_attribute</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the internal degree sequence of one induced subnetwork.</span>

<span class="sd">        Gives the number of links from a specific node to other nodes within</span>
<span class="sd">        the same induced subnetwork. If a link attribute is specified,</span>
<span class="sd">        return the associated strength.</span>

<span class="sd">        **Examples:**</span>

<span class="sd">        &gt;&gt;&gt; InteractingNetworks.SmallTestNetwork().internal_degree([0,3,5])</span>
<span class="sd">        array([2, 1, 1])</span>
<span class="sd">        &gt;&gt;&gt; InteractingNetworks.SmallTestNetwork().internal_degree([1,2,4])</span>
<span class="sd">        array([2, 2, 2])</span>

<span class="sd">        :arg [int] node_list: list of node indices describing the subnetwork</span>
<span class="sd">        :arg str key: link attribute key (optional)</span>
<span class="sd">        :rtype: 1D array [node index]</span>
<span class="sd">        :return: the internal degree sequence.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">directed</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">internal_indegree</span><span class="p">(</span><span class="n">node_list</span><span class="p">,</span> <span class="n">link_attribute</span><span class="p">)</span>
                    <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">internal_outdegree</span><span class="p">(</span><span class="n">node_list</span><span class="p">,</span> <span class="n">link_attribute</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">internal_outdegree</span><span class="p">(</span><span class="n">node_list</span><span class="p">,</span> <span class="n">link_attribute</span><span class="p">)</span></div>

<div class="viewcode-block" id="InteractingNetworks.internal_indegree"><a class="viewcode-back" href="../../../api/core/interacting_networks.html#pyunicorn.core.interacting_networks.InteractingNetworks.internal_indegree">[docs]</a>    <span class="k">def</span> <span class="nf">internal_indegree</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node_list</span><span class="p">,</span> <span class="n">link_attribute</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the internal indegree sequence of one induced subnetwork.</span>

<span class="sd">        Gives the number of links from other nodes to a specific node within</span>
<span class="sd">        the same induced subnetwork. If a link attribute is specified,</span>
<span class="sd">        return the associated in strength.</span>

<span class="sd">        **Example:**</span>

<span class="sd">        &gt;&gt;&gt; net = InteractingNetworks.SmallDirectedTestNetwork()</span>
<span class="sd">        &gt;&gt;&gt; net.internal_indegree([0, 1, 3])</span>
<span class="sd">        array([0, 2, 1])</span>

<span class="sd">        :arg [int] node_list: list of node indices describing the subnetwork</span>
<span class="sd">        :arg str key: link attribute key (optional)</span>
<span class="sd">        :rtype: 1D array [node index]</span>
<span class="sd">        :return: the internal in degree sequence.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">link_attribute</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">internal_adjacency</span><span class="p">(</span><span class="n">node_list</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">internal_link_attribute</span><span class="p">(</span><span class="n">link_attribute</span><span class="p">,</span>
                                                       <span class="n">node_list</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span></div>

<div class="viewcode-block" id="InteractingNetworks.internal_outdegree"><a class="viewcode-back" href="../../../api/core/interacting_networks.html#pyunicorn.core.interacting_networks.InteractingNetworks.internal_outdegree">[docs]</a>    <span class="k">def</span> <span class="nf">internal_outdegree</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node_list</span><span class="p">,</span> <span class="n">link_attribute</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the internal outdegree sequence of one induced subnetwork.</span>

<span class="sd">        Gives the number of links from a specific node to other nodes within</span>
<span class="sd">        the same induced subnetwork. If a link attribute is specified,</span>
<span class="sd">        return the associated out strength.</span>

<span class="sd">        **Example:**</span>

<span class="sd">        &gt;&gt;&gt; net = InteractingNetworks.SmallDirectedTestNetwork()</span>
<span class="sd">        &gt;&gt;&gt; net.internal_outdegree([0, 1, 3])</span>
<span class="sd">        array([2, 0, 1])</span>

<span class="sd">        :arg [int] node_list: list of node indices describing the subnetwork</span>
<span class="sd">        :arg str key: link attribute key (optional)</span>
<span class="sd">        :rtype: 1D array [node index]</span>
<span class="sd">        :return: the internal out degree sequence.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">link_attribute</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">internal_adjacency</span><span class="p">(</span><span class="n">node_list</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">internal_link_attribute</span><span class="p">(</span><span class="n">link_attribute</span><span class="p">,</span>
                                                       <span class="n">node_list</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span></div>

<div class="viewcode-block" id="InteractingNetworks.cross_local_clustering"><a class="viewcode-back" href="../../../api/core/interacting_networks.html#pyunicorn.core.interacting_networks.InteractingNetworks.cross_local_clustering">[docs]</a>    <span class="k">def</span> <span class="nf">cross_local_clustering</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node_list1</span><span class="p">,</span> <span class="n">node_list2</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return local cross clustering for a pair of subnetworks.</span>

<span class="sd">        The local cross clustering coefficient C_v gives the probability, that</span>
<span class="sd">        two randomly drawn neighbors in subnetwork 1 of node v in subnetwork 1</span>
<span class="sd">        are also neighbors. It counts triangles having one vertex in</span>
<span class="sd">        subnetwork 1 and two vertices in subnetwork 2.</span>

<span class="sd">        **Examples:**</span>

<span class="sd">        &gt;&gt;&gt; InteractingNetworks.SmallTestNetwork().\</span>
<span class="sd">                cross_local_clustering([0,3,5], [1,2,4])</span>
<span class="sd">        array([ 0.,  0.,  0.])</span>
<span class="sd">        &gt;&gt;&gt; InteractingNetworks.SmallTestNetwork().\</span>
<span class="sd">                cross_local_clustering([2], [1,3,4])</span>
<span class="sd">        array([ 1.])</span>
<span class="sd">        &gt;&gt;&gt; InteractingNetworks.SmallTestNetwork().\</span>
<span class="sd">                cross_local_clustering([3,4], [1,2])</span>
<span class="sd">        array([ 0.,  1.])</span>

<span class="sd">        :arg [int] node_list1: list of node indices describing the first</span>
<span class="sd">            subnetwork</span>
<span class="sd">        :arg [int] node_list2: list of node indices describing the second</span>
<span class="sd">            subnetwork</span>
<span class="sd">        :rtype: 1D array [node index]</span>
<span class="sd">        :return: the cross local clustering coefficient.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">nodes1</span><span class="p">,</span> <span class="n">nodes2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">node_list1</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">node_list2</span><span class="p">)</span>
        <span class="c1">#  Get cross degree sequence</span>
        <span class="n">cross_degree</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cross_degree</span><span class="p">(</span><span class="n">nodes1</span><span class="p">,</span> <span class="n">nodes2</span><span class="p">)</span>
        <span class="c1">#  Prepare normalization factor</span>
        <span class="n">norm</span> <span class="o">=</span> <span class="n">cross_degree</span> <span class="o">*</span> <span class="p">(</span><span class="n">cross_degree</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="mf">2.</span>
        <span class="c1">#  Initialize</span>
        <span class="n">cross_clustering</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">nodes1</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float</span><span class="p">)</span>

        <span class="n">_cross_local_clustering</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">adjacency</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">),</span> <span class="n">norm</span><span class="p">,</span>
                                <span class="n">nodes1</span><span class="p">,</span> <span class="n">nodes2</span><span class="p">,</span> <span class="n">cross_clustering</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">cross_clustering</span></div>

<div class="viewcode-block" id="InteractingNetworks.cross_local_clustering_sparse"><a class="viewcode-back" href="../../../api/core/interacting_networks.html#pyunicorn.core.interacting_networks.InteractingNetworks.cross_local_clustering_sparse">[docs]</a>    <span class="k">def</span> <span class="nf">cross_local_clustering_sparse</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node_list1</span><span class="p">,</span> <span class="n">node_list2</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return local cross clustering for a pair of subnetworks.</span>

<span class="sd">        The local cross clustering coefficient C_v gives the probability, that</span>
<span class="sd">        two randomly drawn neighbors in subnetwork 1 of node v in subnetwork 1</span>
<span class="sd">        are also neighbors. It counts triangles having one vertex in</span>
<span class="sd">        subnetwork 1 and two vertices in subnetwork 2.</span>

<span class="sd">        Examples:</span>

<span class="sd">        &gt;&gt;&gt; InteractingNetworks.SmallTestNetwork().\</span>
<span class="sd">                cross_local_clustering_sparse([0,3,5], [1,2,4])</span>
<span class="sd">        array([ 0.,  0.,  0.])</span>

<span class="sd">        &gt;&gt;&gt; InteractingNetworks.SmallTestNetwork().\</span>
<span class="sd">                cross_local_clustering_sparse([2], [1,3,4])</span>
<span class="sd">        array([ 1.])</span>

<span class="sd">        &gt;&gt;&gt; InteractingNetworks.SmallTestNetwork().\</span>
<span class="sd">                cross_local_clustering_sparse([3,4], [1,2])</span>
<span class="sd">        array([ 0.,  1.])</span>

<span class="sd">        :arg [int] node_list1: list of node indices describing the first</span>
<span class="sd">            subnetwork</span>
<span class="sd">        :arg [int] node_list2: list of node indices describing the second</span>
<span class="sd">            subnetwork</span>
<span class="sd">        :rtype: 1D array [node index]</span>
<span class="sd">        :return: the cross local clustering coefficient.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1">#  Get cross degree sequence</span>
        <span class="n">cross_degree</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cross_degree</span><span class="p">(</span><span class="n">node_list1</span><span class="p">,</span> <span class="n">node_list2</span><span class="p">)</span>
        <span class="c1">#  Get full adjacency matrix</span>
        <span class="n">A</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sp_A</span><span class="p">[</span><span class="n">node_list1</span><span class="o">+</span><span class="n">node_list2</span><span class="p">,</span> <span class="p">:][:,</span> <span class="n">node_list1</span><span class="o">+</span><span class="n">node_list2</span><span class="p">]</span>
        <span class="c1">#  Get layer sizes</span>
        <span class="n">N1</span><span class="p">,</span> <span class="n">N2</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">node_list1</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">node_list2</span><span class="p">)</span>
        <span class="c1">#  Convert node lists to Numpy arrays</span>
        <span class="n">nodes1</span><span class="p">,</span> <span class="n">nodes2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">node_list1</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">node_list2</span><span class="p">)</span>

        <span class="c1">#  Initialize</span>
        <span class="n">cross_clustering</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">N1</span><span class="p">)</span>
        <span class="c1">#  Prepare normalization factor</span>
        <span class="n">norm</span> <span class="o">=</span> <span class="n">cross_degree</span> <span class="o">*</span> <span class="p">(</span><span class="n">cross_degree</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span>

        <span class="c1"># Calculate cross clustering from subnetwork 1 to subnetwork 2</span>
        <span class="n">counter</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">node1</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N1</span><span class="p">):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">norm</span><span class="p">[</span><span class="n">node1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="c1"># Reset counter</span>
                <span class="n">counter</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="c1">#  Loop over unique pairs of nodes in subnetwork 2</span>
                <span class="k">for</span> <span class="n">node2</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N1</span><span class="p">,</span> <span class="n">N1</span><span class="o">+</span><span class="n">N2</span><span class="p">):</span>
                    <span class="k">for</span> <span class="n">node3</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N1</span><span class="p">,</span> <span class="n">node2</span><span class="p">):</span>
                        <span class="k">if</span> <span class="p">(</span><span class="n">A</span><span class="p">[</span><span class="n">node1</span><span class="p">,</span> <span class="n">node2</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">A</span><span class="p">[</span><span class="n">node2</span><span class="p">,</span> <span class="n">node3</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span>
                                <span class="ow">and</span> <span class="n">A</span><span class="p">[</span><span class="n">node3</span><span class="p">,</span> <span class="n">node1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">):</span>
                            <span class="n">counter</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="n">cross_clustering</span><span class="p">[</span><span class="n">node1</span><span class="p">]</span> <span class="o">=</span> <span class="n">counter</span> <span class="o">/</span> <span class="n">norm</span><span class="p">[</span><span class="n">node1</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">cross_clustering</span></div>

<div class="viewcode-block" id="InteractingNetworks._calculate_general_closeness"><a class="viewcode-back" href="../../../api/core/interacting_networks.html#pyunicorn.core.interacting_networks.InteractingNetworks._calculate_general_closeness">[docs]</a>    <span class="k">def</span> <span class="nf">_calculate_general_closeness</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">path_lengths</span><span class="p">,</span> <span class="n">internal</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculate general closeness sequence for interacting networks.</span>

<span class="sd">        :type path_lengths: 2D array [node,node] of floats</span>
<span class="sd">        :arg  path_lengths: Path lengths to use</span>
<span class="sd">        :arg bool internal: Indicates, whether internal or cross closeness</span>
<span class="sd">            shall be calculated.</span>
<span class="sd">        :rtype:  1D array [index]</span>
<span class="sd">        :return: the general closeness sequence.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1">#  Get shape of path lengths array</span>
        <span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="n">M</span><span class="p">)</span> <span class="o">=</span> <span class="n">path_lengths</span><span class="o">.</span><span class="n">shape</span>

        <span class="c1">#  Set total number of nodes to be considered for calculation</span>
        <span class="k">if</span> <span class="n">internal</span><span class="p">:</span>
            <span class="n">n_nodes</span> <span class="o">=</span> <span class="n">N</span>
            <span class="n">norm</span> <span class="o">=</span> <span class="n">M</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">n_nodes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">N</span>  <span class="c1"># All nodes of the whole network here!</span>
            <span class="n">norm</span> <span class="o">=</span> <span class="n">M</span>

        <span class="c1">#  Closeness has the length of the first dimension of path lengths</span>
        <span class="n">closeness</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">N</span><span class="p">)</span>

        <span class="c1">#  Identify unconnected pairs and save in binary array isinf</span>
        <span class="n">unconnected_pairs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">isinf</span><span class="p">(</span><span class="n">path_lengths</span><span class="p">)</span>
        <span class="c1">#  Set infinite entries corresponding to unconnected pairs to maximum</span>
        <span class="c1">#  possible path length.</span>
        <span class="n">path_lengths</span><span class="p">[</span><span class="n">unconnected_pairs</span><span class="p">]</span> <span class="o">=</span> <span class="n">n_nodes</span> <span class="o">-</span> <span class="mi">1</span>

        <span class="c1">#  Some nodes have a distance of zero to all their</span>
        <span class="c1">#  neighbors. These nodes get zero closeness centrality.</span>
        <span class="n">path_length_sum</span> <span class="o">=</span> <span class="n">path_lengths</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="c1">#  M entries have been summed over, so we also have to normalize by M</span>
        <span class="n">closeness</span><span class="p">[</span><span class="n">path_length_sum</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> \
            <span class="n">norm</span> <span class="o">/</span> <span class="n">path_length_sum</span><span class="p">[</span><span class="n">path_length_sum</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">]</span>

        <span class="c1">#  Reverse changes to path_lengths</span>
        <span class="n">path_lengths</span><span class="p">[</span><span class="n">unconnected_pairs</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span>

        <span class="k">return</span> <span class="n">closeness</span></div>

<div class="viewcode-block" id="InteractingNetworks.cross_closeness"><a class="viewcode-back" href="../../../api/core/interacting_networks.html#pyunicorn.core.interacting_networks.InteractingNetworks.cross_closeness">[docs]</a>    <span class="k">def</span> <span class="nf">cross_closeness</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node_list1</span><span class="p">,</span> <span class="n">node_list2</span><span class="p">,</span> <span class="n">link_attribute</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return cross closeness sequence for a pair of induced subnetworks.</span>

<span class="sd">        Gives the inverse average geodesic distance from a node in subnetwork 1</span>
<span class="sd">        to all nodes in subnetwork 2.</span>

<span class="sd">        **Examples:**</span>

<span class="sd">        &gt;&gt;&gt; InteractingNetworks.SmallTestNetwork().\</span>
<span class="sd">                cross_closeness([0,3,5], [1,2,4], None)</span>
<span class="sd">        array([ 0.6  ,  0.6  ,  0.375])</span>
<span class="sd">        &gt;&gt;&gt; InteractingNetworks.SmallTestNetwork().\</span>
<span class="sd">                cross_closeness([0,5], [1,2,3,4], None)</span>
<span class="sd">        array([ 0.66666667,  0.4       ])</span>

<span class="sd">        :arg [int] node_list1: list of node indices describing the first</span>
<span class="sd">            subnetwork</span>
<span class="sd">        :arg [int] node_list2: list of node indices describing the second</span>
<span class="sd">            subnetwork</span>
<span class="sd">        :arg str link_attribute: Optional name of the link attribute to be used</span>
<span class="sd">            as the links&#39; length. If None, links have length 1. (Default: None)</span>
<span class="sd">        :rtype: 1D arrays [index]</span>
<span class="sd">        :return: the cross closeness sequence.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">path_lengths</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cross_path_lengths</span><span class="p">(</span><span class="n">node_list1</span><span class="p">,</span> <span class="n">node_list2</span><span class="p">,</span>
                                               <span class="n">link_attribute</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_calculate_general_closeness</span><span class="p">(</span><span class="n">path_lengths</span><span class="p">,</span> <span class="n">internal</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span></div>

<div class="viewcode-block" id="InteractingNetworks.internal_closeness"><a class="viewcode-back" href="../../../api/core/interacting_networks.html#pyunicorn.core.interacting_networks.InteractingNetworks.internal_closeness">[docs]</a>    <span class="k">def</span> <span class="nf">internal_closeness</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node_list</span><span class="p">,</span> <span class="n">link_attribute</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return internal closeness sequence for an induced subnetwork.</span>

<span class="sd">        Gives the inverse average geodesic distance from a node to all other</span>
<span class="sd">        nodes in the same induced subnetwork.</span>

<span class="sd">        However, the included paths will generally contain nodes from the whole</span>
<span class="sd">        network. To avoid this, do the following:</span>

<span class="sd">        &gt;&gt;&gt; r(InteractingNetworks.SmallTestNetwork().\</span>
<span class="sd">                subnetwork([0,3,5]).closeness(None))</span>
<span class="sd">        array([ 1. , 0.6667, 0.6667])</span>

<span class="sd">        **Examples:**</span>

<span class="sd">        &gt;&gt;&gt; InteractingNetworks.SmallTestNetwork().\</span>
<span class="sd">                internal_closeness([0,3,5], None)</span>
<span class="sd">        array([ 1.        ,  0.66666667,  0.66666667])</span>
<span class="sd">        &gt;&gt;&gt; InteractingNetworks.SmallTestNetwork().\</span>
<span class="sd">                internal_closeness([1,2,4], None)</span>
<span class="sd">        array([ 1.,  1.,  1.])</span>

<span class="sd">        :arg [int] node_list: list of node indices describing the subnetwork</span>
<span class="sd">        :arg str link_attribute: Optional name of the link attribute to be used</span>
<span class="sd">            as the links&#39; length. If None, links have length 1. (Default: None)</span>
<span class="sd">        :rtype: 1D array [index]</span>
<span class="sd">        :return: the internal closeness sequence.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">path_lengths</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">internal_path_lengths</span><span class="p">(</span><span class="n">node_list</span><span class="p">,</span> <span class="n">link_attribute</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_calculate_general_closeness</span><span class="p">(</span><span class="n">path_lengths</span><span class="p">,</span> <span class="n">internal</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span></div>

<div class="viewcode-block" id="InteractingNetworks.cross_betweenness"><a class="viewcode-back" href="../../../api/core/interacting_networks.html#pyunicorn.core.interacting_networks.InteractingNetworks.cross_betweenness">[docs]</a>    <span class="k">def</span> <span class="nf">cross_betweenness</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node_list1</span><span class="p">,</span> <span class="n">node_list2</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the cross betweenness sequence for the whole network with</span>
<span class="sd">        respect to a pair of subnetworks.</span>

<span class="sd">        Gives the normalized number of shortest paths only between nodes from</span>
<span class="sd">        **two** subnetworks, in which a node :math:`i` is contained. This is</span>
<span class="sd">        equivalent to the inter-regional / inter-group betweenness with respect</span>
<span class="sd">        to subnetwork 1 and subnetwork 2.</span>

<span class="sd">        **Examples:**</span>

<span class="sd">        &gt;&gt;&gt; _i()</span>
<span class="sd">        &gt;&gt;&gt; InteractingNetworks.SmallTestNetwork().\</span>
<span class="sd">                cross_betweenness([2], [3,5])</span>
<span class="sd">        #array([ 1.,  1.,  0.,  0.,  1.,  0.])</span>
<span class="sd">        &gt;&gt;&gt; InteractingNetworks.SmallTestNetwork().\</span>
<span class="sd">                cross_betweenness(range(0,6), range(0,6))</span>
<span class="sd">        array([ 9.,  3.,  0.,  2.,  6.,  0.])</span>

<span class="sd">        :arg [int] node_list1: list of node indices describing the first</span>
<span class="sd">            subnetwork</span>
<span class="sd">        :arg [int] node_list2: list of node indices describing the second</span>
<span class="sd">            subnetwork</span>
<span class="sd">        :rtype: 1D arrays [node index]</span>
<span class="sd">        :return: the cross betweenness sequence for the whole network with</span>
<span class="sd">            respect to two subnetworks.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">interregional_betweenness</span><span class="p">(</span><span class="n">sources</span><span class="o">=</span><span class="n">node_list1</span><span class="p">,</span>
                                              <span class="n">targets</span><span class="o">=</span><span class="n">node_list2</span><span class="p">)</span></div>

<div class="viewcode-block" id="InteractingNetworks.internal_betweenness"><a class="viewcode-back" href="../../../api/core/interacting_networks.html#pyunicorn.core.interacting_networks.InteractingNetworks.internal_betweenness">[docs]</a>    <span class="k">def</span> <span class="nf">internal_betweenness</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node_list</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the internal betweenness sequence for an induced subnetwork.</span>

<span class="sd">        Gives the normalized number of shortest paths only between nodes from</span>
<span class="sd">        subnetwork 1, in which a node :math:`i` from the whole network is</span>
<span class="sd">        contained.  This is equivalent to the inter-regional / inter-group</span>
<span class="sd">        betweenness with respect to subnetwork 1 and subnetwork 1.</span>

<span class="sd">        **Examples:**</span>

<span class="sd">        &gt;&gt;&gt; InteractingNetworks.SmallTestNetwork().\</span>
<span class="sd">                internal_betweenness(range(0,6))</span>
<span class="sd">        array([ 9.,  3.,  0.,  2.,  6.,  0.])</span>

<span class="sd">        :arg [int] node_list: list of node indices describing the subnetwork</span>
<span class="sd">        :rtype: 1D array [node index]</span>
<span class="sd">        :return: the internal betweenness sequence for layer 1.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">interregional_betweenness</span><span class="p">(</span><span class="n">sources</span><span class="o">=</span><span class="n">node_list</span><span class="p">,</span>
                                              <span class="n">targets</span><span class="o">=</span><span class="n">node_list</span><span class="p">)</span></div>

<div class="viewcode-block" id="InteractingNetworks.nsi_cross_degree"><a class="viewcode-back" href="../../../api/core/interacting_networks.html#pyunicorn.core.interacting_networks.InteractingNetworks.nsi_cross_degree">[docs]</a>    <span class="k">def</span> <span class="nf">nsi_cross_degree</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node_list1</span><span class="p">,</span> <span class="n">node_list2</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the n.s.i. cross-degree for a pair of induced subnetworks.</span>

<span class="sd">        Gives an estimation about the quota of the whole domain of interest of</span>
<span class="sd">        the subnetwork 2 any node in the subnetwork 1 is connected to.</span>

<span class="sd">        **Examples:**</span>

<span class="sd">        &gt;&gt;&gt; InteractingNetworks.SmallTestNetwork().\</span>
<span class="sd">                nsi_cross_degree([0,1,2],[3,4,5])</span>
<span class="sd">        array([ 4.2,  2.6,  1.4])</span>
<span class="sd">        &gt;&gt;&gt; InteractingNetworks.SmallTestNetwork().\</span>
<span class="sd">                nsi_cross_degree([0,2,5],[1,4])</span>
<span class="sd">        array([ 1.4,  2.2,  0. ])</span>

<span class="sd">        :arg [int] node_list1: list of node indices describing the subnetwork 1</span>
<span class="sd">        :arg [int] node_list2: list of node indices describing the subnetwork 2</span>
<span class="sd">        :rtype: 1D array [node index]</span>
<span class="sd">        :return: the n.s.i. cross-degree for layer 1.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">cross_A</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">adjacency</span>
                   <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">))[</span><span class="n">node_list1</span><span class="p">,</span> <span class="p">:][:,</span> <span class="n">node_list2</span><span class="p">]</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">cross_A</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">node_weights</span><span class="p">[</span><span class="n">node_list2</span><span class="p">])</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span></div>

<div class="viewcode-block" id="InteractingNetworks.nsi_cross_mean_degree"><a class="viewcode-back" href="../../../api/core/interacting_networks.html#pyunicorn.core.interacting_networks.InteractingNetworks.nsi_cross_mean_degree">[docs]</a>    <span class="k">def</span> <span class="nf">nsi_cross_mean_degree</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node_list1</span><span class="p">,</span> <span class="n">node_list2</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the n.s.i. cross-mean degree for a pair of induced subnetworks.</span>

<span class="sd">        **Examples:**</span>

<span class="sd">        &gt;&gt;&gt; InteractingNetworks.SmallTestNetwork().\</span>
<span class="sd">                nsi_cross_mean_degree([0,1,2],[3,4,5])</span>
<span class="sd">        2.5</span>
<span class="sd">        &gt;&gt;&gt; r(InteractingNetworks.SmallTestNetwork().\</span>
<span class="sd">                nsi_cross_mean_degree([0,2,5],[1,4]))</span>
<span class="sd">        0.95</span>

<span class="sd">        :arg [int] node_list1: list of node indices describing the subnetwork 1</span>
<span class="sd">        :arg [int] node_list2: list of node indices describing the subnetwork 2</span>
<span class="sd">        :return float: the n.s.i. cross-mean degree for layer 1.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">nsi_cross</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nsi_cross_degree</span><span class="p">(</span><span class="n">node_list1</span><span class="p">,</span> <span class="n">node_list2</span><span class="p">)</span>
        <span class="n">node_weights</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">node_weights</span><span class="p">[</span><span class="n">node_list1</span><span class="p">]</span>
        <span class="n">W_i</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">node_weights</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">sum</span><span class="p">(</span><span class="n">nsi_cross</span> <span class="o">*</span> <span class="n">node_weights</span><span class="p">)</span> <span class="o">/</span> <span class="n">W_i</span></div>

<div class="viewcode-block" id="InteractingNetworks.nsi_internal_degree"><a class="viewcode-back" href="../../../api/core/interacting_networks.html#pyunicorn.core.interacting_networks.InteractingNetworks.nsi_internal_degree">[docs]</a>    <span class="k">def</span> <span class="nf">nsi_internal_degree</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node_list</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the n.s.i. internal degree sequence of one induced subnetwork.</span>

<span class="sd">        **Examples:**</span>

<span class="sd">        &gt;&gt;&gt; InteractingNetworks.SmallTestNetwork().\</span>
<span class="sd">                nsi_internal_degree([0,3,5])</span>
<span class="sd">        array([ 3.4,  1.8,  2.2])</span>
<span class="sd">        &gt;&gt;&gt; InteractingNetworks.SmallTestNetwork().\</span>
<span class="sd">                nsi_internal_degree([0,1,3,5])</span>
<span class="sd">        array([ 3.4,  2. ,  2.6,  2.2])</span>

<span class="sd">        :arg [int] node_list: list of node indices describing the subnetwork</span>
<span class="sd">        :rtype: 1D array [node index]</span>
<span class="sd">        :return: the n.s.i. internal degree sequence</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">nsi_cross_degree</span><span class="p">(</span><span class="n">node_list</span><span class="p">,</span> <span class="n">node_list</span><span class="p">)</span></div>

<div class="viewcode-block" id="InteractingNetworks.nsi_cross_local_clustering"><a class="viewcode-back" href="../../../api/core/interacting_networks.html#pyunicorn.core.interacting_networks.InteractingNetworks.nsi_cross_local_clustering">[docs]</a>    <span class="k">def</span> <span class="nf">nsi_cross_local_clustering</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node_list1</span><span class="p">,</span> <span class="n">node_list2</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the n.s.i. cross-local clustering coefficient for a pair of</span>
<span class="sd">        induced subnetworks.</span>

<span class="sd">        **Examples:**</span>

<span class="sd">        &gt;&gt;&gt; InteractingNetworks.SmallTestNetwork().\</span>
<span class="sd">                nsi_cross_local_clustering([0,1,2],[3,4,5])</span>
<span class="sd">        array([ 0.33786848,  0.50295858,  1.  ])</span>
<span class="sd">        &gt;&gt;&gt; InteractingNetworks.SmallTestNetwork().\</span>
<span class="sd">                nsi_cross_local_clustering([0,2,5],[1,4])</span>
<span class="sd">        array([ 1.,  1.,  0.])</span>

<span class="sd">        :arg [int] node_list1: list of node indices describing the subnetwork 1</span>
<span class="sd">        :arg [int] node_list2: list of node indices describing the subnetwork 2</span>
<span class="sd">        :rtype: 1D array [node index]</span>
<span class="sd">        :return: the n.s.i. cross-local clustering coefficient for layer 1.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">nodes1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">node_list1</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
        <span class="n">nodes2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">node_list2</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
        <span class="n">nsi_cc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">nodes1</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float</span><span class="p">)</span>
        <span class="n">_nsi_cross_local_clustering</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">adjacency</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">),</span>
            <span class="n">nsi_cc</span><span class="p">,</span> <span class="n">nodes1</span><span class="p">,</span> <span class="n">nodes2</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">node_weights</span><span class="p">)</span>

        <span class="n">norm</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nsi_cross_degree</span><span class="p">(</span><span class="n">nodes1</span><span class="p">,</span> <span class="n">nodes2</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span>
        <span class="n">nsi_cc</span><span class="p">[</span><span class="n">norm</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">nsi_cc</span><span class="p">[</span><span class="n">norm</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">]</span> <span class="o">/</span> <span class="n">norm</span><span class="p">[</span><span class="n">norm</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">]</span>
        <span class="n">nsi_cc</span><span class="p">[</span><span class="n">norm</span> <span class="o">==</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">return</span> <span class="n">nsi_cc</span></div>

<div class="viewcode-block" id="InteractingNetworks.nsi_cross_closeness_centrality"><a class="viewcode-back" href="../../../api/core/interacting_networks.html#pyunicorn.core.interacting_networks.InteractingNetworks.nsi_cross_closeness_centrality">[docs]</a>    <span class="k">def</span> <span class="nf">nsi_cross_closeness_centrality</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node_list1</span><span class="p">,</span> <span class="n">node_list2</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the n.s.i. cross-closeness centrality for a pair of induced</span>
<span class="sd">        subnetworks.</span>

<span class="sd">        **Examples:**</span>

<span class="sd">        &gt;&gt;&gt; InteractingNetworks.SmallTestNetwork().\</span>
<span class="sd">                nsi_cross_closeness_centrality([0,1,2],[3,4,5])</span>
<span class="sd">        array([ 1.        ,  0.56756757,  0.48837209])</span>
<span class="sd">        &gt;&gt;&gt; InteractingNetworks.SmallTestNetwork().\</span>
<span class="sd">                nsi_cross_closeness_centrality([0,2,5],[1,4])</span>
<span class="sd">        array([ 0.73333333,  1.        ,  0.42307692])</span>

<span class="sd">        :arg [int] node_list1: list of node indices describing the subnetwork 1</span>
<span class="sd">        :arg [int] node_list2: list of node indices describing the subnetwork 2</span>
<span class="sd">        :rtype: 1D array [node index]</span>
<span class="sd">        :return: the n.s.i. cross-closeness for layer 1.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">shortest_paths</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">path_lengths</span><span class="p">()</span>
        <span class="n">node_weights</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">node_weights</span>

        <span class="n">nsi_shortest_paths</span> <span class="o">=</span> <span class="n">shortest_paths</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">shortest_paths</span><span class="p">))</span>
        <span class="n">nsi_shortest_paths</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">isinf</span><span class="p">(</span><span class="n">nsi_shortest_paths</span><span class="p">)]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">N</span> <span class="o">-</span> <span class="mi">1</span>

        <span class="n">nsi_cross_paths</span> <span class="o">=</span> <span class="n">nsi_shortest_paths</span><span class="p">[</span><span class="n">node_list1</span><span class="p">,</span> <span class="p">:][:,</span> <span class="n">node_list2</span><span class="p">]</span>
        <span class="n">W</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">node_weights</span><span class="p">[</span><span class="n">node_list2</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">W</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">nsi_cross_paths</span><span class="p">,</span> <span class="n">node_weights</span><span class="p">[</span><span class="n">node_list2</span><span class="p">])</span></div>

<div class="viewcode-block" id="InteractingNetworks.nsi_internal_closeness_centrality"><a class="viewcode-back" href="../../../api/core/interacting_networks.html#pyunicorn.core.interacting_networks.InteractingNetworks.nsi_internal_closeness_centrality">[docs]</a>    <span class="k">def</span> <span class="nf">nsi_internal_closeness_centrality</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node_list</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the n.s.i. internal closeness sequence of one induced</span>
<span class="sd">        subnetwork.</span>

<span class="sd">        **Examples:**</span>

<span class="sd">        &gt;&gt;&gt; InteractingNetworks.SmallTestNetwork().\</span>
<span class="sd">                nsi_internal_closeness_centrality([0,3,5])</span>
<span class="sd">        array([ 1.        ,  0.68      ,  0.73913043])</span>
<span class="sd">        &gt;&gt;&gt; InteractingNetworks.SmallTestNetwork().\</span>
<span class="sd">                nsi_internal_closeness_centrality([0,1,3,5])</span>
<span class="sd">        array([ 0.84      ,  0.525     ,  0.72413793,  0.6       ])</span>

<span class="sd">        :arg [int] node_list: list of node indices describing the subnetwork</span>
<span class="sd">        :rtype: 1D array [node index]</span>
<span class="sd">        :return: the n.s.i. internal closeness sequence</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">nsi_cross_closeness_centrality</span><span class="p">(</span><span class="n">node_list</span><span class="p">,</span> <span class="n">node_list</span><span class="p">)</span></div>

<div class="viewcode-block" id="InteractingNetworks.nsi_cross_global_clustering"><a class="viewcode-back" href="../../../api/core/interacting_networks.html#pyunicorn.core.interacting_networks.InteractingNetworks.nsi_cross_global_clustering">[docs]</a>    <span class="k">def</span> <span class="nf">nsi_cross_global_clustering</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node_list1</span><span class="p">,</span> <span class="n">node_list2</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the n.s.i. cross-global clustering coefficient for an induced</span>
<span class="sd">        subnetwork 1 with regard to a second induced subnetwork 2.</span>

<span class="sd">        **Examples:**</span>

<span class="sd">        &gt;&gt;&gt; r(InteractingNetworks.SmallTestNetwork().\</span>
<span class="sd">                nsi_cross_global_clustering([0,1,2],[3,4,5]))</span>
<span class="sd">        0.6688</span>

<span class="sd">        :arg [int] node_list1: list of node indices describing the subnetwork 1</span>
<span class="sd">        :arg [int] node_list2: list of node indices describing the subnetwork 2</span>
<span class="sd">        :return float: the n.s.i. cross-global clustering coefficient for the</span>
<span class="sd">            subnetwork 1 with regard to subnetwork 2.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">nsi_cc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nsi_cross_local_clustering</span><span class="p">(</span><span class="n">node_list1</span><span class="p">,</span> <span class="n">node_list2</span><span class="p">)</span>
        <span class="n">node_weights</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">node_weights</span><span class="p">[</span><span class="n">node_list1</span><span class="p">]</span>
        <span class="k">return</span> <span class="nb">sum</span><span class="p">(</span><span class="n">node_weights</span> <span class="o">*</span> <span class="n">nsi_cc</span><span class="p">)</span> <span class="o">/</span> <span class="nb">sum</span><span class="p">(</span><span class="n">node_weights</span><span class="p">)</span></div>

<div class="viewcode-block" id="InteractingNetworks.nsi_internal_local_clustering"><a class="viewcode-back" href="../../../api/core/interacting_networks.html#pyunicorn.core.interacting_networks.InteractingNetworks.nsi_internal_local_clustering">[docs]</a>    <span class="k">def</span> <span class="nf">nsi_internal_local_clustering</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node_list</span><span class="p">):</span>

        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the n.s.i. internal cross-local clustering coefficient for an</span>
<span class="sd">        induced subnetwork.</span>

<span class="sd">        **Examples:**</span>

<span class="sd">        &gt;&gt;&gt; InteractingNetworks.SmallTestNetwork().\</span>
<span class="sd">                nsi_internal_local_clustering([1,2,3,5])</span>
<span class="sd">        array([ 0.73333333,  1.        ,  1.        ,  1.        ])</span>
<span class="sd">        &gt;&gt;&gt; InteractingNetworks.SmallTestNetwork().\</span>
<span class="sd">                nsi_internal_local_clustering([0,2,4])</span>
<span class="sd">        array([ 1.        ,  1.        ,  0.86666667])</span>

<span class="sd">        :arg [int] node_list: list of node indices describing the subnetwork</span>
<span class="sd">        :rtype: 1D numpy array [node_index]</span>
<span class="sd">        :return: the n.s.i. internal-local clustering coefficient for all nodes</span>
<span class="sd">            within the induced subnetwork</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">nsi_cross_local_clustering</span><span class="p">(</span><span class="n">node_list</span><span class="p">,</span> <span class="n">node_list</span><span class="p">)</span></div>

<div class="viewcode-block" id="InteractingNetworks.nsi_cross_betweenness"><a class="viewcode-back" href="../../../api/core/interacting_networks.html#pyunicorn.core.interacting_networks.InteractingNetworks.nsi_cross_betweenness">[docs]</a>    <span class="k">def</span> <span class="nf">nsi_cross_betweenness</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node_list1</span><span class="p">,</span> <span class="n">node_list2</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the n.s.i. cross betweenness sequence for the whole network with</span>
<span class="sd">        respect to a pair of subnetworks.</span>

<span class="sd">        **Examples:**</span>

<span class="sd">        &gt;&gt;&gt; r(InteractingNetworks.SmallTestNetwork().\</span>
<span class="sd">                nsi_cross_betweenness([0,4,5],[1,3]))</span>
<span class="sd">        array([ 6.5333,  1.2   ,  0.    ,</span>
<span class="sd">                0.6769,  0.6769,  0.    ])</span>
<span class="sd">        &gt;&gt;&gt; r(InteractingNetworks.SmallTestNetwork().\</span>
<span class="sd">                nsi_cross_betweenness([0,1],[2,3,4,5]))</span>
<span class="sd">        array([ 2.1333,  0.    ,  0.    ,</span>
<span class="sd">                0.4923,  0.9209,  0.    ])</span>

<span class="sd">        :arg [int] node_list1: list of node indices describing the first</span>
<span class="sd">            subnetwork</span>
<span class="sd">        :arg [int] node_list2: list of node indices describing the second</span>
<span class="sd">            subnetwork</span>
<span class="sd">        :rtype: 1D arrays [node index]</span>
<span class="sd">        :return: the n.s.i. cross betweenness sequence for the whole network</span>
<span class="sd">            with respect to two subnetworks.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">nsi_interregional_betweenness</span><span class="p">(</span><span class="n">sources</span><span class="o">=</span><span class="n">node_list1</span><span class="p">,</span>
                                                  <span class="n">targets</span><span class="o">=</span><span class="n">node_list2</span><span class="p">)</span></div>

<div class="viewcode-block" id="InteractingNetworks.nsi_cross_edge_density"><a class="viewcode-back" href="../../../api/core/interacting_networks.html#pyunicorn.core.interacting_networks.InteractingNetworks.nsi_cross_edge_density">[docs]</a>    <span class="k">def</span> <span class="nf">nsi_cross_edge_density</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node_list1</span><span class="p">,</span> <span class="n">node_list2</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the n.s.i. density of edges between two subnetworks.</span>

<span class="sd">        **Examples:**</span>

<span class="sd">        &gt;&gt;&gt; r(InteractingNetworks.SmallTestNetwork().\</span>
<span class="sd">                nsi_cross_edge_density([1,2,3],[0,5]))</span>
<span class="sd">        0.1091</span>
<span class="sd">        &gt;&gt;&gt; r(InteractingNetworks.SmallTestNetwork().\</span>
<span class="sd">                nsi_cross_edge_density([0],[1,4,5]))</span>
<span class="sd">        0.7895</span>

<span class="sd">        :arg [int] node_list1: list of node indices describing the first</span>
<span class="sd">            subnetwork</span>
<span class="sd">        :arg [int] node_list2: list of node indices describing the second</span>
<span class="sd">            subnetwork</span>
<span class="sd">        :return float: the n.s.i. cross density of edges between two</span>
<span class="sd">            subnetworks 1 and 2.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">W_j</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">node_weights</span><span class="p">[</span><span class="n">node_list2</span><span class="p">])</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">nsi_cross_mean_degree</span><span class="p">(</span><span class="n">node_list1</span><span class="p">,</span> <span class="n">node_list2</span><span class="p">)</span> <span class="o">/</span> <span class="n">W_j</span></div>

<div class="viewcode-block" id="InteractingNetworks.nsi_cross_transitivity"><a class="viewcode-back" href="../../../api/core/interacting_networks.html#pyunicorn.core.interacting_networks.InteractingNetworks.nsi_cross_transitivity">[docs]</a>    <span class="k">def</span> <span class="nf">nsi_cross_transitivity</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node_list1</span><span class="p">,</span> <span class="n">node_list2</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return n.s.i. cross-transitivity for a pair of subnetworks.</span>

<span class="sd">        **Examples:**</span>

<span class="sd">        &gt;&gt;&gt; r(InteractingNetworks.SmallTestNetwork().\</span>
<span class="sd">                nsi_cross_transitivity([1,2],[0,3,4,5]))</span>
<span class="sd">        0.6352</span>
<span class="sd">        &gt;&gt;&gt; InteractingNetworks.SmallTestNetwork().\</span>
<span class="sd">                nsi_cross_transitivity([0,2,3],[1])</span>
<span class="sd">        1.0</span>


<span class="sd">        :arg [int] node_list1: list of node indices describing the first</span>
<span class="sd">            subnetwork</span>
<span class="sd">        :arg [int] node_list2: list of node indices describing the second</span>
<span class="sd">            subnetwork</span>
<span class="sd">        :return float: the n.s.i. cross transitivity for a pair of subnetworks</span>
<span class="sd">            1 and 2.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_nsi_cross_transitivity</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">adjacency</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">),</span>
            <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">node_list1</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">node_list2</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">node_weights</span><span class="p">)</span></div>

<div class="viewcode-block" id="InteractingNetworks.nsi_cross_average_path_length"><a class="viewcode-back" href="../../../api/core/interacting_networks.html#pyunicorn.core.interacting_networks.InteractingNetworks.nsi_cross_average_path_length">[docs]</a>    <span class="k">def</span> <span class="nf">nsi_cross_average_path_length</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node_list1</span><span class="p">,</span> <span class="n">node_list2</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return n.s.i. cross average path length between two induced</span>
<span class="sd">        subnetworks.</span>

<span class="sd">        **Examples:**</span>

<span class="sd">        &gt;&gt;&gt; net = InteractingNetworks.SmallTestNetwork()</span>
<span class="sd">        &gt;&gt;&gt; r(net.nsi_cross_average_path_length([0,5],[1,2,4]))</span>
<span class="sd">        3.3306</span>
<span class="sd">        &gt;&gt;&gt; r(net.nsi_cross_average_path_length([1,3,4,5],[2]))</span>
<span class="sd">        0.376</span>

<span class="sd">        :arg [int] node_list1: list of node indices describing the first</span>
<span class="sd">            subnetwork</span>
<span class="sd">        :arg [int] node_list2: list of node indices describing the second</span>
<span class="sd">            subnetwork</span>
<span class="sd">        :return float: the n.s.i. cross-average path length between a pair of</span>
<span class="sd">            subnetworks.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">shortest_paths</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">path_lengths</span><span class="p">()</span>
        <span class="n">nsi_shortest_paths</span> <span class="o">=</span> <span class="n">shortest_paths</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">shortest_paths</span><span class="p">))</span>
        <span class="n">node_weights</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">node_weights</span>

        <span class="n">Wi</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">node_weights</span><span class="p">[</span><span class="n">node_list1</span><span class="p">])</span>
        <span class="n">Wj</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">node_weights</span><span class="p">[</span><span class="n">node_list1</span><span class="p">])</span>

        <span class="n">w_v</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="n">node_list2</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">node_list1</span><span class="p">)])</span>
        <span class="n">w_v</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">node_weights</span><span class="p">[</span><span class="n">node_list1</span><span class="p">]</span>
        <span class="n">w_q</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="n">node_list1</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">node_list2</span><span class="p">)])</span>
        <span class="n">w_q</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">node_weights</span><span class="p">[</span><span class="n">node_list2</span><span class="p">]</span>

        <span class="n">Wij</span> <span class="o">=</span> <span class="n">w_v</span><span class="o">.</span><span class="n">transpose</span><span class="p">()</span> <span class="o">+</span> <span class="n">w_q</span>
        <span class="n">nsi_cross_paths</span> <span class="o">=</span> <span class="n">nsi_shortest_paths</span><span class="p">[</span><span class="n">node_list1</span><span class="p">,</span> <span class="p">:][:,</span> <span class="n">node_list2</span><span class="p">]</span>
        <span class="n">Wij</span> <span class="o">=</span> <span class="n">Wij</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">isinf</span><span class="p">(</span><span class="n">nsi_cross_paths</span><span class="p">)]</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
        <span class="n">nsi_shortest_paths</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">isinf</span><span class="p">(</span><span class="n">nsi_shortest_paths</span><span class="p">)]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">N</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="n">nsi_cross_paths</span> <span class="o">=</span> <span class="n">nsi_shortest_paths</span><span class="p">[</span><span class="n">node_list1</span><span class="p">,</span> <span class="p">:][:,</span> <span class="n">node_list2</span><span class="p">]</span>

        <span class="n">Lij</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">nsi_cross_paths</span><span class="o">*</span><span class="n">node_weights</span><span class="p">[</span><span class="n">node_list2</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">Lij</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">Lij</span> <span class="o">*</span> <span class="n">node_weights</span><span class="p">[</span><span class="n">node_list1</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">Lij</span> <span class="o">/</span> <span class="p">(</span><span class="n">Wi</span><span class="o">*</span><span class="n">Wj</span> <span class="o">-</span> <span class="n">Wij</span><span class="p">)</span></div></div>
</pre></div>

          </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li><a href="../../../index.html">home</a>|&nbsp;</li>
        <li><a href="../../../search.html">search</a>|&nbsp;</li>

          <li class="nav-item nav-item-1"><a href="../../index.html" >Module code</a> &#187;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2008-2019, Jonathan F. Donges and pyunicorn authors.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.5.6.
    </div>
  </body>
</html>