#-*- Python -*-
""".. module:: Swoop

.. moduleauthor:: Steven Swanson (swanson@cs.ucsd.edu)

Swoop is a library of Python objects for representing and manipulating
Cadsoft Eagle board, schematic, and library files used in designing printed
circuit boards (PCBs).  It parses an input Eagle file, creates a internal
representation data structure that represents the file's contents,
provides accessors and mutators to query, read, and modify those contents, and
generates valid Eagle files as output.

Swoop uses several different objects to represent and manipulate Eagle files.

 1. **EagleFilePart** Swoop use a tree of :class:`EagleFilePart` objects to represent an Eagle file.  There many subclasses of :class:`EagleFilePart` that correspond to different parts of the file.

 2. **Utility classes**  Most notably :class:`From` which provides a fluent interface for Eagle files and :class:`EagleFilePartVisitor` which implements a visitor framework for Swoop data structures.

 3. **Exception classes** For reporting errors.

In addition, Swoop provides :doc:`several mechanisms  </ExtendingSwoop>` for extending its functionality.

Because the Swoop data structures map (almost) directly to Eagle file
structures, some understanding of the Eagle file format is necessary in order
to use Swoop.  However, it is possible to use Swoop without understanding all
the details the format.  The eagle.dtd that ships with Eagle (in the 'doc'
directory) is a good place to start learning about the file format.  If you are
familiar with Eagle, the file format is relatively easy to understand.

The code for most of Swoop is autogenerated by a Python script called
:code:`GenerateSwoop.py` using the Jinja templating system.

Swoop was created by the `NVSL <http://nvsl.ucsd.edu/>`_ at  `UCSD <http://www.ucsd.edu/>`_ as part of the  `Gadgetron project <http://nvsl.ucsd.edu/index.php?path=projects/gadget>`_. 
"""
from __future__ import print_function

from lxml import etree as ET
import io
import logging as log
import copy
import os
import sys
import re
import pickle
import argparse
import inspect
from . import DRU
import collections
import math
from functools import reduce
import pkg_resources

PY2 = sys.version_info < (3,0)


class EagleFormatError(Exception):
    """
    An error occured durig parsing an input file or generating an output file.
    """
    def __init__(self, text=""):
        self.text = text
    def __str__(self):
        return self.text

def NotImplemented(s):
    raise NotImplementedError(s)

def parse_version(v):
    return tuple(map(int, v.split(".")))

class SetNoPickleAction(argparse.Action):
    def __call__(self, parser, namespace, values, option_string=None):
        EagleFile.enablePickle = False
class SetPickleAction(argparse.Action):
    def __call__(self, parser, namespace, values, option_string=None):
        EagleFile.enablePickle = True

def add_args_to_parser(parser):
    parser.add_argument('--swoop:nopickle', nargs=0, action=SetNoPickleAction)
    parser.add_argument('--swoop:pickle', nargs=0, action=SetPickleAction)
    
class SwoopError (Exception):
    """
    An Swoop-related error occurred.
    """
    def __init__(self, text):
        self.text = text
    def __str__(self):
        return self.text


class EagleFilePart(object):

    """

    Base class for all eagle tag objects.  It provides fallback implementations
    of core features, facilities for navagating the part tree, and provides the
    :code:`parent` attribute.
    

    """
    
    def __init__(self):
        self.parent = None

    def get_file(self):
        """
        Get the :class:`EagleFile` containing this object.

        :rtype: :class:`EagleFile`

        """
        r = self.get_root()
        if isinstance(r, EagleFile):
            return r
        else:
            return None

    def get_class_for_tag(self, tag):
        if self.get_file() is None:
            raise NotImplementedError("Creation of children from file-less EFPs is not supported")
        # print "---"
        # print type(self.get_file()).__name__
        # print type(self.get_file()).class_map["library"]
        # print "+++"
        return type(self.get_file()).class_map[tag]
    
    def get_parent(self):
        """
        Get this object's parent.

        :returns: The object's parent.
        :rtype: :class:`EagleFilePart`
        """
        return self.parent

    def detach(self):
        """
        Remove this :class:'EagleFilePart` from its parent.

        :returns: :code:`self`
        :rtype: :class:`EagleFilePart`
        
        """
        self.parent.remove_child(self)
        return self
    
    @classmethod
    def _from_et (cls, et):
        """
        Parse the part from an Element Tree

        """
        raise NotImplementedError("_from_et not implemented in {}".format(cls))
    
    def get_et (self):
        """
        Generate an element tree that represents the :code:`EagleFilePart`.

        :rtype: :class:`etree.ElementTree`

        """
        raise NotImplementedError()

    def get_xml (self, pretty_print=False):
        """
        Return a string that contains the XML representation of this :code:`EagleFilePart`.

        :rtype: :code:`str`

        """
        
        return ET.tostring(self.get_et(),pretty_print=pretty_print)


    def get_root(self):
        """ 
        Find the root of this :class:`EagleFilePart` tree.  This may or may not be an :class:`EagleFile`.

        :rtype: :class:`EagleFilePart`

        """
        if self.get_parent() is not None:
            return self.get_parent().get_root()
        else:
            return self

    def get_DRU(self):
        """
        Return the :class:`DRUFile` object associated with this :code:`EagleFilePart`.
        """
        root = self.get_root()
        if isinstance(root, EagleFile):
            return root.DRUFile
        else:
            return None;
    
    def clone(self):
        """
        Clone the :class:`EagleFilePart`.  It should be identical to the orginial, except that the parent should be :code:`None`.

        :rtype: :class:`EagleFilePart`
        """
        raise NotImplementedError()

    def get_children(self):
        """
        Return a list of all the :code:`EagleFilePart` children of this :code:`EagleFilePart`

        :rtype: List of :class:`EagleFilePart` objects 

        """
        raise NotImplementedError()

    def check_sanity(self, visited_efps = None):
        """
        Perform a (recursive) sanity check on this :code:`EagleFilePart`
        
        :rtype: :code:`None`
        """
        if visited_efps is None:
            visited_efps = {}
        
        for i in self.get_children():
            if i in visited_efps:
                raise SwoopError("Child visited twice. Original parent was {}.  This parent is {}".format(str(visited_efps[i]), str(self)))
            visited_efps[i] = self
            if i.parent != self:
                raise SwoopError("Parent pointer mismatch.  Child = " + str(i) + "; child.parent = " + str(i.parent) + "; Parent = " + str(self) )
            i.check_sanity(visited_efps)

    def with_type(self,t):
        """
        Filter this :code:`EagleFilePart` object based on its type.  For use in combination with :class:`From` objects.
        
        Return :code:`self` if self is an instance of type :code:`t` and :code:`None` otherwise.  This is useful in combination with :class:`From` object.
        
        :param t: The type to check for.
        :returns: :code:`self` if self is an instance of type :code:`t` and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """
        return self if isinstance(self, t) else None

    def without_type(self,t):
        """
        Filter this :code:`EagleFilePart` object based on its non-membership in a type. 
        
        Return :code:`self` if self is not an instance of type :code:`t` and :code:`None` otherwise.  This is useful in combination with :class:`From` object.
        
        :param t: The type to check for.
        :returns: :code:`self` if self is not an instance of type :code:`t` and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """
        return self if not isinstance(self, t) else None

    def make_from(self):
        """
        Create a a :class:`From` object containing this object.

        :returns: :class:`From` object containing this object.
        :rtype: :class:`From`

        """
        return From(self)
    
def parseByType(efp, attrType, default, s):

    try:
        if attrType == "None_is_default_string":
            if s is None:
                r = default
            else:
                r = s
        elif attrType == "None_is_default_float":
            if s is None:
                r = default
            else:
                r = float(s)
        elif attrType == "None_is_default_int":
            assert isinstance(default, int)
            if s is None:
                r = default
            else:
                r = int(s)
            assert isinstance(r, int)
        elif attrType == "locked_bool":
            r = (s == "yes")
        elif attrType == "display_bool":
            r = (s != "off")
        elif attrType == "constant_bool":
            r = (s != "no")
        elif s is not None:
            if attrType == "str":
                r = s
            elif attrType == "int":
                r = int(s)
            elif attrType == "float":
                r = float(s)
            elif attrType == "bool":

                if s.upper() in ["YES"]:
                    r = True
                elif s.upper() in ["NO"]:
                    r = False
                else:
                    raise SwoopError("Invalid eagle bool value '" + s +"' in child of " + str(efp))
            elif attrType == "layer_string":
                r = efp.get_file().layer_number_to_name(int(s))
            else:
                raise SwoopError("Unknown attr type '" + attrType + "'")
            assert r is not None
        else:
            r = None
    except ValueError as e:
        raise SwoopError("Bad value: '{}' should be {} ({}) {}".format(s, attrType,e, efp))

    return r

def num_to_str(f): # render integers without the '.0' e.g., 1.0 should be "1"
    if f - math.ceil(f) == 0:
        return str(int(f))
    else:
        return str(f)
    
def unparseByType(efp, attrType, default, v):
    if v is None:
        return v

    if attrType == "None_is_default_string":
        assert default is not None
        if v == default:
            r = None
        else:
            r = v
    elif attrType == "None_is_default_float":
        assert default is not None
        if v == default:
            r = None
        else:
            r = num_to_str(v)
    elif attrType == "None_is_default_int":
        assert default is not None
        assert default != "None"
        assert isinstance(v, int)
        if v == default:
            r = None
        else:
            r = str(v)
    elif attrType == "display_bool":
        if v == True:
            r = None;
        else:
            r = "off"
    elif attrType == "locked_bool":
        if v == False:
            r = None;
        else:
            r = "yes"
    else:
        if attrType == "str":  # Doing nothing to strings lets us handle weird
                               # unicode characters.
            r = v 
        elif attrType in ["int", "float"]:
            r = num_to_str(v)
        elif attrType == "bool":
            if v:
                return "yes"
            else:
                return "no"
        elif attrType == "constant_bool":
            if not v:
                r = "no"
            else:
                r = None
        elif attrType == "layer_string":
            #if efp.get_file() is None:
            #print efp.get_root()
            #   print efp.get_name()
            r = str(efp.get_file().layer_name_to_number(v))
        else:
            raise SwoopError("Unknown attr type '" + attrType + "'")

        if attrType != "constant_bool":
            assert r is not None
    
    return r

def typeCheck(type, v, cannotBeNone):
    if v is None:
        return not cannotBeNone
    
    if type == "None_is_default_string":
        return isinstance(v,str) or v is None
    elif type == "None_is_default_float":
        return isinstance(v,float) or isinstance(v,int) or v is None
    elif type == "None_is_default_int":
        return isinstance(v,int) or v is None
    elif type == "locked_bool":
        return isinstance(v,bool)
    elif type == "str" or type == "layer_string": 
        return isinstance(v, str)
    elif type == "int":
        return isinstance(v,int) 
    elif type == "float":
        return isinstance(v,float) or isinstance(v, int)
    elif type == "bool" or type == "constant_bool":
        return isinstance(v,bool)
    else:
        raise SwoopError("Unknown type '" + type + "'")

class PolygonGeometry:
    def __init__(self):
        pass
    
    def get_bounds_points(self):
        return reduce(lambda a,b: a+b, map(lambda x: x.get_bounds_points(), self.get_vertices()), [])

class OnePointGeometry:
    def __init__(self):
        pass
    
    def get_bounds_points(self):
        """
        Get the location of this :class:`EagleFilePart`.
        
        :returns: :code:`[(x, y)]'
        """
        return [(self.get_x(), self.get_y())]

    def set_location(self,x,y):
        """
        Set the location of this :class:`EagleFilePart`.
        
        :param x: x coordinate
        :param y: y coordinate
        :returns: :code:`self`
        """
        self.set_x(x);
        self.set_y(y);
        return self;

    def get_location(self):
        """
        Get the location of this :class:`EagleFilePart`.
        
        :returns: a list: :code:`[x, y]`
        """
        return [self.get_x(),self.get_y()]
    
    def translate(self,dx,dy):
        """
        Move this :class:`EagleFilePart`.
        
        :param dx: change in x coordinate
        :param dy: change in y coordinate
        """
        self.set_x(self.get_x() + dx)
        self.set_y(self.get_y() + dy)
        return self

class DimensionGeometry:
    def __init__(self):
        pass
    def set_size(self,width,height):
        """
        Set the size of this :class:`EagleFilePart`.
        
        :param width: width
        :param height: height
        :returns: :code:`self`
        """
        self.set_dx(width);
        self.set_dy(height);
        return self;

    def get_size(self):
        """
        Get the size of this :class:`EagleFilePart`.
        
        :returns: a list: :code:`[width, height]`
        """
        return [self.get_dx(), self.get_dy()]
    
    def get_width(self):
        """
        Get the width of this :class:`EagleFilePart`.
        
        :returns: the width
        :rtype: :code:`float`
        """
        return self.get_dx()

    def set_width(self,width):
        """
        Set the width of this :class:`EagleFilePart`.
        
        :param width: The width
        :returns: :code:`self`
        """
        self.set_dx(width);
        return self;

    def get_height(self):
        """
        Get the height of this :class:`EagleFilePart`.
        
        :returns: the height
        :rtype: :code:`float`
        """
        return self.get_dy();

    def set_height(self,height):
        """
        Set the height of this :class:`EagleFilePart`.
        
        :param height: The height
        :returns: :code:`self`
        """
        self.set_dy(height);
        return self;


class LineGeometry:
    def __init__(self):
        pass

    def get_bounds_points(self):
        """
        Get the start and end points for this :class:`EagleFilePart`.
        
        :returns: :code:`[start_x, start_y, end_x, end_y]`
        """
        return [(self.get_x1(), self.get_y1()),
                (self.get_x2(), self.get_y2())]
                
    def set_start(self,x,y):
        """
        Set the location of the start point of this :class:`EagleFilePart`.
        
        :param x: x coordinate
        :param y: y coordinate
        :returns: :code:`self`
        """
        self.set_x1(x);
        self.set_y1(y);
        return self;

    def set_end(self,x,y):
        """
        Set the location of the end point of this :class:`EagleFilePart`.
        
        :param x: x coordinate
        :param y: y coordinate
        :returns: :code:`self`
        """
        self.set_x2(x);
        self.set_y2(y);
        return self;

    def get_points(self):
        """
        Get the start and end points for this :class:`EagleFilePart`.
        
        :returns: :code:`[start_x, start_y, end_x, end_y]`
        """
        return [self.get_x1(), self.get_y1(),
                self.get_x2(), self.get_y2()]

    def set_points(self, x1,y1,x2,y2):
        """
        Set the start and end points for this :class:`EagleFilePart`.
        
        :param x1: x coordinate of the start
        :param y1: y coordinate of the start
        :param x2: x coordinate of the end
        :param y2: y coordinate of the end
        :returns: :code:`self`
        """
        self.set_x1(x1);
        self.set_y1(y1);
        self.set_x2(x2);
        self.set_y2(y2);
        return self;

    
    def translate(self,dx,dy):
        """
        Move this :class:`EagleFilePart`.
        
        :param dx: change in x coordinate
        :param dy: change in y coordinate
        """
        self.set_x1(self.get_x1() + dx)
        self.set_y1(self.get_y1() + dy)
        self.set_x2(self.get_x2() + dx)
        self.set_y2(self.get_y2() + dy)
        return self

    def get_length(self):
        return math.sqrt((self.x1-self.x2)**2 + (self.y1-self.y2)**2)
    
class MeasureGeometry(LineGeometry):
    def __init__(self):
        pass
    
    def set_align(self, x,y):
        """
        Set the location of the align point of this :class:`EagleFilePart`.
        
        :param x: x coordinate
        :param y: y coordinate
        :returns: :code:`self`
        """
        self.set_x3(x);
        self.set_y3(y);
        return self;

    def get_align(self):
        """
        Get the location of the align point of this :class:`EagleFilePart`.
        
        :returns: a list: :code:`[x, y]`
        """
        return [self.get_x3(), self.get_y3()]

    def translate(self,dx,dy):
        """
        Move this :class:`EagleFilePart`.
        
        :param dx: change in x coordinate
        :param dy: change in y coordinate
        """
        LineGeometry.translate(self,dx,dy)
        self.set_x3(self.get_x3() + dx)
        self.set_y3(self.get_y3() + dy)
        return self

class RectGeometry:
    def __init__(self):
        pass
    def get_bounds_points(self):
        """
        Get the start and end points for this :class:`EagleFilePart`.
        
        :returns: :code:`[start_x, start_y, end_x, end_y]`
        """
        return [(self.get_x1(), self.get_y1()),
                (self.get_x2(), self.get_y2())]
                
    def set_lefttop(self,left,top):
        """
        Set the location of the top-left corner of this :class:`EagleFilePart`.
        
        :param x: x coordinate
        :param y: y coordinate
        :returns: :code:`self`
        """
        self.set_x1(left);
        self.set_y1(top);
        return self;

    def set_rightbottom(self,right,bottom):
        """
        Set the location of the bottom-right corner of this :class:`EagleFilePart`.
        
        :param x: x coordinate
        :param y: y coordinate
        :returns: :code:`self`
        """
        self.set_x2(right);
        self.set_y2(bottom);
        return self;

    def set_corners(self, left, top, right, bottom):
        """
        Set the start and end points for this :class:`EagleFilePart`.
        
        :param left: left coordinate
        :param top: top coordinate
        :param right: right coordinate
        :param bottom: bottom coordinate
        :returns: :code:`self`
        """
        self.set_x1(left);
        self.set_y1(top);
        self.set_x2(right);
        self.set_y2(bottom);
        return self;

    def get_corners(self):
        """
        Get the start and end points for this :class:`EagleFilePart`.
        
        :returns: :code:`[left, top, right, bottom]`
        """
        return [self.get_x1(), self.get_y1(), self.get_x2(), self.get_y2()]
    
    def translate(self,dx,dy):
        """
        Move this :class:`EagleFilePart`.
        
        :param dx: change in x coordinate
        :param dy: change in y coordinate
        """
        self.set_x1(self.get_x1() + dx)
        self.set_y1(self.get_y1() + dy)
        self.set_x2(self.get_x2() + dx)
        self.set_y2(self.get_y2() + dy)
        return self
    
    def get_height(self):
        return abs(self.get_y1() - self.get_y2())

    def get_width(self):
        return abs(self.get_x1() - self.get_x2())

    def get_area(self):
        return self.get_height() * self.get_width()

class CircleRadiusGeometry:
    def __init__(self):
        pass

    def get_bounds_points(self):
        """
        Get the start and end points for this :class:`EagleFilePart`.

        """
        return [(self.get_x() - self.get_diameter()/2, self.get_y() - self.get_diameter()/2),
                (self.get_x() + self.get_diameter()/2, self.get_y() + self.get_diameter()/2)]
                

    def set_diameter(self,d):
        """
        Set the diameter for this :class:`EagleFilePart`.
        
        :param d: the diameter
        :returns: :code:`self`
        """
        self.set_radius(self,d/2);
        return self
    
    def get_diameter(self):
        """
        Get the diameter for this :class:`EagleFilePart`.
        
        :returns: the diameter
        :rtype: :code:`float`
        """
        return self.get_radius()*2;

class CircleDiameterGeometry:
    def __init__(self):
        pass

    def get_bounds_points(self):
        """
        Get the start and end points for this :class:`EagleFilePart`.

        """
        return [(self.get_x() - self.get_diameter()/2, self.get_y() - self.get_diameter()/2),
                (self.get_x() + self.get_diameter()/2, self.get_y() + self.get_diameter()/2)]
    
    def set_radius(self,r):
        """
        Set the radius for this :class:`EagleFilePart`.
        
        :param r: the radius
        :returns: :code:`self`
        """
        self.set_diameter(self,2*r);
        return self
    
    def get_radius(self):
        """
        Get the radius for this :class:`EagleFilePart`.
        
        :returns: the radius
        :rtype: :code:`float`
        """
        return self.get_diameter()/2;

class RotationGeometry:
    def __init__(self):
        pass

    def _parseRot(self):
        r = self.get_rot();
        if r is None:
            return [False, False, 0]
        
        m = re.match("(M)?(S)?(R)(\d+\.?\d*)", r)
        if m is None:
            raise SwoopError("Illegal rot value: '{}'.".format(r))
        
        v =[m.group(1) is not None,
            m.group(2) is not None,
            float(m.group(4))]
        return v

    def _unparseRot(self, rot):
        self.set_rot("{}{}R{:.1f}".format("M" if rot[0] else "",
                                         "S" if rot[1] else "",
                                         float(rot[2]) % 360.0))
                        
    def set_mirrored(self, m):
        """
        Set the mirrored value of this :class:`EagleFilePart`.
        
        :param m: new mirrored value
        :returns: :code:`self`
        """
        t = self._parseRot();
        t[0] = m;
        self._unparseRot(t);
        return self
    
    def set_spin(self, s):
        """
        Set the spin value of this :class:`EagleFilePart`.
        
        :param m: new spin value
        :returns: :code:`self`
        """
        t = self._parseRot();
        t[1] = s;
        self._unparseRot(t);
        return self

    def set_rotation(self, r):
        """
        Set the rotation value of this :class:`EagleFilePart`.
        
        :param m: new rotation value
        :returns: :code:`self`
        """
        t = self._parseRot();
        t[2] = r;
        self._unparseRot(t);
        return self
        
    def get_mirrored(self):
        """
        Get the mirrored value of this :class:`EagleFilePart`.
        
        :returns: :code:`True` if the :class:`EagleFilePart` object is mirrored, otherwise, :code:`False`
        :rtype: Boolean
        """
        return self._parseRot()[0]
    
    def get_spin(self):
        """
        Get the spin value of this :class:`EagleFilePart`.
        
        :returns: :code:`True` if the :class:`EagleFilePart` object is spin, otherwise, :code:`False`
        :rtype: Boolean
        """
        return self._parseRot()[1]
    
    def get_rotation(self):
        """
        Get the rotation value of this :class:`EagleFilePart`.
        
        :returns: the rotation
        :rtype: :code:`float`
        """
        return self._parseRot()[2]

supportedVersions = { 
            (6,0):"eagle-7.2.0.patched.dtd",
            (6,5,0):"eagle-7.2.0.patched.dtd",
            (6,6,0):"eagle-7.2.0.patched.dtd",
            (7,0,0):"eagle-7.2.0.patched.dtd",
            (7,1,0):"eagle-7.2.0.patched.dtd",
            (7,2,0):"eagle-7.2.0.patched.dtd",
            (7,3,0):"eagle-7.2.0.patched.dtd",
            (7,4,0):"eagle-7.2.0.patched.dtd",
            (7,5,0):"eagle-7.2.0.patched.dtd",
            (7,6,0):"eagle-7.2.0.patched.dtd",
            (7,7,0):"eagle-7.2.0.patched.dtd",
            (8,0,2):"eagle-9.2.2.patched.dtd",
            (8,1,0):"eagle-9.2.2.patched.dtd",
            (8,7,0):"eagle-9.2.2.patched.dtd",
            (8,7,1):"eagle-9.2.2.patched.dtd",
            (9,1,0):"eagle-9.2.2.patched.dtd",
            (9,2,0):"eagle-9.2.2.patched.dtd",
            (9,2,1):"eagle-9.2.2.patched.dtd",
            (9,2,2):"eagle-9.2.2.patched.dtd",
            (9,3,0):"eagle-9.2.2.patched.dtd",
            (9,3,1):"eagle-9.2.2.patched.dtd",
            (9,3,2):"eagle-9.2.2.patched.dtd",
            (9,3,3):"eagle-9.2.2.patched.dtd",
            (9,3,4):"eagle-9.2.2.patched.dtd",
            (9,3,5):"eagle-9.2.2.patched.dtd",
            (9,3,6):"eagle-9.2.2.patched.dtd",
            (9,3,7):"eagle-9.2.2.patched.dtd",
        }
        
    
class EagleFile(EagleFilePart):
    """

    Base class for Eagle files.  It handle opening, parsing, validation, associated errors, writing output, and the mapping between layer numbers and layer names.

    This class also serves a factory class for :class:`EagleFilePart` objects.
    Calling the :meth:`new_*()` methods on an :class:`EagleFile`, yields new
    objects that include any Swoop extensions that have been applied.  

    """

    class_map = {}
    boardFileType = None
    schematicFileType = None
    libraryFileType = None
    isRawSwoop = True
    enablePickle = False # disable this because it shows no performance benefit.

    def new_Layer(self):
        return type(self).class_map["layer"]()
    def new_Via(self):
        return type(self).class_map["via"]()
    def new_Pin(self):
        return type(self).class_map["pin"]()
    def new_Text(self):
        return type(self).class_map["text"]()
    def new_Frame(self):
        return type(self).class_map["frame"]()
    def new_Portref(self):
        return type(self).class_map["portref"]()
    def new_Module(self):
        return type(self).class_map["module"]()
    def new_Package3d(self):
        return type(self).class_map["package3d"]()
    def new_Connect(self):
        return type(self).class_map["connect"]()
    def new_Packageinstance(self):
        return type(self).class_map["packageinstance"]()
    def new_Pass(self):
        return type(self).class_map["pass"]()
    def new_Mfgpreviewcolor(self):
        return type(self).class_map["mfgpreviewcolor"]()
    def new_Technology(self):
        return type(self).class_map["technology"]()
    def new_Port(self):
        return type(self).class_map["port"]()
    def new_Approved(self):
        return type(self).class_map["approved"]()
    def new_Wire(self):
        return type(self).class_map["wire"]()
    def new_Sheet(self):
        return type(self).class_map["sheet"]()
    def new_Polygon(self):
        return type(self).class_map["polygon"]()
    def new_Deviceset(self):
        return type(self).class_map["deviceset"]()
    def new_Param(self):
        return type(self).class_map["param"]()
    def new_Label(self):
        return type(self).class_map["label"]()
    def new_Note(self):
        return type(self).class_map["note"]()
    def new_Instance(self):
        return type(self).class_map["instance"]()
    def new_Moduleinst(self):
        return type(self).class_map["moduleinst"]()
    def new_Setting(self):
        return type(self).class_map["setting"]()
    def new_Pad(self):
        return type(self).class_map["pad"]()
    def new_Schematic(self):
        return type(self).class_map["schematic"]()
    def new_Attribute(self):
        return type(self).class_map["attribute"]()
    def new_Gate(self):
        return type(self).class_map["gate"]()
    def new_Circle(self):
        return type(self).class_map["circle"]()
    def new_Smd(self):
        return type(self).class_map["smd"]()
    def new_Rectangle(self):
        return type(self).class_map["rectangle"]()
    def new_Junction(self):
        return type(self).class_map["junction"]()
    def new_Description(self):
        return type(self).class_map["description"]()
    def new_BoardFile(self):
        return type(self).class_map["eagle"]()
    def new_Bus(self):
        return type(self).class_map["bus"]()
    def new_Symbol(self):
        return type(self).class_map["symbol"]()
    def new_Variant(self):
        return type(self).class_map["variant"]()
    def new_Package3dinstance(self):
        return type(self).class_map["package3dinstance"]()
    def new_Class(self):
        return type(self).class_map["class"]()
    def new_Variantdef(self):
        return type(self).class_map["variantdef"]()
    def new_Part(self):
        return type(self).class_map["part"]()
    def new_Grid(self):
        return type(self).class_map["grid"]()
    def new_Library(self):
        return type(self).class_map["library"]()
    def new_Pinref(self):
        return type(self).class_map["pinref"]()
    def new_Device(self):
        return type(self).class_map["device"]()
    def new_Hole(self):
        return type(self).class_map["hole"]()
    def new_Segment(self):
        return type(self).class_map["segment"]()
    def new_Net(self):
        return type(self).class_map["net"]()
    def new_Contactref(self):
        return type(self).class_map["contactref"]()
    def new_Package(self):
        return type(self).class_map["package"]()
    def new_Designrules(self):
        return type(self).class_map["designrules"]()
    def new_Signal(self):
        return type(self).class_map["signal"]()
    def new_Vertex(self):
        return type(self).class_map["vertex"]()
    def new_SchematicFile(self):
        return type(self).class_map["eagle"]()
    def new_Element(self):
        return type(self).class_map["element"]()
    def new_LibraryFile(self):
        return type(self).class_map["eagle"]()
    def new_Compatibility(self):
        return type(self).class_map["compatibility"]()
    def new_Clearance(self):
        return type(self).class_map["clearance"]()
    def new_Dimension(self):
        return type(self).class_map["dimension"]()

    def __init__ (self):
        """
        Construct an empty :class:`EagleFile`.
        """
        EagleFilePart.__init__(self)
        self.filename= None
        self.root = None
        #self.tree = None
        self.layers = {}
        self.layersByName = {}
        self.version = None
        
    def get_filename(self):
        return self.filename
    def set_filename(self, name):
        self.filename = name
        return self

    @classmethod
    def get_DTD(cls, root):
        version = parse_version(root.get('version'))
        filename = supportedVersions[version]
        log.info("Using DTD: {}".format(filename))
        with pkg_resources.resource_stream(__name__, filename) as dtd:
            return ET.DTD(dtd)
    
    @classmethod
    def get_schematic_file_type(cls):
        if cls.schematicFileType is None:
            return SchematicFile
        else:
            return cls.schematicFileType

    @classmethod
    def get_board_file_type(cls):
        if cls.boardFileType is None:
            return BoardFile
        else:
            return cls.boardFileType
        
    @classmethod
    def get_library_file_type(cls):
        if cls.libraryFileType is None:
            return LibraryFile
        else:
            return cls.libraryFileType
        
    def validate(self):
        """
        Check that this file conforms to the eagle DTD. Return True, if it does, False otherwise.

        :rtype: Bool
        """
        et = self.get_et()
        dtd = EagleFile.get_DTD(et)
        if dtd is not None:
            v = dtd.validate(et)
        else:
            log.warning("Can't validate Swoop tree.  DTD is missing.")
            v = True;
        
        if not v:
            log.error("Eagle file opened as '" + str(self.filename) +"' is invalid: " + str(dtd.error_log.filter_from_errors()[0]))
        else:
            log.info("Eagle file opened as '" + str(self.filename) +"' parsed to valid Eagle data.")

        for t in et.findall(".//*"):
            for a in list(t.attrib.values()):
                if a == str(None):
                    log.warning("Eagle file opened as '" + str(self.filename) +"' has 'None' attribute value")
                    return False
        
        return (v, dtd)

    @classmethod
    def open(cls,filename, bestEffort = True, DRUFile=None):
        """
        Loads a Eagle file from a .sch, .lbr, or .brd file.  A synonym for :meth:`EagleFile.from_file`
        
        :param filename: Filename to load.
        :param bestEffort: If :code:`True`, load the file even if it doesn't conform to the DTD.        
        :param DRUFile: A DRU file to use.  You don't need to worry about this unless you need precisely correct answers to questions about the geometry of things on your board.  By default, it uses sensible defaults.
        :returns: A new :class:`BoardFile`, :class:`LibraryFile`, or :class:`SchematicFile` object
        """
        return cls.from_file(filename, bestEffort, DRUFile)

    @classmethod
    def from_etree(cls, et):
        """
        Build file from element tree.

        :param et: Element tree data structure (e.g., returned by :code:`ElementTree.parse(filename)`)
        """
        dtd = EagleFile.get_DTD(et.getroot())
        if dtd:
            if not dtd.validate(et.getroot()):
                raise SwoopError("Tried to load from invalid eTree")
        if issubclass(cls, LibraryFile):
            raise NotImplementedError("Can't create library from raw etree.  What's the librarie's name?")
        return cls._from_et(et.getroot(), None)

    @classmethod
    def from_stream (cls, fileClass, stream, bestEffort = True, DRUFile=None, pickle=True, filename=None):
        """
        Load an Eagle file from a stream.   You need to pass the the class you would like it parsed as.

        :param fileClass: We will return an instance of this class.  Necessary because we may not have a filename.  Good choices are :class:`SchematicFile`, :class:`LibraryFile`, or :class:`BoardFile`.
        :param stream: stream to load. 
        :param bestEffort: If :code:`True`, load the file even if it doesn't conform to the DTD.        
        :returns: A new :class:`BoardFile`, :class:`LibraryFile`, or :class:`SchematicFile` object
        """
        try:
            root = ET.fromstring(stream.read())
        except ET.XMLSyntaxError as e:
            raise EagleFormatError("Eagle file '" + str(filename) +"' doesn't look like XML eagle file.  Try resaving with a newer version of eagle.")
        
        dtd = EagleFile.get_DTD(root)
        v = dtd.validate(root)
        if not v:
            if bestEffort:
                log.warning("Eagle file opened as '" + str(filename) +"' is invalid on disk: " + str(dtd.error_log.filter_from_errors()[0]))
            else:
                raise EagleFormatError("Eagle file opened as '" + str(filename) +"' is invalid on disk: " + str(dtd.error_log.filter_from_errors()[0]))


        if issubclass(fileClass, LibraryFile):
            ef = fileClass._from_et(root, None, filename)
        else:
            ef = fileClass._from_et(root, None)
            
        ef.filename = filename

        if parse_version(ef.get_version()) not in supportedVersions:
            if bestEffort:
                log.warning("Eagle file opened as '" + str(filename) +"' is not one of " + str(supportedVersions) + ".  Doing our best.")
            else:
                raise EagleFormatError("Eagle file opened as '" + str(filename) +"' is not one of " + str(supportedVersions) + ".  Chickening out.")

        if DRUFile is None:
            DRUFile = "default.dru"
            
        with pkg_resources.resource_stream(__name__, DRUFile) as s:

            ef.DRUFile = DRU.DRUFile(s)
            
        ef.check_sanity()
        if cls.isRawSwoop and EagleFile.enablePickle:
            pickle.dump(ef, open(filename + ".pickle", "w"), pickle.HIGHEST_PROTOCOL)

        return ef

    
    @classmethod
    def from_file (cls, filename, bestEffort = True, DRUFile=None, pickle=True):
        """
        Loads a Eagle file from a .sch, .lbr, or .brd file.  A synonym for :meth:`EagleFile.open`

        :param filename: Filename to load. 
        :param bestEffort: If :code:`True`, load the file even if it doesn't conform to the DTD.        
        :returns: A new :class:`BoardFile`, :class:`LibraryFile`, or :class:`SchematicFile` object
        """
        usePickle = False;
        if cls.isRawSwoop:
            realStat = os.stat(filename)
            try:
                pickleStat = os.stat(filename + ".pickle")
                if pickleStat.st_mtime > realStat.st_mtime:
                    usePickle = True
            except Exception as e:
                pass;#print e


            if usePickle and EagleFile.enablePickle:
                ef = pickle.load(open(filename + ".pickle"))
                return ef

        f = open(filename, "rb");
        
        if filename[-4:] == ".sch":
            n = cls.from_stream(cls.get_schematic_file_type(), f, bestEffort, DRUFile, pickle)
        elif filename[-4:] == ".brd":
            n = cls.from_stream(cls.get_board_file_type(), f, bestEffort, DRUFile, pickle)
        elif filename[-4:] == ".lbr":
            n = cls.from_stream(cls.get_library_file_type(), f, bestEffort, DRUFile, pickle, filename=filename)
        else:
            raise SwoopError("Unknown file suffix: '" + filename[-4:] + "'")

        n.set_filename(filename)
        return n

    @staticmethod
    def from_file_by_type(filename, ftype):
        n = EagleFile.from_file(filename)
        if not isinstance(n, ftype):
            raise SwoopError("File is '" + filename + "' is not " + ftype.__name__)
        return n

    def write (self, file, check_sanity=True, dtd_validate=True):
        """
        Exports the Schematic to an EAGLE schematic file.
        
        :param file: Filename or file-like object for output.
        :param check_sanity:  Perform semantic sanity checks before output.
        :param dtd_validate:  Check for DTD compliance before output.
        """

        header="""<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE eagle SYSTEM "eagle.dtd">
""".encode("utf8")
        if check_sanity:
            self.check_sanity()
        et = self.get_et()
        if dtd_validate:
            (v, dtd) =  self.validate()
        else:
            v = True
            dtd = None
   
        if not v:
            if self.filename is not None:
                f = open(self.filename + ".broken.xml", "w")
                to_write = header + ET.tostring(ET.ElementTree(et),pretty_print=True)
                f.write(to_write.decode("utf8"))

            if len(dtd.error_log.filter_from_errors()) > 0:
                raise SwoopError("Swoop structure does not validate" + str(dtd.error_log.filter_from_errors()[0]))
            else:
                raise SwoopError("Swoop structure is not valid.")
        else:
            if hasattr(file, 'read') and hasattr(file, 'write'):
                f = file
                filename = None
            else:
                f = open(file, "w")
                filename = file
            to_write = header+ET.tostring(ET.ElementTree(et),pretty_print=True)
            f.write(to_write.decode("utf8"))

    def add_layer (self, layer):
        """
        Add a layer to this file.
        
        :param layer: The :class:`Layer` to add.

        :rtype: :code:`None`

        """

        assert isinstance(layer, Layer)

        self.layers[int(layer.get_number())] = layer
        self.layersByName[layer.get_name()] = layer
        layer.parent = self

    def get_layer(self, v):
        """
        Lookup a layer by number or name.
        
        :param v: A :code:`str`, or :code:`int` describing a layer.
        :returns: The layer.
        :rtype:  :class:`Layer`
        """
        if isinstance(v, int):
            try:
                return self.layers[v]
            except:
                raise SwoopError("Unknown layer number: {}".format(v))
        elif isinstance(v, str):
            try:
                return self.layersByName[v]
            except:
                raise SwoopError("Unknown layer name: '{}'".format(v))
        else:
            raise SwoopError("Wrong type for layer lookup: {}".format(type(v)))
    
    def get_layers(self):
        """
        Get a list of layers.
        
        :rtype: List of :code:`Swoop.Layer` objects for this eagle file.

        """
        return list(self.layers.values())

    def get_layersByNumber(self):
        """
        Get a map of numbers to Layer objects.

        :rtype: Map of :code:`EagleFilePart` objects keyed by layer number.
        """
        return self.layers

    def get_layersByName(self):
        """
        Get a map of names to Layer objects.

        :rtype: Map of :code:`EagleFilePart` objects keyed by layer number.
        """
        return self.layersByName

    def get_mirrored_layer(self, l):
        """

        Find the mirrored version of a layer.  For 'mirrored' objects, Eagle will
        automatically change layers from a 'top' layer to a 'bottom' layer under the following conditions:

        * The 'top' layer starts with 't' and has an odd layer number.
        * The 'bottom' layer startes with 'b' and has the layer number one higher than the corresponding 'top' layer.
        * The 'top' layer's numbers is less than or equal to 59.

        For instance tPlace (number 21) because bPlace (number 22).

        This function returns the mirrored version of a layer according to the rules above.

        :param l: A :code:`str`, :code:`int`, or :class:`Layer` specifying a layer.
        :returns: A description of the mirrored layer.
        :rtype:  Same type as :code:`l`
        """

        if (isinstance(l, str)):
            return self.get_mirrored_layer(self.layersByName[l]).get_name()
        elif (isinstance(l, int)):
            return self.get_mirrored_layer(self.layers[l]).get_number()
        elif (isinstance(l, Layer)):
            if l.get_number() <= 60: # According to
                                   # http://www.element14.com/community/thread/42249/l/creating-new-pairs-of-topbottom-layers,
                                   # the 't' and 'b' prefixes only work up to
                                   # layer 60
                name = l.get_name()
                if name[0] == "t":
                    assert (l.get_number() % 2) == 1 # 't' layers are supposed to be odd-numbered
                    name = "b" + name[1:]
                elif name[0] == "b":
                    assert (l.get_number() % 2) == 0 # 'b' layers are supposed to be even-numbered
                    name = "t" + name[1:]
                elif name == "Top":
                    name = "Bottom"
                elif name == "Bottom":
                    name = "Top"
                    
                if name not in self.layersByName:
                    raise SwoopError("Tried to mirror layer {}, but '{}' doesn't exist".format(l,name))
                else:
                    return self.layersByName[name]
            return l

    def parse_layer_number(self, num):

        if num is None:
            return None
        return self.layer_number_to_name(num)

    def unparse_layer_name(self, name):
        if name is None:
            return None
        return self.layer_name_to_number(name)
    
    def layer_number_to_name(self, num):

        """
        Given a layer number, return the name.

        :rtype: :class:`Layer` 
        """
        n = int(num)
        if n not in self.layers:
            raise SwoopError("No such layer number: {}".format(num))
        #return "Layer" + str(num)
        else:
            return self.layers[n].name

    def layer_name_to_number(self, name):
        """
        Given a layer name, return the number.

        :rtype: :class:`Layer` 
        """
        assert type(name) is str
        if name not in self.layersByName:
            raise SwoopError("No layer named '" + name + "' in " + str(self.filename))
        return self.layersByName[name].number

    def remove_layer(self, layer):
        """
        Remove a layer.
        
        :param layer: :class:`Layer` object, layer name, or layer number that should be deleted.
        
        :rtype: :code:`None`
        """
        if type(layer) is str:
            l = self.layersByName[layer]
            self.remove_layer(l)
        elif type(layer) is int:
            l = self.layers[layer]
            self.remove_layer(l)
        elif isinstance(layer, Layer):
            self.layersByName[layer.name].parent = None
            del self.layersByName[layer.name]
            del self.layers[int(layer.number)]
        else:
            raise SwoopError("Invalid layer spec: " + str(layer))
            
    # def get_manifest(self):
    #     raise NotImplementedError("Manifest for " + str(type(self)))

    def find_library_by_name(self, l):
        """
        Lookup a library by name and return it.

        :param l: Library name.
        :rtype: :class:`Library` or :code:`None` if the library is not present.
        """
        return self.libraries.get(l)

class nothing():
    def __init__(self):
        pass

def Mixin(mixin, prefix, base=EagleFile):
    """Extend Swoop by adding a mixin to every class.

    This function creates a new subclasses of every class Swoop uses to
    represent an Eagle file (including the file types).  The names of the new
    classes are prefixed with :code:`prefix` and they all inherit from the
    original class and :code:`mixin`.

    :param mixin: Mixin class or module.  Its constructor for a mixin class (Or the classes in a mixin module) should take no arguments.
    :param prefix: Prefix for the class name.  It'll be prepended to the names of all the Swoop classes.
    :param base: Starting point for the extension.  This should either be :class:`Swoop.EagleFile` or a class returned by a previous call to this function.
    :returns: A new subclass of :code:`base` that can be used just like :class:`EagleFile`
    :rtype: A class.

    """
    def Extend(C, m, name):
        class T(C,m):
            class_map={}
            def __init__(self):
                C.__init__(self)
                m.__init__(self)
        T.__name__ = name
        return T

    def get_class_from_module(module, theClass):
        #print module
        #print theClass
        c = inspect.getmembers(module, inspect.isclass)
        #print c
        for i in c:
            if i[1].__name__.split(".")[-1] == theClass.__name__.split(".")[-1]:
                log.debug("Found class '{}' for '{}'".format(i[1], theClass))
                return i[1]
            else:
                log.debug("Class '{}' was no match for '{}'".format(i[1], theClass))
                
        return None
        
    base_mixin = get_class_from_module(mixin,EagleFile)
    base_mixin = base_mixin if base_mixin is not None else nothing

    n = Extend(base, base_mixin, prefix + base.__name__)
    n.isRawSwoop = False
    for i in base.class_map:
        if inspect.isclass(mixin):
            n.class_map[i] = Extend(base.class_map[i], mixin, prefix + base.class_map[i].__name__)
        elif inspect.ismodule(mixin):
            c = get_class_from_module(mixin, EagleFile.class_map[i])
            if c is not None:
                log.info("Patching {} with {}".format(base.class_map[i], c))
                ext =  Extend(base.class_map[i], c, prefix + base.class_map[i].__name__)
                n.class_map[i] = ext
            else:
                n.class_map[i] = base.class_map[i]
        
    board_mixin = get_class_from_module(mixin,BoardFile)
    board_mixin = board_mixin if board_mixin is not None else nothing
        
    schematic_mixin = get_class_from_module(mixin,SchematicFile)
    schematic_mixin = schematic_mixin if schematic_mixin is not None else nothing
        
    library_mixin = get_class_from_module(mixin,LibraryFile)
    library_mixin = library_mixin if library_mixin is not None else nothing
        

    n.boardFileType = Extend(base.get_board_file_type(),
                             board_mixin, prefix + base.get_board_file_type().__name__)
    
    n.schematicFileType = Extend(base.get_schematic_file_type(),
                                 schematic_mixin, prefix + base.get_schematic_file_type().__name__)
    
    n.libraryFileType = Extend(base.get_library_file_type(),
                               library_mixin, prefix + base.get_library_file_type().__name__)

    n.boardFileType.class_map = copy.copy(n.class_map)
    n.schematicFileType.class_map = copy.copy(n.class_map)
    n.libraryFileType.class_map = copy.copy(n.class_map)

    #print("there " + str(n))
    #print("there " + str(n.boardFileType))
    #print("there " + str(n.schematicFileType))
    #print("there " + str(n.libraryFileType))
    #print("there " + str(n.libraryFileType.class_map))
    #print("here" + str(n.class_map.get("library")))
    return n

    
def smartAddSubTags(root, path):

    """
    Add tags as need to create a container for the contents of an xpath.

    :rtype: :code:`None`
    """
    pathSegments = path.split("|")[0].replace("./","").split("/")
    target = root
    for p in pathSegments[0:-1]:
        new_target = target.find(p)
        if new_target is None:
            target = ET.SubElement(target,p)
        else:
            target = new_target
    return target

def filter_list(l, match_type, attrs):
    r = []
    if attrs is None:
        attrs = {}
        
    for efp in l:
        match = True
        for k in attrs:
            if type(attrs[k]) in [str,int,float]:
                match = match and getattr(efp,k) == attrs[k]
            elif callable(attrs[k]):
                match = match and attrs[k](efp)
            else:
                assert False
        if match_type is not None:
            match = match and isinstance(efp, match_type)
        if match:
            r.append(efp)
    return r

def matching(e):
    """Helper function for filtering :class:`From` objects.  The filter allows
    items to pass based on whether they match the regex :code:`e`.  For
    example, this will print the number of packages with names starting with
    "FOO" in a library.

    .. code-block:: python
    
    print(From(library).
          get_packages().
          with_name(matching("^FOO.*")).count()

    """
    return lambda x: re.match(e, x) is not None

def not_matching(e):
    """Helper function for filtering :class:`From` objects.  The filter allows
    items to pass based on whether they *don't* match the regex :code:`e`.  
    
    For example, this will print the number of packages with names not starting
    with "FOO" in a library.

    .. code-block:: python
    
    print(From(library).
          get_packages().
          with_name(not_matching("^FOO.*")).count()

    """
    return lambda x: re.match(e, x) is None


class From(object):
    """An ordered collection of (usually) :class:`EagleFilePart` objects.  Invoke
    a method on a :class:`From` object, invokes the same method with the same
    arguments on all the objects it holds.  The results are placed in a new
    :class:`From` object that is returned.

    :class:`From` objects also provide several utility functions for
    accessing, filtering, mapping, and reducing their contents.

    You can combine the contents of the two :class:`From` objects with the
    :code`+` operator.
    
    :class:`From` objects are iterable.

    """
    def __init__(self, *args):
        r = []
        for i in args:
            if type(i) is list:
                r += i
            elif type(i) == From:
                r += i.efps
            else:
                r += [i]
        self.efps = r

    def __str__(self):
        return "From: " + str(self.efps)

    def __repr__(self):
        return self.__str__()

    def __len__(self):
        return len(self.efps)

    def __getitem__(self,n):
        return self.efps[n]

    def __add__(self, rhs):
        return self.append(rhs)
    
    def __getattr__(self, name):
        def wrapper(*args, **kargs):
            r = []
            for i in self.efps:
                t = getattr(i,name)(*args,**kargs)
                if type(t) is dict:
                    r += list(t.values())
                elif type(t) is list:
                    r += t
                elif t is None:
                    pass
                else:
                    r.append(t)
            return From(r)
        return wrapper

    def append(self, l):
        """
        Merge the contents of :code:`l` into this :class`From` object.

        :param l: Python list of :class:`EagleFilePart` objects, a :class:`From` object, or an :class:`EagleFilePart` object.
        :returns: This :class:`From` object with the new items added.
        :rtype: :class:`From` 
        """
        if type(l) is list:
            self.efps += l
        elif type(l) == From:
            self.efps += l.efps
        else:
            self.efps += [l]
        return self

    def unpack(self):
        """
        Return the contents of the :class:`From` object as a list.
        
        :returns: A list containing the contents of the :class:`From`
        :rtype:  List
        """
        return self.efps

    def first(self):
        """
        Return the first item in the :class:`From` object.  If the :class:`From` is empty, raise an :class:`IndexError` exception.
        
        :returns: The first item in the :class:`From`
        :rtype:  Varies
        :throws: :class:`IndexError`
        """
        try:
            return self.efps[0]
        except:
            return None

    def filtered_by(self, func):
        """
        Filter the :class:`From`.  Similar to the builtin :code:`filter` method.
        
        :returns: A :class:`From` object contain the elements, :code:`x` for which :code:`func(x)` return :code:`True`
        """
        return From([x for x in self.efps if func(x)])

    def unique(self):
        """
        Remove duplicate elements from the :class:`From`
        
        :returns: A :class:`From` object contain the unique elements in this :class:`From`.
        """
        return From(list(set(self.efps)))

    def count(self):
        """
        Count the elements in the :class:`From`

        :returns: The number of elements.
        :rtype: int
        """
        return len(self.efps)

    def sort(self, cmp=None, key=None, reverse=False):
        """
        Sort the :class:`From` object.  Similar to the builtin :code:`sorted` method (and takes the same arguments).

        :param cmp: Comparison function.
        :param key: A key accessor function.
        :param reverse: If :code:`True` sort in reverse order.
        
        :returns: A sorted :class:`From`
        """
        return From(sorted(self.efps, cmp, key, reverse))

    def map(self, func):
        """
        Apply a function to the elments of this :class:`From` and return a :class:`From` containing the results.  Similar to the builtin :code:`map` function.
        
        :param func: The function to apply.
        :returns: A :class:`From` containing the results.
        """
        return From(list(map(func, self.efps)))

    def apply(self, func):
        """Apply a function to the elments of this :class:`From` and return a
        :class:`From` containing the results.  Similar to the builtin
        :code:`map` function.  A synonym for :meth:`From.map`.
        
        :param func: The function to apply.
        :returns: A :class:`From` containing the results.

        """
        return From(list(map(func, self.efps)))

    
    def reduce(self, func, init=None):
        """
        Reduce the elments of this :class:`From` and return the result.  Similar to the builtin :code:`reduce` function.
        
        :param func: The function to apply.
        :param init: The starting value for the reduction.
        :returns: The reduce result
        :rtype: Varies
        """
        if init is None:
            return reduce(func, self.efps)
        else:
            return reduce(func, self.efps, init)

#def from_file(filename):
#    return From(EagleFile.from_file(filename))


class EagleFilePartVisitor(object):
    """A visitor utility class for :class:`EagleFile` objects.  

    The class traverses a subtree of :class:`EagleFilePart` objects in
    depth-first order.  Subclasses can define *vistor* methods of the form
    :code:`*X*_pre()` and :code:`*X*_post()` that will be called in pre-order
    and post-order during the traversal.  If a subclass doesn't define a
    particular an :class:`EagleFilePart` subclass, :meth:`default_pre` and
    :meth:`default_pre` will be used instead.

    Subclasses can also override :meth:`visitFilter` and
    :meth:`decendFilter` to control which :class:`EagleFilePart` the visitor
    invokes the visitor methods on and which :class:`EagleFilePart` the visitor
    decends into.  By default, both visitor methods are called on all
    :class:`EagleFilePart` objects and in the visitor always decends.

    The :meth:`go` method start execution.  It also returns :code:`self` so
    you can easily apply accessor functions after execution.  You can also call
    :meth:`visit` on an :class:`EagleFilePart` object to visit the subtree
    underneath it

    For example, here's a simple visitor that counts the total number of
    :class:`EagleFileParts` in a file and, separately, the number of
    :class:`Element` objects:
    
    .. code-block:: python

        class Counter(SwoopTools.EagleFilePartVisitor):
            def __init__(self, root=None):
                SwoopTools.EagleFilePartVisitor.__init__(self,root)
                self.count = 0;
                self.elementCount = 0
                self.layerCount = 0
            def default_pre(self, efp):
                self.count += 1
            def Element_pre(self, e):
                self.count += 1
                self.elementCount += 1
    
    And you can use it like so:

    .. code-block:: python

        from Swoop import *
        from SwoopTools import *
        ef = EagleFile.from_file(my_file)
        c = Counter(ef)
        print "The file has this many parts: " + str(c.go().count)
        print "There are this many Elements: " + str(c.elementCount)

    """

    def __init__(self, root=None):
        self.root = root

    def go(self):
        """
        Start the visiting process.
        
        :rtype: :code:`self`
        """
        self.visit(self.root)
        return self
    
    def visitFilter(self, e):
        """Predicate that determines whether to call the visit functions on this
        :class:`EagleFilePart`.  The default implementation returns ``True``.
        
        :param e: The :class:`EagleFilePart` to be visited.
        :rtype:   ``Bool``

        """
        return True

    def decendFilter(self, e):
        """Predicate that determines whether to decend into the subtree rooted at ``e``.  The default implementation returns ``True``.
        
        :param e: The root :class:`EagleFilePart`.
        :rtype:   ``Bool``

        """
        return True


    def default_pre(self,e):
        """Default pre-order visitor function.

        This method can return a value that will be passed to the corresponding
        post-order visitor function, making it easy to pass state between the
        two.

        The default implementation does nothing and returns ``None``
        
        :param e: The  :class:`EagleFilePart` being visited.
        :rtype: Any

        """
        return None

    def default_post(self,e, context):
        """Default post-order visitor function.  The default implementation does nothing.
        
        :param e: The  :class:`EagleFilePart` being visited.
        :param context: The value returned by corresponding pre-order visitor.
        :rype: ``None``
        """
        pass

    def visit(self, efp):
        """ Run this visitor on the subtree rooted at ``efp``.
        
        :param efp: The :class:`EagleFilePart` at the root of the tree.
        :rtype:  ``self``
        """
        if self.visitFilter(efp):
            context = efp.accept_preorder_visitor(self)

        if self.decendFilter(efp):
            for e in efp.get_children():        
                self.visit(e)
                
        if self.visitFilter(efp):
            context = efp.accept_postorder_visitor(self, context)

        return self




class Layer(EagleFilePart):
    """
    Class representing the contents of a <layer> tag in Eagle files.

    Attributes:

    * :code:`number`

    * :code:`name`

    * :code:`color`

    * :code:`fill`

    * :code:`visible`

    * :code:`active`


    """
    def __init__(self):
        """
        Construct an empty :class:`Layer` object.
        """
        EagleFilePart.__init__(self)
        
        self.number=None
        self.name=None
        self.color=None
        self.fill=None
        self.visible=None
        self.active=None


        
    @classmethod
    def _from_et(cls,root,parent):
        """
        Create a :class:`Layer` from a :code:`layer` element.
        
        :param root: The element tree tree to parse.
        :param parent: :class:`EagleFilePart` that should hold the resulting :class:`EagleFilePart`
        :rtype: :class:`Layer`
        """
        ## Call the constructor
        n = cls()
        n._init_from_et(root,parent)
        return n

    def _get_error_name(self):
        if hasattr(self, "get_name"):
            return self.get_name();
        else:
            return "Layer";
        
    def  _init_from_et(self, root, parent):
        """
        Initialized a :class:`Layer` from a :code:`layer` element.  This is useful if you have a subclass of :class:`Layer` .
        
        :param root: The element tree tree to parse.
        :param parent: :class:`EagleFilePart` that will become the parent of :code:`this` .
        :rtype: :class:`Layer`
        """
        try:
            self.root = root
            
            if root.tag != "layer":
                raise EagleFormatError("Tried to create layer from " + root.tag)

            self.number=parseByType(parent, "int", None, root.get("number"))
            self.name=parseByType(parent, "str", None, root.get("name"))
            self.color=parseByType(parent, "int", None, root.get("color"))
            self.fill=parseByType(parent, "int", None, root.get("fill"))
            self.visible=parseByType(parent, "bool", None, root.get("visible"))
            self.active=parseByType(parent, "bool", None, root.get("active"))

            self.parent = parent

            ### populate the maps by searching for elements that match xpath and generating objects for them.


            ### Do the same for the lists


            ### Do the same for the attr lists


            ### And the singletons


            ### And, finally, if the objects wants the text from the tag.

        except SwoopError as e:
            e.text = "{}:{}".format(self._get_error_name(), e.text)
            raise e


    def sortkey(self):
        return self.number;

    def get_et(self):
        """
        Generate a <layer> element tree for a :class:`Layer`.
        
        :rtype:  :class:`ElementTree`.
        
        """
        try:
            r = ET.Element("layer")

            ### Set the tag attributes 


            ## Unparse the values.

            v = unparseByType(self, "int", None,  self.number)

            ## For required attributes None becomes "".  For optional attributes, we just leave the attribute out.
            if not (isinstance(self.get_parent(), LibraryFile) and False):  # special case for the name of library.
                if v is not None:
                    r.set("number", v)
                else:
                    r.set("number", "")


            ## Unparse the values.

            v = unparseByType(self, "str", None,  self.name)

            ## For required attributes None becomes "".  For optional attributes, we just leave the attribute out.
            if not (isinstance(self.get_parent(), LibraryFile) and False):  # special case for the name of library.
                if v is not None:
                    r.set("name", v)
                else:
                    r.set("name", "")


            ## Unparse the values.

            v = unparseByType(self, "int", None,  self.color)

            ## For required attributes None becomes "".  For optional attributes, we just leave the attribute out.
            if not (isinstance(self.get_parent(), LibraryFile) and False):  # special case for the name of library.
                if v is not None:
                    r.set("color", v)
                else:
                    r.set("color", "")


            ## Unparse the values.

            v = unparseByType(self, "int", None,  self.fill)

            ## For required attributes None becomes "".  For optional attributes, we just leave the attribute out.
            if not (isinstance(self.get_parent(), LibraryFile) and False):  # special case for the name of library.
                if v is not None:
                    r.set("fill", v)
                else:
                    r.set("fill", "")


            ## Unparse the values.

            v = unparseByType(self, "bool", None,  self.visible)

            ## For required attributes None becomes "".  For optional attributes, we just leave the attribute out.
            if not (isinstance(self.get_parent(), LibraryFile) and False):  # special case for the name of library.
                if v is not None:
                    r.set("visible", v)


            ## Unparse the values.

            v = unparseByType(self, "bool", None,  self.active)

            ## For required attributes None becomes "".  For optional attributes, we just leave the attribute out.
            if not (isinstance(self.get_parent(), LibraryFile) and False):  # special case for the name of library.
                if v is not None:
                    r.set("active", v)


            ### process the sections in order.  They have to be in section order,
            ### because eagle files are order dependent.


            ## set the text, if its needed.

        except SwoopError as e:
            e.text = "{}:{}".format(self._get_error_name(), e.text)
            raise e
        return r

    def clone(self):
        """
        Recursively clone this :code:`Layer`.  It will be identical to the original, but it's parent will be :code:`None`.
        
        :rtype: :class:`Layer`
        """
        try:
            n = copy.copy(self)
            n.parent = None
        except SwoopError as e:
            e.text = "{}:{}".format(self._get_error_name(), e.text)
            raise e
        return n

    def accept_preorder_visitor(self, visitor):
        try:
            pre = getattr(visitor, "Layer_pre")
            return pre(self)
        except AttributeError:
            return visitor.default_pre(self)
        
    def accept_postorder_visitor(self, visitor, context):
        try:
            post = getattr(visitor, "Layer_post")
            post(self,context)
        except AttributeError:
            visitor.default_post(self,context)

    def is_equal(self, other):
        """
        Check whether two :code:`EagleFilePart` objects are identical.
        
        :param other: Object to compare to.
        :returns: :code:`True` if they are identical, otherwise, :code:`False`
        """
        return self.get_xml() == other.get_xml()
        
    ### Getters/Setters for attribute values

    def get_number(self):
        """ Return the value of :code:`number` for this :class:`Layer`.  This corresponds to the :code:`number` attribute of a :code:`<layer>` in an Eagle file.
        
        :rtype: :code:`int`
        """
        return self.number

    def set_number(self,v):
        """ Set the value of :code:`number` for this  :class:`Layer`.  This corresponds to the :code:`number` attribute of a :code:`<layer>` in an Eagle file.

        :param v: new value
        :rtype: :code:`self`
        """
                        
        oldkey = self.number
        if not typeCheck("int", v, True):
            raise SwoopError("Illegal value ({}) of type {} for attribute 'number' of Layer object (should be int).".format(v, type(v)))
        self.number = v
        
        if self.get_parent() is not None:
            self.get_parent()._rekey_child(oldkey, self);
        return self

    def with_number(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`number`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`number` equals :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_number()` is :code:`True`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """

        if type(v) in [str, int, float, bool]:
            return self if self.number == v else None
        elif callable(v):
            return self if v(self.number) else None
        else:
            raise SwoopError("Illegal type passed to with_number")

    def without_number(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`number`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`number` is not equal to :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_number()` is :code:`False`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """
        
        if type(v) in [str, int, float, bool]:
            return self if self.number != v else None
        elif callable(v):
            return self if not v(self.number) else None
        else:
            raise SwoopError("Illegal type passed to without_number")


    def get_name(self):
        """ Return the value of :code:`name` for this :class:`Layer`.  This corresponds to the :code:`name` attribute of a :code:`<layer>` in an Eagle file.
        
        :rtype: :code:`str`
        """
        return self.name

    def set_name(self,v):
        """ Set the value of :code:`name` for this  :class:`Layer`.  This corresponds to the :code:`name` attribute of a :code:`<layer>` in an Eagle file.

        :param v: new value
        :rtype: :code:`self`
        """
                        
        if not typeCheck("str", v, True):
            raise SwoopError("Illegal value ({}) of type {} for attribute 'name' of Layer object (should be str).".format(v, type(v)))
        self.name = v
        
        return self

    def with_name(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`name`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`name` equals :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_name()` is :code:`True`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """

        if type(v) in [str, int, float, bool]:
            return self if self.name == v else None
        elif callable(v):
            return self if v(self.name) else None
        else:
            raise SwoopError("Illegal type passed to with_name")

    def without_name(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`name`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`name` is not equal to :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_name()` is :code:`False`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """
        
        if type(v) in [str, int, float, bool]:
            return self if self.name != v else None
        elif callable(v):
            return self if not v(self.name) else None
        else:
            raise SwoopError("Illegal type passed to without_name")


    def get_color(self):
        """ Return the value of :code:`color` for this :class:`Layer`.  This corresponds to the :code:`color` attribute of a :code:`<layer>` in an Eagle file.
        
        :rtype: :code:`int`
        """
        return self.color

    def set_color(self,v):
        """ Set the value of :code:`color` for this  :class:`Layer`.  This corresponds to the :code:`color` attribute of a :code:`<layer>` in an Eagle file.

        :param v: new value
        :rtype: :code:`self`
        """
                        
        if not typeCheck("int", v, True):
            raise SwoopError("Illegal value ({}) of type {} for attribute 'color' of Layer object (should be int).".format(v, type(v)))
        self.color = v
        
        return self

    def with_color(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`color`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`color` equals :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_color()` is :code:`True`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """

        if type(v) in [str, int, float, bool]:
            return self if self.color == v else None
        elif callable(v):
            return self if v(self.color) else None
        else:
            raise SwoopError("Illegal type passed to with_color")

    def without_color(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`color`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`color` is not equal to :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_color()` is :code:`False`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """
        
        if type(v) in [str, int, float, bool]:
            return self if self.color != v else None
        elif callable(v):
            return self if not v(self.color) else None
        else:
            raise SwoopError("Illegal type passed to without_color")


    def get_fill(self):
        """ Return the value of :code:`fill` for this :class:`Layer`.  This corresponds to the :code:`fill` attribute of a :code:`<layer>` in an Eagle file.
        
        :rtype: :code:`int`
        """
        return self.fill

    def set_fill(self,v):
        """ Set the value of :code:`fill` for this  :class:`Layer`.  This corresponds to the :code:`fill` attribute of a :code:`<layer>` in an Eagle file.

        :param v: new value
        :rtype: :code:`self`
        """
                        
        if not typeCheck("int", v, True):
            raise SwoopError("Illegal value ({}) of type {} for attribute 'fill' of Layer object (should be int).".format(v, type(v)))
        self.fill = v
        
        return self

    def with_fill(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`fill`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`fill` equals :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_fill()` is :code:`True`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """

        if type(v) in [str, int, float, bool]:
            return self if self.fill == v else None
        elif callable(v):
            return self if v(self.fill) else None
        else:
            raise SwoopError("Illegal type passed to with_fill")

    def without_fill(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`fill`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`fill` is not equal to :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_fill()` is :code:`False`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """
        
        if type(v) in [str, int, float, bool]:
            return self if self.fill != v else None
        elif callable(v):
            return self if not v(self.fill) else None
        else:
            raise SwoopError("Illegal type passed to without_fill")


    def get_visible(self):
        """ Return the value of :code:`visible` for this :class:`Layer`.  This corresponds to the :code:`visible` attribute of a :code:`<layer>` in an Eagle file.
        
        :rtype: :code:`bool`
        """
        return self.visible

    def set_visible(self,v):
        """ Set the value of :code:`visible` for this  :class:`Layer`.  This corresponds to the :code:`visible` attribute of a :code:`<layer>` in an Eagle file.

        :param v: new value
        :rtype: :code:`self`
        """
                        
        if not typeCheck("bool", v, False):
            raise SwoopError("Illegal value ({}) of type {} for attribute 'visible' of Layer object (should be bool).".format(v, type(v)))
        self.visible = v
        
        return self

    def with_visible(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`visible`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`visible` equals :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_visible()` is :code:`True`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """

        if type(v) in [str, int, float, bool]:
            return self if self.visible == v else None
        elif callable(v):
            return self if v(self.visible) else None
        else:
            raise SwoopError("Illegal type passed to with_visible")

    def without_visible(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`visible`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`visible` is not equal to :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_visible()` is :code:`False`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """
        
        if type(v) in [str, int, float, bool]:
            return self if self.visible != v else None
        elif callable(v):
            return self if not v(self.visible) else None
        else:
            raise SwoopError("Illegal type passed to without_visible")


    def get_active(self):
        """ Return the value of :code:`active` for this :class:`Layer`.  This corresponds to the :code:`active` attribute of a :code:`<layer>` in an Eagle file.
        
        :rtype: :code:`bool`
        """
        return self.active

    def set_active(self,v):
        """ Set the value of :code:`active` for this  :class:`Layer`.  This corresponds to the :code:`active` attribute of a :code:`<layer>` in an Eagle file.

        :param v: new value
        :rtype: :code:`self`
        """
                        
        if not typeCheck("bool", v, False):
            raise SwoopError("Illegal value ({}) of type {} for attribute 'active' of Layer object (should be bool).".format(v, type(v)))
        self.active = v
        
        return self

    def with_active(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`active`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`active` equals :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_active()` is :code:`True`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """

        if type(v) in [str, int, float, bool]:
            return self if self.active == v else None
        elif callable(v):
            return self if v(self.active) else None
        else:
            raise SwoopError("Illegal type passed to with_active")

    def without_active(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`active`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`active` is not equal to :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_active()` is :code:`False`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """
        
        if type(v) in [str, int, float, bool]:
            return self if self.active != v else None
        elif callable(v):
            return self if not v(self.active) else None
        else:
            raise SwoopError("Illegal type passed to without_active")



    ##### Lookup functions that return EFPs instead of just attribute values.
    
    


    
    ### Adder/getter/lookup for lists
    


    ### Add, lookup, and get for maps


    
    ### Getter/Setter for singletons.


    
    def get_children(self):
        """
        Get all the children of this :class:`EagleFilePart`.
        
        :rtype: List of :class:`EagleFilePart` objects
        """
        r = []




        return r

    def remove_child(self, efp):
        """
        Remove a child :class:`EagleFilePart` object.
        
        :param efp: the class:`EagleFilePart` object to remove.
        :return: Nothing
        """

    def _rekey_child(self, oldkey, efp):
        """
        Remove a child :class:`EagleFilePart` object.
        
        :param efp: the class:`EagleFilePart` object to remove.
        :return: Nothing
        """


    def __str__(self):
        r = "["+repr(self)+" "
        r = r + "number:" + str(self.get_number()) + " "
        r = r + "name:" + str(self.get_name()) + " "
        r = r + "color:" + str(self.get_color()) + " "
        r = r + "fill:" + str(self.get_fill()) + " "
        r = r + "visible:" + str(self.get_visible()) + " "
        r = r + "active:" + str(self.get_active()) + " "
        r = r + "]"
        return r
            
    def dump(self, indent="", increment="   "):
        """
        Recursive debug dump.
        
        :param indent:  Indentation string.  The output will be indented by this much.
        :param increment: This will be appendeded to :code:`indent` on recursive invocations.

        :rtype: :code:`None`
        """
        print(indent + str(self.__class__.__name__), end=' ')
        try:
            print(self.get_name())
        except:
            print()
            pass
        for c in self.get_children():
            c.dump(indent + "   ")

        
EagleFile.class_map["layer"] = Layer
         


class Via(EagleFilePart, OnePointGeometry, CircleDiameterGeometry):
    """
    Class representing the contents of a <via> tag in Eagle files.

    Attributes:

    * :code:`x`

    * :code:`y`

    * :code:`extent`

    * :code:`drill`

    * :code:`diameter`

    * :code:`shape`

    * :code:`alwaysstop`


    """
    def __init__(self):
        """
        Construct an empty :class:`Via` object.
        """
        EagleFilePart.__init__(self)
        OnePointGeometry.__init__(self)
        CircleDiameterGeometry.__init__(self)
        
        self.x=None
        self.y=None
        self.extent=None
        self.drill=None
        self.diameter=None
        self.shape=None
        self.alwaysstop=None


        
    @classmethod
    def _from_et(cls,root,parent):
        """
        Create a :class:`Via` from a :code:`via` element.
        
        :param root: The element tree tree to parse.
        :param parent: :class:`EagleFilePart` that should hold the resulting :class:`EagleFilePart`
        :rtype: :class:`Via`
        """
        ## Call the constructor
        n = cls()
        n._init_from_et(root,parent)
        return n

    def _get_error_name(self):
        if hasattr(self, "get_name"):
            return self.get_name();
        else:
            return "Via";
        
    def  _init_from_et(self, root, parent):
        """
        Initialized a :class:`Via` from a :code:`via` element.  This is useful if you have a subclass of :class:`Via` .
        
        :param root: The element tree tree to parse.
        :param parent: :class:`EagleFilePart` that will become the parent of :code:`this` .
        :rtype: :class:`Via`
        """
        try:
            self.root = root
            
            if root.tag != "via":
                raise EagleFormatError("Tried to create via from " + root.tag)

            self.x=parseByType(parent, "float", None, root.get("x"))
            self.y=parseByType(parent, "float", None, root.get("y"))
            self.extent=parseByType(parent, "str", None, root.get("extent"))
            self.drill=parseByType(parent, "float", None, root.get("drill"))
            self.diameter=parseByType(parent, "float", None, root.get("diameter"))
            self.shape=parseByType(parent, "str", None, root.get("shape"))
            self.alwaysstop=parseByType(parent, "bool", None, root.get("alwaysstop"))

            self.parent = parent

            ### populate the maps by searching for elements that match xpath and generating objects for them.


            ### Do the same for the lists


            ### Do the same for the attr lists


            ### And the singletons


            ### And, finally, if the objects wants the text from the tag.

        except SwoopError as e:
            e.text = "{}:{}".format(self._get_error_name(), e.text)
            raise e


    def sortkey(self):
        r = ""
        r = r + str(self.x)
        r = r + str(self.y)
        r = r + str(self.extent)
        r = r + str(self.drill)
        r = r + str(self.diameter)
        r = r + str(self.shape)
        r = r + str(self.alwaysstop)
        return r

    def get_et(self):
        """
        Generate a <via> element tree for a :class:`Via`.
        
        :rtype:  :class:`ElementTree`.
        
        """
        try:
            r = ET.Element("via")

            ### Set the tag attributes 


            ## Unparse the values.

            v = unparseByType(self, "float", None,  self.x)

            ## For required attributes None becomes "".  For optional attributes, we just leave the attribute out.
            if not (isinstance(self.get_parent(), LibraryFile) and False):  # special case for the name of library.
                if v is not None:
                    r.set("x", v)
                else:
                    r.set("x", "")


            ## Unparse the values.

            v = unparseByType(self, "float", None,  self.y)

            ## For required attributes None becomes "".  For optional attributes, we just leave the attribute out.
            if not (isinstance(self.get_parent(), LibraryFile) and False):  # special case for the name of library.
                if v is not None:
                    r.set("y", v)
                else:
                    r.set("y", "")


            ## Unparse the values.

            v = unparseByType(self, "str", None,  self.extent)

            ## For required attributes None becomes "".  For optional attributes, we just leave the attribute out.
            if not (isinstance(self.get_parent(), LibraryFile) and False):  # special case for the name of library.
                if v is not None:
                    r.set("extent", v)
                else:
                    r.set("extent", "")


            ## Unparse the values.

            v = unparseByType(self, "float", None,  self.drill)

            ## For required attributes None becomes "".  For optional attributes, we just leave the attribute out.
            if not (isinstance(self.get_parent(), LibraryFile) and False):  # special case for the name of library.
                if v is not None:
                    r.set("drill", v)
                else:
                    r.set("drill", "")


            ## Unparse the values.

            v = unparseByType(self, "float", None,  self.diameter)

            ## For required attributes None becomes "".  For optional attributes, we just leave the attribute out.
            if not (isinstance(self.get_parent(), LibraryFile) and False):  # special case for the name of library.
                if v is not None:
                    r.set("diameter", v)


            ## Unparse the values.

            v = unparseByType(self, "str", None,  self.shape)

            ## For required attributes None becomes "".  For optional attributes, we just leave the attribute out.
            if not (isinstance(self.get_parent(), LibraryFile) and False):  # special case for the name of library.
                if v is not None:
                    r.set("shape", v)


            ## Unparse the values.

            v = unparseByType(self, "bool", None,  self.alwaysstop)

            ## For required attributes None becomes "".  For optional attributes, we just leave the attribute out.
            if not (isinstance(self.get_parent(), LibraryFile) and False):  # special case for the name of library.
                if v is not None:
                    r.set("alwaysstop", v)


            ### process the sections in order.  They have to be in section order,
            ### because eagle files are order dependent.


            ## set the text, if its needed.

        except SwoopError as e:
            e.text = "{}:{}".format(self._get_error_name(), e.text)
            raise e
        return r

    def clone(self):
        """
        Recursively clone this :code:`Via`.  It will be identical to the original, but it's parent will be :code:`None`.
        
        :rtype: :class:`Via`
        """
        try:
            n = copy.copy(self)
            n.parent = None
        except SwoopError as e:
            e.text = "{}:{}".format(self._get_error_name(), e.text)
            raise e
        return n

    def accept_preorder_visitor(self, visitor):
        try:
            pre = getattr(visitor, "Via_pre")
            return pre(self)
        except AttributeError:
            return visitor.default_pre(self)
        
    def accept_postorder_visitor(self, visitor, context):
        try:
            post = getattr(visitor, "Via_post")
            post(self,context)
        except AttributeError:
            visitor.default_post(self,context)

    def is_equal(self, other):
        """
        Check whether two :code:`EagleFilePart` objects are identical.
        
        :param other: Object to compare to.
        :returns: :code:`True` if they are identical, otherwise, :code:`False`
        """
        return self.get_xml() == other.get_xml()
        
    ### Getters/Setters for attribute values

    def get_x(self):
        """ Return the value of :code:`x` for this :class:`Via`.  This corresponds to the :code:`x` attribute of a :code:`<via>` in an Eagle file.
        
        :rtype: :code:`float`
        """
        return self.x

    def set_x(self,v):
        """ Set the value of :code:`x` for this  :class:`Via`.  This corresponds to the :code:`x` attribute of a :code:`<via>` in an Eagle file.

        :param v: new value
        :rtype: :code:`self`
        """
                        
        if not typeCheck("float", v, True):
            raise SwoopError("Illegal value ({}) of type {} for attribute 'x' of Via object (should be float).".format(v, type(v)))
        self.x = v
        
        return self

    def with_x(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`x`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`x` equals :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_x()` is :code:`True`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """

        if type(v) in [str, int, float, bool]:
            return self if self.x == v else None
        elif callable(v):
            return self if v(self.x) else None
        else:
            raise SwoopError("Illegal type passed to with_x")

    def without_x(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`x`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`x` is not equal to :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_x()` is :code:`False`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """
        
        if type(v) in [str, int, float, bool]:
            return self if self.x != v else None
        elif callable(v):
            return self if not v(self.x) else None
        else:
            raise SwoopError("Illegal type passed to without_x")


    def get_y(self):
        """ Return the value of :code:`y` for this :class:`Via`.  This corresponds to the :code:`y` attribute of a :code:`<via>` in an Eagle file.
        
        :rtype: :code:`float`
        """
        return self.y

    def set_y(self,v):
        """ Set the value of :code:`y` for this  :class:`Via`.  This corresponds to the :code:`y` attribute of a :code:`<via>` in an Eagle file.

        :param v: new value
        :rtype: :code:`self`
        """
                        
        if not typeCheck("float", v, True):
            raise SwoopError("Illegal value ({}) of type {} for attribute 'y' of Via object (should be float).".format(v, type(v)))
        self.y = v
        
        return self

    def with_y(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`y`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`y` equals :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_y()` is :code:`True`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """

        if type(v) in [str, int, float, bool]:
            return self if self.y == v else None
        elif callable(v):
            return self if v(self.y) else None
        else:
            raise SwoopError("Illegal type passed to with_y")

    def without_y(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`y`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`y` is not equal to :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_y()` is :code:`False`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """
        
        if type(v) in [str, int, float, bool]:
            return self if self.y != v else None
        elif callable(v):
            return self if not v(self.y) else None
        else:
            raise SwoopError("Illegal type passed to without_y")


    def get_extent(self):
        """ Return the value of :code:`extent` for this :class:`Via`.  This corresponds to the :code:`extent` attribute of a :code:`<via>` in an Eagle file.
        
        :rtype: :code:`str`
        """
        return self.extent

    def set_extent(self,v):
        """ Set the value of :code:`extent` for this  :class:`Via`.  This corresponds to the :code:`extent` attribute of a :code:`<via>` in an Eagle file.

        :param v: new value
        :rtype: :code:`self`
        """
                        
        if not typeCheck("str", v, True):
            raise SwoopError("Illegal value ({}) of type {} for attribute 'extent' of Via object (should be str).".format(v, type(v)))
        self.extent = v
        
        return self

    def with_extent(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`extent`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`extent` equals :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_extent()` is :code:`True`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """

        if type(v) in [str, int, float, bool]:
            return self if self.extent == v else None
        elif callable(v):
            return self if v(self.extent) else None
        else:
            raise SwoopError("Illegal type passed to with_extent")

    def without_extent(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`extent`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`extent` is not equal to :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_extent()` is :code:`False`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """
        
        if type(v) in [str, int, float, bool]:
            return self if self.extent != v else None
        elif callable(v):
            return self if not v(self.extent) else None
        else:
            raise SwoopError("Illegal type passed to without_extent")


    def get_drill(self):
        """ Return the value of :code:`drill` for this :class:`Via`.  This corresponds to the :code:`drill` attribute of a :code:`<via>` in an Eagle file.
        
        :rtype: :code:`float`
        """
        return self.drill

    def set_drill(self,v):
        """ Set the value of :code:`drill` for this  :class:`Via`.  This corresponds to the :code:`drill` attribute of a :code:`<via>` in an Eagle file.

        :param v: new value
        :rtype: :code:`self`
        """
                        
        if not typeCheck("float", v, True):
            raise SwoopError("Illegal value ({}) of type {} for attribute 'drill' of Via object (should be float).".format(v, type(v)))
        self.drill = v
        
        return self

    def with_drill(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`drill`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`drill` equals :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_drill()` is :code:`True`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """

        if type(v) in [str, int, float, bool]:
            return self if self.drill == v else None
        elif callable(v):
            return self if v(self.drill) else None
        else:
            raise SwoopError("Illegal type passed to with_drill")

    def without_drill(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`drill`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`drill` is not equal to :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_drill()` is :code:`False`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """
        
        if type(v) in [str, int, float, bool]:
            return self if self.drill != v else None
        elif callable(v):
            return self if not v(self.drill) else None
        else:
            raise SwoopError("Illegal type passed to without_drill")


    def get_diameter(self):
        """ Return the value of :code:`diameter` for this :class:`Via`.  This corresponds to the :code:`diameter` attribute of a :code:`<via>` in an Eagle file.
        
        :rtype: :code:`float`
        """
        return self.diameter

    def set_diameter(self,v):
        """ Set the value of :code:`diameter` for this  :class:`Via`.  This corresponds to the :code:`diameter` attribute of a :code:`<via>` in an Eagle file.

        :param v: new value
        :rtype: :code:`self`
        """
                        
        if not typeCheck("float", v, False):
            raise SwoopError("Illegal value ({}) of type {} for attribute 'diameter' of Via object (should be float).".format(v, type(v)))
        self.diameter = v
        
        return self

    def with_diameter(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`diameter`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`diameter` equals :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_diameter()` is :code:`True`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """

        if type(v) in [str, int, float, bool]:
            return self if self.diameter == v else None
        elif callable(v):
            return self if v(self.diameter) else None
        else:
            raise SwoopError("Illegal type passed to with_diameter")

    def without_diameter(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`diameter`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`diameter` is not equal to :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_diameter()` is :code:`False`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """
        
        if type(v) in [str, int, float, bool]:
            return self if self.diameter != v else None
        elif callable(v):
            return self if not v(self.diameter) else None
        else:
            raise SwoopError("Illegal type passed to without_diameter")


    def get_shape(self):
        """ Return the value of :code:`shape` for this :class:`Via`.  This corresponds to the :code:`shape` attribute of a :code:`<via>` in an Eagle file.
        
        :rtype: :code:`str`
        """
        return self.shape

    def set_shape(self,v):
        """ Set the value of :code:`shape` for this  :class:`Via`.  This corresponds to the :code:`shape` attribute of a :code:`<via>` in an Eagle file.

        :param v: new value
        :rtype: :code:`self`
        """
                        
        if not typeCheck("str", v, False):
            raise SwoopError("Illegal value ({}) of type {} for attribute 'shape' of Via object (should be str).".format(v, type(v)))
        self.shape = v
        
        return self

    def with_shape(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`shape`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`shape` equals :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_shape()` is :code:`True`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """

        if type(v) in [str, int, float, bool]:
            return self if self.shape == v else None
        elif callable(v):
            return self if v(self.shape) else None
        else:
            raise SwoopError("Illegal type passed to with_shape")

    def without_shape(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`shape`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`shape` is not equal to :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_shape()` is :code:`False`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """
        
        if type(v) in [str, int, float, bool]:
            return self if self.shape != v else None
        elif callable(v):
            return self if not v(self.shape) else None
        else:
            raise SwoopError("Illegal type passed to without_shape")


    def get_alwaysstop(self):
        """ Return the value of :code:`alwaysstop` for this :class:`Via`.  This corresponds to the :code:`alwaysstop` attribute of a :code:`<via>` in an Eagle file.
        
        :rtype: :code:`bool`
        """
        return self.alwaysstop

    def set_alwaysstop(self,v):
        """ Set the value of :code:`alwaysstop` for this  :class:`Via`.  This corresponds to the :code:`alwaysstop` attribute of a :code:`<via>` in an Eagle file.

        :param v: new value
        :rtype: :code:`self`
        """
                        
        if not typeCheck("bool", v, False):
            raise SwoopError("Illegal value ({}) of type {} for attribute 'alwaysstop' of Via object (should be bool).".format(v, type(v)))
        self.alwaysstop = v
        
        return self

    def with_alwaysstop(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`alwaysstop`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`alwaysstop` equals :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_alwaysstop()` is :code:`True`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """

        if type(v) in [str, int, float, bool]:
            return self if self.alwaysstop == v else None
        elif callable(v):
            return self if v(self.alwaysstop) else None
        else:
            raise SwoopError("Illegal type passed to with_alwaysstop")

    def without_alwaysstop(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`alwaysstop`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`alwaysstop` is not equal to :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_alwaysstop()` is :code:`False`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """
        
        if type(v) in [str, int, float, bool]:
            return self if self.alwaysstop != v else None
        elif callable(v):
            return self if not v(self.alwaysstop) else None
        else:
            raise SwoopError("Illegal type passed to without_alwaysstop")



    ##### Lookup functions that return EFPs instead of just attribute values.
    
    


    
    ### Adder/getter/lookup for lists
    


    ### Add, lookup, and get for maps


    
    ### Getter/Setter for singletons.


    
    def get_children(self):
        """
        Get all the children of this :class:`EagleFilePart`.
        
        :rtype: List of :class:`EagleFilePart` objects
        """
        r = []




        return r

    def remove_child(self, efp):
        """
        Remove a child :class:`EagleFilePart` object.
        
        :param efp: the class:`EagleFilePart` object to remove.
        :return: Nothing
        """

    def _rekey_child(self, oldkey, efp):
        """
        Remove a child :class:`EagleFilePart` object.
        
        :param efp: the class:`EagleFilePart` object to remove.
        :return: Nothing
        """


    def __str__(self):
        r = "["+repr(self)+" "
        r = r + "x:" + str(self.get_x()) + " "
        r = r + "y:" + str(self.get_y()) + " "
        r = r + "extent:" + str(self.get_extent()) + " "
        r = r + "drill:" + str(self.get_drill()) + " "
        r = r + "diameter:" + str(self.get_diameter()) + " "
        r = r + "shape:" + str(self.get_shape()) + " "
        r = r + "alwaysstop:" + str(self.get_alwaysstop()) + " "
        r = r + "]"
        return r
            
    def dump(self, indent="", increment="   "):
        """
        Recursive debug dump.
        
        :param indent:  Indentation string.  The output will be indented by this much.
        :param increment: This will be appendeded to :code:`indent` on recursive invocations.

        :rtype: :code:`None`
        """
        print(indent + str(self.__class__.__name__), end=' ')
        try:
            print(self.get_name())
        except:
            print()
            pass
        for c in self.get_children():
            c.dump(indent + "   ")

        
EagleFile.class_map["via"] = Via
         


class Pin(EagleFilePart, OnePointGeometry, RotationGeometry):
    """
    Class representing the contents of a <pin> tag in Eagle files.

    Attributes:

    * :code:`name`

    * :code:`x`

    * :code:`y`

    * :code:`visible`

    * :code:`length`

    * :code:`direction`

    * :code:`function`

    * :code:`swaplevel`

    * :code:`rot`


    """
    def __init__(self):
        """
        Construct an empty :class:`Pin` object.
        """
        EagleFilePart.__init__(self)
        OnePointGeometry.__init__(self)
        RotationGeometry.__init__(self)
        
        self.name=None
        self.x=None
        self.y=None
        self.visible=None
        self.length=None
        self.direction=None
        self.function=None
        self.swaplevel=None
        self.rot=None


        
    @classmethod
    def _from_et(cls,root,parent):
        """
        Create a :class:`Pin` from a :code:`pin` element.
        
        :param root: The element tree tree to parse.
        :param parent: :class:`EagleFilePart` that should hold the resulting :class:`EagleFilePart`
        :rtype: :class:`Pin`
        """
        ## Call the constructor
        n = cls()
        n._init_from_et(root,parent)
        return n

    def _get_error_name(self):
        if hasattr(self, "get_name"):
            return self.get_name();
        else:
            return "Pin";
        
    def  _init_from_et(self, root, parent):
        """
        Initialized a :class:`Pin` from a :code:`pin` element.  This is useful if you have a subclass of :class:`Pin` .
        
        :param root: The element tree tree to parse.
        :param parent: :class:`EagleFilePart` that will become the parent of :code:`this` .
        :rtype: :class:`Pin`
        """
        try:
            self.root = root
            
            if root.tag != "pin":
                raise EagleFormatError("Tried to create pin from " + root.tag)

            self.name=parseByType(parent, "str", None, root.get("name"))
            self.x=parseByType(parent, "float", None, root.get("x"))
            self.y=parseByType(parent, "float", None, root.get("y"))
            self.visible=parseByType(parent, "str", None, root.get("visible"))
            self.length=parseByType(parent, "str", None, root.get("length"))
            self.direction=parseByType(parent, "str", None, root.get("direction"))
            self.function=parseByType(parent, "str", None, root.get("function"))
            self.swaplevel=parseByType(parent, "int", None, root.get("swaplevel"))
            self.rot=parseByType(parent, "str", None, root.get("rot"))

            self.parent = parent

            ### populate the maps by searching for elements that match xpath and generating objects for them.


            ### Do the same for the lists


            ### Do the same for the attr lists


            ### And the singletons


            ### And, finally, if the objects wants the text from the tag.

        except SwoopError as e:
            e.text = "{}:{}".format(self._get_error_name(), e.text)
            raise e


    def sortkey(self):
        r = ""
        r = r + str(self.name)
        r = r + str(self.x)
        r = r + str(self.y)
        r = r + str(self.visible)
        r = r + str(self.length)
        r = r + str(self.direction)
        r = r + str(self.function)
        r = r + str(self.swaplevel)
        r = r + str(self.rot)
        return r

    def get_et(self):
        """
        Generate a <pin> element tree for a :class:`Pin`.
        
        :rtype:  :class:`ElementTree`.
        
        """
        try:
            r = ET.Element("pin")

            ### Set the tag attributes 


            ## Unparse the values.

            v = unparseByType(self, "str", None,  self.name)

            ## For required attributes None becomes "".  For optional attributes, we just leave the attribute out.
            if not (isinstance(self.get_parent(), LibraryFile) and False):  # special case for the name of library.
                if v is not None:
                    r.set("name", v)
                else:
                    r.set("name", "")


            ## Unparse the values.

            v = unparseByType(self, "float", None,  self.x)

            ## For required attributes None becomes "".  For optional attributes, we just leave the attribute out.
            if not (isinstance(self.get_parent(), LibraryFile) and False):  # special case for the name of library.
                if v is not None:
                    r.set("x", v)
                else:
                    r.set("x", "")


            ## Unparse the values.

            v = unparseByType(self, "float", None,  self.y)

            ## For required attributes None becomes "".  For optional attributes, we just leave the attribute out.
            if not (isinstance(self.get_parent(), LibraryFile) and False):  # special case for the name of library.
                if v is not None:
                    r.set("y", v)
                else:
                    r.set("y", "")


            ## Unparse the values.

            v = unparseByType(self, "str", None,  self.visible)

            ## For required attributes None becomes "".  For optional attributes, we just leave the attribute out.
            if not (isinstance(self.get_parent(), LibraryFile) and False):  # special case for the name of library.
                if v is not None:
                    r.set("visible", v)


            ## Unparse the values.

            v = unparseByType(self, "str", None,  self.length)

            ## For required attributes None becomes "".  For optional attributes, we just leave the attribute out.
            if not (isinstance(self.get_parent(), LibraryFile) and False):  # special case for the name of library.
                if v is not None:
                    r.set("length", v)


            ## Unparse the values.

            v = unparseByType(self, "str", None,  self.direction)

            ## For required attributes None becomes "".  For optional attributes, we just leave the attribute out.
            if not (isinstance(self.get_parent(), LibraryFile) and False):  # special case for the name of library.
                if v is not None:
                    r.set("direction", v)


            ## Unparse the values.

            v = unparseByType(self, "str", None,  self.function)

            ## For required attributes None becomes "".  For optional attributes, we just leave the attribute out.
            if not (isinstance(self.get_parent(), LibraryFile) and False):  # special case for the name of library.
                if v is not None:
                    r.set("function", v)


            ## Unparse the values.

            v = unparseByType(self, "int", None,  self.swaplevel)

            ## For required attributes None becomes "".  For optional attributes, we just leave the attribute out.
            if not (isinstance(self.get_parent(), LibraryFile) and False):  # special case for the name of library.
                if v is not None:
                    r.set("swaplevel", v)


            ## Unparse the values.

            v = unparseByType(self, "str", None,  self.rot)

            ## For required attributes None becomes "".  For optional attributes, we just leave the attribute out.
            if not (isinstance(self.get_parent(), LibraryFile) and False):  # special case for the name of library.
                if v is not None:
                    r.set("rot", v)


            ### process the sections in order.  They have to be in section order,
            ### because eagle files are order dependent.


            ## set the text, if its needed.

        except SwoopError as e:
            e.text = "{}:{}".format(self._get_error_name(), e.text)
            raise e
        return r

    def clone(self):
        """
        Recursively clone this :code:`Pin`.  It will be identical to the original, but it's parent will be :code:`None`.
        
        :rtype: :class:`Pin`
        """
        try:
            n = copy.copy(self)
            n.parent = None
        except SwoopError as e:
            e.text = "{}:{}".format(self._get_error_name(), e.text)
            raise e
        return n

    def accept_preorder_visitor(self, visitor):
        try:
            pre = getattr(visitor, "Pin_pre")
            return pre(self)
        except AttributeError:
            return visitor.default_pre(self)
        
    def accept_postorder_visitor(self, visitor, context):
        try:
            post = getattr(visitor, "Pin_post")
            post(self,context)
        except AttributeError:
            visitor.default_post(self,context)

    def is_equal(self, other):
        """
        Check whether two :code:`EagleFilePart` objects are identical.
        
        :param other: Object to compare to.
        :returns: :code:`True` if they are identical, otherwise, :code:`False`
        """
        return self.get_xml() == other.get_xml()
        
    ### Getters/Setters for attribute values

    def get_name(self):
        """ Return the value of :code:`name` for this :class:`Pin`.  This corresponds to the :code:`name` attribute of a :code:`<pin>` in an Eagle file.
        
        :rtype: :code:`str`
        """
        return self.name

    def set_name(self,v):
        """ Set the value of :code:`name` for this  :class:`Pin`.  This corresponds to the :code:`name` attribute of a :code:`<pin>` in an Eagle file.

        :param v: new value
        :rtype: :code:`self`
        """
                        
        oldkey = self.name
        if not typeCheck("str", v, True):
            raise SwoopError("Illegal value ({}) of type {} for attribute 'name' of Pin object (should be str).".format(v, type(v)))
        self.name = v
        
        if self.get_parent() is not None:
            self.get_parent()._rekey_child(oldkey, self);
        return self

    def with_name(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`name`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`name` equals :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_name()` is :code:`True`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """

        if type(v) in [str, int, float, bool]:
            return self if self.name == v else None
        elif callable(v):
            return self if v(self.name) else None
        else:
            raise SwoopError("Illegal type passed to with_name")

    def without_name(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`name`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`name` is not equal to :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_name()` is :code:`False`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """
        
        if type(v) in [str, int, float, bool]:
            return self if self.name != v else None
        elif callable(v):
            return self if not v(self.name) else None
        else:
            raise SwoopError("Illegal type passed to without_name")


    def get_x(self):
        """ Return the value of :code:`x` for this :class:`Pin`.  This corresponds to the :code:`x` attribute of a :code:`<pin>` in an Eagle file.
        
        :rtype: :code:`float`
        """
        return self.x

    def set_x(self,v):
        """ Set the value of :code:`x` for this  :class:`Pin`.  This corresponds to the :code:`x` attribute of a :code:`<pin>` in an Eagle file.

        :param v: new value
        :rtype: :code:`self`
        """
                        
        if not typeCheck("float", v, True):
            raise SwoopError("Illegal value ({}) of type {} for attribute 'x' of Pin object (should be float).".format(v, type(v)))
        self.x = v
        
        return self

    def with_x(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`x`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`x` equals :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_x()` is :code:`True`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """

        if type(v) in [str, int, float, bool]:
            return self if self.x == v else None
        elif callable(v):
            return self if v(self.x) else None
        else:
            raise SwoopError("Illegal type passed to with_x")

    def without_x(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`x`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`x` is not equal to :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_x()` is :code:`False`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """
        
        if type(v) in [str, int, float, bool]:
            return self if self.x != v else None
        elif callable(v):
            return self if not v(self.x) else None
        else:
            raise SwoopError("Illegal type passed to without_x")


    def get_y(self):
        """ Return the value of :code:`y` for this :class:`Pin`.  This corresponds to the :code:`y` attribute of a :code:`<pin>` in an Eagle file.
        
        :rtype: :code:`float`
        """
        return self.y

    def set_y(self,v):
        """ Set the value of :code:`y` for this  :class:`Pin`.  This corresponds to the :code:`y` attribute of a :code:`<pin>` in an Eagle file.

        :param v: new value
        :rtype: :code:`self`
        """
                        
        if not typeCheck("float", v, True):
            raise SwoopError("Illegal value ({}) of type {} for attribute 'y' of Pin object (should be float).".format(v, type(v)))
        self.y = v
        
        return self

    def with_y(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`y`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`y` equals :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_y()` is :code:`True`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """

        if type(v) in [str, int, float, bool]:
            return self if self.y == v else None
        elif callable(v):
            return self if v(self.y) else None
        else:
            raise SwoopError("Illegal type passed to with_y")

    def without_y(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`y`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`y` is not equal to :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_y()` is :code:`False`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """
        
        if type(v) in [str, int, float, bool]:
            return self if self.y != v else None
        elif callable(v):
            return self if not v(self.y) else None
        else:
            raise SwoopError("Illegal type passed to without_y")


    def get_visible(self):
        """ Return the value of :code:`visible` for this :class:`Pin`.  This corresponds to the :code:`visible` attribute of a :code:`<pin>` in an Eagle file.
        
        :rtype: :code:`str`
        """
        return self.visible

    def set_visible(self,v):
        """ Set the value of :code:`visible` for this  :class:`Pin`.  This corresponds to the :code:`visible` attribute of a :code:`<pin>` in an Eagle file.

        :param v: new value
        :rtype: :code:`self`
        """
                        
        if not typeCheck("str", v, False):
            raise SwoopError("Illegal value ({}) of type {} for attribute 'visible' of Pin object (should be str).".format(v, type(v)))
        self.visible = v
        
        return self

    def with_visible(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`visible`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`visible` equals :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_visible()` is :code:`True`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """

        if type(v) in [str, int, float, bool]:
            return self if self.visible == v else None
        elif callable(v):
            return self if v(self.visible) else None
        else:
            raise SwoopError("Illegal type passed to with_visible")

    def without_visible(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`visible`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`visible` is not equal to :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_visible()` is :code:`False`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """
        
        if type(v) in [str, int, float, bool]:
            return self if self.visible != v else None
        elif callable(v):
            return self if not v(self.visible) else None
        else:
            raise SwoopError("Illegal type passed to without_visible")


    def get_length(self):
        """ Return the value of :code:`length` for this :class:`Pin`.  This corresponds to the :code:`length` attribute of a :code:`<pin>` in an Eagle file.
        
        :rtype: :code:`str`
        """
        return self.length

    def set_length(self,v):
        """ Set the value of :code:`length` for this  :class:`Pin`.  This corresponds to the :code:`length` attribute of a :code:`<pin>` in an Eagle file.

        :param v: new value
        :rtype: :code:`self`
        """
                        
        if not typeCheck("str", v, False):
            raise SwoopError("Illegal value ({}) of type {} for attribute 'length' of Pin object (should be str).".format(v, type(v)))
        self.length = v
        
        return self

    def with_length(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`length`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`length` equals :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_length()` is :code:`True`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """

        if type(v) in [str, int, float, bool]:
            return self if self.length == v else None
        elif callable(v):
            return self if v(self.length) else None
        else:
            raise SwoopError("Illegal type passed to with_length")

    def without_length(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`length`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`length` is not equal to :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_length()` is :code:`False`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """
        
        if type(v) in [str, int, float, bool]:
            return self if self.length != v else None
        elif callable(v):
            return self if not v(self.length) else None
        else:
            raise SwoopError("Illegal type passed to without_length")


    def get_direction(self):
        """ Return the value of :code:`direction` for this :class:`Pin`.  This corresponds to the :code:`direction` attribute of a :code:`<pin>` in an Eagle file.
        
        :rtype: :code:`str`
        """
        return self.direction

    def set_direction(self,v):
        """ Set the value of :code:`direction` for this  :class:`Pin`.  This corresponds to the :code:`direction` attribute of a :code:`<pin>` in an Eagle file.

        :param v: new value
        :rtype: :code:`self`
        """
                        
        if not typeCheck("str", v, False):
            raise SwoopError("Illegal value ({}) of type {} for attribute 'direction' of Pin object (should be str).".format(v, type(v)))
        self.direction = v
        
        return self

    def with_direction(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`direction`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`direction` equals :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_direction()` is :code:`True`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """

        if type(v) in [str, int, float, bool]:
            return self if self.direction == v else None
        elif callable(v):
            return self if v(self.direction) else None
        else:
            raise SwoopError("Illegal type passed to with_direction")

    def without_direction(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`direction`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`direction` is not equal to :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_direction()` is :code:`False`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """
        
        if type(v) in [str, int, float, bool]:
            return self if self.direction != v else None
        elif callable(v):
            return self if not v(self.direction) else None
        else:
            raise SwoopError("Illegal type passed to without_direction")


    def get_function(self):
        """ Return the value of :code:`function` for this :class:`Pin`.  This corresponds to the :code:`function` attribute of a :code:`<pin>` in an Eagle file.
        
        :rtype: :code:`str`
        """
        return self.function

    def set_function(self,v):
        """ Set the value of :code:`function` for this  :class:`Pin`.  This corresponds to the :code:`function` attribute of a :code:`<pin>` in an Eagle file.

        :param v: new value
        :rtype: :code:`self`
        """
                        
        if not typeCheck("str", v, False):
            raise SwoopError("Illegal value ({}) of type {} for attribute 'function' of Pin object (should be str).".format(v, type(v)))
        self.function = v
        
        return self

    def with_function(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`function`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`function` equals :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_function()` is :code:`True`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """

        if type(v) in [str, int, float, bool]:
            return self if self.function == v else None
        elif callable(v):
            return self if v(self.function) else None
        else:
            raise SwoopError("Illegal type passed to with_function")

    def without_function(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`function`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`function` is not equal to :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_function()` is :code:`False`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """
        
        if type(v) in [str, int, float, bool]:
            return self if self.function != v else None
        elif callable(v):
            return self if not v(self.function) else None
        else:
            raise SwoopError("Illegal type passed to without_function")


    def get_swaplevel(self):
        """ Return the value of :code:`swaplevel` for this :class:`Pin`.  This corresponds to the :code:`swaplevel` attribute of a :code:`<pin>` in an Eagle file.
        
        :rtype: :code:`int`
        """
        return self.swaplevel

    def set_swaplevel(self,v):
        """ Set the value of :code:`swaplevel` for this  :class:`Pin`.  This corresponds to the :code:`swaplevel` attribute of a :code:`<pin>` in an Eagle file.

        :param v: new value
        :rtype: :code:`self`
        """
                        
        if not typeCheck("int", v, False):
            raise SwoopError("Illegal value ({}) of type {} for attribute 'swaplevel' of Pin object (should be int).".format(v, type(v)))
        self.swaplevel = v
        
        return self

    def with_swaplevel(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`swaplevel`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`swaplevel` equals :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_swaplevel()` is :code:`True`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """

        if type(v) in [str, int, float, bool]:
            return self if self.swaplevel == v else None
        elif callable(v):
            return self if v(self.swaplevel) else None
        else:
            raise SwoopError("Illegal type passed to with_swaplevel")

    def without_swaplevel(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`swaplevel`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`swaplevel` is not equal to :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_swaplevel()` is :code:`False`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """
        
        if type(v) in [str, int, float, bool]:
            return self if self.swaplevel != v else None
        elif callable(v):
            return self if not v(self.swaplevel) else None
        else:
            raise SwoopError("Illegal type passed to without_swaplevel")


    def get_rot(self):
        """ Return the value of :code:`rot` for this :class:`Pin`.  This corresponds to the :code:`rot` attribute of a :code:`<pin>` in an Eagle file.
        
        :rtype: :code:`str`
        """
        return self.rot

    def set_rot(self,v):
        """ Set the value of :code:`rot` for this  :class:`Pin`.  This corresponds to the :code:`rot` attribute of a :code:`<pin>` in an Eagle file.

        :param v: new value
        :rtype: :code:`self`
        """
                        
        if not typeCheck("str", v, False):
            raise SwoopError("Illegal value ({}) of type {} for attribute 'rot' of Pin object (should be str).".format(v, type(v)))
        self.rot = v
        
        return self

    def with_rot(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`rot`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`rot` equals :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_rot()` is :code:`True`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """

        if type(v) in [str, int, float, bool]:
            return self if self.rot == v else None
        elif callable(v):
            return self if v(self.rot) else None
        else:
            raise SwoopError("Illegal type passed to with_rot")

    def without_rot(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`rot`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`rot` is not equal to :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_rot()` is :code:`False`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """
        
        if type(v) in [str, int, float, bool]:
            return self if self.rot != v else None
        elif callable(v):
            return self if not v(self.rot) else None
        else:
            raise SwoopError("Illegal type passed to without_rot")



    ##### Lookup functions that return EFPs instead of just attribute values.
    
    


    
    ### Adder/getter/lookup for lists
    


    ### Add, lookup, and get for maps


    
    ### Getter/Setter for singletons.


    
    def get_children(self):
        """
        Get all the children of this :class:`EagleFilePart`.
        
        :rtype: List of :class:`EagleFilePart` objects
        """
        r = []




        return r

    def remove_child(self, efp):
        """
        Remove a child :class:`EagleFilePart` object.
        
        :param efp: the class:`EagleFilePart` object to remove.
        :return: Nothing
        """

    def _rekey_child(self, oldkey, efp):
        """
        Remove a child :class:`EagleFilePart` object.
        
        :param efp: the class:`EagleFilePart` object to remove.
        :return: Nothing
        """


    def __str__(self):
        r = "["+repr(self)+" "
        r = r + "name:" + str(self.get_name()) + " "
        r = r + "x:" + str(self.get_x()) + " "
        r = r + "y:" + str(self.get_y()) + " "
        r = r + "visible:" + str(self.get_visible()) + " "
        r = r + "length:" + str(self.get_length()) + " "
        r = r + "direction:" + str(self.get_direction()) + " "
        r = r + "function:" + str(self.get_function()) + " "
        r = r + "swaplevel:" + str(self.get_swaplevel()) + " "
        r = r + "rot:" + str(self.get_rot()) + " "
        r = r + "]"
        return r
            
    def dump(self, indent="", increment="   "):
        """
        Recursive debug dump.
        
        :param indent:  Indentation string.  The output will be indented by this much.
        :param increment: This will be appendeded to :code:`indent` on recursive invocations.

        :rtype: :code:`None`
        """
        print(indent + str(self.__class__.__name__), end=' ')
        try:
            print(self.get_name())
        except:
            print()
            pass
        for c in self.get_children():
            c.dump(indent + "   ")

        
EagleFile.class_map["pin"] = Pin
         


class Text(EagleFilePart, OnePointGeometry, RotationGeometry):
    """
    Class representing the contents of a <text> tag in Eagle files.

    Attributes:

    * :code:`x`

    * :code:`y`

    * :code:`size`

    * :code:`layer`

    * :code:`font`

    * :code:`ratio`

    * :code:`rot`

    * :code:`align`

    * :code:`distance`


    """
    def __init__(self):
        """
        Construct an empty :class:`Text` object.
        """
        EagleFilePart.__init__(self)
        OnePointGeometry.__init__(self)
        RotationGeometry.__init__(self)
        
        self.x=None
        self.y=None
        self.size=None
        self.layer=None
        self.font=None
        self.ratio=None
        self.rot=None
        self.align=None
        self.distance=None

        self.text = ""

        
    @classmethod
    def _from_et(cls,root,parent):
        """
        Create a :class:`Text` from a :code:`text` element.
        
        :param root: The element tree tree to parse.
        :param parent: :class:`EagleFilePart` that should hold the resulting :class:`EagleFilePart`
        :rtype: :class:`Text`
        """
        ## Call the constructor
        n = cls()
        n._init_from_et(root,parent)
        return n

    def _get_error_name(self):
        if hasattr(self, "get_name"):
            return self.get_name();
        else:
            return "Text";
        
    def  _init_from_et(self, root, parent):
        """
        Initialized a :class:`Text` from a :code:`text` element.  This is useful if you have a subclass of :class:`Text` .
        
        :param root: The element tree tree to parse.
        :param parent: :class:`EagleFilePart` that will become the parent of :code:`this` .
        :rtype: :class:`Text`
        """
        try:
            self.root = root
            
            if root.tag != "text":
                raise EagleFormatError("Tried to create text from " + root.tag)

            self.x=parseByType(parent, "float", None, root.get("x"))
            self.y=parseByType(parent, "float", None, root.get("y"))
            self.size=parseByType(parent, "float", None, root.get("size"))
            self.layer=parseByType(parent, "layer_string", None, root.get("layer"))
            self.font=parseByType(parent, "None_is_default_string", 'proportional', root.get("font"))
            self.ratio=parseByType(parent, "None_is_default_int", 8, root.get("ratio"))
            self.rot=parseByType(parent, "str", None, root.get("rot"))
            self.align=parseByType(parent, "None_is_default_string", 'bottom-left', root.get("align"))
            self.distance=parseByType(parent, "None_is_default_int", 50, root.get("distance"))

            self.parent = parent

            ### populate the maps by searching for elements that match xpath and generating objects for them.


            ### Do the same for the lists


            ### Do the same for the attr lists


            ### And the singletons


            ### And, finally, if the objects wants the text from the tag.

            self.text = root.text or "" # If root.text is None, we still need a string.
        except SwoopError as e:
            e.text = "{}:{}".format(self._get_error_name(), e.text)
            raise e


    def sortkey(self):
        r = ""
        r = r + str(self.x)
        r = r + str(self.y)
        r = r + str(self.size)
        r = r + str(self.layer)
        r = r + str(self.font)
        r = r + str(self.ratio)
        r = r + str(self.rot)
        r = r + str(self.align)
        r = r + str(self.distance)
        return r

    def get_et(self):
        """
        Generate a <text> element tree for a :class:`Text`.
        
        :rtype:  :class:`ElementTree`.
        
        """
        try:
            r = ET.Element("text")

            ### Set the tag attributes 


            ## Unparse the values.

            v = unparseByType(self, "float", None,  self.x)

            ## For required attributes None becomes "".  For optional attributes, we just leave the attribute out.
            if not (isinstance(self.get_parent(), LibraryFile) and False):  # special case for the name of library.
                if v is not None:
                    r.set("x", v)
                else:
                    r.set("x", "")


            ## Unparse the values.

            v = unparseByType(self, "float", None,  self.y)

            ## For required attributes None becomes "".  For optional attributes, we just leave the attribute out.
            if not (isinstance(self.get_parent(), LibraryFile) and False):  # special case for the name of library.
                if v is not None:
                    r.set("y", v)
                else:
                    r.set("y", "")


            ## Unparse the values.

            v = unparseByType(self, "float", None,  self.size)

            ## For required attributes None becomes "".  For optional attributes, we just leave the attribute out.
            if not (isinstance(self.get_parent(), LibraryFile) and False):  # special case for the name of library.
                if v is not None:
                    r.set("size", v)
                else:
                    r.set("size", "")


            ## Unparse the values.

            v = unparseByType(self, "layer_string", None,  self.layer)

            ## For required attributes None becomes "".  For optional attributes, we just leave the attribute out.
            if not (isinstance(self.get_parent(), LibraryFile) and False):  # special case for the name of library.
                if v is not None:
                    r.set("layer", v)
                else:
                    r.set("layer", "")


            ## Unparse the values.

            v = unparseByType(self, "None_is_default_string", 'proportional',  self.font)

            ## For required attributes None becomes "".  For optional attributes, we just leave the attribute out.
            if not (isinstance(self.get_parent(), LibraryFile) and False):  # special case for the name of library.
                if v is not None:
                    r.set("font", v)


            ## Unparse the values.

            v = unparseByType(self, "None_is_default_int", 8,  self.ratio)

            ## For required attributes None becomes "".  For optional attributes, we just leave the attribute out.
            if not (isinstance(self.get_parent(), LibraryFile) and False):  # special case for the name of library.
                if v is not None:
                    r.set("ratio", v)


            ## Unparse the values.

            v = unparseByType(self, "str", None,  self.rot)

            ## For required attributes None becomes "".  For optional attributes, we just leave the attribute out.
            if not (isinstance(self.get_parent(), LibraryFile) and False):  # special case for the name of library.
                if v is not None:
                    r.set("rot", v)


            ## Unparse the values.

            v = unparseByType(self, "None_is_default_string", 'bottom-left',  self.align)

            ## For required attributes None becomes "".  For optional attributes, we just leave the attribute out.
            if not (isinstance(self.get_parent(), LibraryFile) and False):  # special case for the name of library.
                if v is not None:
                    r.set("align", v)


            ## Unparse the values.

            v = unparseByType(self, "None_is_default_int", 50,  self.distance)

            ## For required attributes None becomes "".  For optional attributes, we just leave the attribute out.
            if not (isinstance(self.get_parent(), LibraryFile) and False):  # special case for the name of library.
                if v is not None:
                    r.set("distance", v)


            ### process the sections in order.  They have to be in section order,
            ### because eagle files are order dependent.


            ## set the text, if its needed.

            r.text = self.text
        except SwoopError as e:
            e.text = "{}:{}".format(self._get_error_name(), e.text)
            raise e
        return r

    def clone(self):
        """
        Recursively clone this :code:`Text`.  It will be identical to the original, but it's parent will be :code:`None`.
        
        :rtype: :class:`Text`
        """
        try:
            n = copy.copy(self)
            n.parent = None
        except SwoopError as e:
            e.text = "{}:{}".format(self._get_error_name(), e.text)
            raise e
        return n

    def accept_preorder_visitor(self, visitor):
        try:
            pre = getattr(visitor, "Text_pre")
            return pre(self)
        except AttributeError:
            return visitor.default_pre(self)
        
    def accept_postorder_visitor(self, visitor, context):
        try:
            post = getattr(visitor, "Text_post")
            post(self,context)
        except AttributeError:
            visitor.default_post(self,context)

    def is_equal(self, other):
        """
        Check whether two :code:`EagleFilePart` objects are identical.
        
        :param other: Object to compare to.
        :returns: :code:`True` if they are identical, otherwise, :code:`False`
        """
        return self.get_xml() == other.get_xml()
        
    ### Getters/Setters for attribute values

    def get_x(self):
        """ Return the value of :code:`x` for this :class:`Text`.  This corresponds to the :code:`x` attribute of a :code:`<text>` in an Eagle file.
        
        :rtype: :code:`float`
        """
        return self.x

    def set_x(self,v):
        """ Set the value of :code:`x` for this  :class:`Text`.  This corresponds to the :code:`x` attribute of a :code:`<text>` in an Eagle file.

        :param v: new value
        :rtype: :code:`self`
        """
                        
        if not typeCheck("float", v, True):
            raise SwoopError("Illegal value ({}) of type {} for attribute 'x' of Text object (should be float).".format(v, type(v)))
        self.x = v
        
        return self

    def with_x(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`x`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`x` equals :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_x()` is :code:`True`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """

        if type(v) in [str, int, float, bool]:
            return self if self.x == v else None
        elif callable(v):
            return self if v(self.x) else None
        else:
            raise SwoopError("Illegal type passed to with_x")

    def without_x(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`x`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`x` is not equal to :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_x()` is :code:`False`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """
        
        if type(v) in [str, int, float, bool]:
            return self if self.x != v else None
        elif callable(v):
            return self if not v(self.x) else None
        else:
            raise SwoopError("Illegal type passed to without_x")


    def get_y(self):
        """ Return the value of :code:`y` for this :class:`Text`.  This corresponds to the :code:`y` attribute of a :code:`<text>` in an Eagle file.
        
        :rtype: :code:`float`
        """
        return self.y

    def set_y(self,v):
        """ Set the value of :code:`y` for this  :class:`Text`.  This corresponds to the :code:`y` attribute of a :code:`<text>` in an Eagle file.

        :param v: new value
        :rtype: :code:`self`
        """
                        
        if not typeCheck("float", v, True):
            raise SwoopError("Illegal value ({}) of type {} for attribute 'y' of Text object (should be float).".format(v, type(v)))
        self.y = v
        
        return self

    def with_y(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`y`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`y` equals :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_y()` is :code:`True`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """

        if type(v) in [str, int, float, bool]:
            return self if self.y == v else None
        elif callable(v):
            return self if v(self.y) else None
        else:
            raise SwoopError("Illegal type passed to with_y")

    def without_y(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`y`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`y` is not equal to :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_y()` is :code:`False`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """
        
        if type(v) in [str, int, float, bool]:
            return self if self.y != v else None
        elif callable(v):
            return self if not v(self.y) else None
        else:
            raise SwoopError("Illegal type passed to without_y")


    def get_size(self):
        """ Return the value of :code:`size` for this :class:`Text`.  This corresponds to the :code:`size` attribute of a :code:`<text>` in an Eagle file.
        
        :rtype: :code:`float`
        """
        return self.size

    def set_size(self,v):
        """ Set the value of :code:`size` for this  :class:`Text`.  This corresponds to the :code:`size` attribute of a :code:`<text>` in an Eagle file.

        :param v: new value
        :rtype: :code:`self`
        """
                        
        if not typeCheck("float", v, True):
            raise SwoopError("Illegal value ({}) of type {} for attribute 'size' of Text object (should be float).".format(v, type(v)))
        self.size = v
        
        return self

    def with_size(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`size`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`size` equals :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_size()` is :code:`True`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """

        if type(v) in [str, int, float, bool]:
            return self if self.size == v else None
        elif callable(v):
            return self if v(self.size) else None
        else:
            raise SwoopError("Illegal type passed to with_size")

    def without_size(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`size`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`size` is not equal to :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_size()` is :code:`False`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """
        
        if type(v) in [str, int, float, bool]:
            return self if self.size != v else None
        elif callable(v):
            return self if not v(self.size) else None
        else:
            raise SwoopError("Illegal type passed to without_size")


    def get_layer(self):
        """ Return the value of :code:`layer` for this :class:`Text`.  This corresponds to the :code:`layer` attribute of a :code:`<text>` in an Eagle file.
        
        :rtype: :code:`layer_string`
        """
        return self.layer

    def set_layer(self,v):
        """ Set the value of :code:`layer` for this  :class:`Text`.  This corresponds to the :code:`layer` attribute of a :code:`<text>` in an Eagle file.

        :param v: new value
        :rtype: :code:`self`
        """
                        
        if not typeCheck("layer_string", v, True):
            raise SwoopError("Illegal value ({}) of type {} for attribute 'layer' of Text object (should be layer_string).".format(v, type(v)))
        self.layer = v
        
        return self

    def with_layer(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`layer`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`layer` equals :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_layer()` is :code:`True`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """

        if type(v) in [str, int, float, bool]:
            return self if self.layer == v else None
        elif callable(v):
            return self if v(self.layer) else None
        else:
            raise SwoopError("Illegal type passed to with_layer")

    def without_layer(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`layer`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`layer` is not equal to :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_layer()` is :code:`False`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """
        
        if type(v) in [str, int, float, bool]:
            return self if self.layer != v else None
        elif callable(v):
            return self if not v(self.layer) else None
        else:
            raise SwoopError("Illegal type passed to without_layer")


    def get_font(self):
        """ Return the value of :code:`font` for this :class:`Text`.  This corresponds to the :code:`font` attribute of a :code:`<text>` in an Eagle file.
        
        :rtype: :code:`None_is_default_string`
        """
        return self.font

    def set_font(self,v):
        """ Set the value of :code:`font` for this  :class:`Text`.  This corresponds to the :code:`font` attribute of a :code:`<text>` in an Eagle file.

        :param v: new value
        :rtype: :code:`self`
        """
                        
        if not typeCheck("None_is_default_string", v, False):
            raise SwoopError("Illegal value ({}) of type {} for attribute 'font' of Text object (should be None_is_default_string).".format(v, type(v)))
        self.font = v
        
        return self

    def with_font(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`font`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`font` equals :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_font()` is :code:`True`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """

        if type(v) in [str, int, float, bool]:
            return self if self.font == v else None
        elif callable(v):
            return self if v(self.font) else None
        else:
            raise SwoopError("Illegal type passed to with_font")

    def without_font(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`font`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`font` is not equal to :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_font()` is :code:`False`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """
        
        if type(v) in [str, int, float, bool]:
            return self if self.font != v else None
        elif callable(v):
            return self if not v(self.font) else None
        else:
            raise SwoopError("Illegal type passed to without_font")


    def get_ratio(self):
        """ Return the value of :code:`ratio` for this :class:`Text`.  This corresponds to the :code:`ratio` attribute of a :code:`<text>` in an Eagle file.
        
        :rtype: :code:`None_is_default_int`
        """
        return self.ratio

    def set_ratio(self,v):
        """ Set the value of :code:`ratio` for this  :class:`Text`.  This corresponds to the :code:`ratio` attribute of a :code:`<text>` in an Eagle file.

        :param v: new value
        :rtype: :code:`self`
        """
                        
        if not typeCheck("None_is_default_int", v, False):
            raise SwoopError("Illegal value ({}) of type {} for attribute 'ratio' of Text object (should be None_is_default_int).".format(v, type(v)))
        self.ratio = v
        
        return self

    def with_ratio(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`ratio`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`ratio` equals :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_ratio()` is :code:`True`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """

        if type(v) in [str, int, float, bool]:
            return self if self.ratio == v else None
        elif callable(v):
            return self if v(self.ratio) else None
        else:
            raise SwoopError("Illegal type passed to with_ratio")

    def without_ratio(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`ratio`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`ratio` is not equal to :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_ratio()` is :code:`False`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """
        
        if type(v) in [str, int, float, bool]:
            return self if self.ratio != v else None
        elif callable(v):
            return self if not v(self.ratio) else None
        else:
            raise SwoopError("Illegal type passed to without_ratio")


    def get_rot(self):
        """ Return the value of :code:`rot` for this :class:`Text`.  This corresponds to the :code:`rot` attribute of a :code:`<text>` in an Eagle file.
        
        :rtype: :code:`str`
        """
        return self.rot

    def set_rot(self,v):
        """ Set the value of :code:`rot` for this  :class:`Text`.  This corresponds to the :code:`rot` attribute of a :code:`<text>` in an Eagle file.

        :param v: new value
        :rtype: :code:`self`
        """
                        
        if not typeCheck("str", v, False):
            raise SwoopError("Illegal value ({}) of type {} for attribute 'rot' of Text object (should be str).".format(v, type(v)))
        self.rot = v
        
        return self

    def with_rot(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`rot`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`rot` equals :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_rot()` is :code:`True`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """

        if type(v) in [str, int, float, bool]:
            return self if self.rot == v else None
        elif callable(v):
            return self if v(self.rot) else None
        else:
            raise SwoopError("Illegal type passed to with_rot")

    def without_rot(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`rot`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`rot` is not equal to :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_rot()` is :code:`False`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """
        
        if type(v) in [str, int, float, bool]:
            return self if self.rot != v else None
        elif callable(v):
            return self if not v(self.rot) else None
        else:
            raise SwoopError("Illegal type passed to without_rot")


    def get_align(self):
        """ Return the value of :code:`align` for this :class:`Text`.  This corresponds to the :code:`align` attribute of a :code:`<text>` in an Eagle file.
        
        :rtype: :code:`None_is_default_string`
        """
        return self.align

    def set_align(self,v):
        """ Set the value of :code:`align` for this  :class:`Text`.  This corresponds to the :code:`align` attribute of a :code:`<text>` in an Eagle file.

        :param v: new value
        :rtype: :code:`self`
        """
                        
        if not typeCheck("None_is_default_string", v, False):
            raise SwoopError("Illegal value ({}) of type {} for attribute 'align' of Text object (should be None_is_default_string).".format(v, type(v)))
        self.align = v
        
        return self

    def with_align(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`align`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`align` equals :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_align()` is :code:`True`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """

        if type(v) in [str, int, float, bool]:
            return self if self.align == v else None
        elif callable(v):
            return self if v(self.align) else None
        else:
            raise SwoopError("Illegal type passed to with_align")

    def without_align(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`align`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`align` is not equal to :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_align()` is :code:`False`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """
        
        if type(v) in [str, int, float, bool]:
            return self if self.align != v else None
        elif callable(v):
            return self if not v(self.align) else None
        else:
            raise SwoopError("Illegal type passed to without_align")


    def get_distance(self):
        """ Return the value of :code:`distance` for this :class:`Text`.  This corresponds to the :code:`distance` attribute of a :code:`<text>` in an Eagle file.
        
        :rtype: :code:`None_is_default_int`
        """
        return self.distance

    def set_distance(self,v):
        """ Set the value of :code:`distance` for this  :class:`Text`.  This corresponds to the :code:`distance` attribute of a :code:`<text>` in an Eagle file.

        :param v: new value
        :rtype: :code:`self`
        """
                        
        if not typeCheck("None_is_default_int", v, False):
            raise SwoopError("Illegal value ({}) of type {} for attribute 'distance' of Text object (should be None_is_default_int).".format(v, type(v)))
        self.distance = v
        
        return self

    def with_distance(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`distance`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`distance` equals :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_distance()` is :code:`True`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """

        if type(v) in [str, int, float, bool]:
            return self if self.distance == v else None
        elif callable(v):
            return self if v(self.distance) else None
        else:
            raise SwoopError("Illegal type passed to with_distance")

    def without_distance(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`distance`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`distance` is not equal to :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_distance()` is :code:`False`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """
        
        if type(v) in [str, int, float, bool]:
            return self if self.distance != v else None
        elif callable(v):
            return self if not v(self.distance) else None
        else:
            raise SwoopError("Illegal type passed to without_distance")



    ##### Lookup functions that return EFPs instead of just attribute values.
    
    
    def with_text(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`text`.  For use in combination with :class:`From` objects.
        
        Return :code:`self` if one of the following is true:

        1.  :code:`text` equals :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_text()` is :code:`True`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """

        if type(v) in [str, int, float]:
            return self if self.text == v else None
        elif callable(v):
            return self if v(self.text) else None
        else:
            raise SwoopError("Illegal type passed to with_text")

    def without_text(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`text`.
        
        Return :code:`self` if one of the following is true:

        1.  :code:`text` does not equal :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_text()` is :code:`False`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """

        if type(v) in [str, int, float]:
            return self if self.text == v else None
        elif callable(v):
            return self if v(self.text) else None
        else:
            raise SwoopError("Illegal type passed to without_text")


    
    ### Adder/getter/lookup for lists
    


    ### Add, lookup, and get for maps


    
    ### Getter/Setter for singletons.


    def set_text(self, s):
        """ Set the text content for this :class:`Text`.

        :param s: text to set.
        :rtype: :code:`self`
        """
        self.text = s
        return self

    def get_text(self):
        """ Get the text content from this :class:`Text`.
        
        :rtype: the text content.
        """
        return self.text
    
    
    def get_children(self):
        """
        Get all the children of this :class:`EagleFilePart`.
        
        :rtype: List of :class:`EagleFilePart` objects
        """
        r = []




        return r

    def remove_child(self, efp):
        """
        Remove a child :class:`EagleFilePart` object.
        
        :param efp: the class:`EagleFilePart` object to remove.
        :return: Nothing
        """

    def _rekey_child(self, oldkey, efp):
        """
        Remove a child :class:`EagleFilePart` object.
        
        :param efp: the class:`EagleFilePart` object to remove.
        :return: Nothing
        """


    def __str__(self):
        r = "["+repr(self)+" "
        r = r + "x:" + str(self.get_x()) + " "
        r = r + "y:" + str(self.get_y()) + " "
        r = r + "size:" + str(self.get_size()) + " "
        r = r + "layer:" + str(self.get_layer()) + " "
        r = r + "font:" + str(self.get_font()) + " "
        r = r + "ratio:" + str(self.get_ratio()) + " "
        r = r + "rot:" + str(self.get_rot()) + " "
        r = r + "align:" + str(self.get_align()) + " "
        r = r + "distance:" + str(self.get_distance()) + " "
        r = r + "]"
        return r
            
    def dump(self, indent="", increment="   "):
        """
        Recursive debug dump.
        
        :param indent:  Indentation string.  The output will be indented by this much.
        :param increment: This will be appendeded to :code:`indent` on recursive invocations.

        :rtype: :code:`None`
        """
        print(indent + str(self.__class__.__name__), end=' ')
        try:
            print(self.get_name())
        except:
            print()
            pass
        for c in self.get_children():
            c.dump(indent + "   ")

        
EagleFile.class_map["text"] = Text
         


class Frame(EagleFilePart, RectGeometry):
    """
    Class representing the contents of a <frame> tag in Eagle files.

    Attributes:

    * :code:`x1`

    * :code:`y1`

    * :code:`x2`

    * :code:`y2`

    * :code:`columns`

    * :code:`rows`

    * :code:`layer`

    * :code:`border_left`

    * :code:`border_right`

    * :code:`border_top`

    * :code:`border_bottom`


    """
    def __init__(self):
        """
        Construct an empty :class:`Frame` object.
        """
        EagleFilePart.__init__(self)
        RectGeometry.__init__(self)
        
        self.x1=None
        self.y1=None
        self.x2=None
        self.y2=None
        self.columns=None
        self.rows=None
        self.layer=None
        self.border_left=None
        self.border_right=None
        self.border_top=None
        self.border_bottom=None


        
    @classmethod
    def _from_et(cls,root,parent):
        """
        Create a :class:`Frame` from a :code:`frame` element.
        
        :param root: The element tree tree to parse.
        :param parent: :class:`EagleFilePart` that should hold the resulting :class:`EagleFilePart`
        :rtype: :class:`Frame`
        """
        ## Call the constructor
        n = cls()
        n._init_from_et(root,parent)
        return n

    def _get_error_name(self):
        if hasattr(self, "get_name"):
            return self.get_name();
        else:
            return "Frame";
        
    def  _init_from_et(self, root, parent):
        """
        Initialized a :class:`Frame` from a :code:`frame` element.  This is useful if you have a subclass of :class:`Frame` .
        
        :param root: The element tree tree to parse.
        :param parent: :class:`EagleFilePart` that will become the parent of :code:`this` .
        :rtype: :class:`Frame`
        """
        try:
            self.root = root
            
            if root.tag != "frame":
                raise EagleFormatError("Tried to create frame from " + root.tag)

            self.x1=parseByType(parent, "float", None, root.get("x1"))
            self.y1=parseByType(parent, "float", None, root.get("y1"))
            self.x2=parseByType(parent, "float", None, root.get("x2"))
            self.y2=parseByType(parent, "float", None, root.get("y2"))
            self.columns=parseByType(parent, "int", None, root.get("columns"))
            self.rows=parseByType(parent, "int", None, root.get("rows"))
            self.layer=parseByType(parent, "layer_string", None, root.get("layer"))
            self.border_left=parseByType(parent, "bool", None, root.get("border-left"))
            self.border_right=parseByType(parent, "bool", None, root.get("border-right"))
            self.border_top=parseByType(parent, "bool", None, root.get("border-top"))
            self.border_bottom=parseByType(parent, "bool", None, root.get("border-bottom"))

            self.parent = parent

            ### populate the maps by searching for elements that match xpath and generating objects for them.


            ### Do the same for the lists


            ### Do the same for the attr lists


            ### And the singletons


            ### And, finally, if the objects wants the text from the tag.

        except SwoopError as e:
            e.text = "{}:{}".format(self._get_error_name(), e.text)
            raise e


    def sortkey(self):
        r = ""
        r = r + str(self.x1)
        r = r + str(self.y1)
        r = r + str(self.x2)
        r = r + str(self.y2)
        r = r + str(self.columns)
        r = r + str(self.rows)
        r = r + str(self.layer)
        r = r + str(self.border_left)
        r = r + str(self.border_right)
        r = r + str(self.border_top)
        r = r + str(self.border_bottom)
        return r

    def get_et(self):
        """
        Generate a <frame> element tree for a :class:`Frame`.
        
        :rtype:  :class:`ElementTree`.
        
        """
        try:
            r = ET.Element("frame")

            ### Set the tag attributes 


            ## Unparse the values.

            v = unparseByType(self, "float", None,  self.x1)

            ## For required attributes None becomes "".  For optional attributes, we just leave the attribute out.
            if not (isinstance(self.get_parent(), LibraryFile) and False):  # special case for the name of library.
                if v is not None:
                    r.set("x1", v)
                else:
                    r.set("x1", "")


            ## Unparse the values.

            v = unparseByType(self, "float", None,  self.y1)

            ## For required attributes None becomes "".  For optional attributes, we just leave the attribute out.
            if not (isinstance(self.get_parent(), LibraryFile) and False):  # special case for the name of library.
                if v is not None:
                    r.set("y1", v)
                else:
                    r.set("y1", "")


            ## Unparse the values.

            v = unparseByType(self, "float", None,  self.x2)

            ## For required attributes None becomes "".  For optional attributes, we just leave the attribute out.
            if not (isinstance(self.get_parent(), LibraryFile) and False):  # special case for the name of library.
                if v is not None:
                    r.set("x2", v)
                else:
                    r.set("x2", "")


            ## Unparse the values.

            v = unparseByType(self, "float", None,  self.y2)

            ## For required attributes None becomes "".  For optional attributes, we just leave the attribute out.
            if not (isinstance(self.get_parent(), LibraryFile) and False):  # special case for the name of library.
                if v is not None:
                    r.set("y2", v)
                else:
                    r.set("y2", "")


            ## Unparse the values.

            v = unparseByType(self, "int", None,  self.columns)

            ## For required attributes None becomes "".  For optional attributes, we just leave the attribute out.
            if not (isinstance(self.get_parent(), LibraryFile) and False):  # special case for the name of library.
                if v is not None:
                    r.set("columns", v)
                else:
                    r.set("columns", "")


            ## Unparse the values.

            v = unparseByType(self, "int", None,  self.rows)

            ## For required attributes None becomes "".  For optional attributes, we just leave the attribute out.
            if not (isinstance(self.get_parent(), LibraryFile) and False):  # special case for the name of library.
                if v is not None:
                    r.set("rows", v)
                else:
                    r.set("rows", "")


            ## Unparse the values.

            v = unparseByType(self, "layer_string", None,  self.layer)

            ## For required attributes None becomes "".  For optional attributes, we just leave the attribute out.
            if not (isinstance(self.get_parent(), LibraryFile) and False):  # special case for the name of library.
                if v is not None:
                    r.set("layer", v)
                else:
                    r.set("layer", "")


            ## Unparse the values.

            v = unparseByType(self, "bool", None,  self.border_left)

            ## For required attributes None becomes "".  For optional attributes, we just leave the attribute out.
            if not (isinstance(self.get_parent(), LibraryFile) and False):  # special case for the name of library.
                if v is not None:
                    r.set("border-left", v)


            ## Unparse the values.

            v = unparseByType(self, "bool", None,  self.border_right)

            ## For required attributes None becomes "".  For optional attributes, we just leave the attribute out.
            if not (isinstance(self.get_parent(), LibraryFile) and False):  # special case for the name of library.
                if v is not None:
                    r.set("border-right", v)


            ## Unparse the values.

            v = unparseByType(self, "bool", None,  self.border_top)

            ## For required attributes None becomes "".  For optional attributes, we just leave the attribute out.
            if not (isinstance(self.get_parent(), LibraryFile) and False):  # special case for the name of library.
                if v is not None:
                    r.set("border-top", v)


            ## Unparse the values.

            v = unparseByType(self, "bool", None,  self.border_bottom)

            ## For required attributes None becomes "".  For optional attributes, we just leave the attribute out.
            if not (isinstance(self.get_parent(), LibraryFile) and False):  # special case for the name of library.
                if v is not None:
                    r.set("border-bottom", v)


            ### process the sections in order.  They have to be in section order,
            ### because eagle files are order dependent.


            ## set the text, if its needed.

        except SwoopError as e:
            e.text = "{}:{}".format(self._get_error_name(), e.text)
            raise e
        return r

    def clone(self):
        """
        Recursively clone this :code:`Frame`.  It will be identical to the original, but it's parent will be :code:`None`.
        
        :rtype: :class:`Frame`
        """
        try:
            n = copy.copy(self)
            n.parent = None
        except SwoopError as e:
            e.text = "{}:{}".format(self._get_error_name(), e.text)
            raise e
        return n

    def accept_preorder_visitor(self, visitor):
        try:
            pre = getattr(visitor, "Frame_pre")
            return pre(self)
        except AttributeError:
            return visitor.default_pre(self)
        
    def accept_postorder_visitor(self, visitor, context):
        try:
            post = getattr(visitor, "Frame_post")
            post(self,context)
        except AttributeError:
            visitor.default_post(self,context)

    def is_equal(self, other):
        """
        Check whether two :code:`EagleFilePart` objects are identical.
        
        :param other: Object to compare to.
        :returns: :code:`True` if they are identical, otherwise, :code:`False`
        """
        return self.get_xml() == other.get_xml()
        
    ### Getters/Setters for attribute values

    def get_x1(self):
        """ Return the value of :code:`x1` for this :class:`Frame`.  This corresponds to the :code:`x1` attribute of a :code:`<frame>` in an Eagle file.
        
        :rtype: :code:`float`
        """
        return self.x1

    def set_x1(self,v):
        """ Set the value of :code:`x1` for this  :class:`Frame`.  This corresponds to the :code:`x1` attribute of a :code:`<frame>` in an Eagle file.

        :param v: new value
        :rtype: :code:`self`
        """
                        
        if not typeCheck("float", v, True):
            raise SwoopError("Illegal value ({}) of type {} for attribute 'x1' of Frame object (should be float).".format(v, type(v)))
        self.x1 = v
        
        return self

    def with_x1(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`x1`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`x1` equals :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_x1()` is :code:`True`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """

        if type(v) in [str, int, float, bool]:
            return self if self.x1 == v else None
        elif callable(v):
            return self if v(self.x1) else None
        else:
            raise SwoopError("Illegal type passed to with_x1")

    def without_x1(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`x1`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`x1` is not equal to :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_x1()` is :code:`False`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """
        
        if type(v) in [str, int, float, bool]:
            return self if self.x1 != v else None
        elif callable(v):
            return self if not v(self.x1) else None
        else:
            raise SwoopError("Illegal type passed to without_x1")


    def get_y1(self):
        """ Return the value of :code:`y1` for this :class:`Frame`.  This corresponds to the :code:`y1` attribute of a :code:`<frame>` in an Eagle file.
        
        :rtype: :code:`float`
        """
        return self.y1

    def set_y1(self,v):
        """ Set the value of :code:`y1` for this  :class:`Frame`.  This corresponds to the :code:`y1` attribute of a :code:`<frame>` in an Eagle file.

        :param v: new value
        :rtype: :code:`self`
        """
                        
        if not typeCheck("float", v, True):
            raise SwoopError("Illegal value ({}) of type {} for attribute 'y1' of Frame object (should be float).".format(v, type(v)))
        self.y1 = v
        
        return self

    def with_y1(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`y1`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`y1` equals :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_y1()` is :code:`True`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """

        if type(v) in [str, int, float, bool]:
            return self if self.y1 == v else None
        elif callable(v):
            return self if v(self.y1) else None
        else:
            raise SwoopError("Illegal type passed to with_y1")

    def without_y1(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`y1`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`y1` is not equal to :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_y1()` is :code:`False`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """
        
        if type(v) in [str, int, float, bool]:
            return self if self.y1 != v else None
        elif callable(v):
            return self if not v(self.y1) else None
        else:
            raise SwoopError("Illegal type passed to without_y1")


    def get_x2(self):
        """ Return the value of :code:`x2` for this :class:`Frame`.  This corresponds to the :code:`x2` attribute of a :code:`<frame>` in an Eagle file.
        
        :rtype: :code:`float`
        """
        return self.x2

    def set_x2(self,v):
        """ Set the value of :code:`x2` for this  :class:`Frame`.  This corresponds to the :code:`x2` attribute of a :code:`<frame>` in an Eagle file.

        :param v: new value
        :rtype: :code:`self`
        """
                        
        if not typeCheck("float", v, True):
            raise SwoopError("Illegal value ({}) of type {} for attribute 'x2' of Frame object (should be float).".format(v, type(v)))
        self.x2 = v
        
        return self

    def with_x2(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`x2`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`x2` equals :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_x2()` is :code:`True`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """

        if type(v) in [str, int, float, bool]:
            return self if self.x2 == v else None
        elif callable(v):
            return self if v(self.x2) else None
        else:
            raise SwoopError("Illegal type passed to with_x2")

    def without_x2(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`x2`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`x2` is not equal to :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_x2()` is :code:`False`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """
        
        if type(v) in [str, int, float, bool]:
            return self if self.x2 != v else None
        elif callable(v):
            return self if not v(self.x2) else None
        else:
            raise SwoopError("Illegal type passed to without_x2")


    def get_y2(self):
        """ Return the value of :code:`y2` for this :class:`Frame`.  This corresponds to the :code:`y2` attribute of a :code:`<frame>` in an Eagle file.
        
        :rtype: :code:`float`
        """
        return self.y2

    def set_y2(self,v):
        """ Set the value of :code:`y2` for this  :class:`Frame`.  This corresponds to the :code:`y2` attribute of a :code:`<frame>` in an Eagle file.

        :param v: new value
        :rtype: :code:`self`
        """
                        
        if not typeCheck("float", v, True):
            raise SwoopError("Illegal value ({}) of type {} for attribute 'y2' of Frame object (should be float).".format(v, type(v)))
        self.y2 = v
        
        return self

    def with_y2(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`y2`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`y2` equals :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_y2()` is :code:`True`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """

        if type(v) in [str, int, float, bool]:
            return self if self.y2 == v else None
        elif callable(v):
            return self if v(self.y2) else None
        else:
            raise SwoopError("Illegal type passed to with_y2")

    def without_y2(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`y2`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`y2` is not equal to :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_y2()` is :code:`False`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """
        
        if type(v) in [str, int, float, bool]:
            return self if self.y2 != v else None
        elif callable(v):
            return self if not v(self.y2) else None
        else:
            raise SwoopError("Illegal type passed to without_y2")


    def get_columns(self):
        """ Return the value of :code:`columns` for this :class:`Frame`.  This corresponds to the :code:`columns` attribute of a :code:`<frame>` in an Eagle file.
        
        :rtype: :code:`int`
        """
        return self.columns

    def set_columns(self,v):
        """ Set the value of :code:`columns` for this  :class:`Frame`.  This corresponds to the :code:`columns` attribute of a :code:`<frame>` in an Eagle file.

        :param v: new value
        :rtype: :code:`self`
        """
                        
        if not typeCheck("int", v, True):
            raise SwoopError("Illegal value ({}) of type {} for attribute 'columns' of Frame object (should be int).".format(v, type(v)))
        self.columns = v
        
        return self

    def with_columns(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`columns`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`columns` equals :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_columns()` is :code:`True`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """

        if type(v) in [str, int, float, bool]:
            return self if self.columns == v else None
        elif callable(v):
            return self if v(self.columns) else None
        else:
            raise SwoopError("Illegal type passed to with_columns")

    def without_columns(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`columns`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`columns` is not equal to :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_columns()` is :code:`False`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """
        
        if type(v) in [str, int, float, bool]:
            return self if self.columns != v else None
        elif callable(v):
            return self if not v(self.columns) else None
        else:
            raise SwoopError("Illegal type passed to without_columns")


    def get_rows(self):
        """ Return the value of :code:`rows` for this :class:`Frame`.  This corresponds to the :code:`rows` attribute of a :code:`<frame>` in an Eagle file.
        
        :rtype: :code:`int`
        """
        return self.rows

    def set_rows(self,v):
        """ Set the value of :code:`rows` for this  :class:`Frame`.  This corresponds to the :code:`rows` attribute of a :code:`<frame>` in an Eagle file.

        :param v: new value
        :rtype: :code:`self`
        """
                        
        if not typeCheck("int", v, True):
            raise SwoopError("Illegal value ({}) of type {} for attribute 'rows' of Frame object (should be int).".format(v, type(v)))
        self.rows = v
        
        return self

    def with_rows(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`rows`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`rows` equals :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_rows()` is :code:`True`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """

        if type(v) in [str, int, float, bool]:
            return self if self.rows == v else None
        elif callable(v):
            return self if v(self.rows) else None
        else:
            raise SwoopError("Illegal type passed to with_rows")

    def without_rows(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`rows`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`rows` is not equal to :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_rows()` is :code:`False`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """
        
        if type(v) in [str, int, float, bool]:
            return self if self.rows != v else None
        elif callable(v):
            return self if not v(self.rows) else None
        else:
            raise SwoopError("Illegal type passed to without_rows")


    def get_layer(self):
        """ Return the value of :code:`layer` for this :class:`Frame`.  This corresponds to the :code:`layer` attribute of a :code:`<frame>` in an Eagle file.
        
        :rtype: :code:`layer_string`
        """
        return self.layer

    def set_layer(self,v):
        """ Set the value of :code:`layer` for this  :class:`Frame`.  This corresponds to the :code:`layer` attribute of a :code:`<frame>` in an Eagle file.

        :param v: new value
        :rtype: :code:`self`
        """
                        
        if not typeCheck("layer_string", v, True):
            raise SwoopError("Illegal value ({}) of type {} for attribute 'layer' of Frame object (should be layer_string).".format(v, type(v)))
        self.layer = v
        
        return self

    def with_layer(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`layer`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`layer` equals :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_layer()` is :code:`True`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """

        if type(v) in [str, int, float, bool]:
            return self if self.layer == v else None
        elif callable(v):
            return self if v(self.layer) else None
        else:
            raise SwoopError("Illegal type passed to with_layer")

    def without_layer(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`layer`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`layer` is not equal to :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_layer()` is :code:`False`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """
        
        if type(v) in [str, int, float, bool]:
            return self if self.layer != v else None
        elif callable(v):
            return self if not v(self.layer) else None
        else:
            raise SwoopError("Illegal type passed to without_layer")


    def get_border_left(self):
        """ Return the value of :code:`border_left` for this :class:`Frame`.  This corresponds to the :code:`border_left` attribute of a :code:`<frame>` in an Eagle file.
        
        :rtype: :code:`bool`
        """
        return self.border_left

    def set_border_left(self,v):
        """ Set the value of :code:`border_left` for this  :class:`Frame`.  This corresponds to the :code:`border_left` attribute of a :code:`<frame>` in an Eagle file.

        :param v: new value
        :rtype: :code:`self`
        """
                        
        if not typeCheck("bool", v, False):
            raise SwoopError("Illegal value ({}) of type {} for attribute 'border_left' of Frame object (should be bool).".format(v, type(v)))
        self.border_left = v
        
        return self

    def with_border_left(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`border_left`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`border_left` equals :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_border_left()` is :code:`True`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """

        if type(v) in [str, int, float, bool]:
            return self if self.border_left == v else None
        elif callable(v):
            return self if v(self.border_left) else None
        else:
            raise SwoopError("Illegal type passed to with_border_left")

    def without_border_left(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`border_left`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`border_left` is not equal to :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_border_left()` is :code:`False`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """
        
        if type(v) in [str, int, float, bool]:
            return self if self.border_left != v else None
        elif callable(v):
            return self if not v(self.border_left) else None
        else:
            raise SwoopError("Illegal type passed to without_border_left")


    def get_border_right(self):
        """ Return the value of :code:`border_right` for this :class:`Frame`.  This corresponds to the :code:`border_right` attribute of a :code:`<frame>` in an Eagle file.
        
        :rtype: :code:`bool`
        """
        return self.border_right

    def set_border_right(self,v):
        """ Set the value of :code:`border_right` for this  :class:`Frame`.  This corresponds to the :code:`border_right` attribute of a :code:`<frame>` in an Eagle file.

        :param v: new value
        :rtype: :code:`self`
        """
                        
        if not typeCheck("bool", v, False):
            raise SwoopError("Illegal value ({}) of type {} for attribute 'border_right' of Frame object (should be bool).".format(v, type(v)))
        self.border_right = v
        
        return self

    def with_border_right(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`border_right`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`border_right` equals :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_border_right()` is :code:`True`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """

        if type(v) in [str, int, float, bool]:
            return self if self.border_right == v else None
        elif callable(v):
            return self if v(self.border_right) else None
        else:
            raise SwoopError("Illegal type passed to with_border_right")

    def without_border_right(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`border_right`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`border_right` is not equal to :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_border_right()` is :code:`False`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """
        
        if type(v) in [str, int, float, bool]:
            return self if self.border_right != v else None
        elif callable(v):
            return self if not v(self.border_right) else None
        else:
            raise SwoopError("Illegal type passed to without_border_right")


    def get_border_top(self):
        """ Return the value of :code:`border_top` for this :class:`Frame`.  This corresponds to the :code:`border_top` attribute of a :code:`<frame>` in an Eagle file.
        
        :rtype: :code:`bool`
        """
        return self.border_top

    def set_border_top(self,v):
        """ Set the value of :code:`border_top` for this  :class:`Frame`.  This corresponds to the :code:`border_top` attribute of a :code:`<frame>` in an Eagle file.

        :param v: new value
        :rtype: :code:`self`
        """
                        
        if not typeCheck("bool", v, False):
            raise SwoopError("Illegal value ({}) of type {} for attribute 'border_top' of Frame object (should be bool).".format(v, type(v)))
        self.border_top = v
        
        return self

    def with_border_top(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`border_top`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`border_top` equals :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_border_top()` is :code:`True`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """

        if type(v) in [str, int, float, bool]:
            return self if self.border_top == v else None
        elif callable(v):
            return self if v(self.border_top) else None
        else:
            raise SwoopError("Illegal type passed to with_border_top")

    def without_border_top(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`border_top`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`border_top` is not equal to :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_border_top()` is :code:`False`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """
        
        if type(v) in [str, int, float, bool]:
            return self if self.border_top != v else None
        elif callable(v):
            return self if not v(self.border_top) else None
        else:
            raise SwoopError("Illegal type passed to without_border_top")


    def get_border_bottom(self):
        """ Return the value of :code:`border_bottom` for this :class:`Frame`.  This corresponds to the :code:`border_bottom` attribute of a :code:`<frame>` in an Eagle file.
        
        :rtype: :code:`bool`
        """
        return self.border_bottom

    def set_border_bottom(self,v):
        """ Set the value of :code:`border_bottom` for this  :class:`Frame`.  This corresponds to the :code:`border_bottom` attribute of a :code:`<frame>` in an Eagle file.

        :param v: new value
        :rtype: :code:`self`
        """
                        
        if not typeCheck("bool", v, False):
            raise SwoopError("Illegal value ({}) of type {} for attribute 'border_bottom' of Frame object (should be bool).".format(v, type(v)))
        self.border_bottom = v
        
        return self

    def with_border_bottom(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`border_bottom`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`border_bottom` equals :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_border_bottom()` is :code:`True`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """

        if type(v) in [str, int, float, bool]:
            return self if self.border_bottom == v else None
        elif callable(v):
            return self if v(self.border_bottom) else None
        else:
            raise SwoopError("Illegal type passed to with_border_bottom")

    def without_border_bottom(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`border_bottom`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`border_bottom` is not equal to :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_border_bottom()` is :code:`False`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """
        
        if type(v) in [str, int, float, bool]:
            return self if self.border_bottom != v else None
        elif callable(v):
            return self if not v(self.border_bottom) else None
        else:
            raise SwoopError("Illegal type passed to without_border_bottom")



    ##### Lookup functions that return EFPs instead of just attribute values.
    
    


    
    ### Adder/getter/lookup for lists
    


    ### Add, lookup, and get for maps


    
    ### Getter/Setter for singletons.


    
    def get_children(self):
        """
        Get all the children of this :class:`EagleFilePart`.
        
        :rtype: List of :class:`EagleFilePart` objects
        """
        r = []




        return r

    def remove_child(self, efp):
        """
        Remove a child :class:`EagleFilePart` object.
        
        :param efp: the class:`EagleFilePart` object to remove.
        :return: Nothing
        """

    def _rekey_child(self, oldkey, efp):
        """
        Remove a child :class:`EagleFilePart` object.
        
        :param efp: the class:`EagleFilePart` object to remove.
        :return: Nothing
        """


    def __str__(self):
        r = "["+repr(self)+" "
        r = r + "x1:" + str(self.get_x1()) + " "
        r = r + "y1:" + str(self.get_y1()) + " "
        r = r + "x2:" + str(self.get_x2()) + " "
        r = r + "y2:" + str(self.get_y2()) + " "
        r = r + "columns:" + str(self.get_columns()) + " "
        r = r + "rows:" + str(self.get_rows()) + " "
        r = r + "layer:" + str(self.get_layer()) + " "
        r = r + "border_left:" + str(self.get_border_left()) + " "
        r = r + "border_right:" + str(self.get_border_right()) + " "
        r = r + "border_top:" + str(self.get_border_top()) + " "
        r = r + "border_bottom:" + str(self.get_border_bottom()) + " "
        r = r + "]"
        return r
            
    def dump(self, indent="", increment="   "):
        """
        Recursive debug dump.
        
        :param indent:  Indentation string.  The output will be indented by this much.
        :param increment: This will be appendeded to :code:`indent` on recursive invocations.

        :rtype: :code:`None`
        """
        print(indent + str(self.__class__.__name__), end=' ')
        try:
            print(self.get_name())
        except:
            print()
            pass
        for c in self.get_children():
            c.dump(indent + "   ")

        
EagleFile.class_map["frame"] = Frame
         


class Portref(EagleFilePart):
    """
    Class representing the contents of a <portref> tag in Eagle files.

    Attributes:

    * :code:`moduleinst`

    * :code:`port`


    """
    def __init__(self):
        """
        Construct an empty :class:`Portref` object.
        """
        EagleFilePart.__init__(self)
        
        self.moduleinst=None
        self.port=None


        
    @classmethod
    def _from_et(cls,root,parent):
        """
        Create a :class:`Portref` from a :code:`portref` element.
        
        :param root: The element tree tree to parse.
        :param parent: :class:`EagleFilePart` that should hold the resulting :class:`EagleFilePart`
        :rtype: :class:`Portref`
        """
        ## Call the constructor
        n = cls()
        n._init_from_et(root,parent)
        return n

    def _get_error_name(self):
        if hasattr(self, "get_name"):
            return self.get_name();
        else:
            return "Portref";
        
    def  _init_from_et(self, root, parent):
        """
        Initialized a :class:`Portref` from a :code:`portref` element.  This is useful if you have a subclass of :class:`Portref` .
        
        :param root: The element tree tree to parse.
        :param parent: :class:`EagleFilePart` that will become the parent of :code:`this` .
        :rtype: :class:`Portref`
        """
        try:
            self.root = root
            
            if root.tag != "portref":
                raise EagleFormatError("Tried to create portref from " + root.tag)

            self.moduleinst=parseByType(parent, "str", None, root.get("moduleinst"))
            self.port=parseByType(parent, "str", None, root.get("port"))

            self.parent = parent

            ### populate the maps by searching for elements that match xpath and generating objects for them.


            ### Do the same for the lists


            ### Do the same for the attr lists


            ### And the singletons


            ### And, finally, if the objects wants the text from the tag.

        except SwoopError as e:
            e.text = "{}:{}".format(self._get_error_name(), e.text)
            raise e


    def sortkey(self):
        r = ""
        r = r + str(self.moduleinst)
        r = r + str(self.port)
        return r

    def get_et(self):
        """
        Generate a <portref> element tree for a :class:`Portref`.
        
        :rtype:  :class:`ElementTree`.
        
        """
        try:
            r = ET.Element("portref")

            ### Set the tag attributes 


            ## Unparse the values.

            v = unparseByType(self, "str", None,  self.moduleinst)

            ## For required attributes None becomes "".  For optional attributes, we just leave the attribute out.
            if not (isinstance(self.get_parent(), LibraryFile) and False):  # special case for the name of library.
                if v is not None:
                    r.set("moduleinst", v)
                else:
                    r.set("moduleinst", "")


            ## Unparse the values.

            v = unparseByType(self, "str", None,  self.port)

            ## For required attributes None becomes "".  For optional attributes, we just leave the attribute out.
            if not (isinstance(self.get_parent(), LibraryFile) and False):  # special case for the name of library.
                if v is not None:
                    r.set("port", v)
                else:
                    r.set("port", "")


            ### process the sections in order.  They have to be in section order,
            ### because eagle files are order dependent.


            ## set the text, if its needed.

        except SwoopError as e:
            e.text = "{}:{}".format(self._get_error_name(), e.text)
            raise e
        return r

    def clone(self):
        """
        Recursively clone this :code:`Portref`.  It will be identical to the original, but it's parent will be :code:`None`.
        
        :rtype: :class:`Portref`
        """
        try:
            n = copy.copy(self)
            n.parent = None
        except SwoopError as e:
            e.text = "{}:{}".format(self._get_error_name(), e.text)
            raise e
        return n

    def accept_preorder_visitor(self, visitor):
        try:
            pre = getattr(visitor, "Portref_pre")
            return pre(self)
        except AttributeError:
            return visitor.default_pre(self)
        
    def accept_postorder_visitor(self, visitor, context):
        try:
            post = getattr(visitor, "Portref_post")
            post(self,context)
        except AttributeError:
            visitor.default_post(self,context)

    def is_equal(self, other):
        """
        Check whether two :code:`EagleFilePart` objects are identical.
        
        :param other: Object to compare to.
        :returns: :code:`True` if they are identical, otherwise, :code:`False`
        """
        return self.get_xml() == other.get_xml()
        
    ### Getters/Setters for attribute values

    def get_moduleinst(self):
        """ Return the value of :code:`moduleinst` for this :class:`Portref`.  This corresponds to the :code:`moduleinst` attribute of a :code:`<portref>` in an Eagle file.
        
        :rtype: :code:`str`
        """
        return self.moduleinst

    def set_moduleinst(self,v):
        """ Set the value of :code:`moduleinst` for this  :class:`Portref`.  This corresponds to the :code:`moduleinst` attribute of a :code:`<portref>` in an Eagle file.

        :param v: new value
        :rtype: :code:`self`
        """
                        
        if not typeCheck("str", v, True):
            raise SwoopError("Illegal value ({}) of type {} for attribute 'moduleinst' of Portref object (should be str).".format(v, type(v)))
        self.moduleinst = v
        
        return self

    def with_moduleinst(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`moduleinst`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`moduleinst` equals :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_moduleinst()` is :code:`True`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """

        if type(v) in [str, int, float, bool]:
            return self if self.moduleinst == v else None
        elif callable(v):
            return self if v(self.moduleinst) else None
        else:
            raise SwoopError("Illegal type passed to with_moduleinst")

    def without_moduleinst(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`moduleinst`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`moduleinst` is not equal to :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_moduleinst()` is :code:`False`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """
        
        if type(v) in [str, int, float, bool]:
            return self if self.moduleinst != v else None
        elif callable(v):
            return self if not v(self.moduleinst) else None
        else:
            raise SwoopError("Illegal type passed to without_moduleinst")


    def get_port(self):
        """ Return the value of :code:`port` for this :class:`Portref`.  This corresponds to the :code:`port` attribute of a :code:`<portref>` in an Eagle file.
        
        :rtype: :code:`str`
        """
        return self.port

    def set_port(self,v):
        """ Set the value of :code:`port` for this  :class:`Portref`.  This corresponds to the :code:`port` attribute of a :code:`<portref>` in an Eagle file.

        :param v: new value
        :rtype: :code:`self`
        """
                        
        if not typeCheck("str", v, True):
            raise SwoopError("Illegal value ({}) of type {} for attribute 'port' of Portref object (should be str).".format(v, type(v)))
        self.port = v
        
        return self

    def with_port(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`port`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`port` equals :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_port()` is :code:`True`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """

        if type(v) in [str, int, float, bool]:
            return self if self.port == v else None
        elif callable(v):
            return self if v(self.port) else None
        else:
            raise SwoopError("Illegal type passed to with_port")

    def without_port(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`port`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`port` is not equal to :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_port()` is :code:`False`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """
        
        if type(v) in [str, int, float, bool]:
            return self if self.port != v else None
        elif callable(v):
            return self if not v(self.port) else None
        else:
            raise SwoopError("Illegal type passed to without_port")



    ##### Lookup functions that return EFPs instead of just attribute values.
    
    def find_moduleinst(self):
        """Find the :class:`Moduleinst` object refered to by the :code:`moduleinst` attribute of this object.  This is like
        :meth:`get_moduleinst`, except it returns the :class:`Moduleinst` object instead of its name.
        
        :returns: The object
        :rtype: :class:`Moduleinst`

        """
        f = lambda efp, key: NotImplemented('Lookup of moduleinst from portref not implemented.')
        return f(self, self.moduleinst)
    def find_port(self):
        """Find the :class:`Port` object refered to by the :code:`port` attribute of this object.  This is like
        :meth:`get_port`, except it returns the :class:`Port` object instead of its name.
        
        :returns: The object
        :rtype: :class:`Port`

        """
        f = lambda efp, key: NotImplemented('Lookup of port from portref not implemented.')
        return f(self, self.port)
    


    
    ### Adder/getter/lookup for lists
    


    ### Add, lookup, and get for maps


    
    ### Getter/Setter for singletons.


    
    def get_children(self):
        """
        Get all the children of this :class:`EagleFilePart`.
        
        :rtype: List of :class:`EagleFilePart` objects
        """
        r = []




        return r

    def remove_child(self, efp):
        """
        Remove a child :class:`EagleFilePart` object.
        
        :param efp: the class:`EagleFilePart` object to remove.
        :return: Nothing
        """

    def _rekey_child(self, oldkey, efp):
        """
        Remove a child :class:`EagleFilePart` object.
        
        :param efp: the class:`EagleFilePart` object to remove.
        :return: Nothing
        """


    def __str__(self):
        r = "["+repr(self)+" "
        r = r + "moduleinst:" + str(self.get_moduleinst()) + " "
        r = r + "port:" + str(self.get_port()) + " "
        r = r + "]"
        return r
            
    def dump(self, indent="", increment="   "):
        """
        Recursive debug dump.
        
        :param indent:  Indentation string.  The output will be indented by this much.
        :param increment: This will be appendeded to :code:`indent` on recursive invocations.

        :rtype: :code:`None`
        """
        print(indent + str(self.__class__.__name__), end=' ')
        try:
            print(self.get_name())
        except:
            print()
            pass
        for c in self.get_children():
            c.dump(indent + "   ")

        
EagleFile.class_map["portref"] = Portref
         


class Module(EagleFilePart, DimensionGeometry):
    """
    Class representing the contents of a <module> tag in Eagle files.

    Attributes:

    * :code:`name`

    * :code:`prefix`

    * :code:`dx`

    * :code:`dy`



    Collections:

    * :code:`description`: Singleton :class:`Description` object. 


    * :code:`sheet`: List of :class:`Sheet` objects.


    * :code:`port`: Map of :class:`Port` objects indexed by their :code:`name`.


    * :code:`variantdef`: Map of :class:`Variantdef` objects indexed by their :code:`name`.


    * :code:`part`: Map of :class:`Part` objects indexed by their :code:`name`.



    """
    def __init__(self):
        """
        Construct an empty :class:`Module` object.
        """
        EagleFilePart.__init__(self)
        DimensionGeometry.__init__(self)
        
        self.name=None
        self.prefix=None
        self.dx=None
        self.dy=None
        self.sheets=[]
        self.ports={} #tecollections.OrderedDict()  For unclear reasons, this caused ordering to become more unpredictable, rather than less.
        self.variantdefs={} #tecollections.OrderedDict()  For unclear reasons, this caused ordering to become more unpredictable, rather than less.
        self.parts={} #tecollections.OrderedDict()  For unclear reasons, this caused ordering to become more unpredictable, rather than less.
        self.description=None


        
    @classmethod
    def _from_et(cls,root,parent):
        """
        Create a :class:`Module` from a :code:`module` element.
        
        :param root: The element tree tree to parse.
        :param parent: :class:`EagleFilePart` that should hold the resulting :class:`EagleFilePart`
        :rtype: :class:`Module`
        """
        ## Call the constructor
        n = cls()
        n._init_from_et(root,parent)
        return n

    def _get_error_name(self):
        if hasattr(self, "get_name"):
            return self.get_name();
        else:
            return "Module";
        
    def  _init_from_et(self, root, parent):
        """
        Initialized a :class:`Module` from a :code:`module` element.  This is useful if you have a subclass of :class:`Module` .
        
        :param root: The element tree tree to parse.
        :param parent: :class:`EagleFilePart` that will become the parent of :code:`this` .
        :rtype: :class:`Module`
        """
        try:
            self.root = root
            
            if root.tag != "module":
                raise EagleFormatError("Tried to create module from " + root.tag)

            self.name=parseByType(parent, "str", None, root.get("name"))
            self.prefix=parseByType(parent, "str", None, root.get("prefix"))
            self.dx=parseByType(parent, "float", None, root.get("dx"))
            self.dy=parseByType(parent, "float", None, root.get("dy"))

            self.parent = parent

            ### populate the maps by searching for elements that match xpath and generating objects for them.

            for c in root.xpath("./ports/port"):
                self.add_port(self.get_class_for_tag(c.tag)._from_et(c, self))
            for c in root.xpath("./variantdefs/variantdef"):
                self.add_variantdef(self.get_class_for_tag(c.tag)._from_et(c, self))
            for c in root.xpath("./parts/part"):
                self.add_part(self.get_class_for_tag(c.tag)._from_et(c, self))

            ### Do the same for the lists

            for c in root.xpath("./sheets/sheet"):
                self.add_sheet(self.get_class_for_tag(c.tag)._from_et(c,self))

            ### Do the same for the attr lists


            ### And the singletons

            x = root.xpath("./description")
            if len(x) is not 0:
                self.set_description(self.get_class_for_tag(x[0].tag)._from_et(x[0],self))

            ### And, finally, if the objects wants the text from the tag.

        except SwoopError as e:
            e.text = "{}:{}".format(self._get_error_name(), e.text)
            raise e


    def sortkey(self):
        r = ""
        r = r + str(self.name)
        r = r + str(self.prefix)
        r = r + str(self.dx)
        r = r + str(self.dy)
        return r

    def get_et(self):
        """
        Generate a <module> element tree for a :class:`Module`.
        
        :rtype:  :class:`ElementTree`.
        
        """
        try:
            r = ET.Element("module")

            ### Set the tag attributes 


            ## Unparse the values.

            v = unparseByType(self, "str", None,  self.name)

            ## For required attributes None becomes "".  For optional attributes, we just leave the attribute out.
            if not (isinstance(self.get_parent(), LibraryFile) and False):  # special case for the name of library.
                if v is not None:
                    r.set("name", v)
                else:
                    r.set("name", "")


            ## Unparse the values.

            v = unparseByType(self, "str", None,  self.prefix)

            ## For required attributes None becomes "".  For optional attributes, we just leave the attribute out.
            if not (isinstance(self.get_parent(), LibraryFile) and False):  # special case for the name of library.
                if v is not None:
                    r.set("prefix", v)


            ## Unparse the values.

            v = unparseByType(self, "float", None,  self.dx)

            ## For required attributes None becomes "".  For optional attributes, we just leave the attribute out.
            if not (isinstance(self.get_parent(), LibraryFile) and False):  # special case for the name of library.
                if v is not None:
                    r.set("dx", v)
                else:
                    r.set("dx", "")


            ## Unparse the values.

            v = unparseByType(self, "float", None,  self.dy)

            ## For required attributes None becomes "".  For optional attributes, we just leave the attribute out.
            if not (isinstance(self.get_parent(), LibraryFile) and False):  # special case for the name of library.
                if v is not None:
                    r.set("dy", v)
                else:
                    r.set("dy", "")


            ### process the sections in order.  They have to be in section order,
            ### because eagle files are order dependent.


            ## For some tags, Eagle generates empty tags when there's no contant
            ## rather than just leaving the tag out.  We mark these with
            ## Tag.requireTag in GenerateSwoop.py and force their generation
            ## here.

            smartAddSubTags(r, "./description")


            ## or add a singleton.

            if self.description is not None:
                target = smartAddSubTags(r, "./description")
                target.append(self.description.get_et())

            ## For some tags, Eagle generates empty tags when there's no contant
            ## rather than just leaving the tag out.  We mark these with
            ## Tag.requireTag in GenerateSwoop.py and force their generation
            ## here.

            smartAddSubTags(r, "./ports/port")


            ## add a map.

            if len(self.ports) is not 0:
                target = smartAddSubTags(r, "./ports/port")
                # add them in sorted order.  This gives us a simple canonicalization that makes it feasible to use diff to compare files.
                target.extend([i.get_et() for i in sorted(list(self.ports.values()),key=lambda x: x.sortkey())])


            ## For some tags, Eagle generates empty tags when there's no contant
            ## rather than just leaving the tag out.  We mark these with
            ## Tag.requireTag in GenerateSwoop.py and force their generation
            ## here.

            smartAddSubTags(r, "./variantdefs/variantdef")


            ## add a map.

            if len(self.variantdefs) is not 0:
                target = smartAddSubTags(r, "./variantdefs/variantdef")
                # add them in sorted order.  This gives us a simple canonicalization that makes it feasible to use diff to compare files.
                target.extend([i.get_et() for i in sorted(list(self.variantdefs.values()),key=lambda x: x.sortkey())])


            ## For some tags, Eagle generates empty tags when there's no contant
            ## rather than just leaving the tag out.  We mark these with
            ## Tag.requireTag in GenerateSwoop.py and force their generation
            ## here.

            smartAddSubTags(r, "./parts/part")


            ## add a map.

            if len(self.parts) is not 0:
                target = smartAddSubTags(r, "./parts/part")
                # add them in sorted order.  This gives us a simple canonicalization that makes it feasible to use diff to compare files.
                target.extend([i.get_et() for i in sorted(list(self.parts.values()),key=lambda x: x.sortkey())])


            ## For some tags, Eagle generates empty tags when there's no contant
            ## rather than just leaving the tag out.  We mark these with
            ## Tag.requireTag in GenerateSwoop.py and force their generation
            ## here.



            ## add a list.

            if len(self.sheets) is not 0:
                target = smartAddSubTags(r, "./sheets/sheet")
                # add them in sorted order.  This gives us a simple canonicalization that makes it feasible to use diff to compare files.
                target.extend([i.get_et() for i in sorted(self.sheets,key=lambda x: x.sortkey())])


            ## set the text, if its needed.

        except SwoopError as e:
            e.text = "{}:{}".format(self._get_error_name(), e.text)
            raise e
        return r

    def clone(self):
        """
        Recursively clone this :code:`Module`.  It will be identical to the original, but it's parent will be :code:`None`.
        
        :rtype: :class:`Module`
        """
        try:
            n = copy.copy(self)
            n.ports = {}
            for x in list(self.ports.values()):
                n.add_port(x.clone())
            n.variantdefs = {}
            for x in list(self.variantdefs.values()):
                n.add_variantdef(x.clone())
            n.parts = {}
            for x in list(self.parts.values()):
                n.add_part(x.clone())
            n.sheets = []
            for x in self.sheets:
                n.add_sheet(x.clone())
            n.description = None
            if self.description is not None:
                n.set_description(self.description.clone())
            else:
                n.set_description(None)
            n.parent = None
        except SwoopError as e:
            e.text = "{}:{}".format(self._get_error_name(), e.text)
            raise e
        return n

    def accept_preorder_visitor(self, visitor):
        try:
            pre = getattr(visitor, "Module_pre")
            return pre(self)
        except AttributeError:
            return visitor.default_pre(self)
        
    def accept_postorder_visitor(self, visitor, context):
        try:
            post = getattr(visitor, "Module_post")
            post(self,context)
        except AttributeError:
            visitor.default_post(self,context)

    def is_equal(self, other):
        """
        Check whether two :code:`EagleFilePart` objects are identical.
        
        :param other: Object to compare to.
        :returns: :code:`True` if they are identical, otherwise, :code:`False`
        """
        return self.get_xml() == other.get_xml()
        
    ### Getters/Setters for attribute values

    def get_name(self):
        """ Return the value of :code:`name` for this :class:`Module`.  This corresponds to the :code:`name` attribute of a :code:`<module>` in an Eagle file.
        
        :rtype: :code:`str`
        """
        return self.name

    def set_name(self,v):
        """ Set the value of :code:`name` for this  :class:`Module`.  This corresponds to the :code:`name` attribute of a :code:`<module>` in an Eagle file.

        :param v: new value
        :rtype: :code:`self`
        """
                        
        oldkey = self.name
        if not typeCheck("str", v, True):
            raise SwoopError("Illegal value ({}) of type {} for attribute 'name' of Module object (should be str).".format(v, type(v)))
        self.name = v
        
        if self.get_parent() is not None:
            self.get_parent()._rekey_child(oldkey, self);
        return self

    def with_name(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`name`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`name` equals :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_name()` is :code:`True`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """

        if type(v) in [str, int, float, bool]:
            return self if self.name == v else None
        elif callable(v):
            return self if v(self.name) else None
        else:
            raise SwoopError("Illegal type passed to with_name")

    def without_name(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`name`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`name` is not equal to :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_name()` is :code:`False`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """
        
        if type(v) in [str, int, float, bool]:
            return self if self.name != v else None
        elif callable(v):
            return self if not v(self.name) else None
        else:
            raise SwoopError("Illegal type passed to without_name")


    def get_prefix(self):
        """ Return the value of :code:`prefix` for this :class:`Module`.  This corresponds to the :code:`prefix` attribute of a :code:`<module>` in an Eagle file.
        
        :rtype: :code:`str`
        """
        return self.prefix

    def set_prefix(self,v):
        """ Set the value of :code:`prefix` for this  :class:`Module`.  This corresponds to the :code:`prefix` attribute of a :code:`<module>` in an Eagle file.

        :param v: new value
        :rtype: :code:`self`
        """
                        
        if not typeCheck("str", v, False):
            raise SwoopError("Illegal value ({}) of type {} for attribute 'prefix' of Module object (should be str).".format(v, type(v)))
        self.prefix = v
        
        return self

    def with_prefix(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`prefix`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`prefix` equals :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_prefix()` is :code:`True`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """

        if type(v) in [str, int, float, bool]:
            return self if self.prefix == v else None
        elif callable(v):
            return self if v(self.prefix) else None
        else:
            raise SwoopError("Illegal type passed to with_prefix")

    def without_prefix(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`prefix`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`prefix` is not equal to :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_prefix()` is :code:`False`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """
        
        if type(v) in [str, int, float, bool]:
            return self if self.prefix != v else None
        elif callable(v):
            return self if not v(self.prefix) else None
        else:
            raise SwoopError("Illegal type passed to without_prefix")


    def get_dx(self):
        """ Return the value of :code:`dx` for this :class:`Module`.  This corresponds to the :code:`dx` attribute of a :code:`<module>` in an Eagle file.
        
        :rtype: :code:`float`
        """
        return self.dx

    def set_dx(self,v):
        """ Set the value of :code:`dx` for this  :class:`Module`.  This corresponds to the :code:`dx` attribute of a :code:`<module>` in an Eagle file.

        :param v: new value
        :rtype: :code:`self`
        """
                        
        if not typeCheck("float", v, True):
            raise SwoopError("Illegal value ({}) of type {} for attribute 'dx' of Module object (should be float).".format(v, type(v)))
        self.dx = v
        
        return self

    def with_dx(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`dx`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`dx` equals :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_dx()` is :code:`True`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """

        if type(v) in [str, int, float, bool]:
            return self if self.dx == v else None
        elif callable(v):
            return self if v(self.dx) else None
        else:
            raise SwoopError("Illegal type passed to with_dx")

    def without_dx(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`dx`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`dx` is not equal to :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_dx()` is :code:`False`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """
        
        if type(v) in [str, int, float, bool]:
            return self if self.dx != v else None
        elif callable(v):
            return self if not v(self.dx) else None
        else:
            raise SwoopError("Illegal type passed to without_dx")


    def get_dy(self):
        """ Return the value of :code:`dy` for this :class:`Module`.  This corresponds to the :code:`dy` attribute of a :code:`<module>` in an Eagle file.
        
        :rtype: :code:`float`
        """
        return self.dy

    def set_dy(self,v):
        """ Set the value of :code:`dy` for this  :class:`Module`.  This corresponds to the :code:`dy` attribute of a :code:`<module>` in an Eagle file.

        :param v: new value
        :rtype: :code:`self`
        """
                        
        if not typeCheck("float", v, True):
            raise SwoopError("Illegal value ({}) of type {} for attribute 'dy' of Module object (should be float).".format(v, type(v)))
        self.dy = v
        
        return self

    def with_dy(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`dy`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`dy` equals :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_dy()` is :code:`True`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """

        if type(v) in [str, int, float, bool]:
            return self if self.dy == v else None
        elif callable(v):
            return self if v(self.dy) else None
        else:
            raise SwoopError("Illegal type passed to with_dy")

    def without_dy(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`dy`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`dy` is not equal to :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_dy()` is :code:`False`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """
        
        if type(v) in [str, int, float, bool]:
            return self if self.dy != v else None
        elif callable(v):
            return self if not v(self.dy) else None
        else:
            raise SwoopError("Illegal type passed to without_dy")



    ##### Lookup functions that return EFPs instead of just attribute values.
    
    


    
    ### Adder/getter/lookup for lists
    
    def add_sheet(self, s):
        """ Add a :class:`Sheet` to the :code:`sheets` of this :class:`Module`.

        :param s: The :class:`Sheet` to add.
        :rtype: :code:`self`
        """
        if not any([
                isinstance(s, Sheet),
            ]):
            raise SwoopError("Argument to Module.add_sheet() should be of type Sheet.  Got " + str(type(s).__name__) + ".")
        
        self.sheets.append(s)
        if s.parent is not None and s.parent is not self:
            s.parent.remove_sheet(s)

        s.parent = self
        return self

    def get_nth_sheet(self, n):
        """ get then nth :class:`Sheet` object from the :code:`sheets` of this :class:`Module`.
        
        :param n: Index of the item to return.

        :rtype: :class:`Sheet` object
        """
        return self.sheets[n]

    def get_sheets(self, attrs=None, type=None):
        """Return (and possibly filter) items in the the :code:`sheets` list of :class:`Sheet` objects for this :class:`Module`.
        
        This functions provides a mechanism for filtering the items as well.
        The keys in :code:`attrs` are taken as attributes names and the
        values are requested values.  Items in the list that have all the
        requested values for the corresponding attributes will be returned.  

        A if :code:`type` is not :code:`None`, the item will match if it is an
        instance of the type provided.
        
        :param attrs: A set of key-value pairs that represent a filter to apply to the item's attributes.
        :param type:  A type to filter on.  Only items that are an instance of this type will be returned.
        :returns: A List of :class:`Sheet` objects
        :rtype: List of :class:`Sheet` objects
        """
        if attrs is not None or type is not None:
            raise NotImplementedError("filtered get not implemented.")
        return self.sheets

    def clear_sheets(self):
        """
        Remove all the :class:`Sheet` objects from the :code:`sheets` of this :class:`Module`.
        
        :rtype: :code:`self`
        """
        for efp in self.sheets:
            efp.parent = None
        self.sheets = []
        return self

    def remove_sheet(self, efp):
        """
        Remove a :class:`Sheet` from the :code:`sheets` of this :class:`Module`.
        
        :param efp: The :class:`Sheet` object to remove.

        :rtype: :code:`self`
        """
        self.sheets = [x for x in self.sheets if x != efp]

        if efp.parent is self:
            efp.parent = None
        return self



    ### Add, lookup, and get for maps
    def add_port(self, s):
        """ Add a :class:`Port` to the :code:`ports` of this :class:`Module`.

        :param s: The :class:`Port` to add.
        :rtype: :code:`self`
        """
        if not any([
                isinstance(s, Port),
            ]):
            raise SwoopError("Argument to Module.add_port() should be of type Port.  Got " + str(type(s).__name__) + ".")
        

        self.ports[s.get_name()] = s

        s.parent = self
        return self

    def get_nth_port(self, n):
        """ get then nth :class:`Port` object from the :code:`ports` of this :class:`Module`.
        
        :param n: Index of the item to return.

        :rtype: :class:`Port` object
        """
        return list(self.ports.values())[n]

    def get_port(self, key):
        """ Lookup and return a :class:`Port` from the :code:`ports` of  this :class:`Module`.
        
        :param key: A :code:`str` to use for the lookup.  The lookup uses the :code:`name` of the :class:`Port` objects.

        :rtype: A :class:`Port` object or :code:`None`, if there is no such item.
        """
        return self.ports.get(key)


    def get_ports(self, attrs=None, type=None):
        """Return (and possibly filter) items in the the :code:`ports` map of :class:`Port` objects for this :class:`Module`.
        
        This functions provides a mechanism for filtering the items as well.
        The keys in :code:`attrs` are taken as attributes names and the
        values are requested values.  Items in the list that have all the
        requested values for the corresponding attributes will be returned.  

        A if :code:`type` is not :code:`None`, the item will match if it is an
        instance of the type provided.
        
        :param attrs: A set of key-value pairs that represent a filter to apply to the item's attributes.
        :param type:  A type to filter on.  Only items that are an instance of this type will be returned.
        :returns: A List of :class:`Port` objects
        :rtype: List of :class:`Port` objects
        """
        if attrs is not None or type is not None:
            raise NotImplementedError("filtered get not implemented")
        return list(self.ports.values())
        

    def clear_ports(self):
        """
        Remove all the :class:`Port` objects from the :code:`ports` of this :class:`Module`.
        
        :rtype: :code:`self`
        """
        for efp in list(self.ports.values()):
            efp.parent = None
        self.ports = {}
        return self

    def remove_port(self, efp):
        """
        Remove a :class:`Port` from the :code:`ports` of this :class:`Module`.
        
        :param efp: The :class:`Port` object to remove.

        :rtype: :code:`self`
        """
        if self.ports[efp.get_name()] == efp:
            del self.ports[efp.get_name()]
            efp.parent = None
            return self
        else:
            raise SwoopError("Tried to use remove_port() to delete the wrong kind of child?: {}".format(str(efp)))
    
    def add_variantdef(self, s):
        """ Add a :class:`Variantdef` to the :code:`variantdefs` of this :class:`Module`.

        :param s: The :class:`Variantdef` to add.
        :rtype: :code:`self`
        """
        if not any([
                isinstance(s, Variantdef),
            ]):
            raise SwoopError("Argument to Module.add_variantdef() should be of type Variantdef.  Got " + str(type(s).__name__) + ".")
        

        self.variantdefs[s.get_name()] = s

        s.parent = self
        return self

    def get_nth_variantdef(self, n):
        """ get then nth :class:`Variantdef` object from the :code:`variantdefs` of this :class:`Module`.
        
        :param n: Index of the item to return.

        :rtype: :class:`Variantdef` object
        """
        return list(self.variantdefs.values())[n]

    def get_variantdef(self, key):
        """ Lookup and return a :class:`Variantdef` from the :code:`variantdefs` of  this :class:`Module`.
        
        :param key: A :code:`str` to use for the lookup.  The lookup uses the :code:`name` of the :class:`Variantdef` objects.

        :rtype: A :class:`Variantdef` object or :code:`None`, if there is no such item.
        """
        return self.variantdefs.get(key)


    def get_variantdefs(self, attrs=None, type=None):
        """Return (and possibly filter) items in the the :code:`variantdefs` map of :class:`Variantdef` objects for this :class:`Module`.
        
        This functions provides a mechanism for filtering the items as well.
        The keys in :code:`attrs` are taken as attributes names and the
        values are requested values.  Items in the list that have all the
        requested values for the corresponding attributes will be returned.  

        A if :code:`type` is not :code:`None`, the item will match if it is an
        instance of the type provided.
        
        :param attrs: A set of key-value pairs that represent a filter to apply to the item's attributes.
        :param type:  A type to filter on.  Only items that are an instance of this type will be returned.
        :returns: A List of :class:`Variantdef` objects
        :rtype: List of :class:`Variantdef` objects
        """
        if attrs is not None or type is not None:
            raise NotImplementedError("filtered get not implemented")
        return list(self.variantdefs.values())
        

    def clear_variantdefs(self):
        """
        Remove all the :class:`Variantdef` objects from the :code:`variantdefs` of this :class:`Module`.
        
        :rtype: :code:`self`
        """
        for efp in list(self.variantdefs.values()):
            efp.parent = None
        self.variantdefs = {}
        return self

    def remove_variantdef(self, efp):
        """
        Remove a :class:`Variantdef` from the :code:`variantdefs` of this :class:`Module`.
        
        :param efp: The :class:`Variantdef` object to remove.

        :rtype: :code:`self`
        """
        if self.variantdefs[efp.get_name()] == efp:
            del self.variantdefs[efp.get_name()]
            efp.parent = None
            return self
        else:
            raise SwoopError("Tried to use remove_variantdef() to delete the wrong kind of child?: {}".format(str(efp)))
    
    def add_part(self, s):
        """ Add a :class:`Part` to the :code:`parts` of this :class:`Module`.

        :param s: The :class:`Part` to add.
        :rtype: :code:`self`
        """
        if not any([
                isinstance(s, Part),
            ]):
            raise SwoopError("Argument to Module.add_part() should be of type Part.  Got " + str(type(s).__name__) + ".")
        

        self.parts[s.get_name()] = s

        s.parent = self
        return self

    def get_nth_part(self, n):
        """ get then nth :class:`Part` object from the :code:`parts` of this :class:`Module`.
        
        :param n: Index of the item to return.

        :rtype: :class:`Part` object
        """
        return list(self.parts.values())[n]

    def get_part(self, key):
        """ Lookup and return a :class:`Part` from the :code:`parts` of  this :class:`Module`.
        
        :param key: A :code:`str` to use for the lookup.  The lookup uses the :code:`name` of the :class:`Part` objects.

        :rtype: A :class:`Part` object or :code:`None`, if there is no such item.
        """
        return self.parts.get(key)


    def get_parts(self, attrs=None, type=None):
        """Return (and possibly filter) items in the the :code:`parts` map of :class:`Part` objects for this :class:`Module`.
        
        This functions provides a mechanism for filtering the items as well.
        The keys in :code:`attrs` are taken as attributes names and the
        values are requested values.  Items in the list that have all the
        requested values for the corresponding attributes will be returned.  

        A if :code:`type` is not :code:`None`, the item will match if it is an
        instance of the type provided.
        
        :param attrs: A set of key-value pairs that represent a filter to apply to the item's attributes.
        :param type:  A type to filter on.  Only items that are an instance of this type will be returned.
        :returns: A List of :class:`Part` objects
        :rtype: List of :class:`Part` objects
        """
        if attrs is not None or type is not None:
            raise NotImplementedError("filtered get not implemented")
        return list(self.parts.values())
        

    def clear_parts(self):
        """
        Remove all the :class:`Part` objects from the :code:`parts` of this :class:`Module`.
        
        :rtype: :code:`self`
        """
        for efp in list(self.parts.values()):
            efp.parent = None
        self.parts = {}
        return self

    def remove_part(self, efp):
        """
        Remove a :class:`Part` from the :code:`parts` of this :class:`Module`.
        
        :param efp: The :class:`Part` object to remove.

        :rtype: :code:`self`
        """
        if self.parts[efp.get_name()] == efp:
            del self.parts[efp.get_name()]
            efp.parent = None
            return self
        else:
            raise SwoopError("Tried to use remove_part() to delete the wrong kind of child?: {}".format(str(efp)))
    


    
    ### Getter/Setter for singletons.

    def set_description(self, s):
        """ Set the :class:`Description` for this  :class:`Module`.

        :param s: :class:`Description` to set.
        :rtype: :code:`self`
        """
        if self.description is not None:
            self.description.parent = None
        self.description = s
        if s is not None:
            s.parent = self
        return self

    def get_description(self):
        """ Get the description from this :class:`Module`.
        
        :rtype: :class:`Description` object
        """
        return self.description


    
    def get_children(self):
        """
        Get all the children of this :class:`EagleFilePart`.
        
        :rtype: List of :class:`EagleFilePart` objects
        """
        r = []

        r = r + self.sheets

        r = r + list(self.ports.values())
        r = r + list(self.variantdefs.values())
        r = r + list(self.parts.values())

        if self.description is not None:
            r = r + [self.description]

        return r

    def remove_child(self, efp):
        """
        Remove a child :class:`EagleFilePart` object.
        
        :param efp: the class:`EagleFilePart` object to remove.
        :return: Nothing
        """
        try:
            self.remove_port(efp)
        except:
            pass
        try:
            self.remove_variantdef(efp)
        except:
            pass
        try:
            self.remove_part(efp)
        except:
            pass
        try:
            self.remove_sheet(efp)
        except:
            pass
        if self.get_description() == efp:
            self.set_description(None)

    def _rekey_child(self, oldkey, efp):
        """
        Remove a child :class:`EagleFilePart` object.
        
        :param efp: the class:`EagleFilePart` object to remove.
        :return: Nothing
        """
        try:
            if self.get_port(oldkey) == efp:
                del self.ports[oldkey]
                self.add_port(efp)
        except SwoopError:
            pass
        try:
            if self.get_variantdef(oldkey) == efp:
                del self.variantdefs[oldkey]
                self.add_variantdef(efp)
        except SwoopError:
            pass
        try:
            if self.get_part(oldkey) == efp:
                del self.parts[oldkey]
                self.add_part(efp)
        except SwoopError:
            pass

    def check_sanity(self, visited_efps = None):
        EagleFilePart.check_sanity(self, visited_efps)

        # Check whether keys in our maps match the keys in our children
        for k in self.ports:
            if self.ports[k].get_name() != k:
                raise SwoopError("Child's name ('{}') doesn't match key in parent's map ('{}')".format(self.ports[k].get_name(),k))
        for k in self.variantdefs:
            if self.variantdefs[k].get_name() != k:
                raise SwoopError("Child's name ('{}') doesn't match key in parent's map ('{}')".format(self.variantdefs[k].get_name(),k))
        for k in self.parts:
            if self.parts[k].get_name() != k:
                raise SwoopError("Child's name ('{}') doesn't match key in parent's map ('{}')".format(self.parts[k].get_name(),k))

    def __str__(self):
        r = "["+repr(self)+" "
        r = r + "name:" + str(self.get_name()) + " "
        r = r + "prefix:" + str(self.get_prefix()) + " "
        r = r + "dx:" + str(self.get_dx()) + " "
        r = r + "dy:" + str(self.get_dy()) + " "
        r = r + "]"
        return r
            
    def dump(self, indent="", increment="   "):
        """
        Recursive debug dump.
        
        :param indent:  Indentation string.  The output will be indented by this much.
        :param increment: This will be appendeded to :code:`indent` on recursive invocations.

        :rtype: :code:`None`
        """
        print(indent + str(self.__class__.__name__), end=' ')
        try:
            print(self.get_name())
        except:
            print()
            pass
        for c in self.get_children():
            c.dump(indent + "   ")

        
EagleFile.class_map["module"] = Module
         


class Package3d(EagleFilePart):
    """
    Class representing the contents of a <package3d> tag in Eagle files.

    Attributes:

    * :code:`name`

    * :code:`urn`

    * :code:`type`

    * :code:`locally_modified`

    * :code:`library_version`

    * :code:`library_locally_modified`



    Collections:

    * :code:`description`: Singleton :class:`Description` object. 


    * :code:`packageinstance`: List of :class:`Packageinstance` objects.



    """
    def __init__(self):
        """
        Construct an empty :class:`Package3d` object.
        """
        EagleFilePart.__init__(self)
        
        self.name=None
        self.urn=None
        self.type=None
        self.locally_modified=None
        self.library_version=None
        self.library_locally_modified=None
        self.packageinstances=[]
        self.description=None


        
    @classmethod
    def _from_et(cls,root,parent):
        """
        Create a :class:`Package3d` from a :code:`package3d` element.
        
        :param root: The element tree tree to parse.
        :param parent: :class:`EagleFilePart` that should hold the resulting :class:`EagleFilePart`
        :rtype: :class:`Package3d`
        """
        ## Call the constructor
        n = cls()
        n._init_from_et(root,parent)
        return n

    def _get_error_name(self):
        if hasattr(self, "get_name"):
            return self.get_name();
        else:
            return "Package3d";
        
    def  _init_from_et(self, root, parent):
        """
        Initialized a :class:`Package3d` from a :code:`package3d` element.  This is useful if you have a subclass of :class:`Package3d` .
        
        :param root: The element tree tree to parse.
        :param parent: :class:`EagleFilePart` that will become the parent of :code:`this` .
        :rtype: :class:`Package3d`
        """
        try:
            self.root = root
            
            if root.tag != "package3d":
                raise EagleFormatError("Tried to create package3d from " + root.tag)

            self.name=parseByType(parent, "str", None, root.get("name"))
            self.urn=parseByType(parent, "str", None, root.get("urn"))
            self.type=parseByType(parent, "str", None, root.get("type"))
            self.locally_modified=parseByType(parent, "bool", 'no', root.get("locally_modified"))
            self.library_version=parseByType(parent, "int", None, root.get("library_version"))
            self.library_locally_modified=parseByType(parent, "bool", 'no', root.get("library_locally_modified"))

            self.parent = parent

            ### populate the maps by searching for elements that match xpath and generating objects for them.


            ### Do the same for the lists

            for c in root.xpath("./packageinstances/packageinstance"):
                self.add_packageinstance(self.get_class_for_tag(c.tag)._from_et(c,self))

            ### Do the same for the attr lists


            ### And the singletons

            x = root.xpath("./description")
            if len(x) is not 0:
                self.set_description(self.get_class_for_tag(x[0].tag)._from_et(x[0],self))

            ### And, finally, if the objects wants the text from the tag.

        except SwoopError as e:
            e.text = "{}:{}".format(self._get_error_name(), e.text)
            raise e


    def sortkey(self):
        r = ""
        r = r + str(self.name)
        r = r + str(self.urn)
        r = r + str(self.type)
        r = r + str(self.locally_modified)
        r = r + str(self.library_version)
        r = r + str(self.library_locally_modified)
        return r

    def get_et(self):
        """
        Generate a <package3d> element tree for a :class:`Package3d`.
        
        :rtype:  :class:`ElementTree`.
        
        """
        try:
            r = ET.Element("package3d")

            ### Set the tag attributes 


            ## Unparse the values.

            v = unparseByType(self, "str", None,  self.name)

            ## For required attributes None becomes "".  For optional attributes, we just leave the attribute out.
            if not (isinstance(self.get_parent(), LibraryFile) and False):  # special case for the name of library.
                if v is not None:
                    r.set("name", v)
                else:
                    r.set("name", "")


            ## Unparse the values.

            v = unparseByType(self, "str", None,  self.urn)

            ## For required attributes None becomes "".  For optional attributes, we just leave the attribute out.
            if not (isinstance(self.get_parent(), LibraryFile) and False):  # special case for the name of library.
                if v is not None:
                    r.set("urn", v)


            ## Unparse the values.

            v = unparseByType(self, "str", None,  self.type)

            ## For required attributes None becomes "".  For optional attributes, we just leave the attribute out.
            if not (isinstance(self.get_parent(), LibraryFile) and False):  # special case for the name of library.
                if v is not None:
                    r.set("type", v)
                else:
                    r.set("type", "")


            ## Unparse the values.

            v = unparseByType(self, "bool", 'no',  self.locally_modified)

            ## For required attributes None becomes "".  For optional attributes, we just leave the attribute out.
            if not (isinstance(self.get_parent(), LibraryFile) and False):  # special case for the name of library.
                if v is not None:
                    r.set("locally_modified", v)


            ## Unparse the values.

            v = unparseByType(self, "int", None,  self.library_version)

            ## For required attributes None becomes "".  For optional attributes, we just leave the attribute out.
            if not (isinstance(self.get_parent(), LibraryFile) and False):  # special case for the name of library.
                if v is not None:
                    r.set("library_version", v)


            ## Unparse the values.

            v = unparseByType(self, "bool", 'no',  self.library_locally_modified)

            ## For required attributes None becomes "".  For optional attributes, we just leave the attribute out.
            if not (isinstance(self.get_parent(), LibraryFile) and False):  # special case for the name of library.
                if v is not None:
                    r.set("library_locally_modified", v)


            ### process the sections in order.  They have to be in section order,
            ### because eagle files are order dependent.


            ## For some tags, Eagle generates empty tags when there's no contant
            ## rather than just leaving the tag out.  We mark these with
            ## Tag.requireTag in GenerateSwoop.py and force their generation
            ## here.

            smartAddSubTags(r, "./description")


            ## or add a singleton.

            if self.description is not None:
                target = smartAddSubTags(r, "./description")
                target.append(self.description.get_et())

            ## For some tags, Eagle generates empty tags when there's no contant
            ## rather than just leaving the tag out.  We mark these with
            ## Tag.requireTag in GenerateSwoop.py and force their generation
            ## here.



            ## add a list.

            if len(self.packageinstances) is not 0:
                target = smartAddSubTags(r, "./packageinstances/packageinstance")
                # add them in sorted order.  This gives us a simple canonicalization that makes it feasible to use diff to compare files.
                target.extend([i.get_et() for i in sorted(self.packageinstances,key=lambda x: x.sortkey())])


            ## set the text, if its needed.

        except SwoopError as e:
            e.text = "{}:{}".format(self._get_error_name(), e.text)
            raise e
        return r

    def clone(self):
        """
        Recursively clone this :code:`Package3d`.  It will be identical to the original, but it's parent will be :code:`None`.
        
        :rtype: :class:`Package3d`
        """
        try:
            n = copy.copy(self)
            n.packageinstances = []
            for x in self.packageinstances:
                n.add_packageinstance(x.clone())
            n.description = None
            if self.description is not None:
                n.set_description(self.description.clone())
            else:
                n.set_description(None)
            n.parent = None
        except SwoopError as e:
            e.text = "{}:{}".format(self._get_error_name(), e.text)
            raise e
        return n

    def accept_preorder_visitor(self, visitor):
        try:
            pre = getattr(visitor, "Package3d_pre")
            return pre(self)
        except AttributeError:
            return visitor.default_pre(self)
        
    def accept_postorder_visitor(self, visitor, context):
        try:
            post = getattr(visitor, "Package3d_post")
            post(self,context)
        except AttributeError:
            visitor.default_post(self,context)

    def is_equal(self, other):
        """
        Check whether two :code:`EagleFilePart` objects are identical.
        
        :param other: Object to compare to.
        :returns: :code:`True` if they are identical, otherwise, :code:`False`
        """
        return self.get_xml() == other.get_xml()
        
    ### Getters/Setters for attribute values

    def get_name(self):
        """ Return the value of :code:`name` for this :class:`Package3d`.  This corresponds to the :code:`name` attribute of a :code:`<package3d>` in an Eagle file.
        
        :rtype: :code:`str`
        """
        return self.name

    def set_name(self,v):
        """ Set the value of :code:`name` for this  :class:`Package3d`.  This corresponds to the :code:`name` attribute of a :code:`<package3d>` in an Eagle file.

        :param v: new value
        :rtype: :code:`self`
        """
                        
        oldkey = self.name
        if not typeCheck("str", v, True):
            raise SwoopError("Illegal value ({}) of type {} for attribute 'name' of Package3d object (should be str).".format(v, type(v)))
        self.name = v
        
        if self.get_parent() is not None:
            self.get_parent()._rekey_child(oldkey, self);
        return self

    def with_name(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`name`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`name` equals :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_name()` is :code:`True`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """

        if type(v) in [str, int, float, bool]:
            return self if self.name == v else None
        elif callable(v):
            return self if v(self.name) else None
        else:
            raise SwoopError("Illegal type passed to with_name")

    def without_name(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`name`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`name` is not equal to :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_name()` is :code:`False`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """
        
        if type(v) in [str, int, float, bool]:
            return self if self.name != v else None
        elif callable(v):
            return self if not v(self.name) else None
        else:
            raise SwoopError("Illegal type passed to without_name")


    def get_urn(self):
        """ Return the value of :code:`urn` for this :class:`Package3d`.  This corresponds to the :code:`urn` attribute of a :code:`<package3d>` in an Eagle file.
        
        :rtype: :code:`str`
        """
        return self.urn

    def set_urn(self,v):
        """ Set the value of :code:`urn` for this  :class:`Package3d`.  This corresponds to the :code:`urn` attribute of a :code:`<package3d>` in an Eagle file.

        :param v: new value
        :rtype: :code:`self`
        """
                        
        if not typeCheck("str", v, False):
            raise SwoopError("Illegal value ({}) of type {} for attribute 'urn' of Package3d object (should be str).".format(v, type(v)))
        self.urn = v
        
        return self

    def with_urn(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`urn`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`urn` equals :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_urn()` is :code:`True`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """

        if type(v) in [str, int, float, bool]:
            return self if self.urn == v else None
        elif callable(v):
            return self if v(self.urn) else None
        else:
            raise SwoopError("Illegal type passed to with_urn")

    def without_urn(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`urn`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`urn` is not equal to :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_urn()` is :code:`False`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """
        
        if type(v) in [str, int, float, bool]:
            return self if self.urn != v else None
        elif callable(v):
            return self if not v(self.urn) else None
        else:
            raise SwoopError("Illegal type passed to without_urn")


    def get_type(self):
        """ Return the value of :code:`type` for this :class:`Package3d`.  This corresponds to the :code:`type` attribute of a :code:`<package3d>` in an Eagle file.
        
        :rtype: :code:`str`
        """
        return self.type

    def set_type(self,v):
        """ Set the value of :code:`type` for this  :class:`Package3d`.  This corresponds to the :code:`type` attribute of a :code:`<package3d>` in an Eagle file.

        :param v: new value
        :rtype: :code:`self`
        """
                        
        if not typeCheck("str", v, True):
            raise SwoopError("Illegal value ({}) of type {} for attribute 'type' of Package3d object (should be str).".format(v, type(v)))
        self.type = v
        
        return self

    def with_type(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`type`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`type` equals :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_type()` is :code:`True`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """

        if type(v) in [str, int, float, bool]:
            return self if self.type == v else None
        elif callable(v):
            return self if v(self.type) else None
        else:
            raise SwoopError("Illegal type passed to with_type")

    def without_type(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`type`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`type` is not equal to :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_type()` is :code:`False`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """
        
        if type(v) in [str, int, float, bool]:
            return self if self.type != v else None
        elif callable(v):
            return self if not v(self.type) else None
        else:
            raise SwoopError("Illegal type passed to without_type")


    def get_locally_modified(self):
        """ Return the value of :code:`locally_modified` for this :class:`Package3d`.  This corresponds to the :code:`locally_modified` attribute of a :code:`<package3d>` in an Eagle file.
        
        :rtype: :code:`bool`
        """
        return self.locally_modified

    def set_locally_modified(self,v):
        """ Set the value of :code:`locally_modified` for this  :class:`Package3d`.  This corresponds to the :code:`locally_modified` attribute of a :code:`<package3d>` in an Eagle file.

        :param v: new value
        :rtype: :code:`self`
        """
                        
        if not typeCheck("bool", v, False):
            raise SwoopError("Illegal value ({}) of type {} for attribute 'locally_modified' of Package3d object (should be bool).".format(v, type(v)))
        self.locally_modified = v
        
        return self

    def with_locally_modified(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`locally_modified`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`locally_modified` equals :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_locally_modified()` is :code:`True`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """

        if type(v) in [str, int, float, bool]:
            return self if self.locally_modified == v else None
        elif callable(v):
            return self if v(self.locally_modified) else None
        else:
            raise SwoopError("Illegal type passed to with_locally_modified")

    def without_locally_modified(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`locally_modified`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`locally_modified` is not equal to :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_locally_modified()` is :code:`False`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """
        
        if type(v) in [str, int, float, bool]:
            return self if self.locally_modified != v else None
        elif callable(v):
            return self if not v(self.locally_modified) else None
        else:
            raise SwoopError("Illegal type passed to without_locally_modified")


    def get_library_version(self):
        """ Return the value of :code:`library_version` for this :class:`Package3d`.  This corresponds to the :code:`library_version` attribute of a :code:`<package3d>` in an Eagle file.
        
        :rtype: :code:`int`
        """
        return self.library_version

    def set_library_version(self,v):
        """ Set the value of :code:`library_version` for this  :class:`Package3d`.  This corresponds to the :code:`library_version` attribute of a :code:`<package3d>` in an Eagle file.

        :param v: new value
        :rtype: :code:`self`
        """
                        
        if not typeCheck("int", v, False):
            raise SwoopError("Illegal value ({}) of type {} for attribute 'library_version' of Package3d object (should be int).".format(v, type(v)))
        self.library_version = v
        
        return self

    def with_library_version(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`library_version`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`library_version` equals :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_library_version()` is :code:`True`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """

        if type(v) in [str, int, float, bool]:
            return self if self.library_version == v else None
        elif callable(v):
            return self if v(self.library_version) else None
        else:
            raise SwoopError("Illegal type passed to with_library_version")

    def without_library_version(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`library_version`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`library_version` is not equal to :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_library_version()` is :code:`False`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """
        
        if type(v) in [str, int, float, bool]:
            return self if self.library_version != v else None
        elif callable(v):
            return self if not v(self.library_version) else None
        else:
            raise SwoopError("Illegal type passed to without_library_version")


    def get_library_locally_modified(self):
        """ Return the value of :code:`library_locally_modified` for this :class:`Package3d`.  This corresponds to the :code:`library_locally_modified` attribute of a :code:`<package3d>` in an Eagle file.
        
        :rtype: :code:`bool`
        """
        return self.library_locally_modified

    def set_library_locally_modified(self,v):
        """ Set the value of :code:`library_locally_modified` for this  :class:`Package3d`.  This corresponds to the :code:`library_locally_modified` attribute of a :code:`<package3d>` in an Eagle file.

        :param v: new value
        :rtype: :code:`self`
        """
                        
        if not typeCheck("bool", v, False):
            raise SwoopError("Illegal value ({}) of type {} for attribute 'library_locally_modified' of Package3d object (should be bool).".format(v, type(v)))
        self.library_locally_modified = v
        
        return self

    def with_library_locally_modified(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`library_locally_modified`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`library_locally_modified` equals :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_library_locally_modified()` is :code:`True`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """

        if type(v) in [str, int, float, bool]:
            return self if self.library_locally_modified == v else None
        elif callable(v):
            return self if v(self.library_locally_modified) else None
        else:
            raise SwoopError("Illegal type passed to with_library_locally_modified")

    def without_library_locally_modified(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`library_locally_modified`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`library_locally_modified` is not equal to :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_library_locally_modified()` is :code:`False`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """
        
        if type(v) in [str, int, float, bool]:
            return self if self.library_locally_modified != v else None
        elif callable(v):
            return self if not v(self.library_locally_modified) else None
        else:
            raise SwoopError("Illegal type passed to without_library_locally_modified")



    ##### Lookup functions that return EFPs instead of just attribute values.
    
    


    
    ### Adder/getter/lookup for lists
    
    def add_packageinstance(self, s):
        """ Add a :class:`Packageinstance` to the :code:`packageinstances` of this :class:`Package3d`.

        :param s: The :class:`Packageinstance` to add.
        :rtype: :code:`self`
        """
        if not any([
                isinstance(s, Packageinstance),
            ]):
            raise SwoopError("Argument to Package3d.add_packageinstance() should be of type Packageinstance.  Got " + str(type(s).__name__) + ".")
        
        self.packageinstances.append(s)
        if s.parent is not None and s.parent is not self:
            s.parent.remove_packageinstance(s)

        s.parent = self
        return self

    def get_nth_packageinstance(self, n):
        """ get then nth :class:`Packageinstance` object from the :code:`packageinstances` of this :class:`Package3d`.
        
        :param n: Index of the item to return.

        :rtype: :class:`Packageinstance` object
        """
        return self.packageinstances[n]

    def get_packageinstances(self, attrs=None, type=None):
        """Return (and possibly filter) items in the the :code:`packageinstances` list of :class:`Packageinstance` objects for this :class:`Package3d`.
        
        This functions provides a mechanism for filtering the items as well.
        The keys in :code:`attrs` are taken as attributes names and the
        values are requested values.  Items in the list that have all the
        requested values for the corresponding attributes will be returned.  

        A if :code:`type` is not :code:`None`, the item will match if it is an
        instance of the type provided.
        
        :param attrs: A set of key-value pairs that represent a filter to apply to the item's attributes.
        :param type:  A type to filter on.  Only items that are an instance of this type will be returned.
        :returns: A List of :class:`Packageinstance` objects
        :rtype: List of :class:`Packageinstance` objects
        """
        if attrs is not None or type is not None:
            raise NotImplementedError("filtered get not implemented.")
        return self.packageinstances

    def clear_packageinstances(self):
        """
        Remove all the :class:`Packageinstance` objects from the :code:`packageinstances` of this :class:`Package3d`.
        
        :rtype: :code:`self`
        """
        for efp in self.packageinstances:
            efp.parent = None
        self.packageinstances = []
        return self

    def remove_packageinstance(self, efp):
        """
        Remove a :class:`Packageinstance` from the :code:`packageinstances` of this :class:`Package3d`.
        
        :param efp: The :class:`Packageinstance` object to remove.

        :rtype: :code:`self`
        """
        self.packageinstances = [x for x in self.packageinstances if x != efp]

        if efp.parent is self:
            efp.parent = None
        return self



    ### Add, lookup, and get for maps


    
    ### Getter/Setter for singletons.

    def set_description(self, s):
        """ Set the :class:`Description` for this  :class:`Package3d`.

        :param s: :class:`Description` to set.
        :rtype: :code:`self`
        """
        if self.description is not None:
            self.description.parent = None
        self.description = s
        if s is not None:
            s.parent = self
        return self

    def get_description(self):
        """ Get the description from this :class:`Package3d`.
        
        :rtype: :class:`Description` object
        """
        return self.description


    
    def get_children(self):
        """
        Get all the children of this :class:`EagleFilePart`.
        
        :rtype: List of :class:`EagleFilePart` objects
        """
        r = []

        r = r + self.packageinstances


        if self.description is not None:
            r = r + [self.description]

        return r

    def remove_child(self, efp):
        """
        Remove a child :class:`EagleFilePart` object.
        
        :param efp: the class:`EagleFilePart` object to remove.
        :return: Nothing
        """
        try:
            self.remove_packageinstance(efp)
        except:
            pass
        if self.get_description() == efp:
            self.set_description(None)

    def _rekey_child(self, oldkey, efp):
        """
        Remove a child :class:`EagleFilePart` object.
        
        :param efp: the class:`EagleFilePart` object to remove.
        :return: Nothing
        """


    def __str__(self):
        r = "["+repr(self)+" "
        r = r + "name:" + str(self.get_name()) + " "
        r = r + "urn:" + str(self.get_urn()) + " "
        r = r + "type:" + str(self.get_type()) + " "
        r = r + "locally_modified:" + str(self.get_locally_modified()) + " "
        r = r + "library_version:" + str(self.get_library_version()) + " "
        r = r + "library_locally_modified:" + str(self.get_library_locally_modified()) + " "
        r = r + "]"
        return r
            
    def dump(self, indent="", increment="   "):
        """
        Recursive debug dump.
        
        :param indent:  Indentation string.  The output will be indented by this much.
        :param increment: This will be appendeded to :code:`indent` on recursive invocations.

        :rtype: :code:`None`
        """
        print(indent + str(self.__class__.__name__), end=' ')
        try:
            print(self.get_name())
        except:
            print()
            pass
        for c in self.get_children():
            c.dump(indent + "   ")

        
EagleFile.class_map["package3d"] = Package3d
         


class Connect(EagleFilePart):
    """
    Class representing the contents of a <connect> tag in Eagle files.

    Attributes:

    * :code:`gate`

    * :code:`pin`

    * :code:`route`


    """
    def __init__(self):
        """
        Construct an empty :class:`Connect` object.
        """
        EagleFilePart.__init__(self)
        
        self.gate=None
        self.pin=None
        self.route=None
        self.pads=[]


        
    @classmethod
    def _from_et(cls,root,parent):
        """
        Create a :class:`Connect` from a :code:`connect` element.
        
        :param root: The element tree tree to parse.
        :param parent: :class:`EagleFilePart` that should hold the resulting :class:`EagleFilePart`
        :rtype: :class:`Connect`
        """
        ## Call the constructor
        n = cls()
        n._init_from_et(root,parent)
        return n

    def _get_error_name(self):
        if hasattr(self, "get_name"):
            return self.get_name();
        else:
            return "Connect";
        
    def  _init_from_et(self, root, parent):
        """
        Initialized a :class:`Connect` from a :code:`connect` element.  This is useful if you have a subclass of :class:`Connect` .
        
        :param root: The element tree tree to parse.
        :param parent: :class:`EagleFilePart` that will become the parent of :code:`this` .
        :rtype: :class:`Connect`
        """
        try:
            self.root = root
            
            if root.tag != "connect":
                raise EagleFormatError("Tried to create connect from " + root.tag)

            self.gate=parseByType(parent, "str", None, root.get("gate"))
            self.pin=parseByType(parent, "str", None, root.get("pin"))
            self.route=parseByType(parent, "str", None, root.get("route"))

            self.parent = parent

            ### populate the maps by searching for elements that match xpath and generating objects for them.


            ### Do the same for the lists


            ### Do the same for the attr lists

            for c in root.get("pad").split(" "):
                self.add_pad(c)

            ### And the singletons


            ### And, finally, if the objects wants the text from the tag.

        except SwoopError as e:
            e.text = "{}:{}".format(self._get_error_name(), e.text)
            raise e


    def sortkey(self):
        r = ""
        r = r + str(self.gate)
        r = r + str(self.pin)
        r = r + str(self.route)
        return r

    def get_et(self):
        """
        Generate a <connect> element tree for a :class:`Connect`.
        
        :rtype:  :class:`ElementTree`.
        
        """
        try:
            r = ET.Element("connect")

            ### Set the tag attributes 


            ## Unparse the values.

            v = unparseByType(self, "str", None,  self.gate)

            ## For required attributes None becomes "".  For optional attributes, we just leave the attribute out.
            if not (isinstance(self.get_parent(), LibraryFile) and False):  # special case for the name of library.
                if v is not None:
                    r.set("gate", v)
                else:
                    r.set("gate", "")


            ## Unparse the values.

            v = unparseByType(self, "str", None,  self.pin)

            ## For required attributes None becomes "".  For optional attributes, we just leave the attribute out.
            if not (isinstance(self.get_parent(), LibraryFile) and False):  # special case for the name of library.
                if v is not None:
                    r.set("pin", v)
                else:
                    r.set("pin", "")


            ## Unparse the values.

            v = unparseByType(self, "str", None,  self.route)

            ## For required attributes None becomes "".  For optional attributes, we just leave the attribute out.
            if not (isinstance(self.get_parent(), LibraryFile) and False):  # special case for the name of library.
                if v is not None:
                    r.set("route", v)


            ### process the sections in order.  They have to be in section order,
            ### because eagle files are order dependent.


            ## For some tags, Eagle generates empty tags when there's no contant
            ## rather than just leaving the tag out.  We mark these with
            ## Tag.requireTag in GenerateSwoop.py and force their generation
            ## here.



            if self.pads is not None:
                r.set("pad", " ".join(self.pads))


            ## set the text, if its needed.

        except SwoopError as e:
            e.text = "{}:{}".format(self._get_error_name(), e.text)
            raise e
        return r

    def clone(self):
        """
        Recursively clone this :code:`Connect`.  It will be identical to the original, but it's parent will be :code:`None`.
        
        :rtype: :class:`Connect`
        """
        try:
            n = copy.copy(self)
            n.pads = []
            for x in self.pads:
                n.add_pad(x)
            n.parent = None
        except SwoopError as e:
            e.text = "{}:{}".format(self._get_error_name(), e.text)
            raise e
        return n

    def accept_preorder_visitor(self, visitor):
        try:
            pre = getattr(visitor, "Connect_pre")
            return pre(self)
        except AttributeError:
            return visitor.default_pre(self)
        
    def accept_postorder_visitor(self, visitor, context):
        try:
            post = getattr(visitor, "Connect_post")
            post(self,context)
        except AttributeError:
            visitor.default_post(self,context)

    def is_equal(self, other):
        """
        Check whether two :code:`EagleFilePart` objects are identical.
        
        :param other: Object to compare to.
        :returns: :code:`True` if they are identical, otherwise, :code:`False`
        """
        return self.get_xml() == other.get_xml()
        
    ### Getters/Setters for attribute values

    def get_gate(self):
        """ Return the value of :code:`gate` for this :class:`Connect`.  This corresponds to the :code:`gate` attribute of a :code:`<connect>` in an Eagle file.
        
        :rtype: :code:`str`
        """
        return self.gate

    def set_gate(self,v):
        """ Set the value of :code:`gate` for this  :class:`Connect`.  This corresponds to the :code:`gate` attribute of a :code:`<connect>` in an Eagle file.

        :param v: new value
        :rtype: :code:`self`
        """
                        
        if not typeCheck("str", v, True):
            raise SwoopError("Illegal value ({}) of type {} for attribute 'gate' of Connect object (should be str).".format(v, type(v)))
        self.gate = v
        
        return self

    def with_gate(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`gate`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`gate` equals :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_gate()` is :code:`True`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """

        if type(v) in [str, int, float, bool]:
            return self if self.gate == v else None
        elif callable(v):
            return self if v(self.gate) else None
        else:
            raise SwoopError("Illegal type passed to with_gate")

    def without_gate(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`gate`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`gate` is not equal to :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_gate()` is :code:`False`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """
        
        if type(v) in [str, int, float, bool]:
            return self if self.gate != v else None
        elif callable(v):
            return self if not v(self.gate) else None
        else:
            raise SwoopError("Illegal type passed to without_gate")


    def get_pin(self):
        """ Return the value of :code:`pin` for this :class:`Connect`.  This corresponds to the :code:`pin` attribute of a :code:`<connect>` in an Eagle file.
        
        :rtype: :code:`str`
        """
        return self.pin

    def set_pin(self,v):
        """ Set the value of :code:`pin` for this  :class:`Connect`.  This corresponds to the :code:`pin` attribute of a :code:`<connect>` in an Eagle file.

        :param v: new value
        :rtype: :code:`self`
        """
                        
        if not typeCheck("str", v, True):
            raise SwoopError("Illegal value ({}) of type {} for attribute 'pin' of Connect object (should be str).".format(v, type(v)))
        self.pin = v
        
        return self

    def with_pin(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`pin`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`pin` equals :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_pin()` is :code:`True`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """

        if type(v) in [str, int, float, bool]:
            return self if self.pin == v else None
        elif callable(v):
            return self if v(self.pin) else None
        else:
            raise SwoopError("Illegal type passed to with_pin")

    def without_pin(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`pin`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`pin` is not equal to :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_pin()` is :code:`False`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """
        
        if type(v) in [str, int, float, bool]:
            return self if self.pin != v else None
        elif callable(v):
            return self if not v(self.pin) else None
        else:
            raise SwoopError("Illegal type passed to without_pin")


    def get_route(self):
        """ Return the value of :code:`route` for this :class:`Connect`.  This corresponds to the :code:`route` attribute of a :code:`<connect>` in an Eagle file.
        
        :rtype: :code:`str`
        """
        return self.route

    def set_route(self,v):
        """ Set the value of :code:`route` for this  :class:`Connect`.  This corresponds to the :code:`route` attribute of a :code:`<connect>` in an Eagle file.

        :param v: new value
        :rtype: :code:`self`
        """
                        
        if not typeCheck("str", v, False):
            raise SwoopError("Illegal value ({}) of type {} for attribute 'route' of Connect object (should be str).".format(v, type(v)))
        self.route = v
        
        return self

    def with_route(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`route`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`route` equals :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_route()` is :code:`True`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """

        if type(v) in [str, int, float, bool]:
            return self if self.route == v else None
        elif callable(v):
            return self if v(self.route) else None
        else:
            raise SwoopError("Illegal type passed to with_route")

    def without_route(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`route`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`route` is not equal to :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_route()` is :code:`False`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """
        
        if type(v) in [str, int, float, bool]:
            return self if self.route != v else None
        elif callable(v):
            return self if not v(self.route) else None
        else:
            raise SwoopError("Illegal type passed to without_route")



    ##### Lookup functions that return EFPs instead of just attribute values.
    
    def find_gate(self):
        """Find the :class:`Gate` object refered to by the :code:`gate` attribute of this object.  This is like
        :meth:`get_gate`, except it returns the :class:`Gate` object instead of its name.
        
        :returns: The object
        :rtype: :class:`Gate`

        """
        f = lambda efp, key: NotImplemented('Lookup of gate from connect not implemented.')
        return f(self, self.gate)
    def find_pin(self):
        """Find the :class:`Pin` object refered to by the :code:`pin` attribute of this object.  This is like
        :meth:`get_pin`, except it returns the :class:`Pin` object instead of its name.
        
        :returns: The object
        :rtype: :class:`Pin`

        """
        f = lambda efp, key: NotImplemented('Lookup of pin from connect not implemented.')
        return f(self, self.pin)
    


    
    ### Adder/getter/lookup for lists
    

    def add_pad(self, s):
        """ Add a str to the :code:`pads` of this :class:`Connect`.

        :param s: The str to add.
        :rtype: :code:`self`
        """
        if not isinstance(s, str):
            raise SwoopError("Argument to Connect.add_pad() should be str.  Got " + str(type(s).__name__) + ".")
        
        self.pads.append(s)
        return self

    def get_nth_pad(self, n):
        """ get then nth str object from the :code:`pads` of this :class:`Connect`.
        
        :param n: Index of the item to return.

        :rtype: str object
        """
        return self.pads[n]

    def get_pads(self, attrs=None, type=None):
        """Return (and possibly filter) items in the the :code:`pads` list of str objects for this :class:`Connect`.
        
        This functions provides a mechanism for filtering the items as well.
        The keys in :code:`attrs` are taken as attributes names and the
        values are requested values.  Items in the list that have all the
        requested values for the corresponding attributes will be returned.  

        A if :code:`type` is not :code:`None`, the item will match if it is an
        instance of the type provided.
        
        :param attrs: A set of key-value pairs that represent a filter to apply to the item's attributes.
        :param type:  A type to filter on.  Only items that are an instance of this type will be returned.
        :returns: A List of str objects
        :rtype: List of str objects
        """
        if attrs is not None or type is not None:
            raise NotImplementedError("filtered get not implemented.")
        return self.pads

    def clear_pads(self):
        """
        Remove all the str objects from the :code:`pads` of this :class:`Connect`.
        
        :rtype: :code:`self`
        """
        self.pads = []
        return self

    def remove_pad(self, v):
        """
        Remove a str from the :code:`pads` of this :class:`Connect`.
        
        :param efp: The str object to remove.

        :rtype: :code:`self`
        """
        self.pads = [x for x in self.pads if x != v]
        return self


    ### Add, lookup, and get for maps


    
    ### Getter/Setter for singletons.


    
    def get_children(self):
        """
        Get all the children of this :class:`EagleFilePart`.
        
        :rtype: List of :class:`EagleFilePart` objects
        """
        r = []




        return r

    def remove_child(self, efp):
        """
        Remove a child :class:`EagleFilePart` object.
        
        :param efp: the class:`EagleFilePart` object to remove.
        :return: Nothing
        """

    def _rekey_child(self, oldkey, efp):
        """
        Remove a child :class:`EagleFilePart` object.
        
        :param efp: the class:`EagleFilePart` object to remove.
        :return: Nothing
        """


    def __str__(self):
        r = "["+repr(self)+" "
        r = r + "gate:" + str(self.get_gate()) + " "
        r = r + "pin:" + str(self.get_pin()) + " "
        r = r + "route:" + str(self.get_route()) + " "
        r = r + "]"
        return r
            
    def dump(self, indent="", increment="   "):
        """
        Recursive debug dump.
        
        :param indent:  Indentation string.  The output will be indented by this much.
        :param increment: This will be appendeded to :code:`indent` on recursive invocations.

        :rtype: :code:`None`
        """
        print(indent + str(self.__class__.__name__), end=' ')
        try:
            print(self.get_name())
        except:
            print()
            pass
        for c in self.get_children():
            c.dump(indent + "   ")

        
EagleFile.class_map["connect"] = Connect
         


class Packageinstance(EagleFilePart):
    """
    Class representing the contents of a <packageinstance> tag in Eagle files.

    Attributes:

    * :code:`name`


    """
    def __init__(self):
        """
        Construct an empty :class:`Packageinstance` object.
        """
        EagleFilePart.__init__(self)
        
        self.name=None


        
    @classmethod
    def _from_et(cls,root,parent):
        """
        Create a :class:`Packageinstance` from a :code:`packageinstance` element.
        
        :param root: The element tree tree to parse.
        :param parent: :class:`EagleFilePart` that should hold the resulting :class:`EagleFilePart`
        :rtype: :class:`Packageinstance`
        """
        ## Call the constructor
        n = cls()
        n._init_from_et(root,parent)
        return n

    def _get_error_name(self):
        if hasattr(self, "get_name"):
            return self.get_name();
        else:
            return "Packageinstance";
        
    def  _init_from_et(self, root, parent):
        """
        Initialized a :class:`Packageinstance` from a :code:`packageinstance` element.  This is useful if you have a subclass of :class:`Packageinstance` .
        
        :param root: The element tree tree to parse.
        :param parent: :class:`EagleFilePart` that will become the parent of :code:`this` .
        :rtype: :class:`Packageinstance`
        """
        try:
            self.root = root
            
            if root.tag != "packageinstance":
                raise EagleFormatError("Tried to create packageinstance from " + root.tag)

            self.name=parseByType(parent, "str", None, root.get("name"))

            self.parent = parent

            ### populate the maps by searching for elements that match xpath and generating objects for them.


            ### Do the same for the lists


            ### Do the same for the attr lists


            ### And the singletons


            ### And, finally, if the objects wants the text from the tag.

        except SwoopError as e:
            e.text = "{}:{}".format(self._get_error_name(), e.text)
            raise e


    def sortkey(self):
        r = ""
        r = r + str(self.name)
        return r

    def get_et(self):
        """
        Generate a <packageinstance> element tree for a :class:`Packageinstance`.
        
        :rtype:  :class:`ElementTree`.
        
        """
        try:
            r = ET.Element("packageinstance")

            ### Set the tag attributes 


            ## Unparse the values.

            v = unparseByType(self, "str", None,  self.name)

            ## For required attributes None becomes "".  For optional attributes, we just leave the attribute out.
            if not (isinstance(self.get_parent(), LibraryFile) and False):  # special case for the name of library.
                if v is not None:
                    r.set("name", v)
                else:
                    r.set("name", "")


            ### process the sections in order.  They have to be in section order,
            ### because eagle files are order dependent.


            ## set the text, if its needed.

        except SwoopError as e:
            e.text = "{}:{}".format(self._get_error_name(), e.text)
            raise e
        return r

    def clone(self):
        """
        Recursively clone this :code:`Packageinstance`.  It will be identical to the original, but it's parent will be :code:`None`.
        
        :rtype: :class:`Packageinstance`
        """
        try:
            n = copy.copy(self)
            n.parent = None
        except SwoopError as e:
            e.text = "{}:{}".format(self._get_error_name(), e.text)
            raise e
        return n

    def accept_preorder_visitor(self, visitor):
        try:
            pre = getattr(visitor, "Packageinstance_pre")
            return pre(self)
        except AttributeError:
            return visitor.default_pre(self)
        
    def accept_postorder_visitor(self, visitor, context):
        try:
            post = getattr(visitor, "Packageinstance_post")
            post(self,context)
        except AttributeError:
            visitor.default_post(self,context)

    def is_equal(self, other):
        """
        Check whether two :code:`EagleFilePart` objects are identical.
        
        :param other: Object to compare to.
        :returns: :code:`True` if they are identical, otherwise, :code:`False`
        """
        return self.get_xml() == other.get_xml()
        
    ### Getters/Setters for attribute values

    def get_name(self):
        """ Return the value of :code:`name` for this :class:`Packageinstance`.  This corresponds to the :code:`name` attribute of a :code:`<packageinstance>` in an Eagle file.
        
        :rtype: :code:`str`
        """
        return self.name

    def set_name(self,v):
        """ Set the value of :code:`name` for this  :class:`Packageinstance`.  This corresponds to the :code:`name` attribute of a :code:`<packageinstance>` in an Eagle file.

        :param v: new value
        :rtype: :code:`self`
        """
                        
        oldkey = self.name
        if not typeCheck("str", v, True):
            raise SwoopError("Illegal value ({}) of type {} for attribute 'name' of Packageinstance object (should be str).".format(v, type(v)))
        self.name = v
        
        if self.get_parent() is not None:
            self.get_parent()._rekey_child(oldkey, self);
        return self

    def with_name(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`name`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`name` equals :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_name()` is :code:`True`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """

        if type(v) in [str, int, float, bool]:
            return self if self.name == v else None
        elif callable(v):
            return self if v(self.name) else None
        else:
            raise SwoopError("Illegal type passed to with_name")

    def without_name(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`name`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`name` is not equal to :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_name()` is :code:`False`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """
        
        if type(v) in [str, int, float, bool]:
            return self if self.name != v else None
        elif callable(v):
            return self if not v(self.name) else None
        else:
            raise SwoopError("Illegal type passed to without_name")



    ##### Lookup functions that return EFPs instead of just attribute values.
    
    


    
    ### Adder/getter/lookup for lists
    


    ### Add, lookup, and get for maps


    
    ### Getter/Setter for singletons.


    
    def get_children(self):
        """
        Get all the children of this :class:`EagleFilePart`.
        
        :rtype: List of :class:`EagleFilePart` objects
        """
        r = []




        return r

    def remove_child(self, efp):
        """
        Remove a child :class:`EagleFilePart` object.
        
        :param efp: the class:`EagleFilePart` object to remove.
        :return: Nothing
        """

    def _rekey_child(self, oldkey, efp):
        """
        Remove a child :class:`EagleFilePart` object.
        
        :param efp: the class:`EagleFilePart` object to remove.
        :return: Nothing
        """


    def __str__(self):
        r = "["+repr(self)+" "
        r = r + "name:" + str(self.get_name()) + " "
        r = r + "]"
        return r
            
    def dump(self, indent="", increment="   "):
        """
        Recursive debug dump.
        
        :param indent:  Indentation string.  The output will be indented by this much.
        :param increment: This will be appendeded to :code:`indent` on recursive invocations.

        :rtype: :code:`None`
        """
        print(indent + str(self.__class__.__name__), end=' ')
        try:
            print(self.get_name())
        except:
            print()
            pass
        for c in self.get_children():
            c.dump(indent + "   ")

        
EagleFile.class_map["packageinstance"] = Packageinstance
         


class Pass(EagleFilePart):
    """
    Class representing the contents of a <pass> tag in Eagle files.

    Attributes:

    * :code:`name`

    * :code:`refer`

    * :code:`active`



    Collections:



    * :code:`param`: Map of :class:`Param` objects indexed by their :code:`name`.



    """
    def __init__(self):
        """
        Construct an empty :class:`Pass` object.
        """
        EagleFilePart.__init__(self)
        
        self.name=None
        self.refer=None
        self.active=None
        self.params={} #tecollections.OrderedDict()  For unclear reasons, this caused ordering to become more unpredictable, rather than less.


        
    @classmethod
    def _from_et(cls,root,parent):
        """
        Create a :class:`Pass` from a :code:`pass` element.
        
        :param root: The element tree tree to parse.
        :param parent: :class:`EagleFilePart` that should hold the resulting :class:`EagleFilePart`
        :rtype: :class:`Pass`
        """
        ## Call the constructor
        n = cls()
        n._init_from_et(root,parent)
        return n

    def _get_error_name(self):
        if hasattr(self, "get_name"):
            return self.get_name();
        else:
            return "Pass";
        
    def  _init_from_et(self, root, parent):
        """
        Initialized a :class:`Pass` from a :code:`pass` element.  This is useful if you have a subclass of :class:`Pass` .
        
        :param root: The element tree tree to parse.
        :param parent: :class:`EagleFilePart` that will become the parent of :code:`this` .
        :rtype: :class:`Pass`
        """
        try:
            self.root = root
            
            if root.tag != "pass":
                raise EagleFormatError("Tried to create pass from " + root.tag)

            self.name=parseByType(parent, "str", None, root.get("name"))
            self.refer=parseByType(parent, "str", None, root.get("refer"))
            self.active=parseByType(parent, "str", None, root.get("active"))

            self.parent = parent

            ### populate the maps by searching for elements that match xpath and generating objects for them.

            for c in root.xpath("./param"):
                self.add_param(self.get_class_for_tag(c.tag)._from_et(c, self))

            ### Do the same for the lists


            ### Do the same for the attr lists


            ### And the singletons


            ### And, finally, if the objects wants the text from the tag.

        except SwoopError as e:
            e.text = "{}:{}".format(self._get_error_name(), e.text)
            raise e


    def sortkey(self):
        r = ""
        r = r + str(self.name)
        r = r + str(self.refer)
        r = r + str(self.active)
        return r

    def get_et(self):
        """
        Generate a <pass> element tree for a :class:`Pass`.
        
        :rtype:  :class:`ElementTree`.
        
        """
        try:
            r = ET.Element("pass")

            ### Set the tag attributes 


            ## Unparse the values.

            v = unparseByType(self, "str", None,  self.name)

            ## For required attributes None becomes "".  For optional attributes, we just leave the attribute out.
            if not (isinstance(self.get_parent(), LibraryFile) and False):  # special case for the name of library.
                if v is not None:
                    r.set("name", v)
                else:
                    r.set("name", "")


            ## Unparse the values.

            v = unparseByType(self, "str", None,  self.refer)

            ## For required attributes None becomes "".  For optional attributes, we just leave the attribute out.
            if not (isinstance(self.get_parent(), LibraryFile) and False):  # special case for the name of library.
                if v is not None:
                    r.set("refer", v)


            ## Unparse the values.

            v = unparseByType(self, "str", None,  self.active)

            ## For required attributes None becomes "".  For optional attributes, we just leave the attribute out.
            if not (isinstance(self.get_parent(), LibraryFile) and False):  # special case for the name of library.
                if v is not None:
                    r.set("active", v)


            ### process the sections in order.  They have to be in section order,
            ### because eagle files are order dependent.


            ## For some tags, Eagle generates empty tags when there's no contant
            ## rather than just leaving the tag out.  We mark these with
            ## Tag.requireTag in GenerateSwoop.py and force their generation
            ## here.



            ## add a map.

            if len(self.params) is not 0:
                target = smartAddSubTags(r, "./param")
                # add them in sorted order.  This gives us a simple canonicalization that makes it feasible to use diff to compare files.
                target.extend([i.get_et() for i in sorted(list(self.params.values()),key=lambda x: x.sortkey())])


            ## set the text, if its needed.

        except SwoopError as e:
            e.text = "{}:{}".format(self._get_error_name(), e.text)
            raise e
        return r

    def clone(self):
        """
        Recursively clone this :code:`Pass`.  It will be identical to the original, but it's parent will be :code:`None`.
        
        :rtype: :class:`Pass`
        """
        try:
            n = copy.copy(self)
            n.params = {}
            for x in list(self.params.values()):
                n.add_param(x.clone())
            n.parent = None
        except SwoopError as e:
            e.text = "{}:{}".format(self._get_error_name(), e.text)
            raise e
        return n

    def accept_preorder_visitor(self, visitor):
        try:
            pre = getattr(visitor, "Pass_pre")
            return pre(self)
        except AttributeError:
            return visitor.default_pre(self)
        
    def accept_postorder_visitor(self, visitor, context):
        try:
            post = getattr(visitor, "Pass_post")
            post(self,context)
        except AttributeError:
            visitor.default_post(self,context)

    def is_equal(self, other):
        """
        Check whether two :code:`EagleFilePart` objects are identical.
        
        :param other: Object to compare to.
        :returns: :code:`True` if they are identical, otherwise, :code:`False`
        """
        return self.get_xml() == other.get_xml()
        
    ### Getters/Setters for attribute values

    def get_name(self):
        """ Return the value of :code:`name` for this :class:`Pass`.  This corresponds to the :code:`name` attribute of a :code:`<pass>` in an Eagle file.
        
        :rtype: :code:`str`
        """
        return self.name

    def set_name(self,v):
        """ Set the value of :code:`name` for this  :class:`Pass`.  This corresponds to the :code:`name` attribute of a :code:`<pass>` in an Eagle file.

        :param v: new value
        :rtype: :code:`self`
        """
                        
        oldkey = self.name
        if not typeCheck("str", v, True):
            raise SwoopError("Illegal value ({}) of type {} for attribute 'name' of Pass object (should be str).".format(v, type(v)))
        self.name = v
        
        if self.get_parent() is not None:
            self.get_parent()._rekey_child(oldkey, self);
        return self

    def with_name(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`name`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`name` equals :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_name()` is :code:`True`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """

        if type(v) in [str, int, float, bool]:
            return self if self.name == v else None
        elif callable(v):
            return self if v(self.name) else None
        else:
            raise SwoopError("Illegal type passed to with_name")

    def without_name(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`name`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`name` is not equal to :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_name()` is :code:`False`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """
        
        if type(v) in [str, int, float, bool]:
            return self if self.name != v else None
        elif callable(v):
            return self if not v(self.name) else None
        else:
            raise SwoopError("Illegal type passed to without_name")


    def get_refer(self):
        """ Return the value of :code:`refer` for this :class:`Pass`.  This corresponds to the :code:`refer` attribute of a :code:`<pass>` in an Eagle file.
        
        :rtype: :code:`str`
        """
        return self.refer

    def set_refer(self,v):
        """ Set the value of :code:`refer` for this  :class:`Pass`.  This corresponds to the :code:`refer` attribute of a :code:`<pass>` in an Eagle file.

        :param v: new value
        :rtype: :code:`self`
        """
                        
        if not typeCheck("str", v, False):
            raise SwoopError("Illegal value ({}) of type {} for attribute 'refer' of Pass object (should be str).".format(v, type(v)))
        self.refer = v
        
        return self

    def with_refer(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`refer`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`refer` equals :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_refer()` is :code:`True`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """

        if type(v) in [str, int, float, bool]:
            return self if self.refer == v else None
        elif callable(v):
            return self if v(self.refer) else None
        else:
            raise SwoopError("Illegal type passed to with_refer")

    def without_refer(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`refer`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`refer` is not equal to :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_refer()` is :code:`False`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """
        
        if type(v) in [str, int, float, bool]:
            return self if self.refer != v else None
        elif callable(v):
            return self if not v(self.refer) else None
        else:
            raise SwoopError("Illegal type passed to without_refer")


    def get_active(self):
        """ Return the value of :code:`active` for this :class:`Pass`.  This corresponds to the :code:`active` attribute of a :code:`<pass>` in an Eagle file.
        
        :rtype: :code:`str`
        """
        return self.active

    def set_active(self,v):
        """ Set the value of :code:`active` for this  :class:`Pass`.  This corresponds to the :code:`active` attribute of a :code:`<pass>` in an Eagle file.

        :param v: new value
        :rtype: :code:`self`
        """
                        
        if not typeCheck("str", v, False):
            raise SwoopError("Illegal value ({}) of type {} for attribute 'active' of Pass object (should be str).".format(v, type(v)))
        self.active = v
        
        return self

    def with_active(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`active`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`active` equals :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_active()` is :code:`True`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """

        if type(v) in [str, int, float, bool]:
            return self if self.active == v else None
        elif callable(v):
            return self if v(self.active) else None
        else:
            raise SwoopError("Illegal type passed to with_active")

    def without_active(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`active`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`active` is not equal to :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_active()` is :code:`False`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """
        
        if type(v) in [str, int, float, bool]:
            return self if self.active != v else None
        elif callable(v):
            return self if not v(self.active) else None
        else:
            raise SwoopError("Illegal type passed to without_active")



    ##### Lookup functions that return EFPs instead of just attribute values.
    
    


    
    ### Adder/getter/lookup for lists
    


    ### Add, lookup, and get for maps
    def add_param(self, s):
        """ Add a :class:`Param` to the :code:`params` of this :class:`Pass`.

        :param s: The :class:`Param` to add.
        :rtype: :code:`self`
        """
        if not any([
                isinstance(s, Param),
            ]):
            raise SwoopError("Argument to Pass.add_param() should be of type Param.  Got " + str(type(s).__name__) + ".")
        

        self.params[s.get_name()] = s

        s.parent = self
        return self

    def get_nth_param(self, n):
        """ get then nth :class:`Param` object from the :code:`params` of this :class:`Pass`.
        
        :param n: Index of the item to return.

        :rtype: :class:`Param` object
        """
        return list(self.params.values())[n]

    def get_param(self, key):
        """ Lookup and return a :class:`Param` from the :code:`params` of  this :class:`Pass`.
        
        :param key: A :code:`str` to use for the lookup.  The lookup uses the :code:`name` of the :class:`Param` objects.

        :rtype: A :class:`Param` object or :code:`None`, if there is no such item.
        """
        return self.params.get(key)


    def get_params(self, attrs=None, type=None):
        """Return (and possibly filter) items in the the :code:`params` map of :class:`Param` objects for this :class:`Pass`.
        
        This functions provides a mechanism for filtering the items as well.
        The keys in :code:`attrs` are taken as attributes names and the
        values are requested values.  Items in the list that have all the
        requested values for the corresponding attributes will be returned.  

        A if :code:`type` is not :code:`None`, the item will match if it is an
        instance of the type provided.
        
        :param attrs: A set of key-value pairs that represent a filter to apply to the item's attributes.
        :param type:  A type to filter on.  Only items that are an instance of this type will be returned.
        :returns: A List of :class:`Param` objects
        :rtype: List of :class:`Param` objects
        """
        if attrs is not None or type is not None:
            raise NotImplementedError("filtered get not implemented")
        return list(self.params.values())
        

    def clear_params(self):
        """
        Remove all the :class:`Param` objects from the :code:`params` of this :class:`Pass`.
        
        :rtype: :code:`self`
        """
        for efp in list(self.params.values()):
            efp.parent = None
        self.params = {}
        return self

    def remove_param(self, efp):
        """
        Remove a :class:`Param` from the :code:`params` of this :class:`Pass`.
        
        :param efp: The :class:`Param` object to remove.

        :rtype: :code:`self`
        """
        if self.params[efp.get_name()] == efp:
            del self.params[efp.get_name()]
            efp.parent = None
            return self
        else:
            raise SwoopError("Tried to use remove_param() to delete the wrong kind of child?: {}".format(str(efp)))
    


    
    ### Getter/Setter for singletons.


    
    def get_children(self):
        """
        Get all the children of this :class:`EagleFilePart`.
        
        :rtype: List of :class:`EagleFilePart` objects
        """
        r = []


        r = r + list(self.params.values())


        return r

    def remove_child(self, efp):
        """
        Remove a child :class:`EagleFilePart` object.
        
        :param efp: the class:`EagleFilePart` object to remove.
        :return: Nothing
        """
        try:
            self.remove_param(efp)
        except:
            pass

    def _rekey_child(self, oldkey, efp):
        """
        Remove a child :class:`EagleFilePart` object.
        
        :param efp: the class:`EagleFilePart` object to remove.
        :return: Nothing
        """
        try:
            if self.get_param(oldkey) == efp:
                del self.params[oldkey]
                self.add_param(efp)
        except SwoopError:
            pass

    def check_sanity(self, visited_efps = None):
        EagleFilePart.check_sanity(self, visited_efps)

        # Check whether keys in our maps match the keys in our children
        for k in self.params:
            if self.params[k].get_name() != k:
                raise SwoopError("Child's name ('{}') doesn't match key in parent's map ('{}')".format(self.params[k].get_name(),k))

    def __str__(self):
        r = "["+repr(self)+" "
        r = r + "name:" + str(self.get_name()) + " "
        r = r + "refer:" + str(self.get_refer()) + " "
        r = r + "active:" + str(self.get_active()) + " "
        r = r + "]"
        return r
            
    def dump(self, indent="", increment="   "):
        """
        Recursive debug dump.
        
        :param indent:  Indentation string.  The output will be indented by this much.
        :param increment: This will be appendeded to :code:`indent` on recursive invocations.

        :rtype: :code:`None`
        """
        print(indent + str(self.__class__.__name__), end=' ')
        try:
            print(self.get_name())
        except:
            print()
            pass
        for c in self.get_children():
            c.dump(indent + "   ")

        
EagleFile.class_map["pass"] = Pass
         


class Mfgpreviewcolor(EagleFilePart):
    """
    Class representing the contents of a <mfgpreviewcolor> tag in Eagle files.

    Attributes:

    * :code:`name`

    * :code:`color`


    """
    def __init__(self):
        """
        Construct an empty :class:`Mfgpreviewcolor` object.
        """
        EagleFilePart.__init__(self)
        
        self.name=None
        self.color=None


        
    @classmethod
    def _from_et(cls,root,parent):
        """
        Create a :class:`Mfgpreviewcolor` from a :code:`mfgpreviewcolor` element.
        
        :param root: The element tree tree to parse.
        :param parent: :class:`EagleFilePart` that should hold the resulting :class:`EagleFilePart`
        :rtype: :class:`Mfgpreviewcolor`
        """
        ## Call the constructor
        n = cls()
        n._init_from_et(root,parent)
        return n

    def _get_error_name(self):
        if hasattr(self, "get_name"):
            return self.get_name();
        else:
            return "Mfgpreviewcolor";
        
    def  _init_from_et(self, root, parent):
        """
        Initialized a :class:`Mfgpreviewcolor` from a :code:`mfgpreviewcolor` element.  This is useful if you have a subclass of :class:`Mfgpreviewcolor` .
        
        :param root: The element tree tree to parse.
        :param parent: :class:`EagleFilePart` that will become the parent of :code:`this` .
        :rtype: :class:`Mfgpreviewcolor`
        """
        try:
            self.root = root
            
            if root.tag != "mfgpreviewcolor":
                raise EagleFormatError("Tried to create mfgpreviewcolor from " + root.tag)

            self.name=parseByType(parent, "str", None, root.get("name"))
            self.color=parseByType(parent, "str", None, root.get("color"))

            self.parent = parent

            ### populate the maps by searching for elements that match xpath and generating objects for them.


            ### Do the same for the lists


            ### Do the same for the attr lists


            ### And the singletons


            ### And, finally, if the objects wants the text from the tag.

        except SwoopError as e:
            e.text = "{}:{}".format(self._get_error_name(), e.text)
            raise e


    def sortkey(self):
        r = ""
        r = r + str(self.name)
        r = r + str(self.color)
        return r

    def get_et(self):
        """
        Generate a <mfgpreviewcolor> element tree for a :class:`Mfgpreviewcolor`.
        
        :rtype:  :class:`ElementTree`.
        
        """
        try:
            r = ET.Element("mfgpreviewcolor")

            ### Set the tag attributes 


            ## Unparse the values.

            v = unparseByType(self, "str", None,  self.name)

            ## For required attributes None becomes "".  For optional attributes, we just leave the attribute out.
            if not (isinstance(self.get_parent(), LibraryFile) and False):  # special case for the name of library.
                if v is not None:
                    r.set("name", v)
                else:
                    r.set("name", "")


            ## Unparse the values.

            v = unparseByType(self, "str", None,  self.color)

            ## For required attributes None becomes "".  For optional attributes, we just leave the attribute out.
            if not (isinstance(self.get_parent(), LibraryFile) and False):  # special case for the name of library.
                if v is not None:
                    r.set("color", v)
                else:
                    r.set("color", "")


            ### process the sections in order.  They have to be in section order,
            ### because eagle files are order dependent.


            ## set the text, if its needed.

        except SwoopError as e:
            e.text = "{}:{}".format(self._get_error_name(), e.text)
            raise e
        return r

    def clone(self):
        """
        Recursively clone this :code:`Mfgpreviewcolor`.  It will be identical to the original, but it's parent will be :code:`None`.
        
        :rtype: :class:`Mfgpreviewcolor`
        """
        try:
            n = copy.copy(self)
            n.parent = None
        except SwoopError as e:
            e.text = "{}:{}".format(self._get_error_name(), e.text)
            raise e
        return n

    def accept_preorder_visitor(self, visitor):
        try:
            pre = getattr(visitor, "Mfgpreviewcolor_pre")
            return pre(self)
        except AttributeError:
            return visitor.default_pre(self)
        
    def accept_postorder_visitor(self, visitor, context):
        try:
            post = getattr(visitor, "Mfgpreviewcolor_post")
            post(self,context)
        except AttributeError:
            visitor.default_post(self,context)

    def is_equal(self, other):
        """
        Check whether two :code:`EagleFilePart` objects are identical.
        
        :param other: Object to compare to.
        :returns: :code:`True` if they are identical, otherwise, :code:`False`
        """
        return self.get_xml() == other.get_xml()
        
    ### Getters/Setters for attribute values

    def get_name(self):
        """ Return the value of :code:`name` for this :class:`Mfgpreviewcolor`.  This corresponds to the :code:`name` attribute of a :code:`<mfgpreviewcolor>` in an Eagle file.
        
        :rtype: :code:`str`
        """
        return self.name

    def set_name(self,v):
        """ Set the value of :code:`name` for this  :class:`Mfgpreviewcolor`.  This corresponds to the :code:`name` attribute of a :code:`<mfgpreviewcolor>` in an Eagle file.

        :param v: new value
        :rtype: :code:`self`
        """
                        
        oldkey = self.name
        if not typeCheck("str", v, True):
            raise SwoopError("Illegal value ({}) of type {} for attribute 'name' of Mfgpreviewcolor object (should be str).".format(v, type(v)))
        self.name = v
        
        if self.get_parent() is not None:
            self.get_parent()._rekey_child(oldkey, self);
        return self

    def with_name(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`name`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`name` equals :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_name()` is :code:`True`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """

        if type(v) in [str, int, float, bool]:
            return self if self.name == v else None
        elif callable(v):
            return self if v(self.name) else None
        else:
            raise SwoopError("Illegal type passed to with_name")

    def without_name(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`name`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`name` is not equal to :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_name()` is :code:`False`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """
        
        if type(v) in [str, int, float, bool]:
            return self if self.name != v else None
        elif callable(v):
            return self if not v(self.name) else None
        else:
            raise SwoopError("Illegal type passed to without_name")


    def get_color(self):
        """ Return the value of :code:`color` for this :class:`Mfgpreviewcolor`.  This corresponds to the :code:`color` attribute of a :code:`<mfgpreviewcolor>` in an Eagle file.
        
        :rtype: :code:`str`
        """
        return self.color

    def set_color(self,v):
        """ Set the value of :code:`color` for this  :class:`Mfgpreviewcolor`.  This corresponds to the :code:`color` attribute of a :code:`<mfgpreviewcolor>` in an Eagle file.

        :param v: new value
        :rtype: :code:`self`
        """
                        
        if not typeCheck("str", v, True):
            raise SwoopError("Illegal value ({}) of type {} for attribute 'color' of Mfgpreviewcolor object (should be str).".format(v, type(v)))
        self.color = v
        
        return self

    def with_color(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`color`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`color` equals :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_color()` is :code:`True`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """

        if type(v) in [str, int, float, bool]:
            return self if self.color == v else None
        elif callable(v):
            return self if v(self.color) else None
        else:
            raise SwoopError("Illegal type passed to with_color")

    def without_color(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`color`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`color` is not equal to :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_color()` is :code:`False`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """
        
        if type(v) in [str, int, float, bool]:
            return self if self.color != v else None
        elif callable(v):
            return self if not v(self.color) else None
        else:
            raise SwoopError("Illegal type passed to without_color")



    ##### Lookup functions that return EFPs instead of just attribute values.
    
    


    
    ### Adder/getter/lookup for lists
    


    ### Add, lookup, and get for maps


    
    ### Getter/Setter for singletons.


    
    def get_children(self):
        """
        Get all the children of this :class:`EagleFilePart`.
        
        :rtype: List of :class:`EagleFilePart` objects
        """
        r = []




        return r

    def remove_child(self, efp):
        """
        Remove a child :class:`EagleFilePart` object.
        
        :param efp: the class:`EagleFilePart` object to remove.
        :return: Nothing
        """

    def _rekey_child(self, oldkey, efp):
        """
        Remove a child :class:`EagleFilePart` object.
        
        :param efp: the class:`EagleFilePart` object to remove.
        :return: Nothing
        """


    def __str__(self):
        r = "["+repr(self)+" "
        r = r + "name:" + str(self.get_name()) + " "
        r = r + "color:" + str(self.get_color()) + " "
        r = r + "]"
        return r
            
    def dump(self, indent="", increment="   "):
        """
        Recursive debug dump.
        
        :param indent:  Indentation string.  The output will be indented by this much.
        :param increment: This will be appendeded to :code:`indent` on recursive invocations.

        :rtype: :code:`None`
        """
        print(indent + str(self.__class__.__name__), end=' ')
        try:
            print(self.get_name())
        except:
            print()
            pass
        for c in self.get_children():
            c.dump(indent + "   ")

        
EagleFile.class_map["mfgpreviewcolor"] = Mfgpreviewcolor
         


class Technology(EagleFilePart):
    """
    Class representing the contents of a <technology> tag in Eagle files.

    Attributes:

    * :code:`name`



    Collections:



    * :code:`attribute`: Map of :class:`Attribute` objects indexed by their :code:`name`.



    """
    def __init__(self):
        """
        Construct an empty :class:`Technology` object.
        """
        EagleFilePart.__init__(self)
        
        self.name=None
        self.attributes={} #tecollections.OrderedDict()  For unclear reasons, this caused ordering to become more unpredictable, rather than less.


        
    @classmethod
    def _from_et(cls,root,parent):
        """
        Create a :class:`Technology` from a :code:`technology` element.
        
        :param root: The element tree tree to parse.
        :param parent: :class:`EagleFilePart` that should hold the resulting :class:`EagleFilePart`
        :rtype: :class:`Technology`
        """
        ## Call the constructor
        n = cls()
        n._init_from_et(root,parent)
        return n

    def _get_error_name(self):
        if hasattr(self, "get_name"):
            return self.get_name();
        else:
            return "Technology";
        
    def  _init_from_et(self, root, parent):
        """
        Initialized a :class:`Technology` from a :code:`technology` element.  This is useful if you have a subclass of :class:`Technology` .
        
        :param root: The element tree tree to parse.
        :param parent: :class:`EagleFilePart` that will become the parent of :code:`this` .
        :rtype: :class:`Technology`
        """
        try:
            self.root = root
            
            if root.tag != "technology":
                raise EagleFormatError("Tried to create technology from " + root.tag)

            self.name=parseByType(parent, "str", None, root.get("name"))

            self.parent = parent

            ### populate the maps by searching for elements that match xpath and generating objects for them.

            for c in root.xpath("./attribute"):
                self.add_attribute(self.get_class_for_tag(c.tag)._from_et(c, self))

            ### Do the same for the lists


            ### Do the same for the attr lists


            ### And the singletons


            ### And, finally, if the objects wants the text from the tag.

        except SwoopError as e:
            e.text = "{}:{}".format(self._get_error_name(), e.text)
            raise e


    def sortkey(self):
        r = ""
        r = r + str(self.name)
        return r

    def get_et(self):
        """
        Generate a <technology> element tree for a :class:`Technology`.
        
        :rtype:  :class:`ElementTree`.
        
        """
        try:
            r = ET.Element("technology")

            ### Set the tag attributes 


            ## Unparse the values.

            v = unparseByType(self, "str", None,  self.name)

            ## For required attributes None becomes "".  For optional attributes, we just leave the attribute out.
            if not (isinstance(self.get_parent(), LibraryFile) and False):  # special case for the name of library.
                if v is not None:
                    r.set("name", v)
                else:
                    r.set("name", "")


            ### process the sections in order.  They have to be in section order,
            ### because eagle files are order dependent.


            ## For some tags, Eagle generates empty tags when there's no contant
            ## rather than just leaving the tag out.  We mark these with
            ## Tag.requireTag in GenerateSwoop.py and force their generation
            ## here.

            smartAddSubTags(r, "./attribute")


            ## add a map.

            if len(self.attributes) is not 0:
                target = smartAddSubTags(r, "./attribute")
                # add them in sorted order.  This gives us a simple canonicalization that makes it feasible to use diff to compare files.
                target.extend([i.get_et() for i in sorted(list(self.attributes.values()),key=lambda x: x.sortkey())])


            ## set the text, if its needed.

        except SwoopError as e:
            e.text = "{}:{}".format(self._get_error_name(), e.text)
            raise e
        return r

    def clone(self):
        """
        Recursively clone this :code:`Technology`.  It will be identical to the original, but it's parent will be :code:`None`.
        
        :rtype: :class:`Technology`
        """
        try:
            n = copy.copy(self)
            n.attributes = {}
            for x in list(self.attributes.values()):
                n.add_attribute(x.clone())
            n.parent = None
        except SwoopError as e:
            e.text = "{}:{}".format(self._get_error_name(), e.text)
            raise e
        return n

    def accept_preorder_visitor(self, visitor):
        try:
            pre = getattr(visitor, "Technology_pre")
            return pre(self)
        except AttributeError:
            return visitor.default_pre(self)
        
    def accept_postorder_visitor(self, visitor, context):
        try:
            post = getattr(visitor, "Technology_post")
            post(self,context)
        except AttributeError:
            visitor.default_post(self,context)

    def is_equal(self, other):
        """
        Check whether two :code:`EagleFilePart` objects are identical.
        
        :param other: Object to compare to.
        :returns: :code:`True` if they are identical, otherwise, :code:`False`
        """
        return self.get_xml() == other.get_xml()
        
    ### Getters/Setters for attribute values

    def get_name(self):
        """ Return the value of :code:`name` for this :class:`Technology`.  This corresponds to the :code:`name` attribute of a :code:`<technology>` in an Eagle file.
        
        :rtype: :code:`str`
        """
        return self.name

    def set_name(self,v):
        """ Set the value of :code:`name` for this  :class:`Technology`.  This corresponds to the :code:`name` attribute of a :code:`<technology>` in an Eagle file.

        :param v: new value
        :rtype: :code:`self`
        """
                        
        if not typeCheck("str", v, True):
            raise SwoopError("Illegal value ({}) of type {} for attribute 'name' of Technology object (should be str).".format(v, type(v)))
        self.name = v
        
        return self

    def with_name(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`name`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`name` equals :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_name()` is :code:`True`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """

        if type(v) in [str, int, float, bool]:
            return self if self.name == v else None
        elif callable(v):
            return self if v(self.name) else None
        else:
            raise SwoopError("Illegal type passed to with_name")

    def without_name(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`name`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`name` is not equal to :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_name()` is :code:`False`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """
        
        if type(v) in [str, int, float, bool]:
            return self if self.name != v else None
        elif callable(v):
            return self if not v(self.name) else None
        else:
            raise SwoopError("Illegal type passed to without_name")



    ##### Lookup functions that return EFPs instead of just attribute values.
    
    


    
    ### Adder/getter/lookup for lists
    


    ### Add, lookup, and get for maps
    def add_attribute(self, s):
        """ Add a :class:`Attribute` to the :code:`attributes` of this :class:`Technology`.

        :param s: The :class:`Attribute` to add.
        :rtype: :code:`self`
        """
        if not any([
                isinstance(s, Attribute),
            ]):
            raise SwoopError("Argument to Technology.add_attribute() should be of type Attribute.  Got " + str(type(s).__name__) + ".")
        

        self.attributes[s.get_name()] = s

        s.parent = self
        return self

    def get_nth_attribute(self, n):
        """ get then nth :class:`Attribute` object from the :code:`attributes` of this :class:`Technology`.
        
        :param n: Index of the item to return.

        :rtype: :class:`Attribute` object
        """
        return list(self.attributes.values())[n]

    def get_attribute(self, key):
        """ Lookup and return a :class:`Attribute` from the :code:`attributes` of  this :class:`Technology`.
        
        :param key: A :code:`str` to use for the lookup.  The lookup uses the :code:`name` of the :class:`Attribute` objects.

        :rtype: A :class:`Attribute` object or :code:`None`, if there is no such item.
        """
        return self.attributes.get(key)


    def get_attributes(self, attrs=None, type=None):
        """Return (and possibly filter) items in the the :code:`attributes` map of :class:`Attribute` objects for this :class:`Technology`.
        
        This functions provides a mechanism for filtering the items as well.
        The keys in :code:`attrs` are taken as attributes names and the
        values are requested values.  Items in the list that have all the
        requested values for the corresponding attributes will be returned.  

        A if :code:`type` is not :code:`None`, the item will match if it is an
        instance of the type provided.
        
        :param attrs: A set of key-value pairs that represent a filter to apply to the item's attributes.
        :param type:  A type to filter on.  Only items that are an instance of this type will be returned.
        :returns: A List of :class:`Attribute` objects
        :rtype: List of :class:`Attribute` objects
        """
        if attrs is not None or type is not None:
            raise NotImplementedError("filtered get not implemented")
        return list(self.attributes.values())
        

    def clear_attributes(self):
        """
        Remove all the :class:`Attribute` objects from the :code:`attributes` of this :class:`Technology`.
        
        :rtype: :code:`self`
        """
        for efp in list(self.attributes.values()):
            efp.parent = None
        self.attributes = {}
        return self

    def remove_attribute(self, efp):
        """
        Remove a :class:`Attribute` from the :code:`attributes` of this :class:`Technology`.
        
        :param efp: The :class:`Attribute` object to remove.

        :rtype: :code:`self`
        """
        if self.attributes[efp.get_name()] == efp:
            del self.attributes[efp.get_name()]
            efp.parent = None
            return self
        else:
            raise SwoopError("Tried to use remove_attribute() to delete the wrong kind of child?: {}".format(str(efp)))
    


    
    ### Getter/Setter for singletons.


    
    def get_children(self):
        """
        Get all the children of this :class:`EagleFilePart`.
        
        :rtype: List of :class:`EagleFilePart` objects
        """
        r = []


        r = r + list(self.attributes.values())


        return r

    def remove_child(self, efp):
        """
        Remove a child :class:`EagleFilePart` object.
        
        :param efp: the class:`EagleFilePart` object to remove.
        :return: Nothing
        """
        try:
            self.remove_attribute(efp)
        except:
            pass

    def _rekey_child(self, oldkey, efp):
        """
        Remove a child :class:`EagleFilePart` object.
        
        :param efp: the class:`EagleFilePart` object to remove.
        :return: Nothing
        """
        try:
            if self.get_attribute(oldkey) == efp:
                del self.attributes[oldkey]
                self.add_attribute(efp)
        except SwoopError:
            pass

    def check_sanity(self, visited_efps = None):
        EagleFilePart.check_sanity(self, visited_efps)

        # Check whether keys in our maps match the keys in our children
        for k in self.attributes:
            if self.attributes[k].get_name() != k:
                raise SwoopError("Child's name ('{}') doesn't match key in parent's map ('{}')".format(self.attributes[k].get_name(),k))

    def __str__(self):
        r = "["+repr(self)+" "
        r = r + "name:" + str(self.get_name()) + " "
        r = r + "]"
        return r
            
    def dump(self, indent="", increment="   "):
        """
        Recursive debug dump.
        
        :param indent:  Indentation string.  The output will be indented by this much.
        :param increment: This will be appendeded to :code:`indent` on recursive invocations.

        :rtype: :code:`None`
        """
        print(indent + str(self.__class__.__name__), end=' ')
        try:
            print(self.get_name())
        except:
            print()
            pass
        for c in self.get_children():
            c.dump(indent + "   ")

        
EagleFile.class_map["technology"] = Technology
         


class Port(EagleFilePart):
    """
    Class representing the contents of a <port> tag in Eagle files.

    Attributes:

    * :code:`name`

    * :code:`side`

    * :code:`dimension`

    * :code:`direction`


    """
    def __init__(self):
        """
        Construct an empty :class:`Port` object.
        """
        EagleFilePart.__init__(self)
        
        self.name=None
        self.side=None
        self.dimension=None
        self.direction=None


        
    @classmethod
    def _from_et(cls,root,parent):
        """
        Create a :class:`Port` from a :code:`port` element.
        
        :param root: The element tree tree to parse.
        :param parent: :class:`EagleFilePart` that should hold the resulting :class:`EagleFilePart`
        :rtype: :class:`Port`
        """
        ## Call the constructor
        n = cls()
        n._init_from_et(root,parent)
        return n

    def _get_error_name(self):
        if hasattr(self, "get_name"):
            return self.get_name();
        else:
            return "Port";
        
    def  _init_from_et(self, root, parent):
        """
        Initialized a :class:`Port` from a :code:`port` element.  This is useful if you have a subclass of :class:`Port` .
        
        :param root: The element tree tree to parse.
        :param parent: :class:`EagleFilePart` that will become the parent of :code:`this` .
        :rtype: :class:`Port`
        """
        try:
            self.root = root
            
            if root.tag != "port":
                raise EagleFormatError("Tried to create port from " + root.tag)

            self.name=parseByType(parent, "str", None, root.get("name"))
            self.side=parseByType(parent, "int", None, root.get("side"))
            self.dimension=parseByType(parent, "str", None, root.get("dimension"))
            self.direction=parseByType(parent, "str", None, root.get("direction"))

            self.parent = parent

            ### populate the maps by searching for elements that match xpath and generating objects for them.


            ### Do the same for the lists


            ### Do the same for the attr lists


            ### And the singletons


            ### And, finally, if the objects wants the text from the tag.

        except SwoopError as e:
            e.text = "{}:{}".format(self._get_error_name(), e.text)
            raise e


    def sortkey(self):
        r = ""
        r = r + str(self.name)
        r = r + str(self.side)
        r = r + str(self.dimension)
        r = r + str(self.direction)
        return r

    def get_et(self):
        """
        Generate a <port> element tree for a :class:`Port`.
        
        :rtype:  :class:`ElementTree`.
        
        """
        try:
            r = ET.Element("port")

            ### Set the tag attributes 


            ## Unparse the values.

            v = unparseByType(self, "str", None,  self.name)

            ## For required attributes None becomes "".  For optional attributes, we just leave the attribute out.
            if not (isinstance(self.get_parent(), LibraryFile) and False):  # special case for the name of library.
                if v is not None:
                    r.set("name", v)
                else:
                    r.set("name", "")


            ## Unparse the values.

            v = unparseByType(self, "int", None,  self.side)

            ## For required attributes None becomes "".  For optional attributes, we just leave the attribute out.
            if not (isinstance(self.get_parent(), LibraryFile) and False):  # special case for the name of library.
                if v is not None:
                    r.set("side", v)
                else:
                    r.set("side", "")


            ## Unparse the values.

            v = unparseByType(self, "str", None,  self.dimension)

            ## For required attributes None becomes "".  For optional attributes, we just leave the attribute out.
            if not (isinstance(self.get_parent(), LibraryFile) and False):  # special case for the name of library.
                if v is not None:
                    r.set("dimension", v)
                else:
                    r.set("dimension", "")


            ## Unparse the values.

            v = unparseByType(self, "str", None,  self.direction)

            ## For required attributes None becomes "".  For optional attributes, we just leave the attribute out.
            if not (isinstance(self.get_parent(), LibraryFile) and False):  # special case for the name of library.
                if v is not None:
                    r.set("direction", v)


            ### process the sections in order.  They have to be in section order,
            ### because eagle files are order dependent.


            ## set the text, if its needed.

        except SwoopError as e:
            e.text = "{}:{}".format(self._get_error_name(), e.text)
            raise e
        return r

    def clone(self):
        """
        Recursively clone this :code:`Port`.  It will be identical to the original, but it's parent will be :code:`None`.
        
        :rtype: :class:`Port`
        """
        try:
            n = copy.copy(self)
            n.parent = None
        except SwoopError as e:
            e.text = "{}:{}".format(self._get_error_name(), e.text)
            raise e
        return n

    def accept_preorder_visitor(self, visitor):
        try:
            pre = getattr(visitor, "Port_pre")
            return pre(self)
        except AttributeError:
            return visitor.default_pre(self)
        
    def accept_postorder_visitor(self, visitor, context):
        try:
            post = getattr(visitor, "Port_post")
            post(self,context)
        except AttributeError:
            visitor.default_post(self,context)

    def is_equal(self, other):
        """
        Check whether two :code:`EagleFilePart` objects are identical.
        
        :param other: Object to compare to.
        :returns: :code:`True` if they are identical, otherwise, :code:`False`
        """
        return self.get_xml() == other.get_xml()
        
    ### Getters/Setters for attribute values

    def get_name(self):
        """ Return the value of :code:`name` for this :class:`Port`.  This corresponds to the :code:`name` attribute of a :code:`<port>` in an Eagle file.
        
        :rtype: :code:`str`
        """
        return self.name

    def set_name(self,v):
        """ Set the value of :code:`name` for this  :class:`Port`.  This corresponds to the :code:`name` attribute of a :code:`<port>` in an Eagle file.

        :param v: new value
        :rtype: :code:`self`
        """
                        
        oldkey = self.name
        if not typeCheck("str", v, True):
            raise SwoopError("Illegal value ({}) of type {} for attribute 'name' of Port object (should be str).".format(v, type(v)))
        self.name = v
        
        if self.get_parent() is not None:
            self.get_parent()._rekey_child(oldkey, self);
        return self

    def with_name(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`name`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`name` equals :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_name()` is :code:`True`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """

        if type(v) in [str, int, float, bool]:
            return self if self.name == v else None
        elif callable(v):
            return self if v(self.name) else None
        else:
            raise SwoopError("Illegal type passed to with_name")

    def without_name(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`name`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`name` is not equal to :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_name()` is :code:`False`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """
        
        if type(v) in [str, int, float, bool]:
            return self if self.name != v else None
        elif callable(v):
            return self if not v(self.name) else None
        else:
            raise SwoopError("Illegal type passed to without_name")


    def get_side(self):
        """ Return the value of :code:`side` for this :class:`Port`.  This corresponds to the :code:`side` attribute of a :code:`<port>` in an Eagle file.
        
        :rtype: :code:`int`
        """
        return self.side

    def set_side(self,v):
        """ Set the value of :code:`side` for this  :class:`Port`.  This corresponds to the :code:`side` attribute of a :code:`<port>` in an Eagle file.

        :param v: new value
        :rtype: :code:`self`
        """
                        
        if not typeCheck("int", v, True):
            raise SwoopError("Illegal value ({}) of type {} for attribute 'side' of Port object (should be int).".format(v, type(v)))
        self.side = v
        
        return self

    def with_side(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`side`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`side` equals :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_side()` is :code:`True`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """

        if type(v) in [str, int, float, bool]:
            return self if self.side == v else None
        elif callable(v):
            return self if v(self.side) else None
        else:
            raise SwoopError("Illegal type passed to with_side")

    def without_side(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`side`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`side` is not equal to :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_side()` is :code:`False`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """
        
        if type(v) in [str, int, float, bool]:
            return self if self.side != v else None
        elif callable(v):
            return self if not v(self.side) else None
        else:
            raise SwoopError("Illegal type passed to without_side")


    def get_dimension(self):
        """ Return the value of :code:`dimension` for this :class:`Port`.  This corresponds to the :code:`dimension` attribute of a :code:`<port>` in an Eagle file.
        
        :rtype: :code:`str`
        """
        return self.dimension

    def set_dimension(self,v):
        """ Set the value of :code:`dimension` for this  :class:`Port`.  This corresponds to the :code:`dimension` attribute of a :code:`<port>` in an Eagle file.

        :param v: new value
        :rtype: :code:`self`
        """
                        
        if not typeCheck("str", v, True):
            raise SwoopError("Illegal value ({}) of type {} for attribute 'dimension' of Port object (should be str).".format(v, type(v)))
        self.dimension = v
        
        return self

    def with_dimension(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`dimension`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`dimension` equals :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_dimension()` is :code:`True`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """

        if type(v) in [str, int, float, bool]:
            return self if self.dimension == v else None
        elif callable(v):
            return self if v(self.dimension) else None
        else:
            raise SwoopError("Illegal type passed to with_dimension")

    def without_dimension(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`dimension`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`dimension` is not equal to :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_dimension()` is :code:`False`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """
        
        if type(v) in [str, int, float, bool]:
            return self if self.dimension != v else None
        elif callable(v):
            return self if not v(self.dimension) else None
        else:
            raise SwoopError("Illegal type passed to without_dimension")


    def get_direction(self):
        """ Return the value of :code:`direction` for this :class:`Port`.  This corresponds to the :code:`direction` attribute of a :code:`<port>` in an Eagle file.
        
        :rtype: :code:`str`
        """
        return self.direction

    def set_direction(self,v):
        """ Set the value of :code:`direction` for this  :class:`Port`.  This corresponds to the :code:`direction` attribute of a :code:`<port>` in an Eagle file.

        :param v: new value
        :rtype: :code:`self`
        """
                        
        if not typeCheck("str", v, False):
            raise SwoopError("Illegal value ({}) of type {} for attribute 'direction' of Port object (should be str).".format(v, type(v)))
        self.direction = v
        
        return self

    def with_direction(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`direction`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`direction` equals :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_direction()` is :code:`True`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """

        if type(v) in [str, int, float, bool]:
            return self if self.direction == v else None
        elif callable(v):
            return self if v(self.direction) else None
        else:
            raise SwoopError("Illegal type passed to with_direction")

    def without_direction(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`direction`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`direction` is not equal to :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_direction()` is :code:`False`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """
        
        if type(v) in [str, int, float, bool]:
            return self if self.direction != v else None
        elif callable(v):
            return self if not v(self.direction) else None
        else:
            raise SwoopError("Illegal type passed to without_direction")



    ##### Lookup functions that return EFPs instead of just attribute values.
    
    


    
    ### Adder/getter/lookup for lists
    


    ### Add, lookup, and get for maps


    
    ### Getter/Setter for singletons.


    
    def get_children(self):
        """
        Get all the children of this :class:`EagleFilePart`.
        
        :rtype: List of :class:`EagleFilePart` objects
        """
        r = []




        return r

    def remove_child(self, efp):
        """
        Remove a child :class:`EagleFilePart` object.
        
        :param efp: the class:`EagleFilePart` object to remove.
        :return: Nothing
        """

    def _rekey_child(self, oldkey, efp):
        """
        Remove a child :class:`EagleFilePart` object.
        
        :param efp: the class:`EagleFilePart` object to remove.
        :return: Nothing
        """


    def __str__(self):
        r = "["+repr(self)+" "
        r = r + "name:" + str(self.get_name()) + " "
        r = r + "side:" + str(self.get_side()) + " "
        r = r + "dimension:" + str(self.get_dimension()) + " "
        r = r + "direction:" + str(self.get_direction()) + " "
        r = r + "]"
        return r
            
    def dump(self, indent="", increment="   "):
        """
        Recursive debug dump.
        
        :param indent:  Indentation string.  The output will be indented by this much.
        :param increment: This will be appendeded to :code:`indent` on recursive invocations.

        :rtype: :code:`None`
        """
        print(indent + str(self.__class__.__name__), end=' ')
        try:
            print(self.get_name())
        except:
            print()
            pass
        for c in self.get_children():
            c.dump(indent + "   ")

        
EagleFile.class_map["port"] = Port
         


class Approved(EagleFilePart):
    """
    Class representing the contents of a <approved> tag in Eagle files.

    Attributes:

    * :code:`hash`


    """
    def __init__(self):
        """
        Construct an empty :class:`Approved` object.
        """
        EagleFilePart.__init__(self)
        
        self.hash=None


        
    @classmethod
    def _from_et(cls,root,parent):
        """
        Create a :class:`Approved` from a :code:`approved` element.
        
        :param root: The element tree tree to parse.
        :param parent: :class:`EagleFilePart` that should hold the resulting :class:`EagleFilePart`
        :rtype: :class:`Approved`
        """
        ## Call the constructor
        n = cls()
        n._init_from_et(root,parent)
        return n

    def _get_error_name(self):
        if hasattr(self, "get_name"):
            return self.get_name();
        else:
            return "Approved";
        
    def  _init_from_et(self, root, parent):
        """
        Initialized a :class:`Approved` from a :code:`approved` element.  This is useful if you have a subclass of :class:`Approved` .
        
        :param root: The element tree tree to parse.
        :param parent: :class:`EagleFilePart` that will become the parent of :code:`this` .
        :rtype: :class:`Approved`
        """
        try:
            self.root = root
            
            if root.tag != "approved":
                raise EagleFormatError("Tried to create approved from " + root.tag)

            self.hash=parseByType(parent, "str", None, root.get("hash"))

            self.parent = parent

            ### populate the maps by searching for elements that match xpath and generating objects for them.


            ### Do the same for the lists


            ### Do the same for the attr lists


            ### And the singletons


            ### And, finally, if the objects wants the text from the tag.

        except SwoopError as e:
            e.text = "{}:{}".format(self._get_error_name(), e.text)
            raise e


    def sortkey(self):
        r = ""
        r = r + str(self.hash)
        return r

    def get_et(self):
        """
        Generate a <approved> element tree for a :class:`Approved`.
        
        :rtype:  :class:`ElementTree`.
        
        """
        try:
            r = ET.Element("approved")

            ### Set the tag attributes 


            ## Unparse the values.

            v = unparseByType(self, "str", None,  self.hash)

            ## For required attributes None becomes "".  For optional attributes, we just leave the attribute out.
            if not (isinstance(self.get_parent(), LibraryFile) and False):  # special case for the name of library.
                if v is not None:
                    r.set("hash", v)
                else:
                    r.set("hash", "")


            ### process the sections in order.  They have to be in section order,
            ### because eagle files are order dependent.


            ## set the text, if its needed.

        except SwoopError as e:
            e.text = "{}:{}".format(self._get_error_name(), e.text)
            raise e
        return r

    def clone(self):
        """
        Recursively clone this :code:`Approved`.  It will be identical to the original, but it's parent will be :code:`None`.
        
        :rtype: :class:`Approved`
        """
        try:
            n = copy.copy(self)
            n.parent = None
        except SwoopError as e:
            e.text = "{}:{}".format(self._get_error_name(), e.text)
            raise e
        return n

    def accept_preorder_visitor(self, visitor):
        try:
            pre = getattr(visitor, "Approved_pre")
            return pre(self)
        except AttributeError:
            return visitor.default_pre(self)
        
    def accept_postorder_visitor(self, visitor, context):
        try:
            post = getattr(visitor, "Approved_post")
            post(self,context)
        except AttributeError:
            visitor.default_post(self,context)

    def is_equal(self, other):
        """
        Check whether two :code:`EagleFilePart` objects are identical.
        
        :param other: Object to compare to.
        :returns: :code:`True` if they are identical, otherwise, :code:`False`
        """
        return self.get_xml() == other.get_xml()
        
    ### Getters/Setters for attribute values

    def get_hash(self):
        """ Return the value of :code:`hash` for this :class:`Approved`.  This corresponds to the :code:`hash` attribute of a :code:`<approved>` in an Eagle file.
        
        :rtype: :code:`str`
        """
        return self.hash

    def set_hash(self,v):
        """ Set the value of :code:`hash` for this  :class:`Approved`.  This corresponds to the :code:`hash` attribute of a :code:`<approved>` in an Eagle file.

        :param v: new value
        :rtype: :code:`self`
        """
                        
        if not typeCheck("str", v, True):
            raise SwoopError("Illegal value ({}) of type {} for attribute 'hash' of Approved object (should be str).".format(v, type(v)))
        self.hash = v
        
        return self

    def with_hash(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`hash`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`hash` equals :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_hash()` is :code:`True`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """

        if type(v) in [str, int, float, bool]:
            return self if self.hash == v else None
        elif callable(v):
            return self if v(self.hash) else None
        else:
            raise SwoopError("Illegal type passed to with_hash")

    def without_hash(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`hash`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`hash` is not equal to :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_hash()` is :code:`False`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """
        
        if type(v) in [str, int, float, bool]:
            return self if self.hash != v else None
        elif callable(v):
            return self if not v(self.hash) else None
        else:
            raise SwoopError("Illegal type passed to without_hash")



    ##### Lookup functions that return EFPs instead of just attribute values.
    
    


    
    ### Adder/getter/lookup for lists
    


    ### Add, lookup, and get for maps


    
    ### Getter/Setter for singletons.


    
    def get_children(self):
        """
        Get all the children of this :class:`EagleFilePart`.
        
        :rtype: List of :class:`EagleFilePart` objects
        """
        r = []




        return r

    def remove_child(self, efp):
        """
        Remove a child :class:`EagleFilePart` object.
        
        :param efp: the class:`EagleFilePart` object to remove.
        :return: Nothing
        """

    def _rekey_child(self, oldkey, efp):
        """
        Remove a child :class:`EagleFilePart` object.
        
        :param efp: the class:`EagleFilePart` object to remove.
        :return: Nothing
        """


    def __str__(self):
        r = "["+repr(self)+" "
        r = r + "hash:" + str(self.get_hash()) + " "
        r = r + "]"
        return r
            
    def dump(self, indent="", increment="   "):
        """
        Recursive debug dump.
        
        :param indent:  Indentation string.  The output will be indented by this much.
        :param increment: This will be appendeded to :code:`indent` on recursive invocations.

        :rtype: :code:`None`
        """
        print(indent + str(self.__class__.__name__), end=' ')
        try:
            print(self.get_name())
        except:
            print()
            pass
        for c in self.get_children():
            c.dump(indent + "   ")

        
EagleFile.class_map["approved"] = Approved
         


class Wire(EagleFilePart, LineGeometry):
    """
    Class representing the contents of a <wire> tag in Eagle files.

    Attributes:

    * :code:`x1`

    * :code:`y1`

    * :code:`x2`

    * :code:`y2`

    * :code:`width`

    * :code:`layer`

    * :code:`extent`

    * :code:`style`

    * :code:`curve`

    * :code:`cap`


    """
    def __init__(self):
        """
        Construct an empty :class:`Wire` object.
        """
        EagleFilePart.__init__(self)
        LineGeometry.__init__(self)
        
        self.x1=None
        self.y1=None
        self.x2=None
        self.y2=None
        self.width=None
        self.layer=None
        self.extent=None
        self.style=None
        self.curve=None
        self.cap=None


        
    @classmethod
    def _from_et(cls,root,parent):
        """
        Create a :class:`Wire` from a :code:`wire` element.
        
        :param root: The element tree tree to parse.
        :param parent: :class:`EagleFilePart` that should hold the resulting :class:`EagleFilePart`
        :rtype: :class:`Wire`
        """
        ## Call the constructor
        n = cls()
        n._init_from_et(root,parent)
        return n

    def _get_error_name(self):
        if hasattr(self, "get_name"):
            return self.get_name();
        else:
            return "Wire";
        
    def  _init_from_et(self, root, parent):
        """
        Initialized a :class:`Wire` from a :code:`wire` element.  This is useful if you have a subclass of :class:`Wire` .
        
        :param root: The element tree tree to parse.
        :param parent: :class:`EagleFilePart` that will become the parent of :code:`this` .
        :rtype: :class:`Wire`
        """
        try:
            self.root = root
            
            if root.tag != "wire":
                raise EagleFormatError("Tried to create wire from " + root.tag)

            self.x1=parseByType(parent, "float", None, root.get("x1"))
            self.y1=parseByType(parent, "float", None, root.get("y1"))
            self.x2=parseByType(parent, "float", None, root.get("x2"))
            self.y2=parseByType(parent, "float", None, root.get("y2"))
            self.width=parseByType(parent, "float", None, root.get("width"))
            self.layer=parseByType(parent, "layer_string", None, root.get("layer"))
            self.extent=parseByType(parent, "str", None, root.get("extent"))
            self.style=parseByType(parent, "str", None, root.get("style"))
            self.curve=parseByType(parent, "None_is_default_float", 0.0, root.get("curve"))
            self.cap=parseByType(parent, "str", None, root.get("cap"))

            self.parent = parent

            ### populate the maps by searching for elements that match xpath and generating objects for them.


            ### Do the same for the lists


            ### Do the same for the attr lists


            ### And the singletons


            ### And, finally, if the objects wants the text from the tag.

        except SwoopError as e:
            e.text = "{}:{}".format(self._get_error_name(), e.text)
            raise e


    def sortkey(self):
        r = ""
        r = r + str(self.x1)
        r = r + str(self.y1)
        r = r + str(self.x2)
        r = r + str(self.y2)
        r = r + str(self.width)
        r = r + str(self.layer)
        r = r + str(self.extent)
        r = r + str(self.style)
        r = r + str(self.curve)
        r = r + str(self.cap)
        return r

    def get_et(self):
        """
        Generate a <wire> element tree for a :class:`Wire`.
        
        :rtype:  :class:`ElementTree`.
        
        """
        try:
            r = ET.Element("wire")

            ### Set the tag attributes 


            ## Unparse the values.

            v = unparseByType(self, "float", None,  self.x1)

            ## For required attributes None becomes "".  For optional attributes, we just leave the attribute out.
            if not (isinstance(self.get_parent(), LibraryFile) and False):  # special case for the name of library.
                if v is not None:
                    r.set("x1", v)
                else:
                    r.set("x1", "")


            ## Unparse the values.

            v = unparseByType(self, "float", None,  self.y1)

            ## For required attributes None becomes "".  For optional attributes, we just leave the attribute out.
            if not (isinstance(self.get_parent(), LibraryFile) and False):  # special case for the name of library.
                if v is not None:
                    r.set("y1", v)
                else:
                    r.set("y1", "")


            ## Unparse the values.

            v = unparseByType(self, "float", None,  self.x2)

            ## For required attributes None becomes "".  For optional attributes, we just leave the attribute out.
            if not (isinstance(self.get_parent(), LibraryFile) and False):  # special case for the name of library.
                if v is not None:
                    r.set("x2", v)
                else:
                    r.set("x2", "")


            ## Unparse the values.

            v = unparseByType(self, "float", None,  self.y2)

            ## For required attributes None becomes "".  For optional attributes, we just leave the attribute out.
            if not (isinstance(self.get_parent(), LibraryFile) and False):  # special case for the name of library.
                if v is not None:
                    r.set("y2", v)
                else:
                    r.set("y2", "")


            ## Unparse the values.

            v = unparseByType(self, "float", None,  self.width)

            ## For required attributes None becomes "".  For optional attributes, we just leave the attribute out.
            if not (isinstance(self.get_parent(), LibraryFile) and False):  # special case for the name of library.
                if v is not None:
                    r.set("width", v)
                else:
                    r.set("width", "")


            ## Unparse the values.

            v = unparseByType(self, "layer_string", None,  self.layer)

            ## For required attributes None becomes "".  For optional attributes, we just leave the attribute out.
            if not (isinstance(self.get_parent(), LibraryFile) and False):  # special case for the name of library.
                if v is not None:
                    r.set("layer", v)
                else:
                    r.set("layer", "")


            ## Unparse the values.

            v = unparseByType(self, "str", None,  self.extent)

            ## For required attributes None becomes "".  For optional attributes, we just leave the attribute out.
            if not (isinstance(self.get_parent(), LibraryFile) and False):  # special case for the name of library.
                if v is not None:
                    r.set("extent", v)


            ## Unparse the values.

            v = unparseByType(self, "str", None,  self.style)

            ## For required attributes None becomes "".  For optional attributes, we just leave the attribute out.
            if not (isinstance(self.get_parent(), LibraryFile) and False):  # special case for the name of library.
                if v is not None:
                    r.set("style", v)


            ## Unparse the values.

            v = unparseByType(self, "None_is_default_float", 0.0,  self.curve)

            ## For required attributes None becomes "".  For optional attributes, we just leave the attribute out.
            if not (isinstance(self.get_parent(), LibraryFile) and False):  # special case for the name of library.
                if v is not None:
                    r.set("curve", v)


            ## Unparse the values.

            v = unparseByType(self, "str", None,  self.cap)

            ## For required attributes None becomes "".  For optional attributes, we just leave the attribute out.
            if not (isinstance(self.get_parent(), LibraryFile) and False):  # special case for the name of library.
                if v is not None:
                    r.set("cap", v)


            ### process the sections in order.  They have to be in section order,
            ### because eagle files are order dependent.


            ## set the text, if its needed.

        except SwoopError as e:
            e.text = "{}:{}".format(self._get_error_name(), e.text)
            raise e
        return r

    def clone(self):
        """
        Recursively clone this :code:`Wire`.  It will be identical to the original, but it's parent will be :code:`None`.
        
        :rtype: :class:`Wire`
        """
        try:
            n = copy.copy(self)
            n.parent = None
        except SwoopError as e:
            e.text = "{}:{}".format(self._get_error_name(), e.text)
            raise e
        return n

    def accept_preorder_visitor(self, visitor):
        try:
            pre = getattr(visitor, "Wire_pre")
            return pre(self)
        except AttributeError:
            return visitor.default_pre(self)
        
    def accept_postorder_visitor(self, visitor, context):
        try:
            post = getattr(visitor, "Wire_post")
            post(self,context)
        except AttributeError:
            visitor.default_post(self,context)

    def is_equal(self, other):
        """
        Check whether two :code:`EagleFilePart` objects are identical.
        
        :param other: Object to compare to.
        :returns: :code:`True` if they are identical, otherwise, :code:`False`
        """
        return self.get_xml() == other.get_xml()
        
    ### Getters/Setters for attribute values

    def get_x1(self):
        """ Return the value of :code:`x1` for this :class:`Wire`.  This corresponds to the :code:`x1` attribute of a :code:`<wire>` in an Eagle file.
        
        :rtype: :code:`float`
        """
        return self.x1

    def set_x1(self,v):
        """ Set the value of :code:`x1` for this  :class:`Wire`.  This corresponds to the :code:`x1` attribute of a :code:`<wire>` in an Eagle file.

        :param v: new value
        :rtype: :code:`self`
        """
                        
        if not typeCheck("float", v, True):
            raise SwoopError("Illegal value ({}) of type {} for attribute 'x1' of Wire object (should be float).".format(v, type(v)))
        self.x1 = v
        
        return self

    def with_x1(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`x1`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`x1` equals :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_x1()` is :code:`True`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """

        if type(v) in [str, int, float, bool]:
            return self if self.x1 == v else None
        elif callable(v):
            return self if v(self.x1) else None
        else:
            raise SwoopError("Illegal type passed to with_x1")

    def without_x1(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`x1`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`x1` is not equal to :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_x1()` is :code:`False`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """
        
        if type(v) in [str, int, float, bool]:
            return self if self.x1 != v else None
        elif callable(v):
            return self if not v(self.x1) else None
        else:
            raise SwoopError("Illegal type passed to without_x1")


    def get_y1(self):
        """ Return the value of :code:`y1` for this :class:`Wire`.  This corresponds to the :code:`y1` attribute of a :code:`<wire>` in an Eagle file.
        
        :rtype: :code:`float`
        """
        return self.y1

    def set_y1(self,v):
        """ Set the value of :code:`y1` for this  :class:`Wire`.  This corresponds to the :code:`y1` attribute of a :code:`<wire>` in an Eagle file.

        :param v: new value
        :rtype: :code:`self`
        """
                        
        if not typeCheck("float", v, True):
            raise SwoopError("Illegal value ({}) of type {} for attribute 'y1' of Wire object (should be float).".format(v, type(v)))
        self.y1 = v
        
        return self

    def with_y1(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`y1`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`y1` equals :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_y1()` is :code:`True`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """

        if type(v) in [str, int, float, bool]:
            return self if self.y1 == v else None
        elif callable(v):
            return self if v(self.y1) else None
        else:
            raise SwoopError("Illegal type passed to with_y1")

    def without_y1(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`y1`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`y1` is not equal to :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_y1()` is :code:`False`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """
        
        if type(v) in [str, int, float, bool]:
            return self if self.y1 != v else None
        elif callable(v):
            return self if not v(self.y1) else None
        else:
            raise SwoopError("Illegal type passed to without_y1")


    def get_x2(self):
        """ Return the value of :code:`x2` for this :class:`Wire`.  This corresponds to the :code:`x2` attribute of a :code:`<wire>` in an Eagle file.
        
        :rtype: :code:`float`
        """
        return self.x2

    def set_x2(self,v):
        """ Set the value of :code:`x2` for this  :class:`Wire`.  This corresponds to the :code:`x2` attribute of a :code:`<wire>` in an Eagle file.

        :param v: new value
        :rtype: :code:`self`
        """
                        
        if not typeCheck("float", v, True):
            raise SwoopError("Illegal value ({}) of type {} for attribute 'x2' of Wire object (should be float).".format(v, type(v)))
        self.x2 = v
        
        return self

    def with_x2(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`x2`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`x2` equals :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_x2()` is :code:`True`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """

        if type(v) in [str, int, float, bool]:
            return self if self.x2 == v else None
        elif callable(v):
            return self if v(self.x2) else None
        else:
            raise SwoopError("Illegal type passed to with_x2")

    def without_x2(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`x2`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`x2` is not equal to :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_x2()` is :code:`False`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """
        
        if type(v) in [str, int, float, bool]:
            return self if self.x2 != v else None
        elif callable(v):
            return self if not v(self.x2) else None
        else:
            raise SwoopError("Illegal type passed to without_x2")


    def get_y2(self):
        """ Return the value of :code:`y2` for this :class:`Wire`.  This corresponds to the :code:`y2` attribute of a :code:`<wire>` in an Eagle file.
        
        :rtype: :code:`float`
        """
        return self.y2

    def set_y2(self,v):
        """ Set the value of :code:`y2` for this  :class:`Wire`.  This corresponds to the :code:`y2` attribute of a :code:`<wire>` in an Eagle file.

        :param v: new value
        :rtype: :code:`self`
        """
                        
        if not typeCheck("float", v, True):
            raise SwoopError("Illegal value ({}) of type {} for attribute 'y2' of Wire object (should be float).".format(v, type(v)))
        self.y2 = v
        
        return self

    def with_y2(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`y2`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`y2` equals :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_y2()` is :code:`True`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """

        if type(v) in [str, int, float, bool]:
            return self if self.y2 == v else None
        elif callable(v):
            return self if v(self.y2) else None
        else:
            raise SwoopError("Illegal type passed to with_y2")

    def without_y2(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`y2`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`y2` is not equal to :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_y2()` is :code:`False`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """
        
        if type(v) in [str, int, float, bool]:
            return self if self.y2 != v else None
        elif callable(v):
            return self if not v(self.y2) else None
        else:
            raise SwoopError("Illegal type passed to without_y2")


    def get_width(self):
        """ Return the value of :code:`width` for this :class:`Wire`.  This corresponds to the :code:`width` attribute of a :code:`<wire>` in an Eagle file.
        
        :rtype: :code:`float`
        """
        return self.width

    def set_width(self,v):
        """ Set the value of :code:`width` for this  :class:`Wire`.  This corresponds to the :code:`width` attribute of a :code:`<wire>` in an Eagle file.

        :param v: new value
        :rtype: :code:`self`
        """
                        
        if not typeCheck("float", v, True):
            raise SwoopError("Illegal value ({}) of type {} for attribute 'width' of Wire object (should be float).".format(v, type(v)))
        self.width = v
        
        return self

    def with_width(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`width`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`width` equals :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_width()` is :code:`True`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """

        if type(v) in [str, int, float, bool]:
            return self if self.width == v else None
        elif callable(v):
            return self if v(self.width) else None
        else:
            raise SwoopError("Illegal type passed to with_width")

    def without_width(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`width`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`width` is not equal to :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_width()` is :code:`False`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """
        
        if type(v) in [str, int, float, bool]:
            return self if self.width != v else None
        elif callable(v):
            return self if not v(self.width) else None
        else:
            raise SwoopError("Illegal type passed to without_width")


    def get_layer(self):
        """ Return the value of :code:`layer` for this :class:`Wire`.  This corresponds to the :code:`layer` attribute of a :code:`<wire>` in an Eagle file.
        
        :rtype: :code:`layer_string`
        """
        return self.layer

    def set_layer(self,v):
        """ Set the value of :code:`layer` for this  :class:`Wire`.  This corresponds to the :code:`layer` attribute of a :code:`<wire>` in an Eagle file.

        :param v: new value
        :rtype: :code:`self`
        """
                        
        if not typeCheck("layer_string", v, True):
            raise SwoopError("Illegal value ({}) of type {} for attribute 'layer' of Wire object (should be layer_string).".format(v, type(v)))
        self.layer = v
        
        return self

    def with_layer(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`layer`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`layer` equals :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_layer()` is :code:`True`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """

        if type(v) in [str, int, float, bool]:
            return self if self.layer == v else None
        elif callable(v):
            return self if v(self.layer) else None
        else:
            raise SwoopError("Illegal type passed to with_layer")

    def without_layer(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`layer`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`layer` is not equal to :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_layer()` is :code:`False`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """
        
        if type(v) in [str, int, float, bool]:
            return self if self.layer != v else None
        elif callable(v):
            return self if not v(self.layer) else None
        else:
            raise SwoopError("Illegal type passed to without_layer")


    def get_extent(self):
        """ Return the value of :code:`extent` for this :class:`Wire`.  This corresponds to the :code:`extent` attribute of a :code:`<wire>` in an Eagle file.
        
        :rtype: :code:`str`
        """
        return self.extent

    def set_extent(self,v):
        """ Set the value of :code:`extent` for this  :class:`Wire`.  This corresponds to the :code:`extent` attribute of a :code:`<wire>` in an Eagle file.

        :param v: new value
        :rtype: :code:`self`
        """
                        
        if not typeCheck("str", v, False):
            raise SwoopError("Illegal value ({}) of type {} for attribute 'extent' of Wire object (should be str).".format(v, type(v)))
        self.extent = v
        
        return self

    def with_extent(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`extent`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`extent` equals :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_extent()` is :code:`True`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """

        if type(v) in [str, int, float, bool]:
            return self if self.extent == v else None
        elif callable(v):
            return self if v(self.extent) else None
        else:
            raise SwoopError("Illegal type passed to with_extent")

    def without_extent(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`extent`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`extent` is not equal to :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_extent()` is :code:`False`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """
        
        if type(v) in [str, int, float, bool]:
            return self if self.extent != v else None
        elif callable(v):
            return self if not v(self.extent) else None
        else:
            raise SwoopError("Illegal type passed to without_extent")


    def get_style(self):
        """ Return the value of :code:`style` for this :class:`Wire`.  This corresponds to the :code:`style` attribute of a :code:`<wire>` in an Eagle file.
        
        :rtype: :code:`str`
        """
        return self.style

    def set_style(self,v):
        """ Set the value of :code:`style` for this  :class:`Wire`.  This corresponds to the :code:`style` attribute of a :code:`<wire>` in an Eagle file.

        :param v: new value
        :rtype: :code:`self`
        """
                        
        if not typeCheck("str", v, False):
            raise SwoopError("Illegal value ({}) of type {} for attribute 'style' of Wire object (should be str).".format(v, type(v)))
        self.style = v
        
        return self

    def with_style(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`style`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`style` equals :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_style()` is :code:`True`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """

        if type(v) in [str, int, float, bool]:
            return self if self.style == v else None
        elif callable(v):
            return self if v(self.style) else None
        else:
            raise SwoopError("Illegal type passed to with_style")

    def without_style(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`style`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`style` is not equal to :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_style()` is :code:`False`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """
        
        if type(v) in [str, int, float, bool]:
            return self if self.style != v else None
        elif callable(v):
            return self if not v(self.style) else None
        else:
            raise SwoopError("Illegal type passed to without_style")


    def get_curve(self):
        """ Return the value of :code:`curve` for this :class:`Wire`.  This corresponds to the :code:`curve` attribute of a :code:`<wire>` in an Eagle file.
        
        :rtype: :code:`None_is_default_float`
        """
        return self.curve

    def set_curve(self,v):
        """ Set the value of :code:`curve` for this  :class:`Wire`.  This corresponds to the :code:`curve` attribute of a :code:`<wire>` in an Eagle file.

        :param v: new value
        :rtype: :code:`self`
        """
                        
        if not typeCheck("None_is_default_float", v, False):
            raise SwoopError("Illegal value ({}) of type {} for attribute 'curve' of Wire object (should be None_is_default_float).".format(v, type(v)))
        self.curve = v
        
        return self

    def with_curve(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`curve`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`curve` equals :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_curve()` is :code:`True`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """

        if type(v) in [str, int, float, bool]:
            return self if self.curve == v else None
        elif callable(v):
            return self if v(self.curve) else None
        else:
            raise SwoopError("Illegal type passed to with_curve")

    def without_curve(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`curve`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`curve` is not equal to :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_curve()` is :code:`False`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """
        
        if type(v) in [str, int, float, bool]:
            return self if self.curve != v else None
        elif callable(v):
            return self if not v(self.curve) else None
        else:
            raise SwoopError("Illegal type passed to without_curve")


    def get_cap(self):
        """ Return the value of :code:`cap` for this :class:`Wire`.  This corresponds to the :code:`cap` attribute of a :code:`<wire>` in an Eagle file.
        
        :rtype: :code:`str`
        """
        return self.cap

    def set_cap(self,v):
        """ Set the value of :code:`cap` for this  :class:`Wire`.  This corresponds to the :code:`cap` attribute of a :code:`<wire>` in an Eagle file.

        :param v: new value
        :rtype: :code:`self`
        """
                        
        if not typeCheck("str", v, False):
            raise SwoopError("Illegal value ({}) of type {} for attribute 'cap' of Wire object (should be str).".format(v, type(v)))
        self.cap = v
        
        return self

    def with_cap(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`cap`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`cap` equals :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_cap()` is :code:`True`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """

        if type(v) in [str, int, float, bool]:
            return self if self.cap == v else None
        elif callable(v):
            return self if v(self.cap) else None
        else:
            raise SwoopError("Illegal type passed to with_cap")

    def without_cap(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`cap`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`cap` is not equal to :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_cap()` is :code:`False`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """
        
        if type(v) in [str, int, float, bool]:
            return self if self.cap != v else None
        elif callable(v):
            return self if not v(self.cap) else None
        else:
            raise SwoopError("Illegal type passed to without_cap")



    ##### Lookup functions that return EFPs instead of just attribute values.
    
    


    
    ### Adder/getter/lookup for lists
    


    ### Add, lookup, and get for maps


    
    ### Getter/Setter for singletons.


    
    def get_children(self):
        """
        Get all the children of this :class:`EagleFilePart`.
        
        :rtype: List of :class:`EagleFilePart` objects
        """
        r = []




        return r

    def remove_child(self, efp):
        """
        Remove a child :class:`EagleFilePart` object.
        
        :param efp: the class:`EagleFilePart` object to remove.
        :return: Nothing
        """

    def _rekey_child(self, oldkey, efp):
        """
        Remove a child :class:`EagleFilePart` object.
        
        :param efp: the class:`EagleFilePart` object to remove.
        :return: Nothing
        """


    def __str__(self):
        r = "["+repr(self)+" "
        r = r + "x1:" + str(self.get_x1()) + " "
        r = r + "y1:" + str(self.get_y1()) + " "
        r = r + "x2:" + str(self.get_x2()) + " "
        r = r + "y2:" + str(self.get_y2()) + " "
        r = r + "width:" + str(self.get_width()) + " "
        r = r + "layer:" + str(self.get_layer()) + " "
        r = r + "extent:" + str(self.get_extent()) + " "
        r = r + "style:" + str(self.get_style()) + " "
        r = r + "curve:" + str(self.get_curve()) + " "
        r = r + "cap:" + str(self.get_cap()) + " "
        r = r + "]"
        return r
            
    def dump(self, indent="", increment="   "):
        """
        Recursive debug dump.
        
        :param indent:  Indentation string.  The output will be indented by this much.
        :param increment: This will be appendeded to :code:`indent` on recursive invocations.

        :rtype: :code:`None`
        """
        print(indent + str(self.__class__.__name__), end=' ')
        try:
            print(self.get_name())
        except:
            print()
            pass
        for c in self.get_children():
            c.dump(indent + "   ")

        
EagleFile.class_map["wire"] = Wire
         


class Sheet(EagleFilePart):
    """
    Class representing the contents of a <sheet> tag in Eagle files.

    Attributes:



    Collections:

    * :code:`description`: Singleton :class:`Description` object. 


    * :code:`plain_element`: List of :class:`Polygon`, :class:`Wire`, :class:`Text`, :class:`Dimension`, :class:`Circle`, :class:`Rectangle`, :class:`Frame` and :class:`Hole` objects.

    * :code:`instance`: List of :class:`Instance` objects.


    * :code:`moduleinst`: Map of :class:`Moduleinst` objects indexed by their :code:`name`.


    * :code:`bus`: Map of :class:`Bus` objects indexed by their :code:`name`.


    * :code:`net`: Map of :class:`Net` objects indexed by their :code:`name`.



    """
    def __init__(self):
        """
        Construct an empty :class:`Sheet` object.
        """
        EagleFilePart.__init__(self)
        
        self.plain_elements=[]
        self.instances=[]
        self.moduleinsts={} #tecollections.OrderedDict()  For unclear reasons, this caused ordering to become more unpredictable, rather than less.
        self.busses={} #tecollections.OrderedDict()  For unclear reasons, this caused ordering to become more unpredictable, rather than less.
        self.nets={} #tecollections.OrderedDict()  For unclear reasons, this caused ordering to become more unpredictable, rather than less.
        self.description=None


        
    @classmethod
    def _from_et(cls,root,parent):
        """
        Create a :class:`Sheet` from a :code:`sheet` element.
        
        :param root: The element tree tree to parse.
        :param parent: :class:`EagleFilePart` that should hold the resulting :class:`EagleFilePart`
        :rtype: :class:`Sheet`
        """
        ## Call the constructor
        n = cls()
        n._init_from_et(root,parent)
        return n

    def _get_error_name(self):
        if hasattr(self, "get_name"):
            return self.get_name();
        else:
            return "Sheet";
        
    def  _init_from_et(self, root, parent):
        """
        Initialized a :class:`Sheet` from a :code:`sheet` element.  This is useful if you have a subclass of :class:`Sheet` .
        
        :param root: The element tree tree to parse.
        :param parent: :class:`EagleFilePart` that will become the parent of :code:`this` .
        :rtype: :class:`Sheet`
        """
        try:
            self.root = root
            
            if root.tag != "sheet":
                raise EagleFormatError("Tried to create sheet from " + root.tag)


            self.parent = parent

            ### populate the maps by searching for elements that match xpath and generating objects for them.

            for c in root.xpath("./moduleinsts/moduleinst"):
                self.add_moduleinst(self.get_class_for_tag(c.tag)._from_et(c, self))
            for c in root.xpath("./busses/bus"):
                self.add_bus(self.get_class_for_tag(c.tag)._from_et(c, self))
            for c in root.xpath("./nets/net"):
                self.add_net(self.get_class_for_tag(c.tag)._from_et(c, self))

            ### Do the same for the lists

            for c in root.xpath("./plain/polygon|./plain/wire|./plain/text|./plain/dimension|./plain/circle|./plain/rectangle|./plain/frame|./plain/hole"):
                self.add_plain_element(self.get_class_for_tag(c.tag)._from_et(c,self))
            for c in root.xpath("./instances/instance"):
                self.add_instance(self.get_class_for_tag(c.tag)._from_et(c,self))

            ### Do the same for the attr lists


            ### And the singletons

            x = root.xpath("./description")
            if len(x) is not 0:
                self.set_description(self.get_class_for_tag(x[0].tag)._from_et(x[0],self))

            ### And, finally, if the objects wants the text from the tag.

        except SwoopError as e:
            e.text = "{}:{}".format(self._get_error_name(), e.text)
            raise e


    def sortkey(self):
        r = ""
        return r

    def get_et(self):
        """
        Generate a <sheet> element tree for a :class:`Sheet`.
        
        :rtype:  :class:`ElementTree`.
        
        """
        try:
            r = ET.Element("sheet")

            ### Set the tag attributes 


            ### process the sections in order.  They have to be in section order,
            ### because eagle files are order dependent.


            ## For some tags, Eagle generates empty tags when there's no contant
            ## rather than just leaving the tag out.  We mark these with
            ## Tag.requireTag in GenerateSwoop.py and force their generation
            ## here.

            smartAddSubTags(r, "./description")


            ## or add a singleton.

            if self.description is not None:
                target = smartAddSubTags(r, "./description")
                target.append(self.description.get_et())

            ## For some tags, Eagle generates empty tags when there's no contant
            ## rather than just leaving the tag out.  We mark these with
            ## Tag.requireTag in GenerateSwoop.py and force their generation
            ## here.

            smartAddSubTags(r, "./plain/polygon|./plain/wire|./plain/text|./plain/dimension|./plain/circle|./plain/rectangle|./plain/frame|./plain/hole")


            ## add a list.

            if len(self.plain_elements) is not 0:
                target = smartAddSubTags(r, "./plain/polygon|./plain/wire|./plain/text|./plain/dimension|./plain/circle|./plain/rectangle|./plain/frame|./plain/hole")
                # add them in sorted order.  This gives us a simple canonicalization that makes it feasible to use diff to compare files.
                target.extend([i.get_et() for i in sorted(self.plain_elements,key=lambda x: x.sortkey())])


            ## For some tags, Eagle generates empty tags when there's no contant
            ## rather than just leaving the tag out.  We mark these with
            ## Tag.requireTag in GenerateSwoop.py and force their generation
            ## here.



            ## add a map.

            if len(self.moduleinsts) is not 0:
                target = smartAddSubTags(r, "./moduleinsts/moduleinst")
                # add them in sorted order.  This gives us a simple canonicalization that makes it feasible to use diff to compare files.
                target.extend([i.get_et() for i in sorted(list(self.moduleinsts.values()),key=lambda x: x.sortkey())])


            ## For some tags, Eagle generates empty tags when there's no contant
            ## rather than just leaving the tag out.  We mark these with
            ## Tag.requireTag in GenerateSwoop.py and force their generation
            ## here.

            smartAddSubTags(r, "./instances/instance")


            ## add a list.

            if len(self.instances) is not 0:
                target = smartAddSubTags(r, "./instances/instance")
                # add them in sorted order.  This gives us a simple canonicalization that makes it feasible to use diff to compare files.
                target.extend([i.get_et() for i in sorted(self.instances,key=lambda x: x.sortkey())])


            ## For some tags, Eagle generates empty tags when there's no contant
            ## rather than just leaving the tag out.  We mark these with
            ## Tag.requireTag in GenerateSwoop.py and force their generation
            ## here.

            smartAddSubTags(r, "./busses/bus")


            ## add a map.

            if len(self.busses) is not 0:
                target = smartAddSubTags(r, "./busses/bus")
                # add them in sorted order.  This gives us a simple canonicalization that makes it feasible to use diff to compare files.
                target.extend([i.get_et() for i in sorted(list(self.busses.values()),key=lambda x: x.sortkey())])


            ## For some tags, Eagle generates empty tags when there's no contant
            ## rather than just leaving the tag out.  We mark these with
            ## Tag.requireTag in GenerateSwoop.py and force their generation
            ## here.

            smartAddSubTags(r, "./nets/net")


            ## add a map.

            if len(self.nets) is not 0:
                target = smartAddSubTags(r, "./nets/net")
                # add them in sorted order.  This gives us a simple canonicalization that makes it feasible to use diff to compare files.
                target.extend([i.get_et() for i in sorted(list(self.nets.values()),key=lambda x: x.sortkey())])


            ## set the text, if its needed.

        except SwoopError as e:
            e.text = "{}:{}".format(self._get_error_name(), e.text)
            raise e
        return r

    def clone(self):
        """
        Recursively clone this :code:`Sheet`.  It will be identical to the original, but it's parent will be :code:`None`.
        
        :rtype: :class:`Sheet`
        """
        try:
            n = copy.copy(self)
            n.moduleinsts = {}
            for x in list(self.moduleinsts.values()):
                n.add_moduleinst(x.clone())
            n.busses = {}
            for x in list(self.busses.values()):
                n.add_bus(x.clone())
            n.nets = {}
            for x in list(self.nets.values()):
                n.add_net(x.clone())
            n.plain_elements = []
            for x in self.plain_elements:
                n.add_plain_element(x.clone())
            n.instances = []
            for x in self.instances:
                n.add_instance(x.clone())
            n.description = None
            if self.description is not None:
                n.set_description(self.description.clone())
            else:
                n.set_description(None)
            n.parent = None
        except SwoopError as e:
            e.text = "{}:{}".format(self._get_error_name(), e.text)
            raise e
        return n

    def accept_preorder_visitor(self, visitor):
        try:
            pre = getattr(visitor, "Sheet_pre")
            return pre(self)
        except AttributeError:
            return visitor.default_pre(self)
        
    def accept_postorder_visitor(self, visitor, context):
        try:
            post = getattr(visitor, "Sheet_post")
            post(self,context)
        except AttributeError:
            visitor.default_post(self,context)

    def is_equal(self, other):
        """
        Check whether two :code:`EagleFilePart` objects are identical.
        
        :param other: Object to compare to.
        :returns: :code:`True` if they are identical, otherwise, :code:`False`
        """
        return self.get_xml() == other.get_xml()
        
    ### Getters/Setters for attribute values


    ##### Lookup functions that return EFPs instead of just attribute values.
    
    


    
    ### Adder/getter/lookup for lists
    
    def add_plain_element(self, s):
        """ Add a :class:`Polygon`, :class:`Wire`, :class:`Text`, :class:`Dimension`, :class:`Circle`, :class:`Rectangle`, :class:`Frame` or :class:`Hole` to the :code:`plain_elements` of this :class:`Sheet`.

        :param s: The :class:`Polygon`, :class:`Wire`, :class:`Text`, :class:`Dimension`, :class:`Circle`, :class:`Rectangle`, :class:`Frame` or :class:`Hole` to add.
        :rtype: :code:`self`
        """
        if not any([
                isinstance(s, Polygon),
                isinstance(s, Wire),
                isinstance(s, Text),
                isinstance(s, Dimension),
                isinstance(s, Circle),
                isinstance(s, Rectangle),
                isinstance(s, Frame),
                isinstance(s, Hole),
            ]):
            raise SwoopError("Argument to Sheet.add_plain_element() should be of type Polygon, Wire, Text, Dimension, Circle, Rectangle, Frame or Hole.  Got " + str(type(s).__name__) + ".")
        
        self.plain_elements.append(s)
        if s.parent is not None and s.parent is not self:
            s.parent.remove_plain_element(s)

        s.parent = self
        return self

    def get_nth_plain_element(self, n):
        """ get then nth :class:`Polygon`, :class:`Wire`, :class:`Text`, :class:`Dimension`, :class:`Circle`, :class:`Rectangle`, :class:`Frame` or :class:`Hole` object from the :code:`plain_elements` of this :class:`Sheet`.
        
        :param n: Index of the item to return.

        :rtype: :class:`Polygon`, :class:`Wire`, :class:`Text`, :class:`Dimension`, :class:`Circle`, :class:`Rectangle`, :class:`Frame` or :class:`Hole` object
        """
        return self.plain_elements[n]

    def get_plain_elements(self, attrs=None, type=None):
        """Return (and possibly filter) items in the the :code:`plain_elements` list of :class:`Polygon`, :class:`Wire`, :class:`Text`, :class:`Dimension`, :class:`Circle`, :class:`Rectangle`, :class:`Frame` or :class:`Hole` objects for this :class:`Sheet`.
        
        This functions provides a mechanism for filtering the items as well.
        The keys in :code:`attrs` are taken as attributes names and the
        values are requested values.  Items in the list that have all the
        requested values for the corresponding attributes will be returned.  

        A if :code:`type` is not :code:`None`, the item will match if it is an
        instance of the type provided.
        
        :param attrs: A set of key-value pairs that represent a filter to apply to the item's attributes.
        :param type:  A type to filter on.  Only items that are an instance of this type will be returned.
        :returns: A List of :class:`Polygon`, :class:`Wire`, :class:`Text`, :class:`Dimension`, :class:`Circle`, :class:`Rectangle`, :class:`Frame` and :class:`Hole` objects
        :rtype: List of :class:`Polygon`, :class:`Wire`, :class:`Text`, :class:`Dimension`, :class:`Circle`, :class:`Rectangle`, :class:`Frame` and :class:`Hole` objects
        """
        if attrs is not None or type is not None:
            raise NotImplementedError("filtered get not implemented.")
        return self.plain_elements

    def clear_plain_elements(self):
        """
        Remove all the :class:`Polygon`, :class:`Wire`, :class:`Text`, :class:`Dimension`, :class:`Circle`, :class:`Rectangle`, :class:`Frame` and :class:`Hole` objects from the :code:`plain_elements` of this :class:`Sheet`.
        
        :rtype: :code:`self`
        """
        for efp in self.plain_elements:
            efp.parent = None
        self.plain_elements = []
        return self

    def remove_plain_element(self, efp):
        """
        Remove a :class:`Polygon`, :class:`Wire`, :class:`Text`, :class:`Dimension`, :class:`Circle`, :class:`Rectangle`, :class:`Frame` or :class:`Hole` from the :code:`plain_elements` of this :class:`Sheet`.
        
        :param efp: The :class:`Polygon`, :class:`Wire`, :class:`Text`, :class:`Dimension`, :class:`Circle`, :class:`Rectangle`, :class:`Frame` or :class:`Hole` object to remove.

        :rtype: :code:`self`
        """
        self.plain_elements = [x for x in self.plain_elements if x != efp]

        if efp.parent is self:
            efp.parent = None
        return self

    def add_instance(self, s):
        """ Add a :class:`Instance` to the :code:`instances` of this :class:`Sheet`.

        :param s: The :class:`Instance` to add.
        :rtype: :code:`self`
        """
        if not any([
                isinstance(s, Instance),
            ]):
            raise SwoopError("Argument to Sheet.add_instance() should be of type Instance.  Got " + str(type(s).__name__) + ".")
        
        self.instances.append(s)
        if s.parent is not None and s.parent is not self:
            s.parent.remove_instance(s)

        s.parent = self
        return self

    def get_nth_instance(self, n):
        """ get then nth :class:`Instance` object from the :code:`instances` of this :class:`Sheet`.
        
        :param n: Index of the item to return.

        :rtype: :class:`Instance` object
        """
        return self.instances[n]

    def get_instances(self, attrs=None, type=None):
        """Return (and possibly filter) items in the the :code:`instances` list of :class:`Instance` objects for this :class:`Sheet`.
        
        This functions provides a mechanism for filtering the items as well.
        The keys in :code:`attrs` are taken as attributes names and the
        values are requested values.  Items in the list that have all the
        requested values for the corresponding attributes will be returned.  

        A if :code:`type` is not :code:`None`, the item will match if it is an
        instance of the type provided.
        
        :param attrs: A set of key-value pairs that represent a filter to apply to the item's attributes.
        :param type:  A type to filter on.  Only items that are an instance of this type will be returned.
        :returns: A List of :class:`Instance` objects
        :rtype: List of :class:`Instance` objects
        """
        if attrs is not None or type is not None:
            raise NotImplementedError("filtered get not implemented.")
        return self.instances

    def clear_instances(self):
        """
        Remove all the :class:`Instance` objects from the :code:`instances` of this :class:`Sheet`.
        
        :rtype: :code:`self`
        """
        for efp in self.instances:
            efp.parent = None
        self.instances = []
        return self

    def remove_instance(self, efp):
        """
        Remove a :class:`Instance` from the :code:`instances` of this :class:`Sheet`.
        
        :param efp: The :class:`Instance` object to remove.

        :rtype: :code:`self`
        """
        self.instances = [x for x in self.instances if x != efp]

        if efp.parent is self:
            efp.parent = None
        return self



    ### Add, lookup, and get for maps
    def add_moduleinst(self, s):
        """ Add a :class:`Moduleinst` to the :code:`moduleinsts` of this :class:`Sheet`.

        :param s: The :class:`Moduleinst` to add.
        :rtype: :code:`self`
        """
        if not any([
                isinstance(s, Moduleinst),
            ]):
            raise SwoopError("Argument to Sheet.add_moduleinst() should be of type Moduleinst.  Got " + str(type(s).__name__) + ".")
        

        self.moduleinsts[s.get_name()] = s

        s.parent = self
        return self

    def get_nth_moduleinst(self, n):
        """ get then nth :class:`Moduleinst` object from the :code:`moduleinsts` of this :class:`Sheet`.
        
        :param n: Index of the item to return.

        :rtype: :class:`Moduleinst` object
        """
        return list(self.moduleinsts.values())[n]

    def get_moduleinst(self, key):
        """ Lookup and return a :class:`Moduleinst` from the :code:`moduleinsts` of  this :class:`Sheet`.
        
        :param key: A :code:`str` to use for the lookup.  The lookup uses the :code:`name` of the :class:`Moduleinst` objects.

        :rtype: A :class:`Moduleinst` object or :code:`None`, if there is no such item.
        """
        return self.moduleinsts.get(key)


    def get_moduleinsts(self, attrs=None, type=None):
        """Return (and possibly filter) items in the the :code:`moduleinsts` map of :class:`Moduleinst` objects for this :class:`Sheet`.
        
        This functions provides a mechanism for filtering the items as well.
        The keys in :code:`attrs` are taken as attributes names and the
        values are requested values.  Items in the list that have all the
        requested values for the corresponding attributes will be returned.  

        A if :code:`type` is not :code:`None`, the item will match if it is an
        instance of the type provided.
        
        :param attrs: A set of key-value pairs that represent a filter to apply to the item's attributes.
        :param type:  A type to filter on.  Only items that are an instance of this type will be returned.
        :returns: A List of :class:`Moduleinst` objects
        :rtype: List of :class:`Moduleinst` objects
        """
        if attrs is not None or type is not None:
            raise NotImplementedError("filtered get not implemented")
        return list(self.moduleinsts.values())
        

    def clear_moduleinsts(self):
        """
        Remove all the :class:`Moduleinst` objects from the :code:`moduleinsts` of this :class:`Sheet`.
        
        :rtype: :code:`self`
        """
        for efp in list(self.moduleinsts.values()):
            efp.parent = None
        self.moduleinsts = {}
        return self

    def remove_moduleinst(self, efp):
        """
        Remove a :class:`Moduleinst` from the :code:`moduleinsts` of this :class:`Sheet`.
        
        :param efp: The :class:`Moduleinst` object to remove.

        :rtype: :code:`self`
        """
        if self.moduleinsts[efp.get_name()] == efp:
            del self.moduleinsts[efp.get_name()]
            efp.parent = None
            return self
        else:
            raise SwoopError("Tried to use remove_moduleinst() to delete the wrong kind of child?: {}".format(str(efp)))
    
    def add_bus(self, s):
        """ Add a :class:`Bus` to the :code:`busses` of this :class:`Sheet`.

        :param s: The :class:`Bus` to add.
        :rtype: :code:`self`
        """
        if not any([
                isinstance(s, Bus),
            ]):
            raise SwoopError("Argument to Sheet.add_bus() should be of type Bus.  Got " + str(type(s).__name__) + ".")
        

        self.busses[s.get_name()] = s

        s.parent = self
        return self

    def get_nth_bus(self, n):
        """ get then nth :class:`Bus` object from the :code:`busses` of this :class:`Sheet`.
        
        :param n: Index of the item to return.

        :rtype: :class:`Bus` object
        """
        return list(self.busses.values())[n]

    def get_bus(self, key):
        """ Lookup and return a :class:`Bus` from the :code:`busses` of  this :class:`Sheet`.
        
        :param key: A :code:`str` to use for the lookup.  The lookup uses the :code:`name` of the :class:`Bus` objects.

        :rtype: A :class:`Bus` object or :code:`None`, if there is no such item.
        """
        return self.busses.get(key)


    def get_busses(self, attrs=None, type=None):
        """Return (and possibly filter) items in the the :code:`busses` map of :class:`Bus` objects for this :class:`Sheet`.
        
        This functions provides a mechanism for filtering the items as well.
        The keys in :code:`attrs` are taken as attributes names and the
        values are requested values.  Items in the list that have all the
        requested values for the corresponding attributes will be returned.  

        A if :code:`type` is not :code:`None`, the item will match if it is an
        instance of the type provided.
        
        :param attrs: A set of key-value pairs that represent a filter to apply to the item's attributes.
        :param type:  A type to filter on.  Only items that are an instance of this type will be returned.
        :returns: A List of :class:`Bus` objects
        :rtype: List of :class:`Bus` objects
        """
        if attrs is not None or type is not None:
            raise NotImplementedError("filtered get not implemented")
        return list(self.busses.values())
        

    def clear_busses(self):
        """
        Remove all the :class:`Bus` objects from the :code:`busses` of this :class:`Sheet`.
        
        :rtype: :code:`self`
        """
        for efp in list(self.busses.values()):
            efp.parent = None
        self.busses = {}
        return self

    def remove_bus(self, efp):
        """
        Remove a :class:`Bus` from the :code:`busses` of this :class:`Sheet`.
        
        :param efp: The :class:`Bus` object to remove.

        :rtype: :code:`self`
        """
        if self.busses[efp.get_name()] == efp:
            del self.busses[efp.get_name()]
            efp.parent = None
            return self
        else:
            raise SwoopError("Tried to use remove_bus() to delete the wrong kind of child?: {}".format(str(efp)))
    
    def add_net(self, s):
        """ Add a :class:`Net` to the :code:`nets` of this :class:`Sheet`.

        :param s: The :class:`Net` to add.
        :rtype: :code:`self`
        """
        if not any([
                isinstance(s, Net),
            ]):
            raise SwoopError("Argument to Sheet.add_net() should be of type Net.  Got " + str(type(s).__name__) + ".")
        

        self.nets[s.get_name()] = s

        s.parent = self
        return self

    def get_nth_net(self, n):
        """ get then nth :class:`Net` object from the :code:`nets` of this :class:`Sheet`.
        
        :param n: Index of the item to return.

        :rtype: :class:`Net` object
        """
        return list(self.nets.values())[n]

    def get_net(self, key):
        """ Lookup and return a :class:`Net` from the :code:`nets` of  this :class:`Sheet`.
        
        :param key: A :code:`str` to use for the lookup.  The lookup uses the :code:`name` of the :class:`Net` objects.

        :rtype: A :class:`Net` object or :code:`None`, if there is no such item.
        """
        return self.nets.get(key)


    def get_nets(self, attrs=None, type=None):
        """Return (and possibly filter) items in the the :code:`nets` map of :class:`Net` objects for this :class:`Sheet`.
        
        This functions provides a mechanism for filtering the items as well.
        The keys in :code:`attrs` are taken as attributes names and the
        values are requested values.  Items in the list that have all the
        requested values for the corresponding attributes will be returned.  

        A if :code:`type` is not :code:`None`, the item will match if it is an
        instance of the type provided.
        
        :param attrs: A set of key-value pairs that represent a filter to apply to the item's attributes.
        :param type:  A type to filter on.  Only items that are an instance of this type will be returned.
        :returns: A List of :class:`Net` objects
        :rtype: List of :class:`Net` objects
        """
        if attrs is not None or type is not None:
            raise NotImplementedError("filtered get not implemented")
        return list(self.nets.values())
        

    def clear_nets(self):
        """
        Remove all the :class:`Net` objects from the :code:`nets` of this :class:`Sheet`.
        
        :rtype: :code:`self`
        """
        for efp in list(self.nets.values()):
            efp.parent = None
        self.nets = {}
        return self

    def remove_net(self, efp):
        """
        Remove a :class:`Net` from the :code:`nets` of this :class:`Sheet`.
        
        :param efp: The :class:`Net` object to remove.

        :rtype: :code:`self`
        """
        if self.nets[efp.get_name()] == efp:
            del self.nets[efp.get_name()]
            efp.parent = None
            return self
        else:
            raise SwoopError("Tried to use remove_net() to delete the wrong kind of child?: {}".format(str(efp)))
    


    
    ### Getter/Setter for singletons.

    def set_description(self, s):
        """ Set the :class:`Description` for this  :class:`Sheet`.

        :param s: :class:`Description` to set.
        :rtype: :code:`self`
        """
        if self.description is not None:
            self.description.parent = None
        self.description = s
        if s is not None:
            s.parent = self
        return self

    def get_description(self):
        """ Get the description from this :class:`Sheet`.
        
        :rtype: :class:`Description` object
        """
        return self.description


    
    def get_children(self):
        """
        Get all the children of this :class:`EagleFilePart`.
        
        :rtype: List of :class:`EagleFilePart` objects
        """
        r = []

        r = r + self.plain_elements
        r = r + self.instances

        r = r + list(self.moduleinsts.values())
        r = r + list(self.busses.values())
        r = r + list(self.nets.values())

        if self.description is not None:
            r = r + [self.description]

        return r

    def remove_child(self, efp):
        """
        Remove a child :class:`EagleFilePart` object.
        
        :param efp: the class:`EagleFilePart` object to remove.
        :return: Nothing
        """
        try:
            self.remove_moduleinst(efp)
        except:
            pass
        try:
            self.remove_bus(efp)
        except:
            pass
        try:
            self.remove_net(efp)
        except:
            pass
        try:
            self.remove_plain_element(efp)
        except:
            pass
        try:
            self.remove_instance(efp)
        except:
            pass
        if self.get_description() == efp:
            self.set_description(None)

    def _rekey_child(self, oldkey, efp):
        """
        Remove a child :class:`EagleFilePart` object.
        
        :param efp: the class:`EagleFilePart` object to remove.
        :return: Nothing
        """
        try:
            if self.get_moduleinst(oldkey) == efp:
                del self.moduleinsts[oldkey]
                self.add_moduleinst(efp)
        except SwoopError:
            pass
        try:
            if self.get_bus(oldkey) == efp:
                del self.busses[oldkey]
                self.add_bus(efp)
        except SwoopError:
            pass
        try:
            if self.get_net(oldkey) == efp:
                del self.nets[oldkey]
                self.add_net(efp)
        except SwoopError:
            pass

    def check_sanity(self, visited_efps = None):
        EagleFilePart.check_sanity(self, visited_efps)

        # Check whether keys in our maps match the keys in our children
        for k in self.moduleinsts:
            if self.moduleinsts[k].get_name() != k:
                raise SwoopError("Child's name ('{}') doesn't match key in parent's map ('{}')".format(self.moduleinsts[k].get_name(),k))
        for k in self.busses:
            if self.busses[k].get_name() != k:
                raise SwoopError("Child's name ('{}') doesn't match key in parent's map ('{}')".format(self.busses[k].get_name(),k))
        for k in self.nets:
            if self.nets[k].get_name() != k:
                raise SwoopError("Child's name ('{}') doesn't match key in parent's map ('{}')".format(self.nets[k].get_name(),k))

    def __str__(self):
        r = "["+repr(self)+" "
        r = r + "]"
        return r
            
    def dump(self, indent="", increment="   "):
        """
        Recursive debug dump.
        
        :param indent:  Indentation string.  The output will be indented by this much.
        :param increment: This will be appendeded to :code:`indent` on recursive invocations.

        :rtype: :code:`None`
        """
        print(indent + str(self.__class__.__name__), end=' ')
        try:
            print(self.get_name())
        except:
            print()
            pass
        for c in self.get_children():
            c.dump(indent + "   ")

        
EagleFile.class_map["sheet"] = Sheet
         


class Polygon(EagleFilePart, PolygonGeometry):
    """
    Class representing the contents of a <polygon> tag in Eagle files.

    Attributes:

    * :code:`width`

    * :code:`layer`

    * :code:`spacing`

    * :code:`pour`

    * :code:`isolate`

    * :code:`orphans`

    * :code:`thermals`

    * :code:`rank`



    Collections:


    * :code:`vertex`: List of :class:`Vertex` objects.



    """
    def __init__(self):
        """
        Construct an empty :class:`Polygon` object.
        """
        EagleFilePart.__init__(self)
        PolygonGeometry.__init__(self)
        
        self.width=None
        self.layer=None
        self.spacing=None
        self.pour=None
        self.isolate=None
        self.orphans=None
        self.thermals=None
        self.rank=None
        self.vertices=[]


        
    @classmethod
    def _from_et(cls,root,parent):
        """
        Create a :class:`Polygon` from a :code:`polygon` element.
        
        :param root: The element tree tree to parse.
        :param parent: :class:`EagleFilePart` that should hold the resulting :class:`EagleFilePart`
        :rtype: :class:`Polygon`
        """
        ## Call the constructor
        n = cls()
        n._init_from_et(root,parent)
        return n

    def _get_error_name(self):
        if hasattr(self, "get_name"):
            return self.get_name();
        else:
            return "Polygon";
        
    def  _init_from_et(self, root, parent):
        """
        Initialized a :class:`Polygon` from a :code:`polygon` element.  This is useful if you have a subclass of :class:`Polygon` .
        
        :param root: The element tree tree to parse.
        :param parent: :class:`EagleFilePart` that will become the parent of :code:`this` .
        :rtype: :class:`Polygon`
        """
        try:
            self.root = root
            
            if root.tag != "polygon":
                raise EagleFormatError("Tried to create polygon from " + root.tag)

            self.width=parseByType(parent, "float", None, root.get("width"))
            self.layer=parseByType(parent, "layer_string", None, root.get("layer"))
            self.spacing=parseByType(parent, "float", None, root.get("spacing"))
            self.pour=parseByType(parent, "str", None, root.get("pour"))
            self.isolate=parseByType(parent, "float", None, root.get("isolate"))
            self.orphans=parseByType(parent, "bool", None, root.get("orphans"))
            self.thermals=parseByType(parent, "bool", None, root.get("thermals"))
            self.rank=parseByType(parent, "int", None, root.get("rank"))

            self.parent = parent

            ### populate the maps by searching for elements that match xpath and generating objects for them.


            ### Do the same for the lists

            for c in root.xpath("./vertex"):
                self.add_vertex(self.get_class_for_tag(c.tag)._from_et(c,self))

            ### Do the same for the attr lists


            ### And the singletons


            ### And, finally, if the objects wants the text from the tag.

        except SwoopError as e:
            e.text = "{}:{}".format(self._get_error_name(), e.text)
            raise e


    def sortkey(self):
        r = ""
        r = r + str(self.width)
        r = r + str(self.layer)
        r = r + str(self.spacing)
        r = r + str(self.pour)
        r = r + str(self.isolate)
        r = r + str(self.orphans)
        r = r + str(self.thermals)
        r = r + str(self.rank)
        return r

    def get_et(self):
        """
        Generate a <polygon> element tree for a :class:`Polygon`.
        
        :rtype:  :class:`ElementTree`.
        
        """
        try:
            r = ET.Element("polygon")

            ### Set the tag attributes 


            ## Unparse the values.

            v = unparseByType(self, "float", None,  self.width)

            ## For required attributes None becomes "".  For optional attributes, we just leave the attribute out.
            if not (isinstance(self.get_parent(), LibraryFile) and False):  # special case for the name of library.
                if v is not None:
                    r.set("width", v)
                else:
                    r.set("width", "")


            ## Unparse the values.

            v = unparseByType(self, "layer_string", None,  self.layer)

            ## For required attributes None becomes "".  For optional attributes, we just leave the attribute out.
            if not (isinstance(self.get_parent(), LibraryFile) and False):  # special case for the name of library.
                if v is not None:
                    r.set("layer", v)
                else:
                    r.set("layer", "")


            ## Unparse the values.

            v = unparseByType(self, "float", None,  self.spacing)

            ## For required attributes None becomes "".  For optional attributes, we just leave the attribute out.
            if not (isinstance(self.get_parent(), LibraryFile) and False):  # special case for the name of library.
                if v is not None:
                    r.set("spacing", v)


            ## Unparse the values.

            v = unparseByType(self, "str", None,  self.pour)

            ## For required attributes None becomes "".  For optional attributes, we just leave the attribute out.
            if not (isinstance(self.get_parent(), LibraryFile) and False):  # special case for the name of library.
                if v is not None:
                    r.set("pour", v)


            ## Unparse the values.

            v = unparseByType(self, "float", None,  self.isolate)

            ## For required attributes None becomes "".  For optional attributes, we just leave the attribute out.
            if not (isinstance(self.get_parent(), LibraryFile) and False):  # special case for the name of library.
                if v is not None:
                    r.set("isolate", v)


            ## Unparse the values.

            v = unparseByType(self, "bool", None,  self.orphans)

            ## For required attributes None becomes "".  For optional attributes, we just leave the attribute out.
            if not (isinstance(self.get_parent(), LibraryFile) and False):  # special case for the name of library.
                if v is not None:
                    r.set("orphans", v)


            ## Unparse the values.

            v = unparseByType(self, "bool", None,  self.thermals)

            ## For required attributes None becomes "".  For optional attributes, we just leave the attribute out.
            if not (isinstance(self.get_parent(), LibraryFile) and False):  # special case for the name of library.
                if v is not None:
                    r.set("thermals", v)


            ## Unparse the values.

            v = unparseByType(self, "int", None,  self.rank)

            ## For required attributes None becomes "".  For optional attributes, we just leave the attribute out.
            if not (isinstance(self.get_parent(), LibraryFile) and False):  # special case for the name of library.
                if v is not None:
                    r.set("rank", v)


            ### process the sections in order.  They have to be in section order,
            ### because eagle files are order dependent.


            ## For some tags, Eagle generates empty tags when there's no contant
            ## rather than just leaving the tag out.  We mark these with
            ## Tag.requireTag in GenerateSwoop.py and force their generation
            ## here.



            ## add a list.

            if len(self.vertices) is not 0:
                target = smartAddSubTags(r, "./vertex")
                # add them in sorted order.  This gives us a simple canonicalization that makes it feasible to use diff to compare files.
                target.extend([i.get_et() for i in sorted(self.vertices,key=lambda x: x.sortkey())])


            ## set the text, if its needed.

        except SwoopError as e:
            e.text = "{}:{}".format(self._get_error_name(), e.text)
            raise e
        return r

    def clone(self):
        """
        Recursively clone this :code:`Polygon`.  It will be identical to the original, but it's parent will be :code:`None`.
        
        :rtype: :class:`Polygon`
        """
        try:
            n = copy.copy(self)
            n.vertices = []
            for x in self.vertices:
                n.add_vertex(x.clone())
            n.parent = None
        except SwoopError as e:
            e.text = "{}:{}".format(self._get_error_name(), e.text)
            raise e
        return n

    def accept_preorder_visitor(self, visitor):
        try:
            pre = getattr(visitor, "Polygon_pre")
            return pre(self)
        except AttributeError:
            return visitor.default_pre(self)
        
    def accept_postorder_visitor(self, visitor, context):
        try:
            post = getattr(visitor, "Polygon_post")
            post(self,context)
        except AttributeError:
            visitor.default_post(self,context)

    def is_equal(self, other):
        """
        Check whether two :code:`EagleFilePart` objects are identical.
        
        :param other: Object to compare to.
        :returns: :code:`True` if they are identical, otherwise, :code:`False`
        """
        return self.get_xml() == other.get_xml()
        
    ### Getters/Setters for attribute values

    def get_width(self):
        """ Return the value of :code:`width` for this :class:`Polygon`.  This corresponds to the :code:`width` attribute of a :code:`<polygon>` in an Eagle file.
        
        :rtype: :code:`float`
        """
        return self.width

    def set_width(self,v):
        """ Set the value of :code:`width` for this  :class:`Polygon`.  This corresponds to the :code:`width` attribute of a :code:`<polygon>` in an Eagle file.

        :param v: new value
        :rtype: :code:`self`
        """
                        
        if not typeCheck("float", v, True):
            raise SwoopError("Illegal value ({}) of type {} for attribute 'width' of Polygon object (should be float).".format(v, type(v)))
        self.width = v
        
        return self

    def with_width(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`width`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`width` equals :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_width()` is :code:`True`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """

        if type(v) in [str, int, float, bool]:
            return self if self.width == v else None
        elif callable(v):
            return self if v(self.width) else None
        else:
            raise SwoopError("Illegal type passed to with_width")

    def without_width(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`width`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`width` is not equal to :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_width()` is :code:`False`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """
        
        if type(v) in [str, int, float, bool]:
            return self if self.width != v else None
        elif callable(v):
            return self if not v(self.width) else None
        else:
            raise SwoopError("Illegal type passed to without_width")


    def get_layer(self):
        """ Return the value of :code:`layer` for this :class:`Polygon`.  This corresponds to the :code:`layer` attribute of a :code:`<polygon>` in an Eagle file.
        
        :rtype: :code:`layer_string`
        """
        return self.layer

    def set_layer(self,v):
        """ Set the value of :code:`layer` for this  :class:`Polygon`.  This corresponds to the :code:`layer` attribute of a :code:`<polygon>` in an Eagle file.

        :param v: new value
        :rtype: :code:`self`
        """
                        
        if not typeCheck("layer_string", v, True):
            raise SwoopError("Illegal value ({}) of type {} for attribute 'layer' of Polygon object (should be layer_string).".format(v, type(v)))
        self.layer = v
        
        return self

    def with_layer(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`layer`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`layer` equals :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_layer()` is :code:`True`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """

        if type(v) in [str, int, float, bool]:
            return self if self.layer == v else None
        elif callable(v):
            return self if v(self.layer) else None
        else:
            raise SwoopError("Illegal type passed to with_layer")

    def without_layer(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`layer`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`layer` is not equal to :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_layer()` is :code:`False`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """
        
        if type(v) in [str, int, float, bool]:
            return self if self.layer != v else None
        elif callable(v):
            return self if not v(self.layer) else None
        else:
            raise SwoopError("Illegal type passed to without_layer")


    def get_spacing(self):
        """ Return the value of :code:`spacing` for this :class:`Polygon`.  This corresponds to the :code:`spacing` attribute of a :code:`<polygon>` in an Eagle file.
        
        :rtype: :code:`float`
        """
        return self.spacing

    def set_spacing(self,v):
        """ Set the value of :code:`spacing` for this  :class:`Polygon`.  This corresponds to the :code:`spacing` attribute of a :code:`<polygon>` in an Eagle file.

        :param v: new value
        :rtype: :code:`self`
        """
                        
        if not typeCheck("float", v, False):
            raise SwoopError("Illegal value ({}) of type {} for attribute 'spacing' of Polygon object (should be float).".format(v, type(v)))
        self.spacing = v
        
        return self

    def with_spacing(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`spacing`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`spacing` equals :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_spacing()` is :code:`True`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """

        if type(v) in [str, int, float, bool]:
            return self if self.spacing == v else None
        elif callable(v):
            return self if v(self.spacing) else None
        else:
            raise SwoopError("Illegal type passed to with_spacing")

    def without_spacing(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`spacing`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`spacing` is not equal to :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_spacing()` is :code:`False`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """
        
        if type(v) in [str, int, float, bool]:
            return self if self.spacing != v else None
        elif callable(v):
            return self if not v(self.spacing) else None
        else:
            raise SwoopError("Illegal type passed to without_spacing")


    def get_pour(self):
        """ Return the value of :code:`pour` for this :class:`Polygon`.  This corresponds to the :code:`pour` attribute of a :code:`<polygon>` in an Eagle file.
        
        :rtype: :code:`str`
        """
        return self.pour

    def set_pour(self,v):
        """ Set the value of :code:`pour` for this  :class:`Polygon`.  This corresponds to the :code:`pour` attribute of a :code:`<polygon>` in an Eagle file.

        :param v: new value
        :rtype: :code:`self`
        """
                        
        if not typeCheck("str", v, False):
            raise SwoopError("Illegal value ({}) of type {} for attribute 'pour' of Polygon object (should be str).".format(v, type(v)))
        self.pour = v
        
        return self

    def with_pour(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`pour`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`pour` equals :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_pour()` is :code:`True`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """

        if type(v) in [str, int, float, bool]:
            return self if self.pour == v else None
        elif callable(v):
            return self if v(self.pour) else None
        else:
            raise SwoopError("Illegal type passed to with_pour")

    def without_pour(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`pour`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`pour` is not equal to :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_pour()` is :code:`False`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """
        
        if type(v) in [str, int, float, bool]:
            return self if self.pour != v else None
        elif callable(v):
            return self if not v(self.pour) else None
        else:
            raise SwoopError("Illegal type passed to without_pour")


    def get_isolate(self):
        """ Return the value of :code:`isolate` for this :class:`Polygon`.  This corresponds to the :code:`isolate` attribute of a :code:`<polygon>` in an Eagle file.
        
        :rtype: :code:`float`
        """
        return self.isolate

    def set_isolate(self,v):
        """ Set the value of :code:`isolate` for this  :class:`Polygon`.  This corresponds to the :code:`isolate` attribute of a :code:`<polygon>` in an Eagle file.

        :param v: new value
        :rtype: :code:`self`
        """
                        
        if not typeCheck("float", v, False):
            raise SwoopError("Illegal value ({}) of type {} for attribute 'isolate' of Polygon object (should be float).".format(v, type(v)))
        self.isolate = v
        
        return self

    def with_isolate(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`isolate`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`isolate` equals :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_isolate()` is :code:`True`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """

        if type(v) in [str, int, float, bool]:
            return self if self.isolate == v else None
        elif callable(v):
            return self if v(self.isolate) else None
        else:
            raise SwoopError("Illegal type passed to with_isolate")

    def without_isolate(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`isolate`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`isolate` is not equal to :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_isolate()` is :code:`False`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """
        
        if type(v) in [str, int, float, bool]:
            return self if self.isolate != v else None
        elif callable(v):
            return self if not v(self.isolate) else None
        else:
            raise SwoopError("Illegal type passed to without_isolate")


    def get_orphans(self):
        """ Return the value of :code:`orphans` for this :class:`Polygon`.  This corresponds to the :code:`orphans` attribute of a :code:`<polygon>` in an Eagle file.
        
        :rtype: :code:`bool`
        """
        return self.orphans

    def set_orphans(self,v):
        """ Set the value of :code:`orphans` for this  :class:`Polygon`.  This corresponds to the :code:`orphans` attribute of a :code:`<polygon>` in an Eagle file.

        :param v: new value
        :rtype: :code:`self`
        """
                        
        if not typeCheck("bool", v, False):
            raise SwoopError("Illegal value ({}) of type {} for attribute 'orphans' of Polygon object (should be bool).".format(v, type(v)))
        self.orphans = v
        
        return self

    def with_orphans(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`orphans`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`orphans` equals :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_orphans()` is :code:`True`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """

        if type(v) in [str, int, float, bool]:
            return self if self.orphans == v else None
        elif callable(v):
            return self if v(self.orphans) else None
        else:
            raise SwoopError("Illegal type passed to with_orphans")

    def without_orphans(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`orphans`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`orphans` is not equal to :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_orphans()` is :code:`False`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """
        
        if type(v) in [str, int, float, bool]:
            return self if self.orphans != v else None
        elif callable(v):
            return self if not v(self.orphans) else None
        else:
            raise SwoopError("Illegal type passed to without_orphans")


    def get_thermals(self):
        """ Return the value of :code:`thermals` for this :class:`Polygon`.  This corresponds to the :code:`thermals` attribute of a :code:`<polygon>` in an Eagle file.
        
        :rtype: :code:`bool`
        """
        return self.thermals

    def set_thermals(self,v):
        """ Set the value of :code:`thermals` for this  :class:`Polygon`.  This corresponds to the :code:`thermals` attribute of a :code:`<polygon>` in an Eagle file.

        :param v: new value
        :rtype: :code:`self`
        """
                        
        if not typeCheck("bool", v, False):
            raise SwoopError("Illegal value ({}) of type {} for attribute 'thermals' of Polygon object (should be bool).".format(v, type(v)))
        self.thermals = v
        
        return self

    def with_thermals(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`thermals`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`thermals` equals :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_thermals()` is :code:`True`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """

        if type(v) in [str, int, float, bool]:
            return self if self.thermals == v else None
        elif callable(v):
            return self if v(self.thermals) else None
        else:
            raise SwoopError("Illegal type passed to with_thermals")

    def without_thermals(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`thermals`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`thermals` is not equal to :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_thermals()` is :code:`False`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """
        
        if type(v) in [str, int, float, bool]:
            return self if self.thermals != v else None
        elif callable(v):
            return self if not v(self.thermals) else None
        else:
            raise SwoopError("Illegal type passed to without_thermals")


    def get_rank(self):
        """ Return the value of :code:`rank` for this :class:`Polygon`.  This corresponds to the :code:`rank` attribute of a :code:`<polygon>` in an Eagle file.
        
        :rtype: :code:`int`
        """
        return self.rank

    def set_rank(self,v):
        """ Set the value of :code:`rank` for this  :class:`Polygon`.  This corresponds to the :code:`rank` attribute of a :code:`<polygon>` in an Eagle file.

        :param v: new value
        :rtype: :code:`self`
        """
                        
        if not typeCheck("int", v, False):
            raise SwoopError("Illegal value ({}) of type {} for attribute 'rank' of Polygon object (should be int).".format(v, type(v)))
        self.rank = v
        
        return self

    def with_rank(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`rank`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`rank` equals :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_rank()` is :code:`True`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """

        if type(v) in [str, int, float, bool]:
            return self if self.rank == v else None
        elif callable(v):
            return self if v(self.rank) else None
        else:
            raise SwoopError("Illegal type passed to with_rank")

    def without_rank(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`rank`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`rank` is not equal to :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_rank()` is :code:`False`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """
        
        if type(v) in [str, int, float, bool]:
            return self if self.rank != v else None
        elif callable(v):
            return self if not v(self.rank) else None
        else:
            raise SwoopError("Illegal type passed to without_rank")



    ##### Lookup functions that return EFPs instead of just attribute values.
    
    


    
    ### Adder/getter/lookup for lists
    
    def add_vertex(self, s):
        """ Add a :class:`Vertex` to the :code:`vertices` of this :class:`Polygon`.

        :param s: The :class:`Vertex` to add.
        :rtype: :code:`self`
        """
        if not any([
                isinstance(s, Vertex),
            ]):
            raise SwoopError("Argument to Polygon.add_vertex() should be of type Vertex.  Got " + str(type(s).__name__) + ".")
        
        self.vertices.append(s)
        if s.parent is not None and s.parent is not self:
            s.parent.remove_vertex(s)

        s.parent = self
        return self

    def get_nth_vertex(self, n):
        """ get then nth :class:`Vertex` object from the :code:`vertices` of this :class:`Polygon`.
        
        :param n: Index of the item to return.

        :rtype: :class:`Vertex` object
        """
        return self.vertices[n]

    def get_vertices(self, attrs=None, type=None):
        """Return (and possibly filter) items in the the :code:`vertices` list of :class:`Vertex` objects for this :class:`Polygon`.
        
        This functions provides a mechanism for filtering the items as well.
        The keys in :code:`attrs` are taken as attributes names and the
        values are requested values.  Items in the list that have all the
        requested values for the corresponding attributes will be returned.  

        A if :code:`type` is not :code:`None`, the item will match if it is an
        instance of the type provided.
        
        :param attrs: A set of key-value pairs that represent a filter to apply to the item's attributes.
        :param type:  A type to filter on.  Only items that are an instance of this type will be returned.
        :returns: A List of :class:`Vertex` objects
        :rtype: List of :class:`Vertex` objects
        """
        if attrs is not None or type is not None:
            raise NotImplementedError("filtered get not implemented.")
        return self.vertices

    def clear_vertices(self):
        """
        Remove all the :class:`Vertex` objects from the :code:`vertices` of this :class:`Polygon`.
        
        :rtype: :code:`self`
        """
        for efp in self.vertices:
            efp.parent = None
        self.vertices = []
        return self

    def remove_vertex(self, efp):
        """
        Remove a :class:`Vertex` from the :code:`vertices` of this :class:`Polygon`.
        
        :param efp: The :class:`Vertex` object to remove.

        :rtype: :code:`self`
        """
        self.vertices = [x for x in self.vertices if x != efp]

        if efp.parent is self:
            efp.parent = None
        return self



    ### Add, lookup, and get for maps


    
    ### Getter/Setter for singletons.


    
    def get_children(self):
        """
        Get all the children of this :class:`EagleFilePart`.
        
        :rtype: List of :class:`EagleFilePart` objects
        """
        r = []

        r = r + self.vertices



        return r

    def remove_child(self, efp):
        """
        Remove a child :class:`EagleFilePart` object.
        
        :param efp: the class:`EagleFilePart` object to remove.
        :return: Nothing
        """
        try:
            self.remove_vertex(efp)
        except:
            pass

    def _rekey_child(self, oldkey, efp):
        """
        Remove a child :class:`EagleFilePart` object.
        
        :param efp: the class:`EagleFilePart` object to remove.
        :return: Nothing
        """


    def __str__(self):
        r = "["+repr(self)+" "
        r = r + "width:" + str(self.get_width()) + " "
        r = r + "layer:" + str(self.get_layer()) + " "
        r = r + "spacing:" + str(self.get_spacing()) + " "
        r = r + "pour:" + str(self.get_pour()) + " "
        r = r + "isolate:" + str(self.get_isolate()) + " "
        r = r + "orphans:" + str(self.get_orphans()) + " "
        r = r + "thermals:" + str(self.get_thermals()) + " "
        r = r + "rank:" + str(self.get_rank()) + " "
        r = r + "]"
        return r
            
    def dump(self, indent="", increment="   "):
        """
        Recursive debug dump.
        
        :param indent:  Indentation string.  The output will be indented by this much.
        :param increment: This will be appendeded to :code:`indent` on recursive invocations.

        :rtype: :code:`None`
        """
        print(indent + str(self.__class__.__name__), end=' ')
        try:
            print(self.get_name())
        except:
            print()
            pass
        for c in self.get_children():
            c.dump(indent + "   ")

        
EagleFile.class_map["polygon"] = Polygon
         


class Deviceset(EagleFilePart):
    """
    Class representing the contents of a <deviceset> tag in Eagle files.

    Attributes:

    * :code:`name`

    * :code:`prefix`

    * :code:`uservalue`

    * :code:`urn`

    * :code:`locally_modified`

    * :code:`library_version`

    * :code:`library_locally_modified`



    Collections:

    * :code:`description`: Singleton :class:`Description` object. 



    * :code:`gate`: Map of :class:`Gate` objects indexed by their :code:`name`.


    * :code:`device`: Map of :class:`Device` objects indexed by their :code:`name`.



    """
    def __init__(self):
        """
        Construct an empty :class:`Deviceset` object.
        """
        EagleFilePart.__init__(self)
        
        self.name=None
        self.prefix=None
        self.uservalue=None
        self.urn=None
        self.locally_modified=None
        self.library_version=None
        self.library_locally_modified=None
        self.gates={} #tecollections.OrderedDict()  For unclear reasons, this caused ordering to become more unpredictable, rather than less.
        self.devices={} #tecollections.OrderedDict()  For unclear reasons, this caused ordering to become more unpredictable, rather than less.
        self.description=None


        
    @classmethod
    def _from_et(cls,root,parent):
        """
        Create a :class:`Deviceset` from a :code:`deviceset` element.
        
        :param root: The element tree tree to parse.
        :param parent: :class:`EagleFilePart` that should hold the resulting :class:`EagleFilePart`
        :rtype: :class:`Deviceset`
        """
        ## Call the constructor
        n = cls()
        n._init_from_et(root,parent)
        return n

    def _get_error_name(self):
        if hasattr(self, "get_name"):
            return self.get_name();
        else:
            return "Deviceset";
        
    def  _init_from_et(self, root, parent):
        """
        Initialized a :class:`Deviceset` from a :code:`deviceset` element.  This is useful if you have a subclass of :class:`Deviceset` .
        
        :param root: The element tree tree to parse.
        :param parent: :class:`EagleFilePart` that will become the parent of :code:`this` .
        :rtype: :class:`Deviceset`
        """
        try:
            self.root = root
            
            if root.tag != "deviceset":
                raise EagleFormatError("Tried to create deviceset from " + root.tag)

            self.name=parseByType(parent, "str", None, root.get("name"))
            self.prefix=parseByType(parent, "str", None, root.get("prefix"))
            self.uservalue=parseByType(parent, "bool", None, root.get("uservalue"))
            self.urn=parseByType(parent, "str", None, root.get("urn"))
            self.locally_modified=parseByType(parent, "bool", 'no', root.get("locally_modified"))
            self.library_version=parseByType(parent, "int", None, root.get("library_version"))
            self.library_locally_modified=parseByType(parent, "bool", 'no', root.get("library_locally_modified"))

            self.parent = parent

            ### populate the maps by searching for elements that match xpath and generating objects for them.

            for c in root.xpath("./gates/gate"):
                self.add_gate(self.get_class_for_tag(c.tag)._from_et(c, self))
            for c in root.xpath("./devices/device"):
                self.add_device(self.get_class_for_tag(c.tag)._from_et(c, self))

            ### Do the same for the lists


            ### Do the same for the attr lists


            ### And the singletons

            x = root.xpath("./description")
            if len(x) is not 0:
                self.set_description(self.get_class_for_tag(x[0].tag)._from_et(x[0],self))

            ### And, finally, if the objects wants the text from the tag.

        except SwoopError as e:
            e.text = "{}:{}".format(self._get_error_name(), e.text)
            raise e


    def sortkey(self):
        r = ""
        r = r + str(self.name)
        r = r + str(self.prefix)
        r = r + str(self.uservalue)
        r = r + str(self.urn)
        r = r + str(self.locally_modified)
        r = r + str(self.library_version)
        r = r + str(self.library_locally_modified)
        return r

    def get_et(self):
        """
        Generate a <deviceset> element tree for a :class:`Deviceset`.
        
        :rtype:  :class:`ElementTree`.
        
        """
        try:
            r = ET.Element("deviceset")

            ### Set the tag attributes 


            ## Unparse the values.

            v = unparseByType(self, "str", None,  self.name)

            ## For required attributes None becomes "".  For optional attributes, we just leave the attribute out.
            if not (isinstance(self.get_parent(), LibraryFile) and False):  # special case for the name of library.
                if v is not None:
                    r.set("name", v)
                else:
                    r.set("name", "")


            ## Unparse the values.

            v = unparseByType(self, "str", None,  self.prefix)

            ## For required attributes None becomes "".  For optional attributes, we just leave the attribute out.
            if not (isinstance(self.get_parent(), LibraryFile) and False):  # special case for the name of library.
                if v is not None:
                    r.set("prefix", v)


            ## Unparse the values.

            v = unparseByType(self, "bool", None,  self.uservalue)

            ## For required attributes None becomes "".  For optional attributes, we just leave the attribute out.
            if not (isinstance(self.get_parent(), LibraryFile) and False):  # special case for the name of library.
                if v is not None:
                    r.set("uservalue", v)


            ## Unparse the values.

            v = unparseByType(self, "str", None,  self.urn)

            ## For required attributes None becomes "".  For optional attributes, we just leave the attribute out.
            if not (isinstance(self.get_parent(), LibraryFile) and False):  # special case for the name of library.
                if v is not None:
                    r.set("urn", v)


            ## Unparse the values.

            v = unparseByType(self, "bool", 'no',  self.locally_modified)

            ## For required attributes None becomes "".  For optional attributes, we just leave the attribute out.
            if not (isinstance(self.get_parent(), LibraryFile) and False):  # special case for the name of library.
                if v is not None:
                    r.set("locally_modified", v)


            ## Unparse the values.

            v = unparseByType(self, "int", None,  self.library_version)

            ## For required attributes None becomes "".  For optional attributes, we just leave the attribute out.
            if not (isinstance(self.get_parent(), LibraryFile) and False):  # special case for the name of library.
                if v is not None:
                    r.set("library_version", v)


            ## Unparse the values.

            v = unparseByType(self, "bool", 'no',  self.library_locally_modified)

            ## For required attributes None becomes "".  For optional attributes, we just leave the attribute out.
            if not (isinstance(self.get_parent(), LibraryFile) and False):  # special case for the name of library.
                if v is not None:
                    r.set("library_locally_modified", v)


            ### process the sections in order.  They have to be in section order,
            ### because eagle files are order dependent.


            ## For some tags, Eagle generates empty tags when there's no contant
            ## rather than just leaving the tag out.  We mark these with
            ## Tag.requireTag in GenerateSwoop.py and force their generation
            ## here.

            smartAddSubTags(r, "./description")


            ## or add a singleton.

            if self.description is not None:
                target = smartAddSubTags(r, "./description")
                target.append(self.description.get_et())

            ## For some tags, Eagle generates empty tags when there's no contant
            ## rather than just leaving the tag out.  We mark these with
            ## Tag.requireTag in GenerateSwoop.py and force their generation
            ## here.

            smartAddSubTags(r, "./gates/gate")


            ## add a map.

            if len(self.gates) is not 0:
                target = smartAddSubTags(r, "./gates/gate")
                # add them in sorted order.  This gives us a simple canonicalization that makes it feasible to use diff to compare files.
                target.extend([i.get_et() for i in sorted(list(self.gates.values()),key=lambda x: x.sortkey())])


            ## For some tags, Eagle generates empty tags when there's no contant
            ## rather than just leaving the tag out.  We mark these with
            ## Tag.requireTag in GenerateSwoop.py and force their generation
            ## here.

            smartAddSubTags(r, "./devices/device")


            ## add a map.

            if len(self.devices) is not 0:
                target = smartAddSubTags(r, "./devices/device")
                # add them in sorted order.  This gives us a simple canonicalization that makes it feasible to use diff to compare files.
                target.extend([i.get_et() for i in sorted(list(self.devices.values()),key=lambda x: x.sortkey())])


            ## set the text, if its needed.

        except SwoopError as e:
            e.text = "{}:{}".format(self._get_error_name(), e.text)
            raise e
        return r

    def clone(self):
        """
        Recursively clone this :code:`Deviceset`.  It will be identical to the original, but it's parent will be :code:`None`.
        
        :rtype: :class:`Deviceset`
        """
        try:
            n = copy.copy(self)
            n.gates = {}
            for x in list(self.gates.values()):
                n.add_gate(x.clone())
            n.devices = {}
            for x in list(self.devices.values()):
                n.add_device(x.clone())
            n.description = None
            if self.description is not None:
                n.set_description(self.description.clone())
            else:
                n.set_description(None)
            n.parent = None
        except SwoopError as e:
            e.text = "{}:{}".format(self._get_error_name(), e.text)
            raise e
        return n

    def accept_preorder_visitor(self, visitor):
        try:
            pre = getattr(visitor, "Deviceset_pre")
            return pre(self)
        except AttributeError:
            return visitor.default_pre(self)
        
    def accept_postorder_visitor(self, visitor, context):
        try:
            post = getattr(visitor, "Deviceset_post")
            post(self,context)
        except AttributeError:
            visitor.default_post(self,context)

    def is_equal(self, other):
        """
        Check whether two :code:`EagleFilePart` objects are identical.
        
        :param other: Object to compare to.
        :returns: :code:`True` if they are identical, otherwise, :code:`False`
        """
        return self.get_xml() == other.get_xml()
        
    ### Getters/Setters for attribute values

    def get_name(self):
        """ Return the value of :code:`name` for this :class:`Deviceset`.  This corresponds to the :code:`name` attribute of a :code:`<deviceset>` in an Eagle file.
        
        :rtype: :code:`str`
        """
        return self.name

    def set_name(self,v):
        """ Set the value of :code:`name` for this  :class:`Deviceset`.  This corresponds to the :code:`name` attribute of a :code:`<deviceset>` in an Eagle file.

        :param v: new value
        :rtype: :code:`self`
        """
                        
        oldkey = self.name
        if not typeCheck("str", v, True):
            raise SwoopError("Illegal value ({}) of type {} for attribute 'name' of Deviceset object (should be str).".format(v, type(v)))
        self.name = v
        
        if self.get_parent() is not None:
            self.get_parent()._rekey_child(oldkey, self);
        return self

    def with_name(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`name`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`name` equals :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_name()` is :code:`True`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """

        if type(v) in [str, int, float, bool]:
            return self if self.name == v else None
        elif callable(v):
            return self if v(self.name) else None
        else:
            raise SwoopError("Illegal type passed to with_name")

    def without_name(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`name`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`name` is not equal to :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_name()` is :code:`False`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """
        
        if type(v) in [str, int, float, bool]:
            return self if self.name != v else None
        elif callable(v):
            return self if not v(self.name) else None
        else:
            raise SwoopError("Illegal type passed to without_name")


    def get_prefix(self):
        """ Return the value of :code:`prefix` for this :class:`Deviceset`.  This corresponds to the :code:`prefix` attribute of a :code:`<deviceset>` in an Eagle file.
        
        :rtype: :code:`str`
        """
        return self.prefix

    def set_prefix(self,v):
        """ Set the value of :code:`prefix` for this  :class:`Deviceset`.  This corresponds to the :code:`prefix` attribute of a :code:`<deviceset>` in an Eagle file.

        :param v: new value
        :rtype: :code:`self`
        """
                        
        if not typeCheck("str", v, False):
            raise SwoopError("Illegal value ({}) of type {} for attribute 'prefix' of Deviceset object (should be str).".format(v, type(v)))
        self.prefix = v
        
        return self

    def with_prefix(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`prefix`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`prefix` equals :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_prefix()` is :code:`True`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """

        if type(v) in [str, int, float, bool]:
            return self if self.prefix == v else None
        elif callable(v):
            return self if v(self.prefix) else None
        else:
            raise SwoopError("Illegal type passed to with_prefix")

    def without_prefix(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`prefix`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`prefix` is not equal to :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_prefix()` is :code:`False`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """
        
        if type(v) in [str, int, float, bool]:
            return self if self.prefix != v else None
        elif callable(v):
            return self if not v(self.prefix) else None
        else:
            raise SwoopError("Illegal type passed to without_prefix")


    def get_uservalue(self):
        """ Return the value of :code:`uservalue` for this :class:`Deviceset`.  This corresponds to the :code:`uservalue` attribute of a :code:`<deviceset>` in an Eagle file.
        
        :rtype: :code:`bool`
        """
        return self.uservalue

    def set_uservalue(self,v):
        """ Set the value of :code:`uservalue` for this  :class:`Deviceset`.  This corresponds to the :code:`uservalue` attribute of a :code:`<deviceset>` in an Eagle file.

        :param v: new value
        :rtype: :code:`self`
        """
                        
        if not typeCheck("bool", v, False):
            raise SwoopError("Illegal value ({}) of type {} for attribute 'uservalue' of Deviceset object (should be bool).".format(v, type(v)))
        self.uservalue = v
        
        return self

    def with_uservalue(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`uservalue`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`uservalue` equals :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_uservalue()` is :code:`True`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """

        if type(v) in [str, int, float, bool]:
            return self if self.uservalue == v else None
        elif callable(v):
            return self if v(self.uservalue) else None
        else:
            raise SwoopError("Illegal type passed to with_uservalue")

    def without_uservalue(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`uservalue`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`uservalue` is not equal to :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_uservalue()` is :code:`False`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """
        
        if type(v) in [str, int, float, bool]:
            return self if self.uservalue != v else None
        elif callable(v):
            return self if not v(self.uservalue) else None
        else:
            raise SwoopError("Illegal type passed to without_uservalue")


    def get_urn(self):
        """ Return the value of :code:`urn` for this :class:`Deviceset`.  This corresponds to the :code:`urn` attribute of a :code:`<deviceset>` in an Eagle file.
        
        :rtype: :code:`str`
        """
        return self.urn

    def set_urn(self,v):
        """ Set the value of :code:`urn` for this  :class:`Deviceset`.  This corresponds to the :code:`urn` attribute of a :code:`<deviceset>` in an Eagle file.

        :param v: new value
        :rtype: :code:`self`
        """
                        
        if not typeCheck("str", v, False):
            raise SwoopError("Illegal value ({}) of type {} for attribute 'urn' of Deviceset object (should be str).".format(v, type(v)))
        self.urn = v
        
        return self

    def with_urn(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`urn`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`urn` equals :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_urn()` is :code:`True`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """

        if type(v) in [str, int, float, bool]:
            return self if self.urn == v else None
        elif callable(v):
            return self if v(self.urn) else None
        else:
            raise SwoopError("Illegal type passed to with_urn")

    def without_urn(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`urn`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`urn` is not equal to :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_urn()` is :code:`False`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """
        
        if type(v) in [str, int, float, bool]:
            return self if self.urn != v else None
        elif callable(v):
            return self if not v(self.urn) else None
        else:
            raise SwoopError("Illegal type passed to without_urn")


    def get_locally_modified(self):
        """ Return the value of :code:`locally_modified` for this :class:`Deviceset`.  This corresponds to the :code:`locally_modified` attribute of a :code:`<deviceset>` in an Eagle file.
        
        :rtype: :code:`bool`
        """
        return self.locally_modified

    def set_locally_modified(self,v):
        """ Set the value of :code:`locally_modified` for this  :class:`Deviceset`.  This corresponds to the :code:`locally_modified` attribute of a :code:`<deviceset>` in an Eagle file.

        :param v: new value
        :rtype: :code:`self`
        """
                        
        if not typeCheck("bool", v, False):
            raise SwoopError("Illegal value ({}) of type {} for attribute 'locally_modified' of Deviceset object (should be bool).".format(v, type(v)))
        self.locally_modified = v
        
        return self

    def with_locally_modified(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`locally_modified`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`locally_modified` equals :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_locally_modified()` is :code:`True`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """

        if type(v) in [str, int, float, bool]:
            return self if self.locally_modified == v else None
        elif callable(v):
            return self if v(self.locally_modified) else None
        else:
            raise SwoopError("Illegal type passed to with_locally_modified")

    def without_locally_modified(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`locally_modified`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`locally_modified` is not equal to :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_locally_modified()` is :code:`False`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """
        
        if type(v) in [str, int, float, bool]:
            return self if self.locally_modified != v else None
        elif callable(v):
            return self if not v(self.locally_modified) else None
        else:
            raise SwoopError("Illegal type passed to without_locally_modified")


    def get_library_version(self):
        """ Return the value of :code:`library_version` for this :class:`Deviceset`.  This corresponds to the :code:`library_version` attribute of a :code:`<deviceset>` in an Eagle file.
        
        :rtype: :code:`int`
        """
        return self.library_version

    def set_library_version(self,v):
        """ Set the value of :code:`library_version` for this  :class:`Deviceset`.  This corresponds to the :code:`library_version` attribute of a :code:`<deviceset>` in an Eagle file.

        :param v: new value
        :rtype: :code:`self`
        """
                        
        if not typeCheck("int", v, False):
            raise SwoopError("Illegal value ({}) of type {} for attribute 'library_version' of Deviceset object (should be int).".format(v, type(v)))
        self.library_version = v
        
        return self

    def with_library_version(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`library_version`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`library_version` equals :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_library_version()` is :code:`True`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """

        if type(v) in [str, int, float, bool]:
            return self if self.library_version == v else None
        elif callable(v):
            return self if v(self.library_version) else None
        else:
            raise SwoopError("Illegal type passed to with_library_version")

    def without_library_version(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`library_version`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`library_version` is not equal to :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_library_version()` is :code:`False`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """
        
        if type(v) in [str, int, float, bool]:
            return self if self.library_version != v else None
        elif callable(v):
            return self if not v(self.library_version) else None
        else:
            raise SwoopError("Illegal type passed to without_library_version")


    def get_library_locally_modified(self):
        """ Return the value of :code:`library_locally_modified` for this :class:`Deviceset`.  This corresponds to the :code:`library_locally_modified` attribute of a :code:`<deviceset>` in an Eagle file.
        
        :rtype: :code:`bool`
        """
        return self.library_locally_modified

    def set_library_locally_modified(self,v):
        """ Set the value of :code:`library_locally_modified` for this  :class:`Deviceset`.  This corresponds to the :code:`library_locally_modified` attribute of a :code:`<deviceset>` in an Eagle file.

        :param v: new value
        :rtype: :code:`self`
        """
                        
        if not typeCheck("bool", v, False):
            raise SwoopError("Illegal value ({}) of type {} for attribute 'library_locally_modified' of Deviceset object (should be bool).".format(v, type(v)))
        self.library_locally_modified = v
        
        return self

    def with_library_locally_modified(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`library_locally_modified`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`library_locally_modified` equals :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_library_locally_modified()` is :code:`True`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """

        if type(v) in [str, int, float, bool]:
            return self if self.library_locally_modified == v else None
        elif callable(v):
            return self if v(self.library_locally_modified) else None
        else:
            raise SwoopError("Illegal type passed to with_library_locally_modified")

    def without_library_locally_modified(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`library_locally_modified`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`library_locally_modified` is not equal to :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_library_locally_modified()` is :code:`False`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """
        
        if type(v) in [str, int, float, bool]:
            return self if self.library_locally_modified != v else None
        elif callable(v):
            return self if not v(self.library_locally_modified) else None
        else:
            raise SwoopError("Illegal type passed to without_library_locally_modified")



    ##### Lookup functions that return EFPs instead of just attribute values.
    
    


    
    ### Adder/getter/lookup for lists
    


    ### Add, lookup, and get for maps
    def add_gate(self, s):
        """ Add a :class:`Gate` to the :code:`gates` of this :class:`Deviceset`.

        :param s: The :class:`Gate` to add.
        :rtype: :code:`self`
        """
        if not any([
                isinstance(s, Gate),
            ]):
            raise SwoopError("Argument to Deviceset.add_gate() should be of type Gate.  Got " + str(type(s).__name__) + ".")
        

        self.gates[s.get_name()] = s

        s.parent = self
        return self

    def get_nth_gate(self, n):
        """ get then nth :class:`Gate` object from the :code:`gates` of this :class:`Deviceset`.
        
        :param n: Index of the item to return.

        :rtype: :class:`Gate` object
        """
        return list(self.gates.values())[n]

    def get_gate(self, key):
        """ Lookup and return a :class:`Gate` from the :code:`gates` of  this :class:`Deviceset`.
        
        :param key: A :code:`str` to use for the lookup.  The lookup uses the :code:`name` of the :class:`Gate` objects.

        :rtype: A :class:`Gate` object or :code:`None`, if there is no such item.
        """
        return self.gates.get(key)


    def get_gates(self, attrs=None, type=None):
        """Return (and possibly filter) items in the the :code:`gates` map of :class:`Gate` objects for this :class:`Deviceset`.
        
        This functions provides a mechanism for filtering the items as well.
        The keys in :code:`attrs` are taken as attributes names and the
        values are requested values.  Items in the list that have all the
        requested values for the corresponding attributes will be returned.  

        A if :code:`type` is not :code:`None`, the item will match if it is an
        instance of the type provided.
        
        :param attrs: A set of key-value pairs that represent a filter to apply to the item's attributes.
        :param type:  A type to filter on.  Only items that are an instance of this type will be returned.
        :returns: A List of :class:`Gate` objects
        :rtype: List of :class:`Gate` objects
        """
        if attrs is not None or type is not None:
            raise NotImplementedError("filtered get not implemented")
        return list(self.gates.values())
        

    def clear_gates(self):
        """
        Remove all the :class:`Gate` objects from the :code:`gates` of this :class:`Deviceset`.
        
        :rtype: :code:`self`
        """
        for efp in list(self.gates.values()):
            efp.parent = None
        self.gates = {}
        return self

    def remove_gate(self, efp):
        """
        Remove a :class:`Gate` from the :code:`gates` of this :class:`Deviceset`.
        
        :param efp: The :class:`Gate` object to remove.

        :rtype: :code:`self`
        """
        if self.gates[efp.get_name()] == efp:
            del self.gates[efp.get_name()]
            efp.parent = None
            return self
        else:
            raise SwoopError("Tried to use remove_gate() to delete the wrong kind of child?: {}".format(str(efp)))
    
    def add_device(self, s):
        """ Add a :class:`Device` to the :code:`devices` of this :class:`Deviceset`.

        :param s: The :class:`Device` to add.
        :rtype: :code:`self`
        """
        if not any([
                isinstance(s, Device),
            ]):
            raise SwoopError("Argument to Deviceset.add_device() should be of type Device.  Got " + str(type(s).__name__) + ".")
        

        self.devices[s.get_name()] = s

        s.parent = self
        return self

    def get_nth_device(self, n):
        """ get then nth :class:`Device` object from the :code:`devices` of this :class:`Deviceset`.
        
        :param n: Index of the item to return.

        :rtype: :class:`Device` object
        """
        return list(self.devices.values())[n]

    def get_device(self, key):
        """ Lookup and return a :class:`Device` from the :code:`devices` of  this :class:`Deviceset`.
        
        :param key: A :code:`str` to use for the lookup.  The lookup uses the :code:`name` of the :class:`Device` objects.

        :rtype: A :class:`Device` object or :code:`None`, if there is no such item.
        """
        return self.devices.get(key)


    def get_devices(self, attrs=None, type=None):
        """Return (and possibly filter) items in the the :code:`devices` map of :class:`Device` objects for this :class:`Deviceset`.
        
        This functions provides a mechanism for filtering the items as well.
        The keys in :code:`attrs` are taken as attributes names and the
        values are requested values.  Items in the list that have all the
        requested values for the corresponding attributes will be returned.  

        A if :code:`type` is not :code:`None`, the item will match if it is an
        instance of the type provided.
        
        :param attrs: A set of key-value pairs that represent a filter to apply to the item's attributes.
        :param type:  A type to filter on.  Only items that are an instance of this type will be returned.
        :returns: A List of :class:`Device` objects
        :rtype: List of :class:`Device` objects
        """
        if attrs is not None or type is not None:
            raise NotImplementedError("filtered get not implemented")
        return list(self.devices.values())
        

    def clear_devices(self):
        """
        Remove all the :class:`Device` objects from the :code:`devices` of this :class:`Deviceset`.
        
        :rtype: :code:`self`
        """
        for efp in list(self.devices.values()):
            efp.parent = None
        self.devices = {}
        return self

    def remove_device(self, efp):
        """
        Remove a :class:`Device` from the :code:`devices` of this :class:`Deviceset`.
        
        :param efp: The :class:`Device` object to remove.

        :rtype: :code:`self`
        """
        if self.devices[efp.get_name()] == efp:
            del self.devices[efp.get_name()]
            efp.parent = None
            return self
        else:
            raise SwoopError("Tried to use remove_device() to delete the wrong kind of child?: {}".format(str(efp)))
    


    
    ### Getter/Setter for singletons.

    def set_description(self, s):
        """ Set the :class:`Description` for this  :class:`Deviceset`.

        :param s: :class:`Description` to set.
        :rtype: :code:`self`
        """
        if self.description is not None:
            self.description.parent = None
        self.description = s
        if s is not None:
            s.parent = self
        return self

    def get_description(self):
        """ Get the description from this :class:`Deviceset`.
        
        :rtype: :class:`Description` object
        """
        return self.description


    
    def get_children(self):
        """
        Get all the children of this :class:`EagleFilePart`.
        
        :rtype: List of :class:`EagleFilePart` objects
        """
        r = []


        r = r + list(self.gates.values())
        r = r + list(self.devices.values())

        if self.description is not None:
            r = r + [self.description]

        return r

    def remove_child(self, efp):
        """
        Remove a child :class:`EagleFilePart` object.
        
        :param efp: the class:`EagleFilePart` object to remove.
        :return: Nothing
        """
        try:
            self.remove_gate(efp)
        except:
            pass
        try:
            self.remove_device(efp)
        except:
            pass
        if self.get_description() == efp:
            self.set_description(None)

    def _rekey_child(self, oldkey, efp):
        """
        Remove a child :class:`EagleFilePart` object.
        
        :param efp: the class:`EagleFilePart` object to remove.
        :return: Nothing
        """
        try:
            if self.get_gate(oldkey) == efp:
                del self.gates[oldkey]
                self.add_gate(efp)
        except SwoopError:
            pass
        try:
            if self.get_device(oldkey) == efp:
                del self.devices[oldkey]
                self.add_device(efp)
        except SwoopError:
            pass

    def check_sanity(self, visited_efps = None):
        EagleFilePart.check_sanity(self, visited_efps)

        # Check whether keys in our maps match the keys in our children
        for k in self.gates:
            if self.gates[k].get_name() != k:
                raise SwoopError("Child's name ('{}') doesn't match key in parent's map ('{}')".format(self.gates[k].get_name(),k))
        for k in self.devices:
            if self.devices[k].get_name() != k:
                raise SwoopError("Child's name ('{}') doesn't match key in parent's map ('{}')".format(self.devices[k].get_name(),k))

    def __str__(self):
        r = "["+repr(self)+" "
        r = r + "name:" + str(self.get_name()) + " "
        r = r + "prefix:" + str(self.get_prefix()) + " "
        r = r + "uservalue:" + str(self.get_uservalue()) + " "
        r = r + "urn:" + str(self.get_urn()) + " "
        r = r + "locally_modified:" + str(self.get_locally_modified()) + " "
        r = r + "library_version:" + str(self.get_library_version()) + " "
        r = r + "library_locally_modified:" + str(self.get_library_locally_modified()) + " "
        r = r + "]"
        return r
            
    def dump(self, indent="", increment="   "):
        """
        Recursive debug dump.
        
        :param indent:  Indentation string.  The output will be indented by this much.
        :param increment: This will be appendeded to :code:`indent` on recursive invocations.

        :rtype: :code:`None`
        """
        print(indent + str(self.__class__.__name__), end=' ')
        try:
            print(self.get_name())
        except:
            print()
            pass
        for c in self.get_children():
            c.dump(indent + "   ")

        
EagleFile.class_map["deviceset"] = Deviceset
         


class Param(EagleFilePart):
    """
    Class representing the contents of a <param> tag in Eagle files.

    Attributes:

    * :code:`name`

    * :code:`value`


    """
    def __init__(self):
        """
        Construct an empty :class:`Param` object.
        """
        EagleFilePart.__init__(self)
        
        self.name=None
        self.value=None


        
    @classmethod
    def _from_et(cls,root,parent):
        """
        Create a :class:`Param` from a :code:`param` element.
        
        :param root: The element tree tree to parse.
        :param parent: :class:`EagleFilePart` that should hold the resulting :class:`EagleFilePart`
        :rtype: :class:`Param`
        """
        ## Call the constructor
        n = cls()
        n._init_from_et(root,parent)
        return n

    def _get_error_name(self):
        if hasattr(self, "get_name"):
            return self.get_name();
        else:
            return "Param";
        
    def  _init_from_et(self, root, parent):
        """
        Initialized a :class:`Param` from a :code:`param` element.  This is useful if you have a subclass of :class:`Param` .
        
        :param root: The element tree tree to parse.
        :param parent: :class:`EagleFilePart` that will become the parent of :code:`this` .
        :rtype: :class:`Param`
        """
        try:
            self.root = root
            
            if root.tag != "param":
                raise EagleFormatError("Tried to create param from " + root.tag)

            self.name=parseByType(parent, "str", None, root.get("name"))
            self.value=parseByType(parent, "str", None, root.get("value"))

            self.parent = parent

            ### populate the maps by searching for elements that match xpath and generating objects for them.


            ### Do the same for the lists


            ### Do the same for the attr lists


            ### And the singletons


            ### And, finally, if the objects wants the text from the tag.

        except SwoopError as e:
            e.text = "{}:{}".format(self._get_error_name(), e.text)
            raise e


    def sortkey(self):
        r = ""
        r = r + str(self.name)
        r = r + str(self.value)
        return r

    def get_et(self):
        """
        Generate a <param> element tree for a :class:`Param`.
        
        :rtype:  :class:`ElementTree`.
        
        """
        try:
            r = ET.Element("param")

            ### Set the tag attributes 


            ## Unparse the values.

            v = unparseByType(self, "str", None,  self.name)

            ## For required attributes None becomes "".  For optional attributes, we just leave the attribute out.
            if not (isinstance(self.get_parent(), LibraryFile) and False):  # special case for the name of library.
                if v is not None:
                    r.set("name", v)
                else:
                    r.set("name", "")


            ## Unparse the values.

            v = unparseByType(self, "str", None,  self.value)

            ## For required attributes None becomes "".  For optional attributes, we just leave the attribute out.
            if not (isinstance(self.get_parent(), LibraryFile) and False):  # special case for the name of library.
                if v is not None:
                    r.set("value", v)
                else:
                    r.set("value", "")


            ### process the sections in order.  They have to be in section order,
            ### because eagle files are order dependent.


            ## set the text, if its needed.

        except SwoopError as e:
            e.text = "{}:{}".format(self._get_error_name(), e.text)
            raise e
        return r

    def clone(self):
        """
        Recursively clone this :code:`Param`.  It will be identical to the original, but it's parent will be :code:`None`.
        
        :rtype: :class:`Param`
        """
        try:
            n = copy.copy(self)
            n.parent = None
        except SwoopError as e:
            e.text = "{}:{}".format(self._get_error_name(), e.text)
            raise e
        return n

    def accept_preorder_visitor(self, visitor):
        try:
            pre = getattr(visitor, "Param_pre")
            return pre(self)
        except AttributeError:
            return visitor.default_pre(self)
        
    def accept_postorder_visitor(self, visitor, context):
        try:
            post = getattr(visitor, "Param_post")
            post(self,context)
        except AttributeError:
            visitor.default_post(self,context)

    def is_equal(self, other):
        """
        Check whether two :code:`EagleFilePart` objects are identical.
        
        :param other: Object to compare to.
        :returns: :code:`True` if they are identical, otherwise, :code:`False`
        """
        return self.get_xml() == other.get_xml()
        
    ### Getters/Setters for attribute values

    def get_name(self):
        """ Return the value of :code:`name` for this :class:`Param`.  This corresponds to the :code:`name` attribute of a :code:`<param>` in an Eagle file.
        
        :rtype: :code:`str`
        """
        return self.name

    def set_name(self,v):
        """ Set the value of :code:`name` for this  :class:`Param`.  This corresponds to the :code:`name` attribute of a :code:`<param>` in an Eagle file.

        :param v: new value
        :rtype: :code:`self`
        """
                        
        oldkey = self.name
        if not typeCheck("str", v, True):
            raise SwoopError("Illegal value ({}) of type {} for attribute 'name' of Param object (should be str).".format(v, type(v)))
        self.name = v
        
        if self.get_parent() is not None:
            self.get_parent()._rekey_child(oldkey, self);
        return self

    def with_name(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`name`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`name` equals :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_name()` is :code:`True`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """

        if type(v) in [str, int, float, bool]:
            return self if self.name == v else None
        elif callable(v):
            return self if v(self.name) else None
        else:
            raise SwoopError("Illegal type passed to with_name")

    def without_name(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`name`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`name` is not equal to :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_name()` is :code:`False`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """
        
        if type(v) in [str, int, float, bool]:
            return self if self.name != v else None
        elif callable(v):
            return self if not v(self.name) else None
        else:
            raise SwoopError("Illegal type passed to without_name")


    def get_value(self):
        """ Return the value of :code:`value` for this :class:`Param`.  This corresponds to the :code:`value` attribute of a :code:`<param>` in an Eagle file.
        
        :rtype: :code:`str`
        """
        return self.value

    def set_value(self,v):
        """ Set the value of :code:`value` for this  :class:`Param`.  This corresponds to the :code:`value` attribute of a :code:`<param>` in an Eagle file.

        :param v: new value
        :rtype: :code:`self`
        """
                        
        if not typeCheck("str", v, True):
            raise SwoopError("Illegal value ({}) of type {} for attribute 'value' of Param object (should be str).".format(v, type(v)))
        self.value = v
        
        return self

    def with_value(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`value`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`value` equals :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_value()` is :code:`True`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """

        if type(v) in [str, int, float, bool]:
            return self if self.value == v else None
        elif callable(v):
            return self if v(self.value) else None
        else:
            raise SwoopError("Illegal type passed to with_value")

    def without_value(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`value`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`value` is not equal to :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_value()` is :code:`False`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """
        
        if type(v) in [str, int, float, bool]:
            return self if self.value != v else None
        elif callable(v):
            return self if not v(self.value) else None
        else:
            raise SwoopError("Illegal type passed to without_value")



    ##### Lookup functions that return EFPs instead of just attribute values.
    
    


    
    ### Adder/getter/lookup for lists
    


    ### Add, lookup, and get for maps


    
    ### Getter/Setter for singletons.


    
    def get_children(self):
        """
        Get all the children of this :class:`EagleFilePart`.
        
        :rtype: List of :class:`EagleFilePart` objects
        """
        r = []




        return r

    def remove_child(self, efp):
        """
        Remove a child :class:`EagleFilePart` object.
        
        :param efp: the class:`EagleFilePart` object to remove.
        :return: Nothing
        """

    def _rekey_child(self, oldkey, efp):
        """
        Remove a child :class:`EagleFilePart` object.
        
        :param efp: the class:`EagleFilePart` object to remove.
        :return: Nothing
        """


    def __str__(self):
        r = "["+repr(self)+" "
        r = r + "name:" + str(self.get_name()) + " "
        r = r + "value:" + str(self.get_value()) + " "
        r = r + "]"
        return r
            
    def dump(self, indent="", increment="   "):
        """
        Recursive debug dump.
        
        :param indent:  Indentation string.  The output will be indented by this much.
        :param increment: This will be appendeded to :code:`indent` on recursive invocations.

        :rtype: :code:`None`
        """
        print(indent + str(self.__class__.__name__), end=' ')
        try:
            print(self.get_name())
        except:
            print()
            pass
        for c in self.get_children():
            c.dump(indent + "   ")

        
EagleFile.class_map["param"] = Param
         


class Label(EagleFilePart, OnePointGeometry, RotationGeometry):
    """
    Class representing the contents of a <label> tag in Eagle files.

    Attributes:

    * :code:`x`

    * :code:`y`

    * :code:`size`

    * :code:`layer`

    * :code:`font`

    * :code:`ratio`

    * :code:`rot`

    * :code:`xref`


    """
    def __init__(self):
        """
        Construct an empty :class:`Label` object.
        """
        EagleFilePart.__init__(self)
        OnePointGeometry.__init__(self)
        RotationGeometry.__init__(self)
        
        self.x=None
        self.y=None
        self.size=None
        self.layer=None
        self.font=None
        self.ratio=None
        self.rot=None
        self.xref=None


        
    @classmethod
    def _from_et(cls,root,parent):
        """
        Create a :class:`Label` from a :code:`label` element.
        
        :param root: The element tree tree to parse.
        :param parent: :class:`EagleFilePart` that should hold the resulting :class:`EagleFilePart`
        :rtype: :class:`Label`
        """
        ## Call the constructor
        n = cls()
        n._init_from_et(root,parent)
        return n

    def _get_error_name(self):
        if hasattr(self, "get_name"):
            return self.get_name();
        else:
            return "Label";
        
    def  _init_from_et(self, root, parent):
        """
        Initialized a :class:`Label` from a :code:`label` element.  This is useful if you have a subclass of :class:`Label` .
        
        :param root: The element tree tree to parse.
        :param parent: :class:`EagleFilePart` that will become the parent of :code:`this` .
        :rtype: :class:`Label`
        """
        try:
            self.root = root
            
            if root.tag != "label":
                raise EagleFormatError("Tried to create label from " + root.tag)

            self.x=parseByType(parent, "float", None, root.get("x"))
            self.y=parseByType(parent, "float", None, root.get("y"))
            self.size=parseByType(parent, "float", None, root.get("size"))
            self.layer=parseByType(parent, "layer_string", None, root.get("layer"))
            self.font=parseByType(parent, "str", None, root.get("font"))
            self.ratio=parseByType(parent, "int", None, root.get("ratio"))
            self.rot=parseByType(parent, "str", None, root.get("rot"))
            self.xref=parseByType(parent, "bool", None, root.get("xref"))

            self.parent = parent

            ### populate the maps by searching for elements that match xpath and generating objects for them.


            ### Do the same for the lists


            ### Do the same for the attr lists


            ### And the singletons


            ### And, finally, if the objects wants the text from the tag.

        except SwoopError as e:
            e.text = "{}:{}".format(self._get_error_name(), e.text)
            raise e


    def sortkey(self):
        r = ""
        r = r + str(self.x)
        r = r + str(self.y)
        r = r + str(self.size)
        r = r + str(self.layer)
        r = r + str(self.font)
        r = r + str(self.ratio)
        r = r + str(self.rot)
        r = r + str(self.xref)
        return r

    def get_et(self):
        """
        Generate a <label> element tree for a :class:`Label`.
        
        :rtype:  :class:`ElementTree`.
        
        """
        try:
            r = ET.Element("label")

            ### Set the tag attributes 


            ## Unparse the values.

            v = unparseByType(self, "float", None,  self.x)

            ## For required attributes None becomes "".  For optional attributes, we just leave the attribute out.
            if not (isinstance(self.get_parent(), LibraryFile) and False):  # special case for the name of library.
                if v is not None:
                    r.set("x", v)
                else:
                    r.set("x", "")


            ## Unparse the values.

            v = unparseByType(self, "float", None,  self.y)

            ## For required attributes None becomes "".  For optional attributes, we just leave the attribute out.
            if not (isinstance(self.get_parent(), LibraryFile) and False):  # special case for the name of library.
                if v is not None:
                    r.set("y", v)
                else:
                    r.set("y", "")


            ## Unparse the values.

            v = unparseByType(self, "float", None,  self.size)

            ## For required attributes None becomes "".  For optional attributes, we just leave the attribute out.
            if not (isinstance(self.get_parent(), LibraryFile) and False):  # special case for the name of library.
                if v is not None:
                    r.set("size", v)
                else:
                    r.set("size", "")


            ## Unparse the values.

            v = unparseByType(self, "layer_string", None,  self.layer)

            ## For required attributes None becomes "".  For optional attributes, we just leave the attribute out.
            if not (isinstance(self.get_parent(), LibraryFile) and False):  # special case for the name of library.
                if v is not None:
                    r.set("layer", v)
                else:
                    r.set("layer", "")


            ## Unparse the values.

            v = unparseByType(self, "str", None,  self.font)

            ## For required attributes None becomes "".  For optional attributes, we just leave the attribute out.
            if not (isinstance(self.get_parent(), LibraryFile) and False):  # special case for the name of library.
                if v is not None:
                    r.set("font", v)


            ## Unparse the values.

            v = unparseByType(self, "int", None,  self.ratio)

            ## For required attributes None becomes "".  For optional attributes, we just leave the attribute out.
            if not (isinstance(self.get_parent(), LibraryFile) and False):  # special case for the name of library.
                if v is not None:
                    r.set("ratio", v)


            ## Unparse the values.

            v = unparseByType(self, "str", None,  self.rot)

            ## For required attributes None becomes "".  For optional attributes, we just leave the attribute out.
            if not (isinstance(self.get_parent(), LibraryFile) and False):  # special case for the name of library.
                if v is not None:
                    r.set("rot", v)


            ## Unparse the values.

            v = unparseByType(self, "bool", None,  self.xref)

            ## For required attributes None becomes "".  For optional attributes, we just leave the attribute out.
            if not (isinstance(self.get_parent(), LibraryFile) and False):  # special case for the name of library.
                if v is not None:
                    r.set("xref", v)


            ### process the sections in order.  They have to be in section order,
            ### because eagle files are order dependent.


            ## set the text, if its needed.

        except SwoopError as e:
            e.text = "{}:{}".format(self._get_error_name(), e.text)
            raise e
        return r

    def clone(self):
        """
        Recursively clone this :code:`Label`.  It will be identical to the original, but it's parent will be :code:`None`.
        
        :rtype: :class:`Label`
        """
        try:
            n = copy.copy(self)
            n.parent = None
        except SwoopError as e:
            e.text = "{}:{}".format(self._get_error_name(), e.text)
            raise e
        return n

    def accept_preorder_visitor(self, visitor):
        try:
            pre = getattr(visitor, "Label_pre")
            return pre(self)
        except AttributeError:
            return visitor.default_pre(self)
        
    def accept_postorder_visitor(self, visitor, context):
        try:
            post = getattr(visitor, "Label_post")
            post(self,context)
        except AttributeError:
            visitor.default_post(self,context)

    def is_equal(self, other):
        """
        Check whether two :code:`EagleFilePart` objects are identical.
        
        :param other: Object to compare to.
        :returns: :code:`True` if they are identical, otherwise, :code:`False`
        """
        return self.get_xml() == other.get_xml()
        
    ### Getters/Setters for attribute values

    def get_x(self):
        """ Return the value of :code:`x` for this :class:`Label`.  This corresponds to the :code:`x` attribute of a :code:`<label>` in an Eagle file.
        
        :rtype: :code:`float`
        """
        return self.x

    def set_x(self,v):
        """ Set the value of :code:`x` for this  :class:`Label`.  This corresponds to the :code:`x` attribute of a :code:`<label>` in an Eagle file.

        :param v: new value
        :rtype: :code:`self`
        """
                        
        if not typeCheck("float", v, True):
            raise SwoopError("Illegal value ({}) of type {} for attribute 'x' of Label object (should be float).".format(v, type(v)))
        self.x = v
        
        return self

    def with_x(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`x`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`x` equals :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_x()` is :code:`True`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """

        if type(v) in [str, int, float, bool]:
            return self if self.x == v else None
        elif callable(v):
            return self if v(self.x) else None
        else:
            raise SwoopError("Illegal type passed to with_x")

    def without_x(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`x`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`x` is not equal to :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_x()` is :code:`False`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """
        
        if type(v) in [str, int, float, bool]:
            return self if self.x != v else None
        elif callable(v):
            return self if not v(self.x) else None
        else:
            raise SwoopError("Illegal type passed to without_x")


    def get_y(self):
        """ Return the value of :code:`y` for this :class:`Label`.  This corresponds to the :code:`y` attribute of a :code:`<label>` in an Eagle file.
        
        :rtype: :code:`float`
        """
        return self.y

    def set_y(self,v):
        """ Set the value of :code:`y` for this  :class:`Label`.  This corresponds to the :code:`y` attribute of a :code:`<label>` in an Eagle file.

        :param v: new value
        :rtype: :code:`self`
        """
                        
        if not typeCheck("float", v, True):
            raise SwoopError("Illegal value ({}) of type {} for attribute 'y' of Label object (should be float).".format(v, type(v)))
        self.y = v
        
        return self

    def with_y(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`y`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`y` equals :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_y()` is :code:`True`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """

        if type(v) in [str, int, float, bool]:
            return self if self.y == v else None
        elif callable(v):
            return self if v(self.y) else None
        else:
            raise SwoopError("Illegal type passed to with_y")

    def without_y(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`y`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`y` is not equal to :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_y()` is :code:`False`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """
        
        if type(v) in [str, int, float, bool]:
            return self if self.y != v else None
        elif callable(v):
            return self if not v(self.y) else None
        else:
            raise SwoopError("Illegal type passed to without_y")


    def get_size(self):
        """ Return the value of :code:`size` for this :class:`Label`.  This corresponds to the :code:`size` attribute of a :code:`<label>` in an Eagle file.
        
        :rtype: :code:`float`
        """
        return self.size

    def set_size(self,v):
        """ Set the value of :code:`size` for this  :class:`Label`.  This corresponds to the :code:`size` attribute of a :code:`<label>` in an Eagle file.

        :param v: new value
        :rtype: :code:`self`
        """
                        
        if not typeCheck("float", v, True):
            raise SwoopError("Illegal value ({}) of type {} for attribute 'size' of Label object (should be float).".format(v, type(v)))
        self.size = v
        
        return self

    def with_size(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`size`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`size` equals :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_size()` is :code:`True`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """

        if type(v) in [str, int, float, bool]:
            return self if self.size == v else None
        elif callable(v):
            return self if v(self.size) else None
        else:
            raise SwoopError("Illegal type passed to with_size")

    def without_size(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`size`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`size` is not equal to :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_size()` is :code:`False`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """
        
        if type(v) in [str, int, float, bool]:
            return self if self.size != v else None
        elif callable(v):
            return self if not v(self.size) else None
        else:
            raise SwoopError("Illegal type passed to without_size")


    def get_layer(self):
        """ Return the value of :code:`layer` for this :class:`Label`.  This corresponds to the :code:`layer` attribute of a :code:`<label>` in an Eagle file.
        
        :rtype: :code:`layer_string`
        """
        return self.layer

    def set_layer(self,v):
        """ Set the value of :code:`layer` for this  :class:`Label`.  This corresponds to the :code:`layer` attribute of a :code:`<label>` in an Eagle file.

        :param v: new value
        :rtype: :code:`self`
        """
                        
        if not typeCheck("layer_string", v, True):
            raise SwoopError("Illegal value ({}) of type {} for attribute 'layer' of Label object (should be layer_string).".format(v, type(v)))
        self.layer = v
        
        return self

    def with_layer(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`layer`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`layer` equals :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_layer()` is :code:`True`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """

        if type(v) in [str, int, float, bool]:
            return self if self.layer == v else None
        elif callable(v):
            return self if v(self.layer) else None
        else:
            raise SwoopError("Illegal type passed to with_layer")

    def without_layer(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`layer`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`layer` is not equal to :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_layer()` is :code:`False`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """
        
        if type(v) in [str, int, float, bool]:
            return self if self.layer != v else None
        elif callable(v):
            return self if not v(self.layer) else None
        else:
            raise SwoopError("Illegal type passed to without_layer")


    def get_font(self):
        """ Return the value of :code:`font` for this :class:`Label`.  This corresponds to the :code:`font` attribute of a :code:`<label>` in an Eagle file.
        
        :rtype: :code:`str`
        """
        return self.font

    def set_font(self,v):
        """ Set the value of :code:`font` for this  :class:`Label`.  This corresponds to the :code:`font` attribute of a :code:`<label>` in an Eagle file.

        :param v: new value
        :rtype: :code:`self`
        """
                        
        if not typeCheck("str", v, False):
            raise SwoopError("Illegal value ({}) of type {} for attribute 'font' of Label object (should be str).".format(v, type(v)))
        self.font = v
        
        return self

    def with_font(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`font`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`font` equals :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_font()` is :code:`True`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """

        if type(v) in [str, int, float, bool]:
            return self if self.font == v else None
        elif callable(v):
            return self if v(self.font) else None
        else:
            raise SwoopError("Illegal type passed to with_font")

    def without_font(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`font`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`font` is not equal to :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_font()` is :code:`False`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """
        
        if type(v) in [str, int, float, bool]:
            return self if self.font != v else None
        elif callable(v):
            return self if not v(self.font) else None
        else:
            raise SwoopError("Illegal type passed to without_font")


    def get_ratio(self):
        """ Return the value of :code:`ratio` for this :class:`Label`.  This corresponds to the :code:`ratio` attribute of a :code:`<label>` in an Eagle file.
        
        :rtype: :code:`int`
        """
        return self.ratio

    def set_ratio(self,v):
        """ Set the value of :code:`ratio` for this  :class:`Label`.  This corresponds to the :code:`ratio` attribute of a :code:`<label>` in an Eagle file.

        :param v: new value
        :rtype: :code:`self`
        """
                        
        if not typeCheck("int", v, False):
            raise SwoopError("Illegal value ({}) of type {} for attribute 'ratio' of Label object (should be int).".format(v, type(v)))
        self.ratio = v
        
        return self

    def with_ratio(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`ratio`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`ratio` equals :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_ratio()` is :code:`True`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """

        if type(v) in [str, int, float, bool]:
            return self if self.ratio == v else None
        elif callable(v):
            return self if v(self.ratio) else None
        else:
            raise SwoopError("Illegal type passed to with_ratio")

    def without_ratio(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`ratio`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`ratio` is not equal to :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_ratio()` is :code:`False`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """
        
        if type(v) in [str, int, float, bool]:
            return self if self.ratio != v else None
        elif callable(v):
            return self if not v(self.ratio) else None
        else:
            raise SwoopError("Illegal type passed to without_ratio")


    def get_rot(self):
        """ Return the value of :code:`rot` for this :class:`Label`.  This corresponds to the :code:`rot` attribute of a :code:`<label>` in an Eagle file.
        
        :rtype: :code:`str`
        """
        return self.rot

    def set_rot(self,v):
        """ Set the value of :code:`rot` for this  :class:`Label`.  This corresponds to the :code:`rot` attribute of a :code:`<label>` in an Eagle file.

        :param v: new value
        :rtype: :code:`self`
        """
                        
        if not typeCheck("str", v, False):
            raise SwoopError("Illegal value ({}) of type {} for attribute 'rot' of Label object (should be str).".format(v, type(v)))
        self.rot = v
        
        return self

    def with_rot(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`rot`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`rot` equals :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_rot()` is :code:`True`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """

        if type(v) in [str, int, float, bool]:
            return self if self.rot == v else None
        elif callable(v):
            return self if v(self.rot) else None
        else:
            raise SwoopError("Illegal type passed to with_rot")

    def without_rot(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`rot`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`rot` is not equal to :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_rot()` is :code:`False`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """
        
        if type(v) in [str, int, float, bool]:
            return self if self.rot != v else None
        elif callable(v):
            return self if not v(self.rot) else None
        else:
            raise SwoopError("Illegal type passed to without_rot")


    def get_xref(self):
        """ Return the value of :code:`xref` for this :class:`Label`.  This corresponds to the :code:`xref` attribute of a :code:`<label>` in an Eagle file.
        
        :rtype: :code:`bool`
        """
        return self.xref

    def set_xref(self,v):
        """ Set the value of :code:`xref` for this  :class:`Label`.  This corresponds to the :code:`xref` attribute of a :code:`<label>` in an Eagle file.

        :param v: new value
        :rtype: :code:`self`
        """
                        
        if not typeCheck("bool", v, False):
            raise SwoopError("Illegal value ({}) of type {} for attribute 'xref' of Label object (should be bool).".format(v, type(v)))
        self.xref = v
        
        return self

    def with_xref(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`xref`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`xref` equals :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_xref()` is :code:`True`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """

        if type(v) in [str, int, float, bool]:
            return self if self.xref == v else None
        elif callable(v):
            return self if v(self.xref) else None
        else:
            raise SwoopError("Illegal type passed to with_xref")

    def without_xref(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`xref`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`xref` is not equal to :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_xref()` is :code:`False`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """
        
        if type(v) in [str, int, float, bool]:
            return self if self.xref != v else None
        elif callable(v):
            return self if not v(self.xref) else None
        else:
            raise SwoopError("Illegal type passed to without_xref")



    ##### Lookup functions that return EFPs instead of just attribute values.
    
    


    
    ### Adder/getter/lookup for lists
    


    ### Add, lookup, and get for maps


    
    ### Getter/Setter for singletons.


    
    def get_children(self):
        """
        Get all the children of this :class:`EagleFilePart`.
        
        :rtype: List of :class:`EagleFilePart` objects
        """
        r = []




        return r

    def remove_child(self, efp):
        """
        Remove a child :class:`EagleFilePart` object.
        
        :param efp: the class:`EagleFilePart` object to remove.
        :return: Nothing
        """

    def _rekey_child(self, oldkey, efp):
        """
        Remove a child :class:`EagleFilePart` object.
        
        :param efp: the class:`EagleFilePart` object to remove.
        :return: Nothing
        """


    def __str__(self):
        r = "["+repr(self)+" "
        r = r + "x:" + str(self.get_x()) + " "
        r = r + "y:" + str(self.get_y()) + " "
        r = r + "size:" + str(self.get_size()) + " "
        r = r + "layer:" + str(self.get_layer()) + " "
        r = r + "font:" + str(self.get_font()) + " "
        r = r + "ratio:" + str(self.get_ratio()) + " "
        r = r + "rot:" + str(self.get_rot()) + " "
        r = r + "xref:" + str(self.get_xref()) + " "
        r = r + "]"
        return r
            
    def dump(self, indent="", increment="   "):
        """
        Recursive debug dump.
        
        :param indent:  Indentation string.  The output will be indented by this much.
        :param increment: This will be appendeded to :code:`indent` on recursive invocations.

        :rtype: :code:`None`
        """
        print(indent + str(self.__class__.__name__), end=' ')
        try:
            print(self.get_name())
        except:
            print()
            pass
        for c in self.get_children():
            c.dump(indent + "   ")

        
EagleFile.class_map["label"] = Label
         


class Note(EagleFilePart):
    """
    Class representing the contents of a <note> tag in Eagle files.

    Attributes:

    * :code:`minversion`

    * :code:`version`

    * :code:`severity`


    """
    def __init__(self):
        """
        Construct an empty :class:`Note` object.
        """
        EagleFilePart.__init__(self)
        
        self.minversion=None
        self.version=None
        self.severity=None

        self.text = ""

        
    @classmethod
    def _from_et(cls,root,parent):
        """
        Create a :class:`Note` from a :code:`note` element.
        
        :param root: The element tree tree to parse.
        :param parent: :class:`EagleFilePart` that should hold the resulting :class:`EagleFilePart`
        :rtype: :class:`Note`
        """
        ## Call the constructor
        n = cls()
        n._init_from_et(root,parent)
        return n

    def _get_error_name(self):
        if hasattr(self, "get_name"):
            return self.get_name();
        else:
            return "Note";
        
    def  _init_from_et(self, root, parent):
        """
        Initialized a :class:`Note` from a :code:`note` element.  This is useful if you have a subclass of :class:`Note` .
        
        :param root: The element tree tree to parse.
        :param parent: :class:`EagleFilePart` that will become the parent of :code:`this` .
        :rtype: :class:`Note`
        """
        try:
            self.root = root
            
            if root.tag != "note":
                raise EagleFormatError("Tried to create note from " + root.tag)

            self.minversion=parseByType(parent, "str", None, root.get("minversion"))
            self.version=parseByType(parent, "str", None, root.get("version"))
            self.severity=parseByType(parent, "str", None, root.get("severity"))

            self.parent = parent

            ### populate the maps by searching for elements that match xpath and generating objects for them.


            ### Do the same for the lists


            ### Do the same for the attr lists


            ### And the singletons


            ### And, finally, if the objects wants the text from the tag.

            self.text = root.text or "" # If root.text is None, we still need a string.
        except SwoopError as e:
            e.text = "{}:{}".format(self._get_error_name(), e.text)
            raise e


    def sortkey(self):
        r = ""
        r = r + str(self.minversion)
        r = r + str(self.version)
        r = r + str(self.severity)
        return r

    def get_et(self):
        """
        Generate a <note> element tree for a :class:`Note`.
        
        :rtype:  :class:`ElementTree`.
        
        """
        try:
            r = ET.Element("note")

            ### Set the tag attributes 


            ## Unparse the values.

            v = unparseByType(self, "str", None,  self.minversion)

            ## For required attributes None becomes "".  For optional attributes, we just leave the attribute out.
            if not (isinstance(self.get_parent(), LibraryFile) and False):  # special case for the name of library.
                if v is not None:
                    r.set("minversion", v)
                else:
                    r.set("minversion", "")


            ## Unparse the values.

            v = unparseByType(self, "str", None,  self.version)

            ## For required attributes None becomes "".  For optional attributes, we just leave the attribute out.
            if not (isinstance(self.get_parent(), LibraryFile) and False):  # special case for the name of library.
                if v is not None:
                    r.set("version", v)
                else:
                    r.set("version", "")


            ## Unparse the values.

            v = unparseByType(self, "str", None,  self.severity)

            ## For required attributes None becomes "".  For optional attributes, we just leave the attribute out.
            if not (isinstance(self.get_parent(), LibraryFile) and False):  # special case for the name of library.
                if v is not None:
                    r.set("severity", v)
                else:
                    r.set("severity", "")


            ### process the sections in order.  They have to be in section order,
            ### because eagle files are order dependent.


            ## set the text, if its needed.

            r.text = self.text
        except SwoopError as e:
            e.text = "{}:{}".format(self._get_error_name(), e.text)
            raise e
        return r

    def clone(self):
        """
        Recursively clone this :code:`Note`.  It will be identical to the original, but it's parent will be :code:`None`.
        
        :rtype: :class:`Note`
        """
        try:
            n = copy.copy(self)
            n.parent = None
        except SwoopError as e:
            e.text = "{}:{}".format(self._get_error_name(), e.text)
            raise e
        return n

    def accept_preorder_visitor(self, visitor):
        try:
            pre = getattr(visitor, "Note_pre")
            return pre(self)
        except AttributeError:
            return visitor.default_pre(self)
        
    def accept_postorder_visitor(self, visitor, context):
        try:
            post = getattr(visitor, "Note_post")
            post(self,context)
        except AttributeError:
            visitor.default_post(self,context)

    def is_equal(self, other):
        """
        Check whether two :code:`EagleFilePart` objects are identical.
        
        :param other: Object to compare to.
        :returns: :code:`True` if they are identical, otherwise, :code:`False`
        """
        return self.get_xml() == other.get_xml()
        
    ### Getters/Setters for attribute values

    def get_minversion(self):
        """ Return the value of :code:`minversion` for this :class:`Note`.  This corresponds to the :code:`minversion` attribute of a :code:`<note>` in an Eagle file.
        
        :rtype: :code:`str`
        """
        return self.minversion

    def set_minversion(self,v):
        """ Set the value of :code:`minversion` for this  :class:`Note`.  This corresponds to the :code:`minversion` attribute of a :code:`<note>` in an Eagle file.

        :param v: new value
        :rtype: :code:`self`
        """
                        
        if not typeCheck("str", v, True):
            raise SwoopError("Illegal value ({}) of type {} for attribute 'minversion' of Note object (should be str).".format(v, type(v)))
        self.minversion = v
        
        return self

    def with_minversion(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`minversion`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`minversion` equals :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_minversion()` is :code:`True`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """

        if type(v) in [str, int, float, bool]:
            return self if self.minversion == v else None
        elif callable(v):
            return self if v(self.minversion) else None
        else:
            raise SwoopError("Illegal type passed to with_minversion")

    def without_minversion(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`minversion`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`minversion` is not equal to :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_minversion()` is :code:`False`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """
        
        if type(v) in [str, int, float, bool]:
            return self if self.minversion != v else None
        elif callable(v):
            return self if not v(self.minversion) else None
        else:
            raise SwoopError("Illegal type passed to without_minversion")


    def get_version(self):
        """ Return the value of :code:`version` for this :class:`Note`.  This corresponds to the :code:`version` attribute of a :code:`<note>` in an Eagle file.
        
        :rtype: :code:`str`
        """
        return self.version

    def set_version(self,v):
        """ Set the value of :code:`version` for this  :class:`Note`.  This corresponds to the :code:`version` attribute of a :code:`<note>` in an Eagle file.

        :param v: new value
        :rtype: :code:`self`
        """
                        
        if not typeCheck("str", v, True):
            raise SwoopError("Illegal value ({}) of type {} for attribute 'version' of Note object (should be str).".format(v, type(v)))
        self.version = v
        
        return self

    def with_version(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`version`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`version` equals :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_version()` is :code:`True`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """

        if type(v) in [str, int, float, bool]:
            return self if self.version == v else None
        elif callable(v):
            return self if v(self.version) else None
        else:
            raise SwoopError("Illegal type passed to with_version")

    def without_version(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`version`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`version` is not equal to :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_version()` is :code:`False`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """
        
        if type(v) in [str, int, float, bool]:
            return self if self.version != v else None
        elif callable(v):
            return self if not v(self.version) else None
        else:
            raise SwoopError("Illegal type passed to without_version")


    def get_severity(self):
        """ Return the value of :code:`severity` for this :class:`Note`.  This corresponds to the :code:`severity` attribute of a :code:`<note>` in an Eagle file.
        
        :rtype: :code:`str`
        """
        return self.severity

    def set_severity(self,v):
        """ Set the value of :code:`severity` for this  :class:`Note`.  This corresponds to the :code:`severity` attribute of a :code:`<note>` in an Eagle file.

        :param v: new value
        :rtype: :code:`self`
        """
                        
        if not typeCheck("str", v, True):
            raise SwoopError("Illegal value ({}) of type {} for attribute 'severity' of Note object (should be str).".format(v, type(v)))
        self.severity = v
        
        return self

    def with_severity(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`severity`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`severity` equals :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_severity()` is :code:`True`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """

        if type(v) in [str, int, float, bool]:
            return self if self.severity == v else None
        elif callable(v):
            return self if v(self.severity) else None
        else:
            raise SwoopError("Illegal type passed to with_severity")

    def without_severity(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`severity`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`severity` is not equal to :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_severity()` is :code:`False`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """
        
        if type(v) in [str, int, float, bool]:
            return self if self.severity != v else None
        elif callable(v):
            return self if not v(self.severity) else None
        else:
            raise SwoopError("Illegal type passed to without_severity")



    ##### Lookup functions that return EFPs instead of just attribute values.
    
    
    def with_text(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`text`.  For use in combination with :class:`From` objects.
        
        Return :code:`self` if one of the following is true:

        1.  :code:`text` equals :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_text()` is :code:`True`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """

        if type(v) in [str, int, float]:
            return self if self.text == v else None
        elif callable(v):
            return self if v(self.text) else None
        else:
            raise SwoopError("Illegal type passed to with_text")

    def without_text(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`text`.
        
        Return :code:`self` if one of the following is true:

        1.  :code:`text` does not equal :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_text()` is :code:`False`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """

        if type(v) in [str, int, float]:
            return self if self.text == v else None
        elif callable(v):
            return self if v(self.text) else None
        else:
            raise SwoopError("Illegal type passed to without_text")


    
    ### Adder/getter/lookup for lists
    


    ### Add, lookup, and get for maps


    
    ### Getter/Setter for singletons.


    def set_text(self, s):
        """ Set the text content for this :class:`Note`.

        :param s: text to set.
        :rtype: :code:`self`
        """
        self.text = s
        return self

    def get_text(self):
        """ Get the text content from this :class:`Note`.
        
        :rtype: the text content.
        """
        return self.text
    
    
    def get_children(self):
        """
        Get all the children of this :class:`EagleFilePart`.
        
        :rtype: List of :class:`EagleFilePart` objects
        """
        r = []




        return r

    def remove_child(self, efp):
        """
        Remove a child :class:`EagleFilePart` object.
        
        :param efp: the class:`EagleFilePart` object to remove.
        :return: Nothing
        """

    def _rekey_child(self, oldkey, efp):
        """
        Remove a child :class:`EagleFilePart` object.
        
        :param efp: the class:`EagleFilePart` object to remove.
        :return: Nothing
        """


    def __str__(self):
        r = "["+repr(self)+" "
        r = r + "minversion:" + str(self.get_minversion()) + " "
        r = r + "version:" + str(self.get_version()) + " "
        r = r + "severity:" + str(self.get_severity()) + " "
        r = r + "]"
        return r
            
    def dump(self, indent="", increment="   "):
        """
        Recursive debug dump.
        
        :param indent:  Indentation string.  The output will be indented by this much.
        :param increment: This will be appendeded to :code:`indent` on recursive invocations.

        :rtype: :code:`None`
        """
        print(indent + str(self.__class__.__name__), end=' ')
        try:
            print(self.get_name())
        except:
            print()
            pass
        for c in self.get_children():
            c.dump(indent + "   ")

        
EagleFile.class_map["note"] = Note
         


class Base_Instance(EagleFilePart, OnePointGeometry, RotationGeometry):
    """
    Class representing the contents of a <instance> tag in Eagle files.

    Attributes:

    * :code:`part`

    * :code:`gate`

    * :code:`x`

    * :code:`y`

    * :code:`smashed`

    * :code:`rot`



    Collections:



    * :code:`attribute`: Map of :class:`Attribute` objects indexed by their :code:`name`.



    """
    def __init__(self):
        """
        Construct an empty :class:`Base_Instance` object.
        """
        EagleFilePart.__init__(self)
        OnePointGeometry.__init__(self)
        RotationGeometry.__init__(self)
        
        self.part=None
        self.gate=None
        self.x=None
        self.y=None
        self.smashed=None
        self.rot=None
        self.attributes={} #tecollections.OrderedDict()  For unclear reasons, this caused ordering to become more unpredictable, rather than less.


        
    @classmethod
    def _from_et(cls,root,parent):
        """
        Create a :class:`Instance` from a :code:`instance` element.
        
        :param root: The element tree tree to parse.
        :param parent: :class:`EagleFilePart` that should hold the resulting :class:`EagleFilePart`
        :rtype: :class:`Instance`
        """
        ## Call the constructor
        n = cls()
        n._init_from_et(root,parent)
        return n

    def _get_error_name(self):
        if hasattr(self, "get_name"):
            return self.get_name();
        else:
            return "Instance";
        
    def  _init_from_et(self, root, parent):
        """
        Initialized a :class:`Instance` from a :code:`instance` element.  This is useful if you have a subclass of :class:`Instance` .
        
        :param root: The element tree tree to parse.
        :param parent: :class:`EagleFilePart` that will become the parent of :code:`this` .
        :rtype: :class:`Instance`
        """
        try:
            self.root = root
            
            if root.tag != "instance":
                raise EagleFormatError("Tried to create instance from " + root.tag)

            self.part=parseByType(parent, "str", None, root.get("part"))
            self.gate=parseByType(parent, "str", None, root.get("gate"))
            self.x=parseByType(parent, "float", None, root.get("x"))
            self.y=parseByType(parent, "float", None, root.get("y"))
            self.smashed=parseByType(parent, "str", None, root.get("smashed"))
            self.rot=parseByType(parent, "str", None, root.get("rot"))

            self.parent = parent

            ### populate the maps by searching for elements that match xpath and generating objects for them.

            for c in root.xpath("./attribute"):
                self.add_attribute(self.get_class_for_tag(c.tag)._from_et(c, self))

            ### Do the same for the lists


            ### Do the same for the attr lists


            ### And the singletons


            ### And, finally, if the objects wants the text from the tag.

        except SwoopError as e:
            e.text = "{}:{}".format(self._get_error_name(), e.text)
            raise e


    def sortkey(self):
        r = ""
        r = r + str(self.part)
        r = r + str(self.gate)
        r = r + str(self.x)
        r = r + str(self.y)
        r = r + str(self.smashed)
        r = r + str(self.rot)
        return r

    def get_et(self):
        """
        Generate a <instance> element tree for a :class:`Instance`.
        
        :rtype:  :class:`ElementTree`.
        
        """
        try:
            r = ET.Element("instance")

            ### Set the tag attributes 


            ## Unparse the values.

            v = unparseByType(self, "str", None,  self.part)

            ## For required attributes None becomes "".  For optional attributes, we just leave the attribute out.
            if not (isinstance(self.get_parent(), LibraryFile) and False):  # special case for the name of library.
                if v is not None:
                    r.set("part", v)
                else:
                    r.set("part", "")


            ## Unparse the values.

            v = unparseByType(self, "str", None,  self.gate)

            ## For required attributes None becomes "".  For optional attributes, we just leave the attribute out.
            if not (isinstance(self.get_parent(), LibraryFile) and False):  # special case for the name of library.
                if v is not None:
                    r.set("gate", v)
                else:
                    r.set("gate", "")


            ## Unparse the values.

            v = unparseByType(self, "float", None,  self.x)

            ## For required attributes None becomes "".  For optional attributes, we just leave the attribute out.
            if not (isinstance(self.get_parent(), LibraryFile) and False):  # special case for the name of library.
                if v is not None:
                    r.set("x", v)
                else:
                    r.set("x", "")


            ## Unparse the values.

            v = unparseByType(self, "float", None,  self.y)

            ## For required attributes None becomes "".  For optional attributes, we just leave the attribute out.
            if not (isinstance(self.get_parent(), LibraryFile) and False):  # special case for the name of library.
                if v is not None:
                    r.set("y", v)
                else:
                    r.set("y", "")


            ## Unparse the values.

            v = unparseByType(self, "str", None,  self.smashed)

            ## For required attributes None becomes "".  For optional attributes, we just leave the attribute out.
            if not (isinstance(self.get_parent(), LibraryFile) and False):  # special case for the name of library.
                if v is not None:
                    r.set("smashed", v)


            ## Unparse the values.

            v = unparseByType(self, "str", None,  self.rot)

            ## For required attributes None becomes "".  For optional attributes, we just leave the attribute out.
            if not (isinstance(self.get_parent(), LibraryFile) and False):  # special case for the name of library.
                if v is not None:
                    r.set("rot", v)


            ### process the sections in order.  They have to be in section order,
            ### because eagle files are order dependent.


            ## For some tags, Eagle generates empty tags when there's no contant
            ## rather than just leaving the tag out.  We mark these with
            ## Tag.requireTag in GenerateSwoop.py and force their generation
            ## here.

            smartAddSubTags(r, "./attribute")


            ## add a map.

            if len(self.attributes) is not 0:
                target = smartAddSubTags(r, "./attribute")
                # add them in sorted order.  This gives us a simple canonicalization that makes it feasible to use diff to compare files.
                target.extend([i.get_et() for i in sorted(list(self.attributes.values()),key=lambda x: x.sortkey())])


            ## set the text, if its needed.

        except SwoopError as e:
            e.text = "{}:{}".format(self._get_error_name(), e.text)
            raise e
        return r

    def clone(self):
        """
        Recursively clone this :code:`Instance`.  It will be identical to the original, but it's parent will be :code:`None`.
        
        :rtype: :class:`Instance`
        """
        try:
            n = copy.copy(self)
            n.attributes = {}
            for x in list(self.attributes.values()):
                n.add_attribute(x.clone())
            n.parent = None
        except SwoopError as e:
            e.text = "{}:{}".format(self._get_error_name(), e.text)
            raise e
        return n

    def accept_preorder_visitor(self, visitor):
        try:
            pre = getattr(visitor, "Instance_pre")
            return pre(self)
        except AttributeError:
            return visitor.default_pre(self)
        
    def accept_postorder_visitor(self, visitor, context):
        try:
            post = getattr(visitor, "Instance_post")
            post(self,context)
        except AttributeError:
            visitor.default_post(self,context)

    def is_equal(self, other):
        """
        Check whether two :code:`EagleFilePart` objects are identical.
        
        :param other: Object to compare to.
        :returns: :code:`True` if they are identical, otherwise, :code:`False`
        """
        return self.get_xml() == other.get_xml()
        
    ### Getters/Setters for attribute values

    def get_part(self):
        """ Return the value of :code:`part` for this :class:`Instance`.  This corresponds to the :code:`part` attribute of a :code:`<instance>` in an Eagle file.
        
        :rtype: :code:`str`
        """
        return self.part

    def set_part(self,v):
        """ Set the value of :code:`part` for this  :class:`Instance`.  This corresponds to the :code:`part` attribute of a :code:`<instance>` in an Eagle file.

        :param v: new value
        :rtype: :code:`self`
        """
                        
        if not typeCheck("str", v, True):
            raise SwoopError("Illegal value ({}) of type {} for attribute 'part' of Instance object (should be str).".format(v, type(v)))
        self.part = v
        
        return self

    def with_part(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`part`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`part` equals :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_part()` is :code:`True`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """

        if type(v) in [str, int, float, bool]:
            return self if self.part == v else None
        elif callable(v):
            return self if v(self.part) else None
        else:
            raise SwoopError("Illegal type passed to with_part")

    def without_part(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`part`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`part` is not equal to :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_part()` is :code:`False`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """
        
        if type(v) in [str, int, float, bool]:
            return self if self.part != v else None
        elif callable(v):
            return self if not v(self.part) else None
        else:
            raise SwoopError("Illegal type passed to without_part")


    def get_gate(self):
        """ Return the value of :code:`gate` for this :class:`Instance`.  This corresponds to the :code:`gate` attribute of a :code:`<instance>` in an Eagle file.
        
        :rtype: :code:`str`
        """
        return self.gate

    def set_gate(self,v):
        """ Set the value of :code:`gate` for this  :class:`Instance`.  This corresponds to the :code:`gate` attribute of a :code:`<instance>` in an Eagle file.

        :param v: new value
        :rtype: :code:`self`
        """
                        
        if not typeCheck("str", v, True):
            raise SwoopError("Illegal value ({}) of type {} for attribute 'gate' of Instance object (should be str).".format(v, type(v)))
        self.gate = v
        
        return self

    def with_gate(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`gate`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`gate` equals :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_gate()` is :code:`True`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """

        if type(v) in [str, int, float, bool]:
            return self if self.gate == v else None
        elif callable(v):
            return self if v(self.gate) else None
        else:
            raise SwoopError("Illegal type passed to with_gate")

    def without_gate(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`gate`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`gate` is not equal to :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_gate()` is :code:`False`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """
        
        if type(v) in [str, int, float, bool]:
            return self if self.gate != v else None
        elif callable(v):
            return self if not v(self.gate) else None
        else:
            raise SwoopError("Illegal type passed to without_gate")


    def get_x(self):
        """ Return the value of :code:`x` for this :class:`Instance`.  This corresponds to the :code:`x` attribute of a :code:`<instance>` in an Eagle file.
        
        :rtype: :code:`float`
        """
        return self.x

    def set_x(self,v):
        """ Set the value of :code:`x` for this  :class:`Instance`.  This corresponds to the :code:`x` attribute of a :code:`<instance>` in an Eagle file.

        :param v: new value
        :rtype: :code:`self`
        """
                        
        if not typeCheck("float", v, True):
            raise SwoopError("Illegal value ({}) of type {} for attribute 'x' of Instance object (should be float).".format(v, type(v)))
        self.x = v
        
        return self

    def with_x(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`x`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`x` equals :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_x()` is :code:`True`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """

        if type(v) in [str, int, float, bool]:
            return self if self.x == v else None
        elif callable(v):
            return self if v(self.x) else None
        else:
            raise SwoopError("Illegal type passed to with_x")

    def without_x(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`x`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`x` is not equal to :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_x()` is :code:`False`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """
        
        if type(v) in [str, int, float, bool]:
            return self if self.x != v else None
        elif callable(v):
            return self if not v(self.x) else None
        else:
            raise SwoopError("Illegal type passed to without_x")


    def get_y(self):
        """ Return the value of :code:`y` for this :class:`Instance`.  This corresponds to the :code:`y` attribute of a :code:`<instance>` in an Eagle file.
        
        :rtype: :code:`float`
        """
        return self.y

    def set_y(self,v):
        """ Set the value of :code:`y` for this  :class:`Instance`.  This corresponds to the :code:`y` attribute of a :code:`<instance>` in an Eagle file.

        :param v: new value
        :rtype: :code:`self`
        """
                        
        if not typeCheck("float", v, True):
            raise SwoopError("Illegal value ({}) of type {} for attribute 'y' of Instance object (should be float).".format(v, type(v)))
        self.y = v
        
        return self

    def with_y(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`y`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`y` equals :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_y()` is :code:`True`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """

        if type(v) in [str, int, float, bool]:
            return self if self.y == v else None
        elif callable(v):
            return self if v(self.y) else None
        else:
            raise SwoopError("Illegal type passed to with_y")

    def without_y(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`y`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`y` is not equal to :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_y()` is :code:`False`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """
        
        if type(v) in [str, int, float, bool]:
            return self if self.y != v else None
        elif callable(v):
            return self if not v(self.y) else None
        else:
            raise SwoopError("Illegal type passed to without_y")


    def get_smashed(self):
        """ Return the value of :code:`smashed` for this :class:`Instance`.  This corresponds to the :code:`smashed` attribute of a :code:`<instance>` in an Eagle file.
        
        :rtype: :code:`str`
        """
        return self.smashed

    def set_smashed(self,v):
        """ Set the value of :code:`smashed` for this  :class:`Instance`.  This corresponds to the :code:`smashed` attribute of a :code:`<instance>` in an Eagle file.

        :param v: new value
        :rtype: :code:`self`
        """
                        
        if not typeCheck("str", v, False):
            raise SwoopError("Illegal value ({}) of type {} for attribute 'smashed' of Instance object (should be str).".format(v, type(v)))
        self.smashed = v
        
        return self

    def with_smashed(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`smashed`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`smashed` equals :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_smashed()` is :code:`True`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """

        if type(v) in [str, int, float, bool]:
            return self if self.smashed == v else None
        elif callable(v):
            return self if v(self.smashed) else None
        else:
            raise SwoopError("Illegal type passed to with_smashed")

    def without_smashed(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`smashed`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`smashed` is not equal to :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_smashed()` is :code:`False`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """
        
        if type(v) in [str, int, float, bool]:
            return self if self.smashed != v else None
        elif callable(v):
            return self if not v(self.smashed) else None
        else:
            raise SwoopError("Illegal type passed to without_smashed")


    def get_rot(self):
        """ Return the value of :code:`rot` for this :class:`Instance`.  This corresponds to the :code:`rot` attribute of a :code:`<instance>` in an Eagle file.
        
        :rtype: :code:`str`
        """
        return self.rot

    def set_rot(self,v):
        """ Set the value of :code:`rot` for this  :class:`Instance`.  This corresponds to the :code:`rot` attribute of a :code:`<instance>` in an Eagle file.

        :param v: new value
        :rtype: :code:`self`
        """
                        
        if not typeCheck("str", v, False):
            raise SwoopError("Illegal value ({}) of type {} for attribute 'rot' of Instance object (should be str).".format(v, type(v)))
        self.rot = v
        
        return self

    def with_rot(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`rot`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`rot` equals :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_rot()` is :code:`True`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """

        if type(v) in [str, int, float, bool]:
            return self if self.rot == v else None
        elif callable(v):
            return self if v(self.rot) else None
        else:
            raise SwoopError("Illegal type passed to with_rot")

    def without_rot(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`rot`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`rot` is not equal to :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_rot()` is :code:`False`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """
        
        if type(v) in [str, int, float, bool]:
            return self if self.rot != v else None
        elif callable(v):
            return self if not v(self.rot) else None
        else:
            raise SwoopError("Illegal type passed to without_rot")



    ##### Lookup functions that return EFPs instead of just attribute values.
    
    def find_part(self):
        """Find the :class:`Part` object refered to by the :code:`part` attribute of this object.  This is like
        :meth:`get_part`, except it returns the :class:`Part` object instead of its name.
        
        :returns: The object
        :rtype: :class:`Part`

        """
        f = lambda efp, key: efp.get_parent().get_parent().get_part(key)
        return f(self, self.part)
    def find_gate(self):
        """Find the :class:`Gate` object refered to by the :code:`gate` attribute of this object.  This is like
        :meth:`get_gate`, except it returns the :class:`Gate` object instead of its name.
        
        :returns: The object
        :rtype: :class:`Gate`

        """
        f = lambda efp, key: NotImplemented('Lookup of gate from instance not implemented.')
        return f(self, self.gate)
    


    
    ### Adder/getter/lookup for lists
    


    ### Add, lookup, and get for maps
    def add_attribute(self, s):
        """ Add a :class:`Attribute` to the :code:`attributes` of this :class:`Instance`.

        :param s: The :class:`Attribute` to add.
        :rtype: :code:`self`
        """
        if not any([
                isinstance(s, Attribute),
            ]):
            raise SwoopError("Argument to Base_Instance.add_attribute() should be of type Attribute.  Got " + str(type(s).__name__) + ".")
        

        self.attributes[s.get_name()] = s

        s.parent = self
        return self

    def get_nth_attribute(self, n):
        """ get then nth :class:`Attribute` object from the :code:`attributes` of this :class:`Instance`.
        
        :param n: Index of the item to return.

        :rtype: :class:`Attribute` object
        """
        return list(self.attributes.values())[n]

    def get_attribute(self, key):
        """ Lookup and return a :class:`Attribute` from the :code:`attributes` of  this :class:`Instance`.
        
        :param key: A :code:`str` to use for the lookup.  The lookup uses the :code:`name` of the :class:`Attribute` objects.

        :rtype: A :class:`Attribute` object or :code:`None`, if there is no such item.
        """
        return self.attributes.get(key)


    def get_attributes(self, attrs=None, type=None):
        """Return (and possibly filter) items in the the :code:`attributes` map of :class:`Attribute` objects for this :class:`Instance`.
        
        This functions provides a mechanism for filtering the items as well.
        The keys in :code:`attrs` are taken as attributes names and the
        values are requested values.  Items in the list that have all the
        requested values for the corresponding attributes will be returned.  

        A if :code:`type` is not :code:`None`, the item will match if it is an
        instance of the type provided.
        
        :param attrs: A set of key-value pairs that represent a filter to apply to the item's attributes.
        :param type:  A type to filter on.  Only items that are an instance of this type will be returned.
        :returns: A List of :class:`Attribute` objects
        :rtype: List of :class:`Attribute` objects
        """
        if attrs is not None or type is not None:
            raise NotImplementedError("filtered get not implemented")
        return list(self.attributes.values())
        

    def clear_attributes(self):
        """
        Remove all the :class:`Attribute` objects from the :code:`attributes` of this :class:`Instance`.
        
        :rtype: :code:`self`
        """
        for efp in list(self.attributes.values()):
            efp.parent = None
        self.attributes = {}
        return self

    def remove_attribute(self, efp):
        """
        Remove a :class:`Attribute` from the :code:`attributes` of this :class:`Instance`.
        
        :param efp: The :class:`Attribute` object to remove.

        :rtype: :code:`self`
        """
        if self.attributes[efp.get_name()] == efp:
            del self.attributes[efp.get_name()]
            efp.parent = None
            return self
        else:
            raise SwoopError("Tried to use remove_attribute() to delete the wrong kind of child?: {}".format(str(efp)))
    


    
    ### Getter/Setter for singletons.


    
    def get_children(self):
        """
        Get all the children of this :class:`EagleFilePart`.
        
        :rtype: List of :class:`EagleFilePart` objects
        """
        r = []


        r = r + list(self.attributes.values())


        return r

    def remove_child(self, efp):
        """
        Remove a child :class:`EagleFilePart` object.
        
        :param efp: the class:`EagleFilePart` object to remove.
        :return: Nothing
        """
        try:
            self.remove_attribute(efp)
        except:
            pass

    def _rekey_child(self, oldkey, efp):
        """
        Remove a child :class:`EagleFilePart` object.
        
        :param efp: the class:`EagleFilePart` object to remove.
        :return: Nothing
        """
        try:
            if self.get_attribute(oldkey) == efp:
                del self.attributes[oldkey]
                self.add_attribute(efp)
        except SwoopError:
            pass

    def check_sanity(self, visited_efps = None):
        EagleFilePart.check_sanity(self, visited_efps)

        # Check whether keys in our maps match the keys in our children
        for k in self.attributes:
            if self.attributes[k].get_name() != k:
                raise SwoopError("Child's name ('{}') doesn't match key in parent's map ('{}')".format(self.attributes[k].get_name(),k))

    def __str__(self):
        r = "["+repr(self)+" "
        r = r + "part:" + str(self.get_part()) + " "
        r = r + "gate:" + str(self.get_gate()) + " "
        r = r + "x:" + str(self.get_x()) + " "
        r = r + "y:" + str(self.get_y()) + " "
        r = r + "smashed:" + str(self.get_smashed()) + " "
        r = r + "rot:" + str(self.get_rot()) + " "
        r = r + "]"
        return r
            
    def dump(self, indent="", increment="   "):
        """
        Recursive debug dump.
        
        :param indent:  Indentation string.  The output will be indented by this much.
        :param increment: This will be appendeded to :code:`indent` on recursive invocations.

        :rtype: :code:`None`
        """
        print(indent + str(self.__class__.__name__), end=' ')
        try:
            print(self.get_name())
        except:
            print()
            pass
        for c in self.get_children():
            c.dump(indent + "   ")

        
EagleFile.class_map["instance"] = Base_Instance
         


class Moduleinst(EagleFilePart, OnePointGeometry, RotationGeometry):
    """
    Class representing the contents of a <moduleinst> tag in Eagle files.

    Attributes:

    * :code:`name`

    * :code:`module`

    * :code:`modulevariant`

    * :code:`x`

    * :code:`y`

    * :code:`offset`

    * :code:`smashed`

    * :code:`rot`



    Collections:



    * :code:`attribute`: Map of :class:`Attribute` objects indexed by their :code:`name`.



    """
    def __init__(self):
        """
        Construct an empty :class:`Moduleinst` object.
        """
        EagleFilePart.__init__(self)
        OnePointGeometry.__init__(self)
        RotationGeometry.__init__(self)
        
        self.name=None
        self.module=None
        self.modulevariant=None
        self.x=None
        self.y=None
        self.offset=None
        self.smashed=None
        self.rot=None
        self.attributes={} #tecollections.OrderedDict()  For unclear reasons, this caused ordering to become more unpredictable, rather than less.


        
    @classmethod
    def _from_et(cls,root,parent):
        """
        Create a :class:`Moduleinst` from a :code:`moduleinst` element.
        
        :param root: The element tree tree to parse.
        :param parent: :class:`EagleFilePart` that should hold the resulting :class:`EagleFilePart`
        :rtype: :class:`Moduleinst`
        """
        ## Call the constructor
        n = cls()
        n._init_from_et(root,parent)
        return n

    def _get_error_name(self):
        if hasattr(self, "get_name"):
            return self.get_name();
        else:
            return "Moduleinst";
        
    def  _init_from_et(self, root, parent):
        """
        Initialized a :class:`Moduleinst` from a :code:`moduleinst` element.  This is useful if you have a subclass of :class:`Moduleinst` .
        
        :param root: The element tree tree to parse.
        :param parent: :class:`EagleFilePart` that will become the parent of :code:`this` .
        :rtype: :class:`Moduleinst`
        """
        try:
            self.root = root
            
            if root.tag != "moduleinst":
                raise EagleFormatError("Tried to create moduleinst from " + root.tag)

            self.name=parseByType(parent, "str", None, root.get("name"))
            self.module=parseByType(parent, "str", None, root.get("module"))
            self.modulevariant=parseByType(parent, "str", None, root.get("modulevariant"))
            self.x=parseByType(parent, "float", None, root.get("x"))
            self.y=parseByType(parent, "float", None, root.get("y"))
            self.offset=parseByType(parent, "int", None, root.get("offset"))
            self.smashed=parseByType(parent, "str", None, root.get("smashed"))
            self.rot=parseByType(parent, "str", None, root.get("rot"))

            self.parent = parent

            ### populate the maps by searching for elements that match xpath and generating objects for them.

            for c in root.xpath("./attribute"):
                self.add_attribute(self.get_class_for_tag(c.tag)._from_et(c, self))

            ### Do the same for the lists


            ### Do the same for the attr lists


            ### And the singletons


            ### And, finally, if the objects wants the text from the tag.

        except SwoopError as e:
            e.text = "{}:{}".format(self._get_error_name(), e.text)
            raise e


    def sortkey(self):
        r = ""
        r = r + str(self.name)
        r = r + str(self.module)
        r = r + str(self.modulevariant)
        r = r + str(self.x)
        r = r + str(self.y)
        r = r + str(self.offset)
        r = r + str(self.smashed)
        r = r + str(self.rot)
        return r

    def get_et(self):
        """
        Generate a <moduleinst> element tree for a :class:`Moduleinst`.
        
        :rtype:  :class:`ElementTree`.
        
        """
        try:
            r = ET.Element("moduleinst")

            ### Set the tag attributes 


            ## Unparse the values.

            v = unparseByType(self, "str", None,  self.name)

            ## For required attributes None becomes "".  For optional attributes, we just leave the attribute out.
            if not (isinstance(self.get_parent(), LibraryFile) and False):  # special case for the name of library.
                if v is not None:
                    r.set("name", v)
                else:
                    r.set("name", "")


            ## Unparse the values.

            v = unparseByType(self, "str", None,  self.module)

            ## For required attributes None becomes "".  For optional attributes, we just leave the attribute out.
            if not (isinstance(self.get_parent(), LibraryFile) and False):  # special case for the name of library.
                if v is not None:
                    r.set("module", v)
                else:
                    r.set("module", "")


            ## Unparse the values.

            v = unparseByType(self, "str", None,  self.modulevariant)

            ## For required attributes None becomes "".  For optional attributes, we just leave the attribute out.
            if not (isinstance(self.get_parent(), LibraryFile) and False):  # special case for the name of library.
                if v is not None:
                    r.set("modulevariant", v)


            ## Unparse the values.

            v = unparseByType(self, "float", None,  self.x)

            ## For required attributes None becomes "".  For optional attributes, we just leave the attribute out.
            if not (isinstance(self.get_parent(), LibraryFile) and False):  # special case for the name of library.
                if v is not None:
                    r.set("x", v)
                else:
                    r.set("x", "")


            ## Unparse the values.

            v = unparseByType(self, "float", None,  self.y)

            ## For required attributes None becomes "".  For optional attributes, we just leave the attribute out.
            if not (isinstance(self.get_parent(), LibraryFile) and False):  # special case for the name of library.
                if v is not None:
                    r.set("y", v)
                else:
                    r.set("y", "")


            ## Unparse the values.

            v = unparseByType(self, "int", None,  self.offset)

            ## For required attributes None becomes "".  For optional attributes, we just leave the attribute out.
            if not (isinstance(self.get_parent(), LibraryFile) and False):  # special case for the name of library.
                if v is not None:
                    r.set("offset", v)


            ## Unparse the values.

            v = unparseByType(self, "str", None,  self.smashed)

            ## For required attributes None becomes "".  For optional attributes, we just leave the attribute out.
            if not (isinstance(self.get_parent(), LibraryFile) and False):  # special case for the name of library.
                if v is not None:
                    r.set("smashed", v)


            ## Unparse the values.

            v = unparseByType(self, "str", None,  self.rot)

            ## For required attributes None becomes "".  For optional attributes, we just leave the attribute out.
            if not (isinstance(self.get_parent(), LibraryFile) and False):  # special case for the name of library.
                if v is not None:
                    r.set("rot", v)


            ### process the sections in order.  They have to be in section order,
            ### because eagle files are order dependent.


            ## For some tags, Eagle generates empty tags when there's no contant
            ## rather than just leaving the tag out.  We mark these with
            ## Tag.requireTag in GenerateSwoop.py and force their generation
            ## here.



            ## add a map.

            if len(self.attributes) is not 0:
                target = smartAddSubTags(r, "./attribute")
                # add them in sorted order.  This gives us a simple canonicalization that makes it feasible to use diff to compare files.
                target.extend([i.get_et() for i in sorted(list(self.attributes.values()),key=lambda x: x.sortkey())])


            ## set the text, if its needed.

        except SwoopError as e:
            e.text = "{}:{}".format(self._get_error_name(), e.text)
            raise e
        return r

    def clone(self):
        """
        Recursively clone this :code:`Moduleinst`.  It will be identical to the original, but it's parent will be :code:`None`.
        
        :rtype: :class:`Moduleinst`
        """
        try:
            n = copy.copy(self)
            n.attributes = {}
            for x in list(self.attributes.values()):
                n.add_attribute(x.clone())
            n.parent = None
        except SwoopError as e:
            e.text = "{}:{}".format(self._get_error_name(), e.text)
            raise e
        return n

    def accept_preorder_visitor(self, visitor):
        try:
            pre = getattr(visitor, "Moduleinst_pre")
            return pre(self)
        except AttributeError:
            return visitor.default_pre(self)
        
    def accept_postorder_visitor(self, visitor, context):
        try:
            post = getattr(visitor, "Moduleinst_post")
            post(self,context)
        except AttributeError:
            visitor.default_post(self,context)

    def is_equal(self, other):
        """
        Check whether two :code:`EagleFilePart` objects are identical.
        
        :param other: Object to compare to.
        :returns: :code:`True` if they are identical, otherwise, :code:`False`
        """
        return self.get_xml() == other.get_xml()
        
    ### Getters/Setters for attribute values

    def get_name(self):
        """ Return the value of :code:`name` for this :class:`Moduleinst`.  This corresponds to the :code:`name` attribute of a :code:`<moduleinst>` in an Eagle file.
        
        :rtype: :code:`str`
        """
        return self.name

    def set_name(self,v):
        """ Set the value of :code:`name` for this  :class:`Moduleinst`.  This corresponds to the :code:`name` attribute of a :code:`<moduleinst>` in an Eagle file.

        :param v: new value
        :rtype: :code:`self`
        """
                        
        oldkey = self.name
        if not typeCheck("str", v, True):
            raise SwoopError("Illegal value ({}) of type {} for attribute 'name' of Moduleinst object (should be str).".format(v, type(v)))
        self.name = v
        
        if self.get_parent() is not None:
            self.get_parent()._rekey_child(oldkey, self);
        return self

    def with_name(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`name`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`name` equals :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_name()` is :code:`True`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """

        if type(v) in [str, int, float, bool]:
            return self if self.name == v else None
        elif callable(v):
            return self if v(self.name) else None
        else:
            raise SwoopError("Illegal type passed to with_name")

    def without_name(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`name`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`name` is not equal to :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_name()` is :code:`False`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """
        
        if type(v) in [str, int, float, bool]:
            return self if self.name != v else None
        elif callable(v):
            return self if not v(self.name) else None
        else:
            raise SwoopError("Illegal type passed to without_name")


    def get_module(self):
        """ Return the value of :code:`module` for this :class:`Moduleinst`.  This corresponds to the :code:`module` attribute of a :code:`<moduleinst>` in an Eagle file.
        
        :rtype: :code:`str`
        """
        return self.module

    def set_module(self,v):
        """ Set the value of :code:`module` for this  :class:`Moduleinst`.  This corresponds to the :code:`module` attribute of a :code:`<moduleinst>` in an Eagle file.

        :param v: new value
        :rtype: :code:`self`
        """
                        
        if not typeCheck("str", v, True):
            raise SwoopError("Illegal value ({}) of type {} for attribute 'module' of Moduleinst object (should be str).".format(v, type(v)))
        self.module = v
        
        return self

    def with_module(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`module`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`module` equals :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_module()` is :code:`True`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """

        if type(v) in [str, int, float, bool]:
            return self if self.module == v else None
        elif callable(v):
            return self if v(self.module) else None
        else:
            raise SwoopError("Illegal type passed to with_module")

    def without_module(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`module`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`module` is not equal to :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_module()` is :code:`False`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """
        
        if type(v) in [str, int, float, bool]:
            return self if self.module != v else None
        elif callable(v):
            return self if not v(self.module) else None
        else:
            raise SwoopError("Illegal type passed to without_module")


    def get_modulevariant(self):
        """ Return the value of :code:`modulevariant` for this :class:`Moduleinst`.  This corresponds to the :code:`modulevariant` attribute of a :code:`<moduleinst>` in an Eagle file.
        
        :rtype: :code:`str`
        """
        return self.modulevariant

    def set_modulevariant(self,v):
        """ Set the value of :code:`modulevariant` for this  :class:`Moduleinst`.  This corresponds to the :code:`modulevariant` attribute of a :code:`<moduleinst>` in an Eagle file.

        :param v: new value
        :rtype: :code:`self`
        """
                        
        if not typeCheck("str", v, False):
            raise SwoopError("Illegal value ({}) of type {} for attribute 'modulevariant' of Moduleinst object (should be str).".format(v, type(v)))
        self.modulevariant = v
        
        return self

    def with_modulevariant(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`modulevariant`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`modulevariant` equals :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_modulevariant()` is :code:`True`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """

        if type(v) in [str, int, float, bool]:
            return self if self.modulevariant == v else None
        elif callable(v):
            return self if v(self.modulevariant) else None
        else:
            raise SwoopError("Illegal type passed to with_modulevariant")

    def without_modulevariant(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`modulevariant`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`modulevariant` is not equal to :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_modulevariant()` is :code:`False`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """
        
        if type(v) in [str, int, float, bool]:
            return self if self.modulevariant != v else None
        elif callable(v):
            return self if not v(self.modulevariant) else None
        else:
            raise SwoopError("Illegal type passed to without_modulevariant")


    def get_x(self):
        """ Return the value of :code:`x` for this :class:`Moduleinst`.  This corresponds to the :code:`x` attribute of a :code:`<moduleinst>` in an Eagle file.
        
        :rtype: :code:`float`
        """
        return self.x

    def set_x(self,v):
        """ Set the value of :code:`x` for this  :class:`Moduleinst`.  This corresponds to the :code:`x` attribute of a :code:`<moduleinst>` in an Eagle file.

        :param v: new value
        :rtype: :code:`self`
        """
                        
        if not typeCheck("float", v, True):
            raise SwoopError("Illegal value ({}) of type {} for attribute 'x' of Moduleinst object (should be float).".format(v, type(v)))
        self.x = v
        
        return self

    def with_x(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`x`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`x` equals :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_x()` is :code:`True`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """

        if type(v) in [str, int, float, bool]:
            return self if self.x == v else None
        elif callable(v):
            return self if v(self.x) else None
        else:
            raise SwoopError("Illegal type passed to with_x")

    def without_x(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`x`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`x` is not equal to :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_x()` is :code:`False`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """
        
        if type(v) in [str, int, float, bool]:
            return self if self.x != v else None
        elif callable(v):
            return self if not v(self.x) else None
        else:
            raise SwoopError("Illegal type passed to without_x")


    def get_y(self):
        """ Return the value of :code:`y` for this :class:`Moduleinst`.  This corresponds to the :code:`y` attribute of a :code:`<moduleinst>` in an Eagle file.
        
        :rtype: :code:`float`
        """
        return self.y

    def set_y(self,v):
        """ Set the value of :code:`y` for this  :class:`Moduleinst`.  This corresponds to the :code:`y` attribute of a :code:`<moduleinst>` in an Eagle file.

        :param v: new value
        :rtype: :code:`self`
        """
                        
        if not typeCheck("float", v, True):
            raise SwoopError("Illegal value ({}) of type {} for attribute 'y' of Moduleinst object (should be float).".format(v, type(v)))
        self.y = v
        
        return self

    def with_y(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`y`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`y` equals :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_y()` is :code:`True`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """

        if type(v) in [str, int, float, bool]:
            return self if self.y == v else None
        elif callable(v):
            return self if v(self.y) else None
        else:
            raise SwoopError("Illegal type passed to with_y")

    def without_y(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`y`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`y` is not equal to :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_y()` is :code:`False`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """
        
        if type(v) in [str, int, float, bool]:
            return self if self.y != v else None
        elif callable(v):
            return self if not v(self.y) else None
        else:
            raise SwoopError("Illegal type passed to without_y")


    def get_offset(self):
        """ Return the value of :code:`offset` for this :class:`Moduleinst`.  This corresponds to the :code:`offset` attribute of a :code:`<moduleinst>` in an Eagle file.
        
        :rtype: :code:`int`
        """
        return self.offset

    def set_offset(self,v):
        """ Set the value of :code:`offset` for this  :class:`Moduleinst`.  This corresponds to the :code:`offset` attribute of a :code:`<moduleinst>` in an Eagle file.

        :param v: new value
        :rtype: :code:`self`
        """
                        
        if not typeCheck("int", v, False):
            raise SwoopError("Illegal value ({}) of type {} for attribute 'offset' of Moduleinst object (should be int).".format(v, type(v)))
        self.offset = v
        
        return self

    def with_offset(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`offset`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`offset` equals :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_offset()` is :code:`True`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """

        if type(v) in [str, int, float, bool]:
            return self if self.offset == v else None
        elif callable(v):
            return self if v(self.offset) else None
        else:
            raise SwoopError("Illegal type passed to with_offset")

    def without_offset(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`offset`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`offset` is not equal to :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_offset()` is :code:`False`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """
        
        if type(v) in [str, int, float, bool]:
            return self if self.offset != v else None
        elif callable(v):
            return self if not v(self.offset) else None
        else:
            raise SwoopError("Illegal type passed to without_offset")


    def get_smashed(self):
        """ Return the value of :code:`smashed` for this :class:`Moduleinst`.  This corresponds to the :code:`smashed` attribute of a :code:`<moduleinst>` in an Eagle file.
        
        :rtype: :code:`str`
        """
        return self.smashed

    def set_smashed(self,v):
        """ Set the value of :code:`smashed` for this  :class:`Moduleinst`.  This corresponds to the :code:`smashed` attribute of a :code:`<moduleinst>` in an Eagle file.

        :param v: new value
        :rtype: :code:`self`
        """
                        
        if not typeCheck("str", v, False):
            raise SwoopError("Illegal value ({}) of type {} for attribute 'smashed' of Moduleinst object (should be str).".format(v, type(v)))
        self.smashed = v
        
        return self

    def with_smashed(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`smashed`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`smashed` equals :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_smashed()` is :code:`True`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """

        if type(v) in [str, int, float, bool]:
            return self if self.smashed == v else None
        elif callable(v):
            return self if v(self.smashed) else None
        else:
            raise SwoopError("Illegal type passed to with_smashed")

    def without_smashed(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`smashed`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`smashed` is not equal to :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_smashed()` is :code:`False`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """
        
        if type(v) in [str, int, float, bool]:
            return self if self.smashed != v else None
        elif callable(v):
            return self if not v(self.smashed) else None
        else:
            raise SwoopError("Illegal type passed to without_smashed")


    def get_rot(self):
        """ Return the value of :code:`rot` for this :class:`Moduleinst`.  This corresponds to the :code:`rot` attribute of a :code:`<moduleinst>` in an Eagle file.
        
        :rtype: :code:`str`
        """
        return self.rot

    def set_rot(self,v):
        """ Set the value of :code:`rot` for this  :class:`Moduleinst`.  This corresponds to the :code:`rot` attribute of a :code:`<moduleinst>` in an Eagle file.

        :param v: new value
        :rtype: :code:`self`
        """
                        
        if not typeCheck("str", v, False):
            raise SwoopError("Illegal value ({}) of type {} for attribute 'rot' of Moduleinst object (should be str).".format(v, type(v)))
        self.rot = v
        
        return self

    def with_rot(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`rot`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`rot` equals :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_rot()` is :code:`True`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """

        if type(v) in [str, int, float, bool]:
            return self if self.rot == v else None
        elif callable(v):
            return self if v(self.rot) else None
        else:
            raise SwoopError("Illegal type passed to with_rot")

    def without_rot(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`rot`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`rot` is not equal to :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_rot()` is :code:`False`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """
        
        if type(v) in [str, int, float, bool]:
            return self if self.rot != v else None
        elif callable(v):
            return self if not v(self.rot) else None
        else:
            raise SwoopError("Illegal type passed to without_rot")



    ##### Lookup functions that return EFPs instead of just attribute values.
    
    def find_module(self):
        """Find the :class:`Module` object refered to by the :code:`module` attribute of this object.  This is like
        :meth:`get_module`, except it returns the :class:`Module` object instead of its name.
        
        :returns: The object
        :rtype: :class:`Module`

        """
        f = lambda efp, key: NotImplemented('Module lookup not implemented')
        return f(self, self.module)
    


    
    ### Adder/getter/lookup for lists
    


    ### Add, lookup, and get for maps
    def add_attribute(self, s):
        """ Add a :class:`Attribute` to the :code:`attributes` of this :class:`Moduleinst`.

        :param s: The :class:`Attribute` to add.
        :rtype: :code:`self`
        """
        if not any([
                isinstance(s, Attribute),
            ]):
            raise SwoopError("Argument to Moduleinst.add_attribute() should be of type Attribute.  Got " + str(type(s).__name__) + ".")
        

        self.attributes[s.get_name()] = s

        s.parent = self
        return self

    def get_nth_attribute(self, n):
        """ get then nth :class:`Attribute` object from the :code:`attributes` of this :class:`Moduleinst`.
        
        :param n: Index of the item to return.

        :rtype: :class:`Attribute` object
        """
        return list(self.attributes.values())[n]

    def get_attribute(self, key):
        """ Lookup and return a :class:`Attribute` from the :code:`attributes` of  this :class:`Moduleinst`.
        
        :param key: A :code:`str` to use for the lookup.  The lookup uses the :code:`name` of the :class:`Attribute` objects.

        :rtype: A :class:`Attribute` object or :code:`None`, if there is no such item.
        """
        return self.attributes.get(key)


    def get_attributes(self, attrs=None, type=None):
        """Return (and possibly filter) items in the the :code:`attributes` map of :class:`Attribute` objects for this :class:`Moduleinst`.
        
        This functions provides a mechanism for filtering the items as well.
        The keys in :code:`attrs` are taken as attributes names and the
        values are requested values.  Items in the list that have all the
        requested values for the corresponding attributes will be returned.  

        A if :code:`type` is not :code:`None`, the item will match if it is an
        instance of the type provided.
        
        :param attrs: A set of key-value pairs that represent a filter to apply to the item's attributes.
        :param type:  A type to filter on.  Only items that are an instance of this type will be returned.
        :returns: A List of :class:`Attribute` objects
        :rtype: List of :class:`Attribute` objects
        """
        if attrs is not None or type is not None:
            raise NotImplementedError("filtered get not implemented")
        return list(self.attributes.values())
        

    def clear_attributes(self):
        """
        Remove all the :class:`Attribute` objects from the :code:`attributes` of this :class:`Moduleinst`.
        
        :rtype: :code:`self`
        """
        for efp in list(self.attributes.values()):
            efp.parent = None
        self.attributes = {}
        return self

    def remove_attribute(self, efp):
        """
        Remove a :class:`Attribute` from the :code:`attributes` of this :class:`Moduleinst`.
        
        :param efp: The :class:`Attribute` object to remove.

        :rtype: :code:`self`
        """
        if self.attributes[efp.get_name()] == efp:
            del self.attributes[efp.get_name()]
            efp.parent = None
            return self
        else:
            raise SwoopError("Tried to use remove_attribute() to delete the wrong kind of child?: {}".format(str(efp)))
    


    
    ### Getter/Setter for singletons.


    
    def get_children(self):
        """
        Get all the children of this :class:`EagleFilePart`.
        
        :rtype: List of :class:`EagleFilePart` objects
        """
        r = []


        r = r + list(self.attributes.values())


        return r

    def remove_child(self, efp):
        """
        Remove a child :class:`EagleFilePart` object.
        
        :param efp: the class:`EagleFilePart` object to remove.
        :return: Nothing
        """
        try:
            self.remove_attribute(efp)
        except:
            pass

    def _rekey_child(self, oldkey, efp):
        """
        Remove a child :class:`EagleFilePart` object.
        
        :param efp: the class:`EagleFilePart` object to remove.
        :return: Nothing
        """
        try:
            if self.get_attribute(oldkey) == efp:
                del self.attributes[oldkey]
                self.add_attribute(efp)
        except SwoopError:
            pass

    def check_sanity(self, visited_efps = None):
        EagleFilePart.check_sanity(self, visited_efps)

        # Check whether keys in our maps match the keys in our children
        for k in self.attributes:
            if self.attributes[k].get_name() != k:
                raise SwoopError("Child's name ('{}') doesn't match key in parent's map ('{}')".format(self.attributes[k].get_name(),k))

    def __str__(self):
        r = "["+repr(self)+" "
        r = r + "name:" + str(self.get_name()) + " "
        r = r + "module:" + str(self.get_module()) + " "
        r = r + "modulevariant:" + str(self.get_modulevariant()) + " "
        r = r + "x:" + str(self.get_x()) + " "
        r = r + "y:" + str(self.get_y()) + " "
        r = r + "offset:" + str(self.get_offset()) + " "
        r = r + "smashed:" + str(self.get_smashed()) + " "
        r = r + "rot:" + str(self.get_rot()) + " "
        r = r + "]"
        return r
            
    def dump(self, indent="", increment="   "):
        """
        Recursive debug dump.
        
        :param indent:  Indentation string.  The output will be indented by this much.
        :param increment: This will be appendeded to :code:`indent` on recursive invocations.

        :rtype: :code:`None`
        """
        print(indent + str(self.__class__.__name__), end=' ')
        try:
            print(self.get_name())
        except:
            print()
            pass
        for c in self.get_children():
            c.dump(indent + "   ")

        
EagleFile.class_map["moduleinst"] = Moduleinst
         


class Setting(EagleFilePart):
    """
    Class representing the contents of a <setting> tag in Eagle files.

    Attributes:

    * :code:`alwaysvectorfont`

    * :code:`keepoldvectorfont`

    * :code:`verticaltext`


    """
    def __init__(self):
        """
        Construct an empty :class:`Setting` object.
        """
        EagleFilePart.__init__(self)
        
        self.alwaysvectorfont=None
        self.keepoldvectorfont=None
        self.verticaltext=None


        
    @classmethod
    def _from_et(cls,root,parent):
        """
        Create a :class:`Setting` from a :code:`setting` element.
        
        :param root: The element tree tree to parse.
        :param parent: :class:`EagleFilePart` that should hold the resulting :class:`EagleFilePart`
        :rtype: :class:`Setting`
        """
        ## Call the constructor
        n = cls()
        n._init_from_et(root,parent)
        return n

    def _get_error_name(self):
        if hasattr(self, "get_name"):
            return self.get_name();
        else:
            return "Setting";
        
    def  _init_from_et(self, root, parent):
        """
        Initialized a :class:`Setting` from a :code:`setting` element.  This is useful if you have a subclass of :class:`Setting` .
        
        :param root: The element tree tree to parse.
        :param parent: :class:`EagleFilePart` that will become the parent of :code:`this` .
        :rtype: :class:`Setting`
        """
        try:
            self.root = root
            
            if root.tag != "setting":
                raise EagleFormatError("Tried to create setting from " + root.tag)

            self.alwaysvectorfont=parseByType(parent, "bool", None, root.get("alwaysvectorfont"))
            self.keepoldvectorfont=parseByType(parent, "bool", None, root.get("keepoldvectorfont"))
            self.verticaltext=parseByType(parent, "str", None, root.get("verticaltext"))

            self.parent = parent

            ### populate the maps by searching for elements that match xpath and generating objects for them.


            ### Do the same for the lists


            ### Do the same for the attr lists


            ### And the singletons


            ### And, finally, if the objects wants the text from the tag.

        except SwoopError as e:
            e.text = "{}:{}".format(self._get_error_name(), e.text)
            raise e


    def sortkey(self):
        r = ""
        r = r + str(self.alwaysvectorfont)
        r = r + str(self.keepoldvectorfont)
        r = r + str(self.verticaltext)
        return r

    def get_et(self):
        """
        Generate a <setting> element tree for a :class:`Setting`.
        
        :rtype:  :class:`ElementTree`.
        
        """
        try:
            r = ET.Element("setting")

            ### Set the tag attributes 


            ## Unparse the values.

            v = unparseByType(self, "bool", None,  self.alwaysvectorfont)

            ## For required attributes None becomes "".  For optional attributes, we just leave the attribute out.
            if not (isinstance(self.get_parent(), LibraryFile) and False):  # special case for the name of library.
                if v is not None:
                    r.set("alwaysvectorfont", v)


            ## Unparse the values.

            v = unparseByType(self, "bool", None,  self.keepoldvectorfont)

            ## For required attributes None becomes "".  For optional attributes, we just leave the attribute out.
            if not (isinstance(self.get_parent(), LibraryFile) and False):  # special case for the name of library.
                if v is not None:
                    r.set("keepoldvectorfont", v)


            ## Unparse the values.

            v = unparseByType(self, "str", None,  self.verticaltext)

            ## For required attributes None becomes "".  For optional attributes, we just leave the attribute out.
            if not (isinstance(self.get_parent(), LibraryFile) and False):  # special case for the name of library.
                if v is not None:
                    r.set("verticaltext", v)


            ### process the sections in order.  They have to be in section order,
            ### because eagle files are order dependent.


            ## set the text, if its needed.

        except SwoopError as e:
            e.text = "{}:{}".format(self._get_error_name(), e.text)
            raise e
        return r

    def clone(self):
        """
        Recursively clone this :code:`Setting`.  It will be identical to the original, but it's parent will be :code:`None`.
        
        :rtype: :class:`Setting`
        """
        try:
            n = copy.copy(self)
            n.parent = None
        except SwoopError as e:
            e.text = "{}:{}".format(self._get_error_name(), e.text)
            raise e
        return n

    def accept_preorder_visitor(self, visitor):
        try:
            pre = getattr(visitor, "Setting_pre")
            return pre(self)
        except AttributeError:
            return visitor.default_pre(self)
        
    def accept_postorder_visitor(self, visitor, context):
        try:
            post = getattr(visitor, "Setting_post")
            post(self,context)
        except AttributeError:
            visitor.default_post(self,context)

    def is_equal(self, other):
        """
        Check whether two :code:`EagleFilePart` objects are identical.
        
        :param other: Object to compare to.
        :returns: :code:`True` if they are identical, otherwise, :code:`False`
        """
        return self.get_xml() == other.get_xml()
        
    ### Getters/Setters for attribute values

    def get_alwaysvectorfont(self):
        """ Return the value of :code:`alwaysvectorfont` for this :class:`Setting`.  This corresponds to the :code:`alwaysvectorfont` attribute of a :code:`<setting>` in an Eagle file.
        
        :rtype: :code:`bool`
        """
        return self.alwaysvectorfont

    def set_alwaysvectorfont(self,v):
        """ Set the value of :code:`alwaysvectorfont` for this  :class:`Setting`.  This corresponds to the :code:`alwaysvectorfont` attribute of a :code:`<setting>` in an Eagle file.

        :param v: new value
        :rtype: :code:`self`
        """
                        
        if not typeCheck("bool", v, False):
            raise SwoopError("Illegal value ({}) of type {} for attribute 'alwaysvectorfont' of Setting object (should be bool).".format(v, type(v)))
        self.alwaysvectorfont = v
        
        return self

    def with_alwaysvectorfont(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`alwaysvectorfont`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`alwaysvectorfont` equals :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_alwaysvectorfont()` is :code:`True`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """

        if type(v) in [str, int, float, bool]:
            return self if self.alwaysvectorfont == v else None
        elif callable(v):
            return self if v(self.alwaysvectorfont) else None
        else:
            raise SwoopError("Illegal type passed to with_alwaysvectorfont")

    def without_alwaysvectorfont(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`alwaysvectorfont`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`alwaysvectorfont` is not equal to :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_alwaysvectorfont()` is :code:`False`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """
        
        if type(v) in [str, int, float, bool]:
            return self if self.alwaysvectorfont != v else None
        elif callable(v):
            return self if not v(self.alwaysvectorfont) else None
        else:
            raise SwoopError("Illegal type passed to without_alwaysvectorfont")


    def get_keepoldvectorfont(self):
        """ Return the value of :code:`keepoldvectorfont` for this :class:`Setting`.  This corresponds to the :code:`keepoldvectorfont` attribute of a :code:`<setting>` in an Eagle file.
        
        :rtype: :code:`bool`
        """
        return self.keepoldvectorfont

    def set_keepoldvectorfont(self,v):
        """ Set the value of :code:`keepoldvectorfont` for this  :class:`Setting`.  This corresponds to the :code:`keepoldvectorfont` attribute of a :code:`<setting>` in an Eagle file.

        :param v: new value
        :rtype: :code:`self`
        """
                        
        if not typeCheck("bool", v, False):
            raise SwoopError("Illegal value ({}) of type {} for attribute 'keepoldvectorfont' of Setting object (should be bool).".format(v, type(v)))
        self.keepoldvectorfont = v
        
        return self

    def with_keepoldvectorfont(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`keepoldvectorfont`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`keepoldvectorfont` equals :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_keepoldvectorfont()` is :code:`True`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """

        if type(v) in [str, int, float, bool]:
            return self if self.keepoldvectorfont == v else None
        elif callable(v):
            return self if v(self.keepoldvectorfont) else None
        else:
            raise SwoopError("Illegal type passed to with_keepoldvectorfont")

    def without_keepoldvectorfont(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`keepoldvectorfont`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`keepoldvectorfont` is not equal to :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_keepoldvectorfont()` is :code:`False`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """
        
        if type(v) in [str, int, float, bool]:
            return self if self.keepoldvectorfont != v else None
        elif callable(v):
            return self if not v(self.keepoldvectorfont) else None
        else:
            raise SwoopError("Illegal type passed to without_keepoldvectorfont")


    def get_verticaltext(self):
        """ Return the value of :code:`verticaltext` for this :class:`Setting`.  This corresponds to the :code:`verticaltext` attribute of a :code:`<setting>` in an Eagle file.
        
        :rtype: :code:`str`
        """
        return self.verticaltext

    def set_verticaltext(self,v):
        """ Set the value of :code:`verticaltext` for this  :class:`Setting`.  This corresponds to the :code:`verticaltext` attribute of a :code:`<setting>` in an Eagle file.

        :param v: new value
        :rtype: :code:`self`
        """
                        
        if not typeCheck("str", v, False):
            raise SwoopError("Illegal value ({}) of type {} for attribute 'verticaltext' of Setting object (should be str).".format(v, type(v)))
        self.verticaltext = v
        
        return self

    def with_verticaltext(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`verticaltext`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`verticaltext` equals :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_verticaltext()` is :code:`True`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """

        if type(v) in [str, int, float, bool]:
            return self if self.verticaltext == v else None
        elif callable(v):
            return self if v(self.verticaltext) else None
        else:
            raise SwoopError("Illegal type passed to with_verticaltext")

    def without_verticaltext(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`verticaltext`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`verticaltext` is not equal to :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_verticaltext()` is :code:`False`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """
        
        if type(v) in [str, int, float, bool]:
            return self if self.verticaltext != v else None
        elif callable(v):
            return self if not v(self.verticaltext) else None
        else:
            raise SwoopError("Illegal type passed to without_verticaltext")



    ##### Lookup functions that return EFPs instead of just attribute values.
    
    


    
    ### Adder/getter/lookup for lists
    


    ### Add, lookup, and get for maps


    
    ### Getter/Setter for singletons.


    
    def get_children(self):
        """
        Get all the children of this :class:`EagleFilePart`.
        
        :rtype: List of :class:`EagleFilePart` objects
        """
        r = []




        return r

    def remove_child(self, efp):
        """
        Remove a child :class:`EagleFilePart` object.
        
        :param efp: the class:`EagleFilePart` object to remove.
        :return: Nothing
        """

    def _rekey_child(self, oldkey, efp):
        """
        Remove a child :class:`EagleFilePart` object.
        
        :param efp: the class:`EagleFilePart` object to remove.
        :return: Nothing
        """


    def __str__(self):
        r = "["+repr(self)+" "
        r = r + "alwaysvectorfont:" + str(self.get_alwaysvectorfont()) + " "
        r = r + "keepoldvectorfont:" + str(self.get_keepoldvectorfont()) + " "
        r = r + "verticaltext:" + str(self.get_verticaltext()) + " "
        r = r + "]"
        return r
            
    def dump(self, indent="", increment="   "):
        """
        Recursive debug dump.
        
        :param indent:  Indentation string.  The output will be indented by this much.
        :param increment: This will be appendeded to :code:`indent` on recursive invocations.

        :rtype: :code:`None`
        """
        print(indent + str(self.__class__.__name__), end=' ')
        try:
            print(self.get_name())
        except:
            print()
            pass
        for c in self.get_children():
            c.dump(indent + "   ")

        
EagleFile.class_map["setting"] = Setting
         


class Pad(EagleFilePart, OnePointGeometry, CircleDiameterGeometry, RotationGeometry):
    """
    Class representing the contents of a <pad> tag in Eagle files.

    Attributes:

    * :code:`name`

    * :code:`x`

    * :code:`y`

    * :code:`drill`

    * :code:`diameter`

    * :code:`shape`

    * :code:`rot`

    * :code:`stop`

    * :code:`thermals`

    * :code:`first`


    """
    def __init__(self):
        """
        Construct an empty :class:`Pad` object.
        """
        EagleFilePart.__init__(self)
        OnePointGeometry.__init__(self)
        CircleDiameterGeometry.__init__(self)
        RotationGeometry.__init__(self)
        
        self.name=None
        self.x=None
        self.y=None
        self.drill=None
        self.diameter=None
        self.shape=None
        self.rot=None
        self.stop=None
        self.thermals=None
        self.first=None


        
    @classmethod
    def _from_et(cls,root,parent):
        """
        Create a :class:`Pad` from a :code:`pad` element.
        
        :param root: The element tree tree to parse.
        :param parent: :class:`EagleFilePart` that should hold the resulting :class:`EagleFilePart`
        :rtype: :class:`Pad`
        """
        ## Call the constructor
        n = cls()
        n._init_from_et(root,parent)
        return n

    def _get_error_name(self):
        if hasattr(self, "get_name"):
            return self.get_name();
        else:
            return "Pad";
        
    def  _init_from_et(self, root, parent):
        """
        Initialized a :class:`Pad` from a :code:`pad` element.  This is useful if you have a subclass of :class:`Pad` .
        
        :param root: The element tree tree to parse.
        :param parent: :class:`EagleFilePart` that will become the parent of :code:`this` .
        :rtype: :class:`Pad`
        """
        try:
            self.root = root
            
            if root.tag != "pad":
                raise EagleFormatError("Tried to create pad from " + root.tag)

            self.name=parseByType(parent, "str", None, root.get("name"))
            self.x=parseByType(parent, "float", None, root.get("x"))
            self.y=parseByType(parent, "float", None, root.get("y"))
            self.drill=parseByType(parent, "float", None, root.get("drill"))
            self.diameter=parseByType(parent, "float", None, root.get("diameter"))
            self.shape=parseByType(parent, "str", None, root.get("shape"))
            self.rot=parseByType(parent, "str", None, root.get("rot"))
            self.stop=parseByType(parent, "bool", None, root.get("stop"))
            self.thermals=parseByType(parent, "bool", None, root.get("thermals"))
            self.first=parseByType(parent, "bool", None, root.get("first"))

            self.parent = parent

            ### populate the maps by searching for elements that match xpath and generating objects for them.


            ### Do the same for the lists


            ### Do the same for the attr lists


            ### And the singletons


            ### And, finally, if the objects wants the text from the tag.

        except SwoopError as e:
            e.text = "{}:{}".format(self._get_error_name(), e.text)
            raise e


    def sortkey(self):
        r = ""
        r = r + str(self.name)
        r = r + str(self.x)
        r = r + str(self.y)
        r = r + str(self.drill)
        r = r + str(self.diameter)
        r = r + str(self.shape)
        r = r + str(self.rot)
        r = r + str(self.stop)
        r = r + str(self.thermals)
        r = r + str(self.first)
        return r

    def get_et(self):
        """
        Generate a <pad> element tree for a :class:`Pad`.
        
        :rtype:  :class:`ElementTree`.
        
        """
        try:
            r = ET.Element("pad")

            ### Set the tag attributes 


            ## Unparse the values.

            v = unparseByType(self, "str", None,  self.name)

            ## For required attributes None becomes "".  For optional attributes, we just leave the attribute out.
            if not (isinstance(self.get_parent(), LibraryFile) and False):  # special case for the name of library.
                if v is not None:
                    r.set("name", v)
                else:
                    r.set("name", "")


            ## Unparse the values.

            v = unparseByType(self, "float", None,  self.x)

            ## For required attributes None becomes "".  For optional attributes, we just leave the attribute out.
            if not (isinstance(self.get_parent(), LibraryFile) and False):  # special case for the name of library.
                if v is not None:
                    r.set("x", v)
                else:
                    r.set("x", "")


            ## Unparse the values.

            v = unparseByType(self, "float", None,  self.y)

            ## For required attributes None becomes "".  For optional attributes, we just leave the attribute out.
            if not (isinstance(self.get_parent(), LibraryFile) and False):  # special case for the name of library.
                if v is not None:
                    r.set("y", v)
                else:
                    r.set("y", "")


            ## Unparse the values.

            v = unparseByType(self, "float", None,  self.drill)

            ## For required attributes None becomes "".  For optional attributes, we just leave the attribute out.
            if not (isinstance(self.get_parent(), LibraryFile) and False):  # special case for the name of library.
                if v is not None:
                    r.set("drill", v)
                else:
                    r.set("drill", "")


            ## Unparse the values.

            v = unparseByType(self, "float", None,  self.diameter)

            ## For required attributes None becomes "".  For optional attributes, we just leave the attribute out.
            if not (isinstance(self.get_parent(), LibraryFile) and False):  # special case for the name of library.
                if v is not None:
                    r.set("diameter", v)


            ## Unparse the values.

            v = unparseByType(self, "str", None,  self.shape)

            ## For required attributes None becomes "".  For optional attributes, we just leave the attribute out.
            if not (isinstance(self.get_parent(), LibraryFile) and False):  # special case for the name of library.
                if v is not None:
                    r.set("shape", v)


            ## Unparse the values.

            v = unparseByType(self, "str", None,  self.rot)

            ## For required attributes None becomes "".  For optional attributes, we just leave the attribute out.
            if not (isinstance(self.get_parent(), LibraryFile) and False):  # special case for the name of library.
                if v is not None:
                    r.set("rot", v)


            ## Unparse the values.

            v = unparseByType(self, "bool", None,  self.stop)

            ## For required attributes None becomes "".  For optional attributes, we just leave the attribute out.
            if not (isinstance(self.get_parent(), LibraryFile) and False):  # special case for the name of library.
                if v is not None:
                    r.set("stop", v)


            ## Unparse the values.

            v = unparseByType(self, "bool", None,  self.thermals)

            ## For required attributes None becomes "".  For optional attributes, we just leave the attribute out.
            if not (isinstance(self.get_parent(), LibraryFile) and False):  # special case for the name of library.
                if v is not None:
                    r.set("thermals", v)


            ## Unparse the values.

            v = unparseByType(self, "bool", None,  self.first)

            ## For required attributes None becomes "".  For optional attributes, we just leave the attribute out.
            if not (isinstance(self.get_parent(), LibraryFile) and False):  # special case for the name of library.
                if v is not None:
                    r.set("first", v)


            ### process the sections in order.  They have to be in section order,
            ### because eagle files are order dependent.


            ## set the text, if its needed.

        except SwoopError as e:
            e.text = "{}:{}".format(self._get_error_name(), e.text)
            raise e
        return r

    def clone(self):
        """
        Recursively clone this :code:`Pad`.  It will be identical to the original, but it's parent will be :code:`None`.
        
        :rtype: :class:`Pad`
        """
        try:
            n = copy.copy(self)
            n.parent = None
        except SwoopError as e:
            e.text = "{}:{}".format(self._get_error_name(), e.text)
            raise e
        return n

    def accept_preorder_visitor(self, visitor):
        try:
            pre = getattr(visitor, "Pad_pre")
            return pre(self)
        except AttributeError:
            return visitor.default_pre(self)
        
    def accept_postorder_visitor(self, visitor, context):
        try:
            post = getattr(visitor, "Pad_post")
            post(self,context)
        except AttributeError:
            visitor.default_post(self,context)

    def is_equal(self, other):
        """
        Check whether two :code:`EagleFilePart` objects are identical.
        
        :param other: Object to compare to.
        :returns: :code:`True` if they are identical, otherwise, :code:`False`
        """
        return self.get_xml() == other.get_xml()
        
    ### Getters/Setters for attribute values

    def get_name(self):
        """ Return the value of :code:`name` for this :class:`Pad`.  This corresponds to the :code:`name` attribute of a :code:`<pad>` in an Eagle file.
        
        :rtype: :code:`str`
        """
        return self.name

    def set_name(self,v):
        """ Set the value of :code:`name` for this  :class:`Pad`.  This corresponds to the :code:`name` attribute of a :code:`<pad>` in an Eagle file.

        :param v: new value
        :rtype: :code:`self`
        """
                        
        oldkey = self.name
        if not typeCheck("str", v, True):
            raise SwoopError("Illegal value ({}) of type {} for attribute 'name' of Pad object (should be str).".format(v, type(v)))
        self.name = v
        
        if self.get_parent() is not None:
            self.get_parent()._rekey_child(oldkey, self);
        return self

    def with_name(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`name`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`name` equals :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_name()` is :code:`True`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """

        if type(v) in [str, int, float, bool]:
            return self if self.name == v else None
        elif callable(v):
            return self if v(self.name) else None
        else:
            raise SwoopError("Illegal type passed to with_name")

    def without_name(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`name`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`name` is not equal to :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_name()` is :code:`False`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """
        
        if type(v) in [str, int, float, bool]:
            return self if self.name != v else None
        elif callable(v):
            return self if not v(self.name) else None
        else:
            raise SwoopError("Illegal type passed to without_name")


    def get_x(self):
        """ Return the value of :code:`x` for this :class:`Pad`.  This corresponds to the :code:`x` attribute of a :code:`<pad>` in an Eagle file.
        
        :rtype: :code:`float`
        """
        return self.x

    def set_x(self,v):
        """ Set the value of :code:`x` for this  :class:`Pad`.  This corresponds to the :code:`x` attribute of a :code:`<pad>` in an Eagle file.

        :param v: new value
        :rtype: :code:`self`
        """
                        
        if not typeCheck("float", v, True):
            raise SwoopError("Illegal value ({}) of type {} for attribute 'x' of Pad object (should be float).".format(v, type(v)))
        self.x = v
        
        return self

    def with_x(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`x`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`x` equals :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_x()` is :code:`True`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """

        if type(v) in [str, int, float, bool]:
            return self if self.x == v else None
        elif callable(v):
            return self if v(self.x) else None
        else:
            raise SwoopError("Illegal type passed to with_x")

    def without_x(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`x`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`x` is not equal to :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_x()` is :code:`False`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """
        
        if type(v) in [str, int, float, bool]:
            return self if self.x != v else None
        elif callable(v):
            return self if not v(self.x) else None
        else:
            raise SwoopError("Illegal type passed to without_x")


    def get_y(self):
        """ Return the value of :code:`y` for this :class:`Pad`.  This corresponds to the :code:`y` attribute of a :code:`<pad>` in an Eagle file.
        
        :rtype: :code:`float`
        """
        return self.y

    def set_y(self,v):
        """ Set the value of :code:`y` for this  :class:`Pad`.  This corresponds to the :code:`y` attribute of a :code:`<pad>` in an Eagle file.

        :param v: new value
        :rtype: :code:`self`
        """
                        
        if not typeCheck("float", v, True):
            raise SwoopError("Illegal value ({}) of type {} for attribute 'y' of Pad object (should be float).".format(v, type(v)))
        self.y = v
        
        return self

    def with_y(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`y`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`y` equals :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_y()` is :code:`True`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """

        if type(v) in [str, int, float, bool]:
            return self if self.y == v else None
        elif callable(v):
            return self if v(self.y) else None
        else:
            raise SwoopError("Illegal type passed to with_y")

    def without_y(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`y`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`y` is not equal to :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_y()` is :code:`False`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """
        
        if type(v) in [str, int, float, bool]:
            return self if self.y != v else None
        elif callable(v):
            return self if not v(self.y) else None
        else:
            raise SwoopError("Illegal type passed to without_y")


    def get_drill(self):
        """ Return the value of :code:`drill` for this :class:`Pad`.  This corresponds to the :code:`drill` attribute of a :code:`<pad>` in an Eagle file.
        
        :rtype: :code:`float`
        """
        return self.drill

    def set_drill(self,v):
        """ Set the value of :code:`drill` for this  :class:`Pad`.  This corresponds to the :code:`drill` attribute of a :code:`<pad>` in an Eagle file.

        :param v: new value
        :rtype: :code:`self`
        """
                        
        if not typeCheck("float", v, True):
            raise SwoopError("Illegal value ({}) of type {} for attribute 'drill' of Pad object (should be float).".format(v, type(v)))
        self.drill = v
        
        return self

    def with_drill(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`drill`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`drill` equals :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_drill()` is :code:`True`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """

        if type(v) in [str, int, float, bool]:
            return self if self.drill == v else None
        elif callable(v):
            return self if v(self.drill) else None
        else:
            raise SwoopError("Illegal type passed to with_drill")

    def without_drill(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`drill`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`drill` is not equal to :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_drill()` is :code:`False`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """
        
        if type(v) in [str, int, float, bool]:
            return self if self.drill != v else None
        elif callable(v):
            return self if not v(self.drill) else None
        else:
            raise SwoopError("Illegal type passed to without_drill")


    def get_diameter(self):
        """ Return the value of :code:`diameter` for this :class:`Pad`.  This corresponds to the :code:`diameter` attribute of a :code:`<pad>` in an Eagle file.
        
        :rtype: :code:`float`
        """
        return self.diameter

    def set_diameter(self,v):
        """ Set the value of :code:`diameter` for this  :class:`Pad`.  This corresponds to the :code:`diameter` attribute of a :code:`<pad>` in an Eagle file.

        :param v: new value
        :rtype: :code:`self`
        """
                        
        if not typeCheck("float", v, False):
            raise SwoopError("Illegal value ({}) of type {} for attribute 'diameter' of Pad object (should be float).".format(v, type(v)))
        self.diameter = v
        
        return self

    def with_diameter(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`diameter`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`diameter` equals :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_diameter()` is :code:`True`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """

        if type(v) in [str, int, float, bool]:
            return self if self.diameter == v else None
        elif callable(v):
            return self if v(self.diameter) else None
        else:
            raise SwoopError("Illegal type passed to with_diameter")

    def without_diameter(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`diameter`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`diameter` is not equal to :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_diameter()` is :code:`False`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """
        
        if type(v) in [str, int, float, bool]:
            return self if self.diameter != v else None
        elif callable(v):
            return self if not v(self.diameter) else None
        else:
            raise SwoopError("Illegal type passed to without_diameter")


    def get_shape(self):
        """ Return the value of :code:`shape` for this :class:`Pad`.  This corresponds to the :code:`shape` attribute of a :code:`<pad>` in an Eagle file.
        
        :rtype: :code:`str`
        """
        return self.shape

    def set_shape(self,v):
        """ Set the value of :code:`shape` for this  :class:`Pad`.  This corresponds to the :code:`shape` attribute of a :code:`<pad>` in an Eagle file.

        :param v: new value
        :rtype: :code:`self`
        """
                        
        if not typeCheck("str", v, False):
            raise SwoopError("Illegal value ({}) of type {} for attribute 'shape' of Pad object (should be str).".format(v, type(v)))
        self.shape = v
        
        return self

    def with_shape(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`shape`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`shape` equals :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_shape()` is :code:`True`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """

        if type(v) in [str, int, float, bool]:
            return self if self.shape == v else None
        elif callable(v):
            return self if v(self.shape) else None
        else:
            raise SwoopError("Illegal type passed to with_shape")

    def without_shape(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`shape`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`shape` is not equal to :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_shape()` is :code:`False`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """
        
        if type(v) in [str, int, float, bool]:
            return self if self.shape != v else None
        elif callable(v):
            return self if not v(self.shape) else None
        else:
            raise SwoopError("Illegal type passed to without_shape")


    def get_rot(self):
        """ Return the value of :code:`rot` for this :class:`Pad`.  This corresponds to the :code:`rot` attribute of a :code:`<pad>` in an Eagle file.
        
        :rtype: :code:`str`
        """
        return self.rot

    def set_rot(self,v):
        """ Set the value of :code:`rot` for this  :class:`Pad`.  This corresponds to the :code:`rot` attribute of a :code:`<pad>` in an Eagle file.

        :param v: new value
        :rtype: :code:`self`
        """
                        
        if not typeCheck("str", v, False):
            raise SwoopError("Illegal value ({}) of type {} for attribute 'rot' of Pad object (should be str).".format(v, type(v)))
        self.rot = v
        
        return self

    def with_rot(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`rot`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`rot` equals :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_rot()` is :code:`True`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """

        if type(v) in [str, int, float, bool]:
            return self if self.rot == v else None
        elif callable(v):
            return self if v(self.rot) else None
        else:
            raise SwoopError("Illegal type passed to with_rot")

    def without_rot(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`rot`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`rot` is not equal to :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_rot()` is :code:`False`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """
        
        if type(v) in [str, int, float, bool]:
            return self if self.rot != v else None
        elif callable(v):
            return self if not v(self.rot) else None
        else:
            raise SwoopError("Illegal type passed to without_rot")


    def get_stop(self):
        """ Return the value of :code:`stop` for this :class:`Pad`.  This corresponds to the :code:`stop` attribute of a :code:`<pad>` in an Eagle file.
        
        :rtype: :code:`bool`
        """
        return self.stop

    def set_stop(self,v):
        """ Set the value of :code:`stop` for this  :class:`Pad`.  This corresponds to the :code:`stop` attribute of a :code:`<pad>` in an Eagle file.

        :param v: new value
        :rtype: :code:`self`
        """
                        
        if not typeCheck("bool", v, False):
            raise SwoopError("Illegal value ({}) of type {} for attribute 'stop' of Pad object (should be bool).".format(v, type(v)))
        self.stop = v
        
        return self

    def with_stop(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`stop`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`stop` equals :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_stop()` is :code:`True`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """

        if type(v) in [str, int, float, bool]:
            return self if self.stop == v else None
        elif callable(v):
            return self if v(self.stop) else None
        else:
            raise SwoopError("Illegal type passed to with_stop")

    def without_stop(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`stop`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`stop` is not equal to :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_stop()` is :code:`False`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """
        
        if type(v) in [str, int, float, bool]:
            return self if self.stop != v else None
        elif callable(v):
            return self if not v(self.stop) else None
        else:
            raise SwoopError("Illegal type passed to without_stop")


    def get_thermals(self):
        """ Return the value of :code:`thermals` for this :class:`Pad`.  This corresponds to the :code:`thermals` attribute of a :code:`<pad>` in an Eagle file.
        
        :rtype: :code:`bool`
        """
        return self.thermals

    def set_thermals(self,v):
        """ Set the value of :code:`thermals` for this  :class:`Pad`.  This corresponds to the :code:`thermals` attribute of a :code:`<pad>` in an Eagle file.

        :param v: new value
        :rtype: :code:`self`
        """
                        
        if not typeCheck("bool", v, False):
            raise SwoopError("Illegal value ({}) of type {} for attribute 'thermals' of Pad object (should be bool).".format(v, type(v)))
        self.thermals = v
        
        return self

    def with_thermals(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`thermals`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`thermals` equals :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_thermals()` is :code:`True`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """

        if type(v) in [str, int, float, bool]:
            return self if self.thermals == v else None
        elif callable(v):
            return self if v(self.thermals) else None
        else:
            raise SwoopError("Illegal type passed to with_thermals")

    def without_thermals(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`thermals`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`thermals` is not equal to :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_thermals()` is :code:`False`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """
        
        if type(v) in [str, int, float, bool]:
            return self if self.thermals != v else None
        elif callable(v):
            return self if not v(self.thermals) else None
        else:
            raise SwoopError("Illegal type passed to without_thermals")


    def get_first(self):
        """ Return the value of :code:`first` for this :class:`Pad`.  This corresponds to the :code:`first` attribute of a :code:`<pad>` in an Eagle file.
        
        :rtype: :code:`bool`
        """
        return self.first

    def set_first(self,v):
        """ Set the value of :code:`first` for this  :class:`Pad`.  This corresponds to the :code:`first` attribute of a :code:`<pad>` in an Eagle file.

        :param v: new value
        :rtype: :code:`self`
        """
                        
        if not typeCheck("bool", v, False):
            raise SwoopError("Illegal value ({}) of type {} for attribute 'first' of Pad object (should be bool).".format(v, type(v)))
        self.first = v
        
        return self

    def with_first(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`first`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`first` equals :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_first()` is :code:`True`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """

        if type(v) in [str, int, float, bool]:
            return self if self.first == v else None
        elif callable(v):
            return self if v(self.first) else None
        else:
            raise SwoopError("Illegal type passed to with_first")

    def without_first(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`first`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`first` is not equal to :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_first()` is :code:`False`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """
        
        if type(v) in [str, int, float, bool]:
            return self if self.first != v else None
        elif callable(v):
            return self if not v(self.first) else None
        else:
            raise SwoopError("Illegal type passed to without_first")



    ##### Lookup functions that return EFPs instead of just attribute values.
    
    


    
    ### Adder/getter/lookup for lists
    


    ### Add, lookup, and get for maps


    
    ### Getter/Setter for singletons.


    
    def get_children(self):
        """
        Get all the children of this :class:`EagleFilePart`.
        
        :rtype: List of :class:`EagleFilePart` objects
        """
        r = []




        return r

    def remove_child(self, efp):
        """
        Remove a child :class:`EagleFilePart` object.
        
        :param efp: the class:`EagleFilePart` object to remove.
        :return: Nothing
        """

    def _rekey_child(self, oldkey, efp):
        """
        Remove a child :class:`EagleFilePart` object.
        
        :param efp: the class:`EagleFilePart` object to remove.
        :return: Nothing
        """


    def __str__(self):
        r = "["+repr(self)+" "
        r = r + "name:" + str(self.get_name()) + " "
        r = r + "x:" + str(self.get_x()) + " "
        r = r + "y:" + str(self.get_y()) + " "
        r = r + "drill:" + str(self.get_drill()) + " "
        r = r + "diameter:" + str(self.get_diameter()) + " "
        r = r + "shape:" + str(self.get_shape()) + " "
        r = r + "rot:" + str(self.get_rot()) + " "
        r = r + "stop:" + str(self.get_stop()) + " "
        r = r + "thermals:" + str(self.get_thermals()) + " "
        r = r + "first:" + str(self.get_first()) + " "
        r = r + "]"
        return r
            
    def dump(self, indent="", increment="   "):
        """
        Recursive debug dump.
        
        :param indent:  Indentation string.  The output will be indented by this much.
        :param increment: This will be appendeded to :code:`indent` on recursive invocations.

        :rtype: :code:`None`
        """
        print(indent + str(self.__class__.__name__), end=' ')
        try:
            print(self.get_name())
        except:
            print()
            pass
        for c in self.get_children():
            c.dump(indent + "   ")

        
EagleFile.class_map["pad"] = Pad
         


class Schematic(EagleFilePart):
    """
    Class representing the contents of a <schematic> tag in Eagle files.

    Attributes:

    * :code:`xreflabel`

    * :code:`xrefpart`


    """
    def __init__(self):
        """
        Construct an empty :class:`Schematic` object.
        """
        EagleFilePart.__init__(self)
        
        self.xreflabel=None
        self.xrefpart=None


        
    @classmethod
    def _from_et(cls,root,parent):
        """
        Create a :class:`Schematic` from a :code:`schematic` element.
        
        :param root: The element tree tree to parse.
        :param parent: :class:`EagleFilePart` that should hold the resulting :class:`EagleFilePart`
        :rtype: :class:`Schematic`
        """
        ## Call the constructor
        n = cls()
        n._init_from_et(root,parent)
        return n

    def _get_error_name(self):
        if hasattr(self, "get_name"):
            return self.get_name();
        else:
            return "Schematic";
        
    def  _init_from_et(self, root, parent):
        """
        Initialized a :class:`Schematic` from a :code:`schematic` element.  This is useful if you have a subclass of :class:`Schematic` .
        
        :param root: The element tree tree to parse.
        :param parent: :class:`EagleFilePart` that will become the parent of :code:`this` .
        :rtype: :class:`Schematic`
        """
        try:
            self.root = root
            
            if root.tag != "schematic":
                raise EagleFormatError("Tried to create schematic from " + root.tag)

            self.xreflabel=parseByType(parent, "str", None, root.get("xreflabel"))
            self.xrefpart=parseByType(parent, "str", None, root.get("xrefpart"))

            self.parent = parent

            ### populate the maps by searching for elements that match xpath and generating objects for them.


            ### Do the same for the lists


            ### Do the same for the attr lists


            ### And the singletons


            ### And, finally, if the objects wants the text from the tag.

        except SwoopError as e:
            e.text = "{}:{}".format(self._get_error_name(), e.text)
            raise e


    def sortkey(self):
        r = ""
        r = r + str(self.xreflabel)
        r = r + str(self.xrefpart)
        return r

    def get_et(self):
        """
        Generate a <schematic> element tree for a :class:`Schematic`.
        
        :rtype:  :class:`ElementTree`.
        
        """
        try:
            r = ET.Element("schematic")

            ### Set the tag attributes 


            ## Unparse the values.

            v = unparseByType(self, "str", None,  self.xreflabel)

            ## For required attributes None becomes "".  For optional attributes, we just leave the attribute out.
            if not (isinstance(self.get_parent(), LibraryFile) and False):  # special case for the name of library.
                if v is not None:
                    r.set("xreflabel", v)


            ## Unparse the values.

            v = unparseByType(self, "str", None,  self.xrefpart)

            ## For required attributes None becomes "".  For optional attributes, we just leave the attribute out.
            if not (isinstance(self.get_parent(), LibraryFile) and False):  # special case for the name of library.
                if v is not None:
                    r.set("xrefpart", v)


            ### process the sections in order.  They have to be in section order,
            ### because eagle files are order dependent.


            ## set the text, if its needed.

        except SwoopError as e:
            e.text = "{}:{}".format(self._get_error_name(), e.text)
            raise e
        return r

    def clone(self):
        """
        Recursively clone this :code:`Schematic`.  It will be identical to the original, but it's parent will be :code:`None`.
        
        :rtype: :class:`Schematic`
        """
        try:
            n = copy.copy(self)
            n.parent = None
        except SwoopError as e:
            e.text = "{}:{}".format(self._get_error_name(), e.text)
            raise e
        return n

    def accept_preorder_visitor(self, visitor):
        try:
            pre = getattr(visitor, "Schematic_pre")
            return pre(self)
        except AttributeError:
            return visitor.default_pre(self)
        
    def accept_postorder_visitor(self, visitor, context):
        try:
            post = getattr(visitor, "Schematic_post")
            post(self,context)
        except AttributeError:
            visitor.default_post(self,context)

    def is_equal(self, other):
        """
        Check whether two :code:`EagleFilePart` objects are identical.
        
        :param other: Object to compare to.
        :returns: :code:`True` if they are identical, otherwise, :code:`False`
        """
        return self.get_xml() == other.get_xml()
        
    ### Getters/Setters for attribute values

    def get_xreflabel(self):
        """ Return the value of :code:`xreflabel` for this :class:`Schematic`.  This corresponds to the :code:`xreflabel` attribute of a :code:`<schematic>` in an Eagle file.
        
        :rtype: :code:`str`
        """
        return self.xreflabel

    def set_xreflabel(self,v):
        """ Set the value of :code:`xreflabel` for this  :class:`Schematic`.  This corresponds to the :code:`xreflabel` attribute of a :code:`<schematic>` in an Eagle file.

        :param v: new value
        :rtype: :code:`self`
        """
                        
        if not typeCheck("str", v, False):
            raise SwoopError("Illegal value ({}) of type {} for attribute 'xreflabel' of Schematic object (should be str).".format(v, type(v)))
        self.xreflabel = v
        
        return self

    def with_xreflabel(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`xreflabel`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`xreflabel` equals :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_xreflabel()` is :code:`True`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """

        if type(v) in [str, int, float, bool]:
            return self if self.xreflabel == v else None
        elif callable(v):
            return self if v(self.xreflabel) else None
        else:
            raise SwoopError("Illegal type passed to with_xreflabel")

    def without_xreflabel(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`xreflabel`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`xreflabel` is not equal to :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_xreflabel()` is :code:`False`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """
        
        if type(v) in [str, int, float, bool]:
            return self if self.xreflabel != v else None
        elif callable(v):
            return self if not v(self.xreflabel) else None
        else:
            raise SwoopError("Illegal type passed to without_xreflabel")


    def get_xrefpart(self):
        """ Return the value of :code:`xrefpart` for this :class:`Schematic`.  This corresponds to the :code:`xrefpart` attribute of a :code:`<schematic>` in an Eagle file.
        
        :rtype: :code:`str`
        """
        return self.xrefpart

    def set_xrefpart(self,v):
        """ Set the value of :code:`xrefpart` for this  :class:`Schematic`.  This corresponds to the :code:`xrefpart` attribute of a :code:`<schematic>` in an Eagle file.

        :param v: new value
        :rtype: :code:`self`
        """
                        
        if not typeCheck("str", v, False):
            raise SwoopError("Illegal value ({}) of type {} for attribute 'xrefpart' of Schematic object (should be str).".format(v, type(v)))
        self.xrefpart = v
        
        return self

    def with_xrefpart(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`xrefpart`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`xrefpart` equals :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_xrefpart()` is :code:`True`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """

        if type(v) in [str, int, float, bool]:
            return self if self.xrefpart == v else None
        elif callable(v):
            return self if v(self.xrefpart) else None
        else:
            raise SwoopError("Illegal type passed to with_xrefpart")

    def without_xrefpart(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`xrefpart`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`xrefpart` is not equal to :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_xrefpart()` is :code:`False`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """
        
        if type(v) in [str, int, float, bool]:
            return self if self.xrefpart != v else None
        elif callable(v):
            return self if not v(self.xrefpart) else None
        else:
            raise SwoopError("Illegal type passed to without_xrefpart")



    ##### Lookup functions that return EFPs instead of just attribute values.
    
    


    
    ### Adder/getter/lookup for lists
    


    ### Add, lookup, and get for maps


    
    ### Getter/Setter for singletons.


    
    def get_children(self):
        """
        Get all the children of this :class:`EagleFilePart`.
        
        :rtype: List of :class:`EagleFilePart` objects
        """
        r = []




        return r

    def remove_child(self, efp):
        """
        Remove a child :class:`EagleFilePart` object.
        
        :param efp: the class:`EagleFilePart` object to remove.
        :return: Nothing
        """

    def _rekey_child(self, oldkey, efp):
        """
        Remove a child :class:`EagleFilePart` object.
        
        :param efp: the class:`EagleFilePart` object to remove.
        :return: Nothing
        """


    def __str__(self):
        r = "["+repr(self)+" "
        r = r + "xreflabel:" + str(self.get_xreflabel()) + " "
        r = r + "xrefpart:" + str(self.get_xrefpart()) + " "
        r = r + "]"
        return r
            
    def dump(self, indent="", increment="   "):
        """
        Recursive debug dump.
        
        :param indent:  Indentation string.  The output will be indented by this much.
        :param increment: This will be appendeded to :code:`indent` on recursive invocations.

        :rtype: :code:`None`
        """
        print(indent + str(self.__class__.__name__), end=' ')
        try:
            print(self.get_name())
        except:
            print()
            pass
        for c in self.get_children():
            c.dump(indent + "   ")

        
EagleFile.class_map["schematic"] = Schematic
         


class Base_Attribute(EagleFilePart):
    """
    Class representing the contents of a <attribute> tag in Eagle files.

    Attributes:

    * :code:`name`

    * :code:`value`

    * :code:`x`

    * :code:`y`

    * :code:`size`

    * :code:`layer`

    * :code:`font`

    * :code:`ratio`

    * :code:`rot`

    * :code:`display`

    * :code:`align`

    * :code:`constant`


    """
    def __init__(self):
        """
        Construct an empty :class:`Base_Attribute` object.
        """
        EagleFilePart.__init__(self)
        
        self.name=None
        self.value=None
        self.x=None
        self.y=None
        self.size=None
        self.layer=None
        self.font=None
        self.ratio=None
        self.rot=None
        self.display=None
        self.align=None
        self.constant=None


        
    @classmethod
    def _from_et(cls,root,parent):
        """
        Create a :class:`Attribute` from a :code:`attribute` element.
        
        :param root: The element tree tree to parse.
        :param parent: :class:`EagleFilePart` that should hold the resulting :class:`EagleFilePart`
        :rtype: :class:`Attribute`
        """
        ## Call the constructor
        n = cls()
        n._init_from_et(root,parent)
        return n

    def _get_error_name(self):
        if hasattr(self, "get_name"):
            return self.get_name();
        else:
            return "Attribute";
        
    def  _init_from_et(self, root, parent):
        """
        Initialized a :class:`Attribute` from a :code:`attribute` element.  This is useful if you have a subclass of :class:`Attribute` .
        
        :param root: The element tree tree to parse.
        :param parent: :class:`EagleFilePart` that will become the parent of :code:`this` .
        :rtype: :class:`Attribute`
        """
        try:
            self.root = root
            
            if root.tag != "attribute":
                raise EagleFormatError("Tried to create attribute from " + root.tag)

            self.name=parseByType(parent, "str", None, root.get("name"))
            self.value=parseByType(parent, "str", None, root.get("value"))
            self.x=parseByType(parent, "float", None, root.get("x"))
            self.y=parseByType(parent, "float", None, root.get("y"))
            self.size=parseByType(parent, "float", None, root.get("size"))
            self.layer=parseByType(parent, "layer_string", None, root.get("layer"))
            self.font=parseByType(parent, "str", None, root.get("font"))
            self.ratio=parseByType(parent, "int", None, root.get("ratio"))
            self.rot=parseByType(parent, "str", None, root.get("rot"))
            self.display=parseByType(parent, "display_bool", None, root.get("display"))
            self.align=parseByType(parent, "str", None, root.get("align"))
            self.constant=parseByType(parent, "constant_bool", None, root.get("constant"))

            self.parent = parent

            ### populate the maps by searching for elements that match xpath and generating objects for them.


            ### Do the same for the lists


            ### Do the same for the attr lists


            ### And the singletons


            ### And, finally, if the objects wants the text from the tag.

        except SwoopError as e:
            e.text = "{}:{}".format(self._get_error_name(), e.text)
            raise e


    def sortkey(self):
        r = ""
        r = r + str(self.name)
        r = r + str(self.value)
        r = r + str(self.x)
        r = r + str(self.y)
        r = r + str(self.size)
        r = r + str(self.layer)
        r = r + str(self.font)
        r = r + str(self.ratio)
        r = r + str(self.rot)
        r = r + str(self.display)
        r = r + str(self.align)
        r = r + str(self.constant)
        return r

    def get_et(self):
        """
        Generate a <attribute> element tree for a :class:`Attribute`.
        
        :rtype:  :class:`ElementTree`.
        
        """
        try:
            r = ET.Element("attribute")

            ### Set the tag attributes 


            ## Unparse the values.

            v = unparseByType(self, "str", None,  self.name)

            ## For required attributes None becomes "".  For optional attributes, we just leave the attribute out.
            if not (isinstance(self.get_parent(), LibraryFile) and False):  # special case for the name of library.
                if v is not None:
                    r.set("name", v)
                else:
                    r.set("name", "")


            ## Unparse the values.

            v = unparseByType(self, "str", None,  self.value)

            ## For required attributes None becomes "".  For optional attributes, we just leave the attribute out.
            if not (isinstance(self.get_parent(), LibraryFile) and False):  # special case for the name of library.
                if v is not None:
                    r.set("value", v)


            ## Unparse the values.

            v = unparseByType(self, "float", None,  self.x)

            ## For required attributes None becomes "".  For optional attributes, we just leave the attribute out.
            if not (isinstance(self.get_parent(), LibraryFile) and False):  # special case for the name of library.
                if v is not None:
                    r.set("x", v)


            ## Unparse the values.

            v = unparseByType(self, "float", None,  self.y)

            ## For required attributes None becomes "".  For optional attributes, we just leave the attribute out.
            if not (isinstance(self.get_parent(), LibraryFile) and False):  # special case for the name of library.
                if v is not None:
                    r.set("y", v)


            ## Unparse the values.

            v = unparseByType(self, "float", None,  self.size)

            ## For required attributes None becomes "".  For optional attributes, we just leave the attribute out.
            if not (isinstance(self.get_parent(), LibraryFile) and False):  # special case for the name of library.
                if v is not None:
                    r.set("size", v)


            ## Unparse the values.

            v = unparseByType(self, "layer_string", None,  self.layer)

            ## For required attributes None becomes "".  For optional attributes, we just leave the attribute out.
            if not (isinstance(self.get_parent(), LibraryFile) and False):  # special case for the name of library.
                if v is not None:
                    r.set("layer", v)


            ## Unparse the values.

            v = unparseByType(self, "str", None,  self.font)

            ## For required attributes None becomes "".  For optional attributes, we just leave the attribute out.
            if not (isinstance(self.get_parent(), LibraryFile) and False):  # special case for the name of library.
                if v is not None:
                    r.set("font", v)


            ## Unparse the values.

            v = unparseByType(self, "int", None,  self.ratio)

            ## For required attributes None becomes "".  For optional attributes, we just leave the attribute out.
            if not (isinstance(self.get_parent(), LibraryFile) and False):  # special case for the name of library.
                if v is not None:
                    r.set("ratio", v)


            ## Unparse the values.

            v = unparseByType(self, "str", None,  self.rot)

            ## For required attributes None becomes "".  For optional attributes, we just leave the attribute out.
            if not (isinstance(self.get_parent(), LibraryFile) and False):  # special case for the name of library.
                if v is not None:
                    r.set("rot", v)


            ## Unparse the values.

            v = unparseByType(self, "display_bool", None,  self.display)

            ## For required attributes None becomes "".  For optional attributes, we just leave the attribute out.
            if not (isinstance(self.get_parent(), LibraryFile) and False):  # special case for the name of library.
                if v is not None:
                    r.set("display", v)


            ## Unparse the values.

            v = unparseByType(self, "str", None,  self.align)

            ## For required attributes None becomes "".  For optional attributes, we just leave the attribute out.
            if not (isinstance(self.get_parent(), LibraryFile) and False):  # special case for the name of library.
                if v is not None:
                    r.set("align", v)


            ## Unparse the values.

            v = unparseByType(self, "constant_bool", None,  self.constant)

            ## For required attributes None becomes "".  For optional attributes, we just leave the attribute out.
            if not (isinstance(self.get_parent(), LibraryFile) and False):  # special case for the name of library.
                if v is not None:
                    r.set("constant", v)


            ### process the sections in order.  They have to be in section order,
            ### because eagle files are order dependent.


            ## set the text, if its needed.

        except SwoopError as e:
            e.text = "{}:{}".format(self._get_error_name(), e.text)
            raise e
        return r

    def clone(self):
        """
        Recursively clone this :code:`Attribute`.  It will be identical to the original, but it's parent will be :code:`None`.
        
        :rtype: :class:`Attribute`
        """
        try:
            n = copy.copy(self)
            n.parent = None
        except SwoopError as e:
            e.text = "{}:{}".format(self._get_error_name(), e.text)
            raise e
        return n

    def accept_preorder_visitor(self, visitor):
        try:
            pre = getattr(visitor, "Attribute_pre")
            return pre(self)
        except AttributeError:
            return visitor.default_pre(self)
        
    def accept_postorder_visitor(self, visitor, context):
        try:
            post = getattr(visitor, "Attribute_post")
            post(self,context)
        except AttributeError:
            visitor.default_post(self,context)

    def is_equal(self, other):
        """
        Check whether two :code:`EagleFilePart` objects are identical.
        
        :param other: Object to compare to.
        :returns: :code:`True` if they are identical, otherwise, :code:`False`
        """
        return self.get_xml() == other.get_xml()
        
    ### Getters/Setters for attribute values

    def get_name(self):
        """ Return the value of :code:`name` for this :class:`Attribute`.  This corresponds to the :code:`name` attribute of a :code:`<attribute>` in an Eagle file.
        
        :rtype: :code:`str`
        """
        return self.name

    def set_name(self,v):
        """ Set the value of :code:`name` for this  :class:`Attribute`.  This corresponds to the :code:`name` attribute of a :code:`<attribute>` in an Eagle file.

        :param v: new value
        :rtype: :code:`self`
        """
                        
        oldkey = self.name
        if not typeCheck("str", v, True):
            raise SwoopError("Illegal value ({}) of type {} for attribute 'name' of Attribute object (should be str).".format(v, type(v)))
        self.name = v
        
        if self.get_parent() is not None:
            self.get_parent()._rekey_child(oldkey, self);
        return self

    def with_name(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`name`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`name` equals :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_name()` is :code:`True`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """

        if type(v) in [str, int, float, bool]:
            return self if self.name == v else None
        elif callable(v):
            return self if v(self.name) else None
        else:
            raise SwoopError("Illegal type passed to with_name")

    def without_name(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`name`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`name` is not equal to :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_name()` is :code:`False`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """
        
        if type(v) in [str, int, float, bool]:
            return self if self.name != v else None
        elif callable(v):
            return self if not v(self.name) else None
        else:
            raise SwoopError("Illegal type passed to without_name")


    def get_value(self):
        """ Return the value of :code:`value` for this :class:`Attribute`.  This corresponds to the :code:`value` attribute of a :code:`<attribute>` in an Eagle file.
        
        :rtype: :code:`str`
        """
        return self.value

    def set_value(self,v):
        """ Set the value of :code:`value` for this  :class:`Attribute`.  This corresponds to the :code:`value` attribute of a :code:`<attribute>` in an Eagle file.

        :param v: new value
        :rtype: :code:`self`
        """
                        
        if not typeCheck("str", v, False):
            raise SwoopError("Illegal value ({}) of type {} for attribute 'value' of Attribute object (should be str).".format(v, type(v)))
        self.value = v
        
        return self

    def with_value(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`value`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`value` equals :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_value()` is :code:`True`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """

        if type(v) in [str, int, float, bool]:
            return self if self.value == v else None
        elif callable(v):
            return self if v(self.value) else None
        else:
            raise SwoopError("Illegal type passed to with_value")

    def without_value(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`value`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`value` is not equal to :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_value()` is :code:`False`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """
        
        if type(v) in [str, int, float, bool]:
            return self if self.value != v else None
        elif callable(v):
            return self if not v(self.value) else None
        else:
            raise SwoopError("Illegal type passed to without_value")


    def get_x(self):
        """ Return the value of :code:`x` for this :class:`Attribute`.  This corresponds to the :code:`x` attribute of a :code:`<attribute>` in an Eagle file.
        
        :rtype: :code:`float`
        """
        return self.x

    def set_x(self,v):
        """ Set the value of :code:`x` for this  :class:`Attribute`.  This corresponds to the :code:`x` attribute of a :code:`<attribute>` in an Eagle file.

        :param v: new value
        :rtype: :code:`self`
        """
                        
        if not typeCheck("float", v, False):
            raise SwoopError("Illegal value ({}) of type {} for attribute 'x' of Attribute object (should be float).".format(v, type(v)))
        self.x = v
        
        return self

    def with_x(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`x`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`x` equals :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_x()` is :code:`True`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """

        if type(v) in [str, int, float, bool]:
            return self if self.x == v else None
        elif callable(v):
            return self if v(self.x) else None
        else:
            raise SwoopError("Illegal type passed to with_x")

    def without_x(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`x`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`x` is not equal to :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_x()` is :code:`False`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """
        
        if type(v) in [str, int, float, bool]:
            return self if self.x != v else None
        elif callable(v):
            return self if not v(self.x) else None
        else:
            raise SwoopError("Illegal type passed to without_x")


    def get_y(self):
        """ Return the value of :code:`y` for this :class:`Attribute`.  This corresponds to the :code:`y` attribute of a :code:`<attribute>` in an Eagle file.
        
        :rtype: :code:`float`
        """
        return self.y

    def set_y(self,v):
        """ Set the value of :code:`y` for this  :class:`Attribute`.  This corresponds to the :code:`y` attribute of a :code:`<attribute>` in an Eagle file.

        :param v: new value
        :rtype: :code:`self`
        """
                        
        if not typeCheck("float", v, False):
            raise SwoopError("Illegal value ({}) of type {} for attribute 'y' of Attribute object (should be float).".format(v, type(v)))
        self.y = v
        
        return self

    def with_y(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`y`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`y` equals :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_y()` is :code:`True`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """

        if type(v) in [str, int, float, bool]:
            return self if self.y == v else None
        elif callable(v):
            return self if v(self.y) else None
        else:
            raise SwoopError("Illegal type passed to with_y")

    def without_y(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`y`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`y` is not equal to :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_y()` is :code:`False`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """
        
        if type(v) in [str, int, float, bool]:
            return self if self.y != v else None
        elif callable(v):
            return self if not v(self.y) else None
        else:
            raise SwoopError("Illegal type passed to without_y")


    def get_size(self):
        """ Return the value of :code:`size` for this :class:`Attribute`.  This corresponds to the :code:`size` attribute of a :code:`<attribute>` in an Eagle file.
        
        :rtype: :code:`float`
        """
        return self.size

    def set_size(self,v):
        """ Set the value of :code:`size` for this  :class:`Attribute`.  This corresponds to the :code:`size` attribute of a :code:`<attribute>` in an Eagle file.

        :param v: new value
        :rtype: :code:`self`
        """
                        
        if not typeCheck("float", v, False):
            raise SwoopError("Illegal value ({}) of type {} for attribute 'size' of Attribute object (should be float).".format(v, type(v)))
        self.size = v
        
        return self

    def with_size(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`size`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`size` equals :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_size()` is :code:`True`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """

        if type(v) in [str, int, float, bool]:
            return self if self.size == v else None
        elif callable(v):
            return self if v(self.size) else None
        else:
            raise SwoopError("Illegal type passed to with_size")

    def without_size(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`size`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`size` is not equal to :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_size()` is :code:`False`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """
        
        if type(v) in [str, int, float, bool]:
            return self if self.size != v else None
        elif callable(v):
            return self if not v(self.size) else None
        else:
            raise SwoopError("Illegal type passed to without_size")


    def get_layer(self):
        """ Return the value of :code:`layer` for this :class:`Attribute`.  This corresponds to the :code:`layer` attribute of a :code:`<attribute>` in an Eagle file.
        
        :rtype: :code:`layer_string`
        """
        return self.layer

    def set_layer(self,v):
        """ Set the value of :code:`layer` for this  :class:`Attribute`.  This corresponds to the :code:`layer` attribute of a :code:`<attribute>` in an Eagle file.

        :param v: new value
        :rtype: :code:`self`
        """
                        
        if not typeCheck("layer_string", v, False):
            raise SwoopError("Illegal value ({}) of type {} for attribute 'layer' of Attribute object (should be layer_string).".format(v, type(v)))
        self.layer = v
        
        return self

    def with_layer(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`layer`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`layer` equals :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_layer()` is :code:`True`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """

        if type(v) in [str, int, float, bool]:
            return self if self.layer == v else None
        elif callable(v):
            return self if v(self.layer) else None
        else:
            raise SwoopError("Illegal type passed to with_layer")

    def without_layer(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`layer`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`layer` is not equal to :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_layer()` is :code:`False`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """
        
        if type(v) in [str, int, float, bool]:
            return self if self.layer != v else None
        elif callable(v):
            return self if not v(self.layer) else None
        else:
            raise SwoopError("Illegal type passed to without_layer")


    def get_font(self):
        """ Return the value of :code:`font` for this :class:`Attribute`.  This corresponds to the :code:`font` attribute of a :code:`<attribute>` in an Eagle file.
        
        :rtype: :code:`str`
        """
        return self.font

    def set_font(self,v):
        """ Set the value of :code:`font` for this  :class:`Attribute`.  This corresponds to the :code:`font` attribute of a :code:`<attribute>` in an Eagle file.

        :param v: new value
        :rtype: :code:`self`
        """
                        
        if not typeCheck("str", v, False):
            raise SwoopError("Illegal value ({}) of type {} for attribute 'font' of Attribute object (should be str).".format(v, type(v)))
        self.font = v
        
        return self

    def with_font(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`font`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`font` equals :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_font()` is :code:`True`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """

        if type(v) in [str, int, float, bool]:
            return self if self.font == v else None
        elif callable(v):
            return self if v(self.font) else None
        else:
            raise SwoopError("Illegal type passed to with_font")

    def without_font(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`font`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`font` is not equal to :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_font()` is :code:`False`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """
        
        if type(v) in [str, int, float, bool]:
            return self if self.font != v else None
        elif callable(v):
            return self if not v(self.font) else None
        else:
            raise SwoopError("Illegal type passed to without_font")


    def get_ratio(self):
        """ Return the value of :code:`ratio` for this :class:`Attribute`.  This corresponds to the :code:`ratio` attribute of a :code:`<attribute>` in an Eagle file.
        
        :rtype: :code:`int`
        """
        return self.ratio

    def set_ratio(self,v):
        """ Set the value of :code:`ratio` for this  :class:`Attribute`.  This corresponds to the :code:`ratio` attribute of a :code:`<attribute>` in an Eagle file.

        :param v: new value
        :rtype: :code:`self`
        """
                        
        if not typeCheck("int", v, False):
            raise SwoopError("Illegal value ({}) of type {} for attribute 'ratio' of Attribute object (should be int).".format(v, type(v)))
        self.ratio = v
        
        return self

    def with_ratio(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`ratio`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`ratio` equals :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_ratio()` is :code:`True`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """

        if type(v) in [str, int, float, bool]:
            return self if self.ratio == v else None
        elif callable(v):
            return self if v(self.ratio) else None
        else:
            raise SwoopError("Illegal type passed to with_ratio")

    def without_ratio(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`ratio`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`ratio` is not equal to :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_ratio()` is :code:`False`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """
        
        if type(v) in [str, int, float, bool]:
            return self if self.ratio != v else None
        elif callable(v):
            return self if not v(self.ratio) else None
        else:
            raise SwoopError("Illegal type passed to without_ratio")


    def get_rot(self):
        """ Return the value of :code:`rot` for this :class:`Attribute`.  This corresponds to the :code:`rot` attribute of a :code:`<attribute>` in an Eagle file.
        
        :rtype: :code:`str`
        """
        return self.rot

    def set_rot(self,v):
        """ Set the value of :code:`rot` for this  :class:`Attribute`.  This corresponds to the :code:`rot` attribute of a :code:`<attribute>` in an Eagle file.

        :param v: new value
        :rtype: :code:`self`
        """
                        
        if not typeCheck("str", v, False):
            raise SwoopError("Illegal value ({}) of type {} for attribute 'rot' of Attribute object (should be str).".format(v, type(v)))
        self.rot = v
        
        return self

    def with_rot(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`rot`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`rot` equals :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_rot()` is :code:`True`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """

        if type(v) in [str, int, float, bool]:
            return self if self.rot == v else None
        elif callable(v):
            return self if v(self.rot) else None
        else:
            raise SwoopError("Illegal type passed to with_rot")

    def without_rot(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`rot`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`rot` is not equal to :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_rot()` is :code:`False`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """
        
        if type(v) in [str, int, float, bool]:
            return self if self.rot != v else None
        elif callable(v):
            return self if not v(self.rot) else None
        else:
            raise SwoopError("Illegal type passed to without_rot")


    def get_display(self):
        """ Return the value of :code:`display` for this :class:`Attribute`.  This corresponds to the :code:`display` attribute of a :code:`<attribute>` in an Eagle file.
        
        :rtype: :code:`display_bool`
        """
        return self.display

    def set_display(self,v):
        """ Set the value of :code:`display` for this  :class:`Attribute`.  This corresponds to the :code:`display` attribute of a :code:`<attribute>` in an Eagle file.

        :param v: new value
        :rtype: :code:`self`
        """
                        
        if not typeCheck("display_bool", v, False):
            raise SwoopError("Illegal value ({}) of type {} for attribute 'display' of Attribute object (should be display_bool).".format(v, type(v)))
        self.display = v
        
        return self

    def with_display(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`display`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`display` equals :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_display()` is :code:`True`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """

        if type(v) in [str, int, float, bool]:
            return self if self.display == v else None
        elif callable(v):
            return self if v(self.display) else None
        else:
            raise SwoopError("Illegal type passed to with_display")

    def without_display(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`display`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`display` is not equal to :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_display()` is :code:`False`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """
        
        if type(v) in [str, int, float, bool]:
            return self if self.display != v else None
        elif callable(v):
            return self if not v(self.display) else None
        else:
            raise SwoopError("Illegal type passed to without_display")


    def get_align(self):
        """ Return the value of :code:`align` for this :class:`Attribute`.  This corresponds to the :code:`align` attribute of a :code:`<attribute>` in an Eagle file.
        
        :rtype: :code:`str`
        """
        return self.align

    def set_align(self,v):
        """ Set the value of :code:`align` for this  :class:`Attribute`.  This corresponds to the :code:`align` attribute of a :code:`<attribute>` in an Eagle file.

        :param v: new value
        :rtype: :code:`self`
        """
                        
        if not typeCheck("str", v, False):
            raise SwoopError("Illegal value ({}) of type {} for attribute 'align' of Attribute object (should be str).".format(v, type(v)))
        self.align = v
        
        return self

    def with_align(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`align`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`align` equals :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_align()` is :code:`True`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """

        if type(v) in [str, int, float, bool]:
            return self if self.align == v else None
        elif callable(v):
            return self if v(self.align) else None
        else:
            raise SwoopError("Illegal type passed to with_align")

    def without_align(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`align`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`align` is not equal to :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_align()` is :code:`False`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """
        
        if type(v) in [str, int, float, bool]:
            return self if self.align != v else None
        elif callable(v):
            return self if not v(self.align) else None
        else:
            raise SwoopError("Illegal type passed to without_align")


    def get_constant(self):
        """ Return the value of :code:`constant` for this :class:`Attribute`.  This corresponds to the :code:`constant` attribute of a :code:`<attribute>` in an Eagle file.
        
        :rtype: :code:`constant_bool`
        """
        return self.constant

    def set_constant(self,v):
        """ Set the value of :code:`constant` for this  :class:`Attribute`.  This corresponds to the :code:`constant` attribute of a :code:`<attribute>` in an Eagle file.

        :param v: new value
        :rtype: :code:`self`
        """
                        
        if not typeCheck("constant_bool", v, False):
            raise SwoopError("Illegal value ({}) of type {} for attribute 'constant' of Attribute object (should be constant_bool).".format(v, type(v)))
        self.constant = v
        
        return self

    def with_constant(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`constant`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`constant` equals :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_constant()` is :code:`True`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """

        if type(v) in [str, int, float, bool]:
            return self if self.constant == v else None
        elif callable(v):
            return self if v(self.constant) else None
        else:
            raise SwoopError("Illegal type passed to with_constant")

    def without_constant(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`constant`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`constant` is not equal to :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_constant()` is :code:`False`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """
        
        if type(v) in [str, int, float, bool]:
            return self if self.constant != v else None
        elif callable(v):
            return self if not v(self.constant) else None
        else:
            raise SwoopError("Illegal type passed to without_constant")



    ##### Lookup functions that return EFPs instead of just attribute values.
    
    


    
    ### Adder/getter/lookup for lists
    


    ### Add, lookup, and get for maps


    
    ### Getter/Setter for singletons.


    
    def get_children(self):
        """
        Get all the children of this :class:`EagleFilePart`.
        
        :rtype: List of :class:`EagleFilePart` objects
        """
        r = []




        return r

    def remove_child(self, efp):
        """
        Remove a child :class:`EagleFilePart` object.
        
        :param efp: the class:`EagleFilePart` object to remove.
        :return: Nothing
        """

    def _rekey_child(self, oldkey, efp):
        """
        Remove a child :class:`EagleFilePart` object.
        
        :param efp: the class:`EagleFilePart` object to remove.
        :return: Nothing
        """


    def __str__(self):
        r = "["+repr(self)+" "
        r = r + "name:" + str(self.get_name()) + " "
        r = r + "value:" + str(self.get_value()) + " "
        r = r + "x:" + str(self.get_x()) + " "
        r = r + "y:" + str(self.get_y()) + " "
        r = r + "size:" + str(self.get_size()) + " "
        r = r + "layer:" + str(self.get_layer()) + " "
        r = r + "font:" + str(self.get_font()) + " "
        r = r + "ratio:" + str(self.get_ratio()) + " "
        r = r + "rot:" + str(self.get_rot()) + " "
        r = r + "display:" + str(self.get_display()) + " "
        r = r + "align:" + str(self.get_align()) + " "
        r = r + "constant:" + str(self.get_constant()) + " "
        r = r + "]"
        return r
            
    def dump(self, indent="", increment="   "):
        """
        Recursive debug dump.
        
        :param indent:  Indentation string.  The output will be indented by this much.
        :param increment: This will be appendeded to :code:`indent` on recursive invocations.

        :rtype: :code:`None`
        """
        print(indent + str(self.__class__.__name__), end=' ')
        try:
            print(self.get_name())
        except:
            print()
            pass
        for c in self.get_children():
            c.dump(indent + "   ")

        
EagleFile.class_map["attribute"] = Base_Attribute
         


class Gate(EagleFilePart, OnePointGeometry):
    """
    Class representing the contents of a <gate> tag in Eagle files.

    Attributes:

    * :code:`name`

    * :code:`symbol`

    * :code:`x`

    * :code:`y`

    * :code:`addlevel`

    * :code:`swaplevel`


    """
    def __init__(self):
        """
        Construct an empty :class:`Gate` object.
        """
        EagleFilePart.__init__(self)
        OnePointGeometry.__init__(self)
        
        self.name=None
        self.symbol=None
        self.x=None
        self.y=None
        self.addlevel=None
        self.swaplevel=None


        
    @classmethod
    def _from_et(cls,root,parent):
        """
        Create a :class:`Gate` from a :code:`gate` element.
        
        :param root: The element tree tree to parse.
        :param parent: :class:`EagleFilePart` that should hold the resulting :class:`EagleFilePart`
        :rtype: :class:`Gate`
        """
        ## Call the constructor
        n = cls()
        n._init_from_et(root,parent)
        return n

    def _get_error_name(self):
        if hasattr(self, "get_name"):
            return self.get_name();
        else:
            return "Gate";
        
    def  _init_from_et(self, root, parent):
        """
        Initialized a :class:`Gate` from a :code:`gate` element.  This is useful if you have a subclass of :class:`Gate` .
        
        :param root: The element tree tree to parse.
        :param parent: :class:`EagleFilePart` that will become the parent of :code:`this` .
        :rtype: :class:`Gate`
        """
        try:
            self.root = root
            
            if root.tag != "gate":
                raise EagleFormatError("Tried to create gate from " + root.tag)

            self.name=parseByType(parent, "str", None, root.get("name"))
            self.symbol=parseByType(parent, "str", None, root.get("symbol"))
            self.x=parseByType(parent, "float", None, root.get("x"))
            self.y=parseByType(parent, "float", None, root.get("y"))
            self.addlevel=parseByType(parent, "str", None, root.get("addlevel"))
            self.swaplevel=parseByType(parent, "int", None, root.get("swaplevel"))

            self.parent = parent

            ### populate the maps by searching for elements that match xpath and generating objects for them.


            ### Do the same for the lists


            ### Do the same for the attr lists


            ### And the singletons


            ### And, finally, if the objects wants the text from the tag.

        except SwoopError as e:
            e.text = "{}:{}".format(self._get_error_name(), e.text)
            raise e


    def sortkey(self):
        r = ""
        r = r + str(self.name)
        r = r + str(self.symbol)
        r = r + str(self.x)
        r = r + str(self.y)
        r = r + str(self.addlevel)
        r = r + str(self.swaplevel)
        return r

    def get_et(self):
        """
        Generate a <gate> element tree for a :class:`Gate`.
        
        :rtype:  :class:`ElementTree`.
        
        """
        try:
            r = ET.Element("gate")

            ### Set the tag attributes 


            ## Unparse the values.

            v = unparseByType(self, "str", None,  self.name)

            ## For required attributes None becomes "".  For optional attributes, we just leave the attribute out.
            if not (isinstance(self.get_parent(), LibraryFile) and False):  # special case for the name of library.
                if v is not None:
                    r.set("name", v)
                else:
                    r.set("name", "")


            ## Unparse the values.

            v = unparseByType(self, "str", None,  self.symbol)

            ## For required attributes None becomes "".  For optional attributes, we just leave the attribute out.
            if not (isinstance(self.get_parent(), LibraryFile) and False):  # special case for the name of library.
                if v is not None:
                    r.set("symbol", v)
                else:
                    r.set("symbol", "")


            ## Unparse the values.

            v = unparseByType(self, "float", None,  self.x)

            ## For required attributes None becomes "".  For optional attributes, we just leave the attribute out.
            if not (isinstance(self.get_parent(), LibraryFile) and False):  # special case for the name of library.
                if v is not None:
                    r.set("x", v)
                else:
                    r.set("x", "")


            ## Unparse the values.

            v = unparseByType(self, "float", None,  self.y)

            ## For required attributes None becomes "".  For optional attributes, we just leave the attribute out.
            if not (isinstance(self.get_parent(), LibraryFile) and False):  # special case for the name of library.
                if v is not None:
                    r.set("y", v)
                else:
                    r.set("y", "")


            ## Unparse the values.

            v = unparseByType(self, "str", None,  self.addlevel)

            ## For required attributes None becomes "".  For optional attributes, we just leave the attribute out.
            if not (isinstance(self.get_parent(), LibraryFile) and False):  # special case for the name of library.
                if v is not None:
                    r.set("addlevel", v)


            ## Unparse the values.

            v = unparseByType(self, "int", None,  self.swaplevel)

            ## For required attributes None becomes "".  For optional attributes, we just leave the attribute out.
            if not (isinstance(self.get_parent(), LibraryFile) and False):  # special case for the name of library.
                if v is not None:
                    r.set("swaplevel", v)


            ### process the sections in order.  They have to be in section order,
            ### because eagle files are order dependent.


            ## set the text, if its needed.

        except SwoopError as e:
            e.text = "{}:{}".format(self._get_error_name(), e.text)
            raise e
        return r

    def clone(self):
        """
        Recursively clone this :code:`Gate`.  It will be identical to the original, but it's parent will be :code:`None`.
        
        :rtype: :class:`Gate`
        """
        try:
            n = copy.copy(self)
            n.parent = None
        except SwoopError as e:
            e.text = "{}:{}".format(self._get_error_name(), e.text)
            raise e
        return n

    def accept_preorder_visitor(self, visitor):
        try:
            pre = getattr(visitor, "Gate_pre")
            return pre(self)
        except AttributeError:
            return visitor.default_pre(self)
        
    def accept_postorder_visitor(self, visitor, context):
        try:
            post = getattr(visitor, "Gate_post")
            post(self,context)
        except AttributeError:
            visitor.default_post(self,context)

    def is_equal(self, other):
        """
        Check whether two :code:`EagleFilePart` objects are identical.
        
        :param other: Object to compare to.
        :returns: :code:`True` if they are identical, otherwise, :code:`False`
        """
        return self.get_xml() == other.get_xml()
        
    ### Getters/Setters for attribute values

    def get_name(self):
        """ Return the value of :code:`name` for this :class:`Gate`.  This corresponds to the :code:`name` attribute of a :code:`<gate>` in an Eagle file.
        
        :rtype: :code:`str`
        """
        return self.name

    def set_name(self,v):
        """ Set the value of :code:`name` for this  :class:`Gate`.  This corresponds to the :code:`name` attribute of a :code:`<gate>` in an Eagle file.

        :param v: new value
        :rtype: :code:`self`
        """
                        
        oldkey = self.name
        if not typeCheck("str", v, True):
            raise SwoopError("Illegal value ({}) of type {} for attribute 'name' of Gate object (should be str).".format(v, type(v)))
        self.name = v
        
        if self.get_parent() is not None:
            self.get_parent()._rekey_child(oldkey, self);
        return self

    def with_name(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`name`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`name` equals :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_name()` is :code:`True`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """

        if type(v) in [str, int, float, bool]:
            return self if self.name == v else None
        elif callable(v):
            return self if v(self.name) else None
        else:
            raise SwoopError("Illegal type passed to with_name")

    def without_name(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`name`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`name` is not equal to :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_name()` is :code:`False`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """
        
        if type(v) in [str, int, float, bool]:
            return self if self.name != v else None
        elif callable(v):
            return self if not v(self.name) else None
        else:
            raise SwoopError("Illegal type passed to without_name")


    def get_symbol(self):
        """ Return the value of :code:`symbol` for this :class:`Gate`.  This corresponds to the :code:`symbol` attribute of a :code:`<gate>` in an Eagle file.
        
        :rtype: :code:`str`
        """
        return self.symbol

    def set_symbol(self,v):
        """ Set the value of :code:`symbol` for this  :class:`Gate`.  This corresponds to the :code:`symbol` attribute of a :code:`<gate>` in an Eagle file.

        :param v: new value
        :rtype: :code:`self`
        """
                        
        if not typeCheck("str", v, True):
            raise SwoopError("Illegal value ({}) of type {} for attribute 'symbol' of Gate object (should be str).".format(v, type(v)))
        self.symbol = v
        
        return self

    def with_symbol(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`symbol`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`symbol` equals :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_symbol()` is :code:`True`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """

        if type(v) in [str, int, float, bool]:
            return self if self.symbol == v else None
        elif callable(v):
            return self if v(self.symbol) else None
        else:
            raise SwoopError("Illegal type passed to with_symbol")

    def without_symbol(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`symbol`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`symbol` is not equal to :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_symbol()` is :code:`False`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """
        
        if type(v) in [str, int, float, bool]:
            return self if self.symbol != v else None
        elif callable(v):
            return self if not v(self.symbol) else None
        else:
            raise SwoopError("Illegal type passed to without_symbol")


    def get_x(self):
        """ Return the value of :code:`x` for this :class:`Gate`.  This corresponds to the :code:`x` attribute of a :code:`<gate>` in an Eagle file.
        
        :rtype: :code:`float`
        """
        return self.x

    def set_x(self,v):
        """ Set the value of :code:`x` for this  :class:`Gate`.  This corresponds to the :code:`x` attribute of a :code:`<gate>` in an Eagle file.

        :param v: new value
        :rtype: :code:`self`
        """
                        
        if not typeCheck("float", v, True):
            raise SwoopError("Illegal value ({}) of type {} for attribute 'x' of Gate object (should be float).".format(v, type(v)))
        self.x = v
        
        return self

    def with_x(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`x`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`x` equals :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_x()` is :code:`True`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """

        if type(v) in [str, int, float, bool]:
            return self if self.x == v else None
        elif callable(v):
            return self if v(self.x) else None
        else:
            raise SwoopError("Illegal type passed to with_x")

    def without_x(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`x`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`x` is not equal to :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_x()` is :code:`False`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """
        
        if type(v) in [str, int, float, bool]:
            return self if self.x != v else None
        elif callable(v):
            return self if not v(self.x) else None
        else:
            raise SwoopError("Illegal type passed to without_x")


    def get_y(self):
        """ Return the value of :code:`y` for this :class:`Gate`.  This corresponds to the :code:`y` attribute of a :code:`<gate>` in an Eagle file.
        
        :rtype: :code:`float`
        """
        return self.y

    def set_y(self,v):
        """ Set the value of :code:`y` for this  :class:`Gate`.  This corresponds to the :code:`y` attribute of a :code:`<gate>` in an Eagle file.

        :param v: new value
        :rtype: :code:`self`
        """
                        
        if not typeCheck("float", v, True):
            raise SwoopError("Illegal value ({}) of type {} for attribute 'y' of Gate object (should be float).".format(v, type(v)))
        self.y = v
        
        return self

    def with_y(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`y`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`y` equals :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_y()` is :code:`True`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """

        if type(v) in [str, int, float, bool]:
            return self if self.y == v else None
        elif callable(v):
            return self if v(self.y) else None
        else:
            raise SwoopError("Illegal type passed to with_y")

    def without_y(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`y`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`y` is not equal to :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_y()` is :code:`False`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """
        
        if type(v) in [str, int, float, bool]:
            return self if self.y != v else None
        elif callable(v):
            return self if not v(self.y) else None
        else:
            raise SwoopError("Illegal type passed to without_y")


    def get_addlevel(self):
        """ Return the value of :code:`addlevel` for this :class:`Gate`.  This corresponds to the :code:`addlevel` attribute of a :code:`<gate>` in an Eagle file.
        
        :rtype: :code:`str`
        """
        return self.addlevel

    def set_addlevel(self,v):
        """ Set the value of :code:`addlevel` for this  :class:`Gate`.  This corresponds to the :code:`addlevel` attribute of a :code:`<gate>` in an Eagle file.

        :param v: new value
        :rtype: :code:`self`
        """
                        
        if not typeCheck("str", v, False):
            raise SwoopError("Illegal value ({}) of type {} for attribute 'addlevel' of Gate object (should be str).".format(v, type(v)))
        self.addlevel = v
        
        return self

    def with_addlevel(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`addlevel`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`addlevel` equals :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_addlevel()` is :code:`True`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """

        if type(v) in [str, int, float, bool]:
            return self if self.addlevel == v else None
        elif callable(v):
            return self if v(self.addlevel) else None
        else:
            raise SwoopError("Illegal type passed to with_addlevel")

    def without_addlevel(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`addlevel`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`addlevel` is not equal to :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_addlevel()` is :code:`False`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """
        
        if type(v) in [str, int, float, bool]:
            return self if self.addlevel != v else None
        elif callable(v):
            return self if not v(self.addlevel) else None
        else:
            raise SwoopError("Illegal type passed to without_addlevel")


    def get_swaplevel(self):
        """ Return the value of :code:`swaplevel` for this :class:`Gate`.  This corresponds to the :code:`swaplevel` attribute of a :code:`<gate>` in an Eagle file.
        
        :rtype: :code:`int`
        """
        return self.swaplevel

    def set_swaplevel(self,v):
        """ Set the value of :code:`swaplevel` for this  :class:`Gate`.  This corresponds to the :code:`swaplevel` attribute of a :code:`<gate>` in an Eagle file.

        :param v: new value
        :rtype: :code:`self`
        """
                        
        if not typeCheck("int", v, False):
            raise SwoopError("Illegal value ({}) of type {} for attribute 'swaplevel' of Gate object (should be int).".format(v, type(v)))
        self.swaplevel = v
        
        return self

    def with_swaplevel(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`swaplevel`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`swaplevel` equals :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_swaplevel()` is :code:`True`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """

        if type(v) in [str, int, float, bool]:
            return self if self.swaplevel == v else None
        elif callable(v):
            return self if v(self.swaplevel) else None
        else:
            raise SwoopError("Illegal type passed to with_swaplevel")

    def without_swaplevel(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`swaplevel`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`swaplevel` is not equal to :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_swaplevel()` is :code:`False`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """
        
        if type(v) in [str, int, float, bool]:
            return self if self.swaplevel != v else None
        elif callable(v):
            return self if not v(self.swaplevel) else None
        else:
            raise SwoopError("Illegal type passed to without_swaplevel")



    ##### Lookup functions that return EFPs instead of just attribute values.
    
    def find_symbol(self):
        """Find the :class:`Symbol` object refered to by the :code:`symbol` attribute of this object.  This is like
        :meth:`get_symbol`, except it returns the :class:`Symbol` object instead of its name.
        
        :returns: The object
        :rtype: :class:`Symbol`

        """
        f = lambda efp, key: efp.get_parent().get_parent().get_symbol(key)
        return f(self, self.symbol)
    


    
    ### Adder/getter/lookup for lists
    


    ### Add, lookup, and get for maps


    
    ### Getter/Setter for singletons.


    
    def get_children(self):
        """
        Get all the children of this :class:`EagleFilePart`.
        
        :rtype: List of :class:`EagleFilePart` objects
        """
        r = []




        return r

    def remove_child(self, efp):
        """
        Remove a child :class:`EagleFilePart` object.
        
        :param efp: the class:`EagleFilePart` object to remove.
        :return: Nothing
        """

    def _rekey_child(self, oldkey, efp):
        """
        Remove a child :class:`EagleFilePart` object.
        
        :param efp: the class:`EagleFilePart` object to remove.
        :return: Nothing
        """


    def __str__(self):
        r = "["+repr(self)+" "
        r = r + "name:" + str(self.get_name()) + " "
        r = r + "symbol:" + str(self.get_symbol()) + " "
        r = r + "x:" + str(self.get_x()) + " "
        r = r + "y:" + str(self.get_y()) + " "
        r = r + "addlevel:" + str(self.get_addlevel()) + " "
        r = r + "swaplevel:" + str(self.get_swaplevel()) + " "
        r = r + "]"
        return r
            
    def dump(self, indent="", increment="   "):
        """
        Recursive debug dump.
        
        :param indent:  Indentation string.  The output will be indented by this much.
        :param increment: This will be appendeded to :code:`indent` on recursive invocations.

        :rtype: :code:`None`
        """
        print(indent + str(self.__class__.__name__), end=' ')
        try:
            print(self.get_name())
        except:
            print()
            pass
        for c in self.get_children():
            c.dump(indent + "   ")

        
EagleFile.class_map["gate"] = Gate
         


class Circle(EagleFilePart, OnePointGeometry, CircleRadiusGeometry):
    """
    Class representing the contents of a <circle> tag in Eagle files.

    Attributes:

    * :code:`x`

    * :code:`y`

    * :code:`radius`

    * :code:`width`

    * :code:`layer`


    """
    def __init__(self):
        """
        Construct an empty :class:`Circle` object.
        """
        EagleFilePart.__init__(self)
        OnePointGeometry.__init__(self)
        CircleRadiusGeometry.__init__(self)
        
        self.x=None
        self.y=None
        self.radius=None
        self.width=None
        self.layer=None


        
    @classmethod
    def _from_et(cls,root,parent):
        """
        Create a :class:`Circle` from a :code:`circle` element.
        
        :param root: The element tree tree to parse.
        :param parent: :class:`EagleFilePart` that should hold the resulting :class:`EagleFilePart`
        :rtype: :class:`Circle`
        """
        ## Call the constructor
        n = cls()
        n._init_from_et(root,parent)
        return n

    def _get_error_name(self):
        if hasattr(self, "get_name"):
            return self.get_name();
        else:
            return "Circle";
        
    def  _init_from_et(self, root, parent):
        """
        Initialized a :class:`Circle` from a :code:`circle` element.  This is useful if you have a subclass of :class:`Circle` .
        
        :param root: The element tree tree to parse.
        :param parent: :class:`EagleFilePart` that will become the parent of :code:`this` .
        :rtype: :class:`Circle`
        """
        try:
            self.root = root
            
            if root.tag != "circle":
                raise EagleFormatError("Tried to create circle from " + root.tag)

            self.x=parseByType(parent, "float", None, root.get("x"))
            self.y=parseByType(parent, "float", None, root.get("y"))
            self.radius=parseByType(parent, "float", None, root.get("radius"))
            self.width=parseByType(parent, "float", None, root.get("width"))
            self.layer=parseByType(parent, "layer_string", None, root.get("layer"))

            self.parent = parent

            ### populate the maps by searching for elements that match xpath and generating objects for them.


            ### Do the same for the lists


            ### Do the same for the attr lists


            ### And the singletons


            ### And, finally, if the objects wants the text from the tag.

        except SwoopError as e:
            e.text = "{}:{}".format(self._get_error_name(), e.text)
            raise e


    def sortkey(self):
        r = ""
        r = r + str(self.x)
        r = r + str(self.y)
        r = r + str(self.radius)
        r = r + str(self.width)
        r = r + str(self.layer)
        return r

    def get_et(self):
        """
        Generate a <circle> element tree for a :class:`Circle`.
        
        :rtype:  :class:`ElementTree`.
        
        """
        try:
            r = ET.Element("circle")

            ### Set the tag attributes 


            ## Unparse the values.

            v = unparseByType(self, "float", None,  self.x)

            ## For required attributes None becomes "".  For optional attributes, we just leave the attribute out.
            if not (isinstance(self.get_parent(), LibraryFile) and False):  # special case for the name of library.
                if v is not None:
                    r.set("x", v)
                else:
                    r.set("x", "")


            ## Unparse the values.

            v = unparseByType(self, "float", None,  self.y)

            ## For required attributes None becomes "".  For optional attributes, we just leave the attribute out.
            if not (isinstance(self.get_parent(), LibraryFile) and False):  # special case for the name of library.
                if v is not None:
                    r.set("y", v)
                else:
                    r.set("y", "")


            ## Unparse the values.

            v = unparseByType(self, "float", None,  self.radius)

            ## For required attributes None becomes "".  For optional attributes, we just leave the attribute out.
            if not (isinstance(self.get_parent(), LibraryFile) and False):  # special case for the name of library.
                if v is not None:
                    r.set("radius", v)
                else:
                    r.set("radius", "")


            ## Unparse the values.

            v = unparseByType(self, "float", None,  self.width)

            ## For required attributes None becomes "".  For optional attributes, we just leave the attribute out.
            if not (isinstance(self.get_parent(), LibraryFile) and False):  # special case for the name of library.
                if v is not None:
                    r.set("width", v)
                else:
                    r.set("width", "")


            ## Unparse the values.

            v = unparseByType(self, "layer_string", None,  self.layer)

            ## For required attributes None becomes "".  For optional attributes, we just leave the attribute out.
            if not (isinstance(self.get_parent(), LibraryFile) and False):  # special case for the name of library.
                if v is not None:
                    r.set("layer", v)
                else:
                    r.set("layer", "")


            ### process the sections in order.  They have to be in section order,
            ### because eagle files are order dependent.


            ## set the text, if its needed.

        except SwoopError as e:
            e.text = "{}:{}".format(self._get_error_name(), e.text)
            raise e
        return r

    def clone(self):
        """
        Recursively clone this :code:`Circle`.  It will be identical to the original, but it's parent will be :code:`None`.
        
        :rtype: :class:`Circle`
        """
        try:
            n = copy.copy(self)
            n.parent = None
        except SwoopError as e:
            e.text = "{}:{}".format(self._get_error_name(), e.text)
            raise e
        return n

    def accept_preorder_visitor(self, visitor):
        try:
            pre = getattr(visitor, "Circle_pre")
            return pre(self)
        except AttributeError:
            return visitor.default_pre(self)
        
    def accept_postorder_visitor(self, visitor, context):
        try:
            post = getattr(visitor, "Circle_post")
            post(self,context)
        except AttributeError:
            visitor.default_post(self,context)

    def is_equal(self, other):
        """
        Check whether two :code:`EagleFilePart` objects are identical.
        
        :param other: Object to compare to.
        :returns: :code:`True` if they are identical, otherwise, :code:`False`
        """
        return self.get_xml() == other.get_xml()
        
    ### Getters/Setters for attribute values

    def get_x(self):
        """ Return the value of :code:`x` for this :class:`Circle`.  This corresponds to the :code:`x` attribute of a :code:`<circle>` in an Eagle file.
        
        :rtype: :code:`float`
        """
        return self.x

    def set_x(self,v):
        """ Set the value of :code:`x` for this  :class:`Circle`.  This corresponds to the :code:`x` attribute of a :code:`<circle>` in an Eagle file.

        :param v: new value
        :rtype: :code:`self`
        """
                        
        if not typeCheck("float", v, True):
            raise SwoopError("Illegal value ({}) of type {} for attribute 'x' of Circle object (should be float).".format(v, type(v)))
        self.x = v
        
        return self

    def with_x(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`x`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`x` equals :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_x()` is :code:`True`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """

        if type(v) in [str, int, float, bool]:
            return self if self.x == v else None
        elif callable(v):
            return self if v(self.x) else None
        else:
            raise SwoopError("Illegal type passed to with_x")

    def without_x(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`x`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`x` is not equal to :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_x()` is :code:`False`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """
        
        if type(v) in [str, int, float, bool]:
            return self if self.x != v else None
        elif callable(v):
            return self if not v(self.x) else None
        else:
            raise SwoopError("Illegal type passed to without_x")


    def get_y(self):
        """ Return the value of :code:`y` for this :class:`Circle`.  This corresponds to the :code:`y` attribute of a :code:`<circle>` in an Eagle file.
        
        :rtype: :code:`float`
        """
        return self.y

    def set_y(self,v):
        """ Set the value of :code:`y` for this  :class:`Circle`.  This corresponds to the :code:`y` attribute of a :code:`<circle>` in an Eagle file.

        :param v: new value
        :rtype: :code:`self`
        """
                        
        if not typeCheck("float", v, True):
            raise SwoopError("Illegal value ({}) of type {} for attribute 'y' of Circle object (should be float).".format(v, type(v)))
        self.y = v
        
        return self

    def with_y(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`y`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`y` equals :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_y()` is :code:`True`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """

        if type(v) in [str, int, float, bool]:
            return self if self.y == v else None
        elif callable(v):
            return self if v(self.y) else None
        else:
            raise SwoopError("Illegal type passed to with_y")

    def without_y(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`y`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`y` is not equal to :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_y()` is :code:`False`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """
        
        if type(v) in [str, int, float, bool]:
            return self if self.y != v else None
        elif callable(v):
            return self if not v(self.y) else None
        else:
            raise SwoopError("Illegal type passed to without_y")


    def get_radius(self):
        """ Return the value of :code:`radius` for this :class:`Circle`.  This corresponds to the :code:`radius` attribute of a :code:`<circle>` in an Eagle file.
        
        :rtype: :code:`float`
        """
        return self.radius

    def set_radius(self,v):
        """ Set the value of :code:`radius` for this  :class:`Circle`.  This corresponds to the :code:`radius` attribute of a :code:`<circle>` in an Eagle file.

        :param v: new value
        :rtype: :code:`self`
        """
                        
        if not typeCheck("float", v, True):
            raise SwoopError("Illegal value ({}) of type {} for attribute 'radius' of Circle object (should be float).".format(v, type(v)))
        self.radius = v
        
        return self

    def with_radius(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`radius`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`radius` equals :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_radius()` is :code:`True`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """

        if type(v) in [str, int, float, bool]:
            return self if self.radius == v else None
        elif callable(v):
            return self if v(self.radius) else None
        else:
            raise SwoopError("Illegal type passed to with_radius")

    def without_radius(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`radius`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`radius` is not equal to :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_radius()` is :code:`False`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """
        
        if type(v) in [str, int, float, bool]:
            return self if self.radius != v else None
        elif callable(v):
            return self if not v(self.radius) else None
        else:
            raise SwoopError("Illegal type passed to without_radius")


    def get_width(self):
        """ Return the value of :code:`width` for this :class:`Circle`.  This corresponds to the :code:`width` attribute of a :code:`<circle>` in an Eagle file.
        
        :rtype: :code:`float`
        """
        return self.width

    def set_width(self,v):
        """ Set the value of :code:`width` for this  :class:`Circle`.  This corresponds to the :code:`width` attribute of a :code:`<circle>` in an Eagle file.

        :param v: new value
        :rtype: :code:`self`
        """
                        
        if not typeCheck("float", v, True):
            raise SwoopError("Illegal value ({}) of type {} for attribute 'width' of Circle object (should be float).".format(v, type(v)))
        self.width = v
        
        return self

    def with_width(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`width`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`width` equals :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_width()` is :code:`True`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """

        if type(v) in [str, int, float, bool]:
            return self if self.width == v else None
        elif callable(v):
            return self if v(self.width) else None
        else:
            raise SwoopError("Illegal type passed to with_width")

    def without_width(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`width`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`width` is not equal to :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_width()` is :code:`False`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """
        
        if type(v) in [str, int, float, bool]:
            return self if self.width != v else None
        elif callable(v):
            return self if not v(self.width) else None
        else:
            raise SwoopError("Illegal type passed to without_width")


    def get_layer(self):
        """ Return the value of :code:`layer` for this :class:`Circle`.  This corresponds to the :code:`layer` attribute of a :code:`<circle>` in an Eagle file.
        
        :rtype: :code:`layer_string`
        """
        return self.layer

    def set_layer(self,v):
        """ Set the value of :code:`layer` for this  :class:`Circle`.  This corresponds to the :code:`layer` attribute of a :code:`<circle>` in an Eagle file.

        :param v: new value
        :rtype: :code:`self`
        """
                        
        if not typeCheck("layer_string", v, True):
            raise SwoopError("Illegal value ({}) of type {} for attribute 'layer' of Circle object (should be layer_string).".format(v, type(v)))
        self.layer = v
        
        return self

    def with_layer(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`layer`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`layer` equals :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_layer()` is :code:`True`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """

        if type(v) in [str, int, float, bool]:
            return self if self.layer == v else None
        elif callable(v):
            return self if v(self.layer) else None
        else:
            raise SwoopError("Illegal type passed to with_layer")

    def without_layer(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`layer`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`layer` is not equal to :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_layer()` is :code:`False`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """
        
        if type(v) in [str, int, float, bool]:
            return self if self.layer != v else None
        elif callable(v):
            return self if not v(self.layer) else None
        else:
            raise SwoopError("Illegal type passed to without_layer")



    ##### Lookup functions that return EFPs instead of just attribute values.
    
    


    
    ### Adder/getter/lookup for lists
    


    ### Add, lookup, and get for maps


    
    ### Getter/Setter for singletons.


    
    def get_children(self):
        """
        Get all the children of this :class:`EagleFilePart`.
        
        :rtype: List of :class:`EagleFilePart` objects
        """
        r = []




        return r

    def remove_child(self, efp):
        """
        Remove a child :class:`EagleFilePart` object.
        
        :param efp: the class:`EagleFilePart` object to remove.
        :return: Nothing
        """

    def _rekey_child(self, oldkey, efp):
        """
        Remove a child :class:`EagleFilePart` object.
        
        :param efp: the class:`EagleFilePart` object to remove.
        :return: Nothing
        """


    def __str__(self):
        r = "["+repr(self)+" "
        r = r + "x:" + str(self.get_x()) + " "
        r = r + "y:" + str(self.get_y()) + " "
        r = r + "radius:" + str(self.get_radius()) + " "
        r = r + "width:" + str(self.get_width()) + " "
        r = r + "layer:" + str(self.get_layer()) + " "
        r = r + "]"
        return r
            
    def dump(self, indent="", increment="   "):
        """
        Recursive debug dump.
        
        :param indent:  Indentation string.  The output will be indented by this much.
        :param increment: This will be appendeded to :code:`indent` on recursive invocations.

        :rtype: :code:`None`
        """
        print(indent + str(self.__class__.__name__), end=' ')
        try:
            print(self.get_name())
        except:
            print()
            pass
        for c in self.get_children():
            c.dump(indent + "   ")

        
EagleFile.class_map["circle"] = Circle
         


class Smd(EagleFilePart, OnePointGeometry, DimensionGeometry, RotationGeometry):
    """
    Class representing the contents of a <smd> tag in Eagle files.

    Attributes:

    * :code:`name`

    * :code:`x`

    * :code:`y`

    * :code:`dx`

    * :code:`dy`

    * :code:`layer`

    * :code:`roundness`

    * :code:`rot`

    * :code:`stop`

    * :code:`thermals`

    * :code:`cream`


    """
    def __init__(self):
        """
        Construct an empty :class:`Smd` object.
        """
        EagleFilePart.__init__(self)
        OnePointGeometry.__init__(self)
        DimensionGeometry.__init__(self)
        RotationGeometry.__init__(self)
        
        self.name=None
        self.x=None
        self.y=None
        self.dx=None
        self.dy=None
        self.layer=None
        self.roundness=None
        self.rot=None
        self.stop=None
        self.thermals=None
        self.cream=None


        
    @classmethod
    def _from_et(cls,root,parent):
        """
        Create a :class:`Smd` from a :code:`smd` element.
        
        :param root: The element tree tree to parse.
        :param parent: :class:`EagleFilePart` that should hold the resulting :class:`EagleFilePart`
        :rtype: :class:`Smd`
        """
        ## Call the constructor
        n = cls()
        n._init_from_et(root,parent)
        return n

    def _get_error_name(self):
        if hasattr(self, "get_name"):
            return self.get_name();
        else:
            return "Smd";
        
    def  _init_from_et(self, root, parent):
        """
        Initialized a :class:`Smd` from a :code:`smd` element.  This is useful if you have a subclass of :class:`Smd` .
        
        :param root: The element tree tree to parse.
        :param parent: :class:`EagleFilePart` that will become the parent of :code:`this` .
        :rtype: :class:`Smd`
        """
        try:
            self.root = root
            
            if root.tag != "smd":
                raise EagleFormatError("Tried to create smd from " + root.tag)

            self.name=parseByType(parent, "str", None, root.get("name"))
            self.x=parseByType(parent, "float", None, root.get("x"))
            self.y=parseByType(parent, "float", None, root.get("y"))
            self.dx=parseByType(parent, "float", None, root.get("dx"))
            self.dy=parseByType(parent, "float", None, root.get("dy"))
            self.layer=parseByType(parent, "layer_string", None, root.get("layer"))
            self.roundness=parseByType(parent, "int", None, root.get("roundness"))
            self.rot=parseByType(parent, "str", None, root.get("rot"))
            self.stop=parseByType(parent, "constant_bool", None, root.get("stop"))
            self.thermals=parseByType(parent, "constant_bool", None, root.get("thermals"))
            self.cream=parseByType(parent, "constant_bool", None, root.get("cream"))

            self.parent = parent

            ### populate the maps by searching for elements that match xpath and generating objects for them.


            ### Do the same for the lists


            ### Do the same for the attr lists


            ### And the singletons


            ### And, finally, if the objects wants the text from the tag.

        except SwoopError as e:
            e.text = "{}:{}".format(self._get_error_name(), e.text)
            raise e


    def sortkey(self):
        r = ""
        r = r + str(self.name)
        r = r + str(self.x)
        r = r + str(self.y)
        r = r + str(self.dx)
        r = r + str(self.dy)
        r = r + str(self.layer)
        r = r + str(self.roundness)
        r = r + str(self.rot)
        r = r + str(self.stop)
        r = r + str(self.thermals)
        r = r + str(self.cream)
        return r

    def get_et(self):
        """
        Generate a <smd> element tree for a :class:`Smd`.
        
        :rtype:  :class:`ElementTree`.
        
        """
        try:
            r = ET.Element("smd")

            ### Set the tag attributes 


            ## Unparse the values.

            v = unparseByType(self, "str", None,  self.name)

            ## For required attributes None becomes "".  For optional attributes, we just leave the attribute out.
            if not (isinstance(self.get_parent(), LibraryFile) and False):  # special case for the name of library.
                if v is not None:
                    r.set("name", v)
                else:
                    r.set("name", "")


            ## Unparse the values.

            v = unparseByType(self, "float", None,  self.x)

            ## For required attributes None becomes "".  For optional attributes, we just leave the attribute out.
            if not (isinstance(self.get_parent(), LibraryFile) and False):  # special case for the name of library.
                if v is not None:
                    r.set("x", v)
                else:
                    r.set("x", "")


            ## Unparse the values.

            v = unparseByType(self, "float", None,  self.y)

            ## For required attributes None becomes "".  For optional attributes, we just leave the attribute out.
            if not (isinstance(self.get_parent(), LibraryFile) and False):  # special case for the name of library.
                if v is not None:
                    r.set("y", v)
                else:
                    r.set("y", "")


            ## Unparse the values.

            v = unparseByType(self, "float", None,  self.dx)

            ## For required attributes None becomes "".  For optional attributes, we just leave the attribute out.
            if not (isinstance(self.get_parent(), LibraryFile) and False):  # special case for the name of library.
                if v is not None:
                    r.set("dx", v)
                else:
                    r.set("dx", "")


            ## Unparse the values.

            v = unparseByType(self, "float", None,  self.dy)

            ## For required attributes None becomes "".  For optional attributes, we just leave the attribute out.
            if not (isinstance(self.get_parent(), LibraryFile) and False):  # special case for the name of library.
                if v is not None:
                    r.set("dy", v)
                else:
                    r.set("dy", "")


            ## Unparse the values.

            v = unparseByType(self, "layer_string", None,  self.layer)

            ## For required attributes None becomes "".  For optional attributes, we just leave the attribute out.
            if not (isinstance(self.get_parent(), LibraryFile) and False):  # special case for the name of library.
                if v is not None:
                    r.set("layer", v)
                else:
                    r.set("layer", "")


            ## Unparse the values.

            v = unparseByType(self, "int", None,  self.roundness)

            ## For required attributes None becomes "".  For optional attributes, we just leave the attribute out.
            if not (isinstance(self.get_parent(), LibraryFile) and False):  # special case for the name of library.
                if v is not None:
                    r.set("roundness", v)


            ## Unparse the values.

            v = unparseByType(self, "str", None,  self.rot)

            ## For required attributes None becomes "".  For optional attributes, we just leave the attribute out.
            if not (isinstance(self.get_parent(), LibraryFile) and False):  # special case for the name of library.
                if v is not None:
                    r.set("rot", v)


            ## Unparse the values.

            v = unparseByType(self, "constant_bool", None,  self.stop)

            ## For required attributes None becomes "".  For optional attributes, we just leave the attribute out.
            if not (isinstance(self.get_parent(), LibraryFile) and False):  # special case for the name of library.
                if v is not None:
                    r.set("stop", v)


            ## Unparse the values.

            v = unparseByType(self, "constant_bool", None,  self.thermals)

            ## For required attributes None becomes "".  For optional attributes, we just leave the attribute out.
            if not (isinstance(self.get_parent(), LibraryFile) and False):  # special case for the name of library.
                if v is not None:
                    r.set("thermals", v)


            ## Unparse the values.

            v = unparseByType(self, "constant_bool", None,  self.cream)

            ## For required attributes None becomes "".  For optional attributes, we just leave the attribute out.
            if not (isinstance(self.get_parent(), LibraryFile) and False):  # special case for the name of library.
                if v is not None:
                    r.set("cream", v)


            ### process the sections in order.  They have to be in section order,
            ### because eagle files are order dependent.


            ## set the text, if its needed.

        except SwoopError as e:
            e.text = "{}:{}".format(self._get_error_name(), e.text)
            raise e
        return r

    def clone(self):
        """
        Recursively clone this :code:`Smd`.  It will be identical to the original, but it's parent will be :code:`None`.
        
        :rtype: :class:`Smd`
        """
        try:
            n = copy.copy(self)
            n.parent = None
        except SwoopError as e:
            e.text = "{}:{}".format(self._get_error_name(), e.text)
            raise e
        return n

    def accept_preorder_visitor(self, visitor):
        try:
            pre = getattr(visitor, "Smd_pre")
            return pre(self)
        except AttributeError:
            return visitor.default_pre(self)
        
    def accept_postorder_visitor(self, visitor, context):
        try:
            post = getattr(visitor, "Smd_post")
            post(self,context)
        except AttributeError:
            visitor.default_post(self,context)

    def is_equal(self, other):
        """
        Check whether two :code:`EagleFilePart` objects are identical.
        
        :param other: Object to compare to.
        :returns: :code:`True` if they are identical, otherwise, :code:`False`
        """
        return self.get_xml() == other.get_xml()
        
    ### Getters/Setters for attribute values

    def get_name(self):
        """ Return the value of :code:`name` for this :class:`Smd`.  This corresponds to the :code:`name` attribute of a :code:`<smd>` in an Eagle file.
        
        :rtype: :code:`str`
        """
        return self.name

    def set_name(self,v):
        """ Set the value of :code:`name` for this  :class:`Smd`.  This corresponds to the :code:`name` attribute of a :code:`<smd>` in an Eagle file.

        :param v: new value
        :rtype: :code:`self`
        """
                        
        oldkey = self.name
        if not typeCheck("str", v, True):
            raise SwoopError("Illegal value ({}) of type {} for attribute 'name' of Smd object (should be str).".format(v, type(v)))
        self.name = v
        
        if self.get_parent() is not None:
            self.get_parent()._rekey_child(oldkey, self);
        return self

    def with_name(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`name`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`name` equals :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_name()` is :code:`True`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """

        if type(v) in [str, int, float, bool]:
            return self if self.name == v else None
        elif callable(v):
            return self if v(self.name) else None
        else:
            raise SwoopError("Illegal type passed to with_name")

    def without_name(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`name`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`name` is not equal to :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_name()` is :code:`False`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """
        
        if type(v) in [str, int, float, bool]:
            return self if self.name != v else None
        elif callable(v):
            return self if not v(self.name) else None
        else:
            raise SwoopError("Illegal type passed to without_name")


    def get_x(self):
        """ Return the value of :code:`x` for this :class:`Smd`.  This corresponds to the :code:`x` attribute of a :code:`<smd>` in an Eagle file.
        
        :rtype: :code:`float`
        """
        return self.x

    def set_x(self,v):
        """ Set the value of :code:`x` for this  :class:`Smd`.  This corresponds to the :code:`x` attribute of a :code:`<smd>` in an Eagle file.

        :param v: new value
        :rtype: :code:`self`
        """
                        
        if not typeCheck("float", v, True):
            raise SwoopError("Illegal value ({}) of type {} for attribute 'x' of Smd object (should be float).".format(v, type(v)))
        self.x = v
        
        return self

    def with_x(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`x`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`x` equals :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_x()` is :code:`True`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """

        if type(v) in [str, int, float, bool]:
            return self if self.x == v else None
        elif callable(v):
            return self if v(self.x) else None
        else:
            raise SwoopError("Illegal type passed to with_x")

    def without_x(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`x`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`x` is not equal to :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_x()` is :code:`False`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """
        
        if type(v) in [str, int, float, bool]:
            return self if self.x != v else None
        elif callable(v):
            return self if not v(self.x) else None
        else:
            raise SwoopError("Illegal type passed to without_x")


    def get_y(self):
        """ Return the value of :code:`y` for this :class:`Smd`.  This corresponds to the :code:`y` attribute of a :code:`<smd>` in an Eagle file.
        
        :rtype: :code:`float`
        """
        return self.y

    def set_y(self,v):
        """ Set the value of :code:`y` for this  :class:`Smd`.  This corresponds to the :code:`y` attribute of a :code:`<smd>` in an Eagle file.

        :param v: new value
        :rtype: :code:`self`
        """
                        
        if not typeCheck("float", v, True):
            raise SwoopError("Illegal value ({}) of type {} for attribute 'y' of Smd object (should be float).".format(v, type(v)))
        self.y = v
        
        return self

    def with_y(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`y`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`y` equals :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_y()` is :code:`True`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """

        if type(v) in [str, int, float, bool]:
            return self if self.y == v else None
        elif callable(v):
            return self if v(self.y) else None
        else:
            raise SwoopError("Illegal type passed to with_y")

    def without_y(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`y`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`y` is not equal to :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_y()` is :code:`False`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """
        
        if type(v) in [str, int, float, bool]:
            return self if self.y != v else None
        elif callable(v):
            return self if not v(self.y) else None
        else:
            raise SwoopError("Illegal type passed to without_y")


    def get_dx(self):
        """ Return the value of :code:`dx` for this :class:`Smd`.  This corresponds to the :code:`dx` attribute of a :code:`<smd>` in an Eagle file.
        
        :rtype: :code:`float`
        """
        return self.dx

    def set_dx(self,v):
        """ Set the value of :code:`dx` for this  :class:`Smd`.  This corresponds to the :code:`dx` attribute of a :code:`<smd>` in an Eagle file.

        :param v: new value
        :rtype: :code:`self`
        """
                        
        if not typeCheck("float", v, True):
            raise SwoopError("Illegal value ({}) of type {} for attribute 'dx' of Smd object (should be float).".format(v, type(v)))
        self.dx = v
        
        return self

    def with_dx(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`dx`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`dx` equals :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_dx()` is :code:`True`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """

        if type(v) in [str, int, float, bool]:
            return self if self.dx == v else None
        elif callable(v):
            return self if v(self.dx) else None
        else:
            raise SwoopError("Illegal type passed to with_dx")

    def without_dx(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`dx`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`dx` is not equal to :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_dx()` is :code:`False`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """
        
        if type(v) in [str, int, float, bool]:
            return self if self.dx != v else None
        elif callable(v):
            return self if not v(self.dx) else None
        else:
            raise SwoopError("Illegal type passed to without_dx")


    def get_dy(self):
        """ Return the value of :code:`dy` for this :class:`Smd`.  This corresponds to the :code:`dy` attribute of a :code:`<smd>` in an Eagle file.
        
        :rtype: :code:`float`
        """
        return self.dy

    def set_dy(self,v):
        """ Set the value of :code:`dy` for this  :class:`Smd`.  This corresponds to the :code:`dy` attribute of a :code:`<smd>` in an Eagle file.

        :param v: new value
        :rtype: :code:`self`
        """
                        
        if not typeCheck("float", v, True):
            raise SwoopError("Illegal value ({}) of type {} for attribute 'dy' of Smd object (should be float).".format(v, type(v)))
        self.dy = v
        
        return self

    def with_dy(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`dy`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`dy` equals :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_dy()` is :code:`True`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """

        if type(v) in [str, int, float, bool]:
            return self if self.dy == v else None
        elif callable(v):
            return self if v(self.dy) else None
        else:
            raise SwoopError("Illegal type passed to with_dy")

    def without_dy(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`dy`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`dy` is not equal to :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_dy()` is :code:`False`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """
        
        if type(v) in [str, int, float, bool]:
            return self if self.dy != v else None
        elif callable(v):
            return self if not v(self.dy) else None
        else:
            raise SwoopError("Illegal type passed to without_dy")


    def get_layer(self):
        """ Return the value of :code:`layer` for this :class:`Smd`.  This corresponds to the :code:`layer` attribute of a :code:`<smd>` in an Eagle file.
        
        :rtype: :code:`layer_string`
        """
        return self.layer

    def set_layer(self,v):
        """ Set the value of :code:`layer` for this  :class:`Smd`.  This corresponds to the :code:`layer` attribute of a :code:`<smd>` in an Eagle file.

        :param v: new value
        :rtype: :code:`self`
        """
                        
        if not typeCheck("layer_string", v, True):
            raise SwoopError("Illegal value ({}) of type {} for attribute 'layer' of Smd object (should be layer_string).".format(v, type(v)))
        self.layer = v
        
        return self

    def with_layer(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`layer`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`layer` equals :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_layer()` is :code:`True`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """

        if type(v) in [str, int, float, bool]:
            return self if self.layer == v else None
        elif callable(v):
            return self if v(self.layer) else None
        else:
            raise SwoopError("Illegal type passed to with_layer")

    def without_layer(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`layer`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`layer` is not equal to :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_layer()` is :code:`False`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """
        
        if type(v) in [str, int, float, bool]:
            return self if self.layer != v else None
        elif callable(v):
            return self if not v(self.layer) else None
        else:
            raise SwoopError("Illegal type passed to without_layer")


    def get_roundness(self):
        """ Return the value of :code:`roundness` for this :class:`Smd`.  This corresponds to the :code:`roundness` attribute of a :code:`<smd>` in an Eagle file.
        
        :rtype: :code:`int`
        """
        return self.roundness

    def set_roundness(self,v):
        """ Set the value of :code:`roundness` for this  :class:`Smd`.  This corresponds to the :code:`roundness` attribute of a :code:`<smd>` in an Eagle file.

        :param v: new value
        :rtype: :code:`self`
        """
                        
        if not typeCheck("int", v, False):
            raise SwoopError("Illegal value ({}) of type {} for attribute 'roundness' of Smd object (should be int).".format(v, type(v)))
        self.roundness = v
        
        return self

    def with_roundness(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`roundness`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`roundness` equals :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_roundness()` is :code:`True`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """

        if type(v) in [str, int, float, bool]:
            return self if self.roundness == v else None
        elif callable(v):
            return self if v(self.roundness) else None
        else:
            raise SwoopError("Illegal type passed to with_roundness")

    def without_roundness(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`roundness`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`roundness` is not equal to :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_roundness()` is :code:`False`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """
        
        if type(v) in [str, int, float, bool]:
            return self if self.roundness != v else None
        elif callable(v):
            return self if not v(self.roundness) else None
        else:
            raise SwoopError("Illegal type passed to without_roundness")


    def get_rot(self):
        """ Return the value of :code:`rot` for this :class:`Smd`.  This corresponds to the :code:`rot` attribute of a :code:`<smd>` in an Eagle file.
        
        :rtype: :code:`str`
        """
        return self.rot

    def set_rot(self,v):
        """ Set the value of :code:`rot` for this  :class:`Smd`.  This corresponds to the :code:`rot` attribute of a :code:`<smd>` in an Eagle file.

        :param v: new value
        :rtype: :code:`self`
        """
                        
        if not typeCheck("str", v, False):
            raise SwoopError("Illegal value ({}) of type {} for attribute 'rot' of Smd object (should be str).".format(v, type(v)))
        self.rot = v
        
        return self

    def with_rot(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`rot`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`rot` equals :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_rot()` is :code:`True`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """

        if type(v) in [str, int, float, bool]:
            return self if self.rot == v else None
        elif callable(v):
            return self if v(self.rot) else None
        else:
            raise SwoopError("Illegal type passed to with_rot")

    def without_rot(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`rot`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`rot` is not equal to :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_rot()` is :code:`False`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """
        
        if type(v) in [str, int, float, bool]:
            return self if self.rot != v else None
        elif callable(v):
            return self if not v(self.rot) else None
        else:
            raise SwoopError("Illegal type passed to without_rot")


    def get_stop(self):
        """ Return the value of :code:`stop` for this :class:`Smd`.  This corresponds to the :code:`stop` attribute of a :code:`<smd>` in an Eagle file.
        
        :rtype: :code:`constant_bool`
        """
        return self.stop

    def set_stop(self,v):
        """ Set the value of :code:`stop` for this  :class:`Smd`.  This corresponds to the :code:`stop` attribute of a :code:`<smd>` in an Eagle file.

        :param v: new value
        :rtype: :code:`self`
        """
                        
        if not typeCheck("constant_bool", v, False):
            raise SwoopError("Illegal value ({}) of type {} for attribute 'stop' of Smd object (should be constant_bool).".format(v, type(v)))
        self.stop = v
        
        return self

    def with_stop(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`stop`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`stop` equals :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_stop()` is :code:`True`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """

        if type(v) in [str, int, float, bool]:
            return self if self.stop == v else None
        elif callable(v):
            return self if v(self.stop) else None
        else:
            raise SwoopError("Illegal type passed to with_stop")

    def without_stop(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`stop`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`stop` is not equal to :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_stop()` is :code:`False`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """
        
        if type(v) in [str, int, float, bool]:
            return self if self.stop != v else None
        elif callable(v):
            return self if not v(self.stop) else None
        else:
            raise SwoopError("Illegal type passed to without_stop")


    def get_thermals(self):
        """ Return the value of :code:`thermals` for this :class:`Smd`.  This corresponds to the :code:`thermals` attribute of a :code:`<smd>` in an Eagle file.
        
        :rtype: :code:`constant_bool`
        """
        return self.thermals

    def set_thermals(self,v):
        """ Set the value of :code:`thermals` for this  :class:`Smd`.  This corresponds to the :code:`thermals` attribute of a :code:`<smd>` in an Eagle file.

        :param v: new value
        :rtype: :code:`self`
        """
                        
        if not typeCheck("constant_bool", v, False):
            raise SwoopError("Illegal value ({}) of type {} for attribute 'thermals' of Smd object (should be constant_bool).".format(v, type(v)))
        self.thermals = v
        
        return self

    def with_thermals(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`thermals`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`thermals` equals :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_thermals()` is :code:`True`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """

        if type(v) in [str, int, float, bool]:
            return self if self.thermals == v else None
        elif callable(v):
            return self if v(self.thermals) else None
        else:
            raise SwoopError("Illegal type passed to with_thermals")

    def without_thermals(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`thermals`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`thermals` is not equal to :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_thermals()` is :code:`False`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """
        
        if type(v) in [str, int, float, bool]:
            return self if self.thermals != v else None
        elif callable(v):
            return self if not v(self.thermals) else None
        else:
            raise SwoopError("Illegal type passed to without_thermals")


    def get_cream(self):
        """ Return the value of :code:`cream` for this :class:`Smd`.  This corresponds to the :code:`cream` attribute of a :code:`<smd>` in an Eagle file.
        
        :rtype: :code:`constant_bool`
        """
        return self.cream

    def set_cream(self,v):
        """ Set the value of :code:`cream` for this  :class:`Smd`.  This corresponds to the :code:`cream` attribute of a :code:`<smd>` in an Eagle file.

        :param v: new value
        :rtype: :code:`self`
        """
                        
        if not typeCheck("constant_bool", v, False):
            raise SwoopError("Illegal value ({}) of type {} for attribute 'cream' of Smd object (should be constant_bool).".format(v, type(v)))
        self.cream = v
        
        return self

    def with_cream(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`cream`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`cream` equals :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_cream()` is :code:`True`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """

        if type(v) in [str, int, float, bool]:
            return self if self.cream == v else None
        elif callable(v):
            return self if v(self.cream) else None
        else:
            raise SwoopError("Illegal type passed to with_cream")

    def without_cream(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`cream`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`cream` is not equal to :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_cream()` is :code:`False`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """
        
        if type(v) in [str, int, float, bool]:
            return self if self.cream != v else None
        elif callable(v):
            return self if not v(self.cream) else None
        else:
            raise SwoopError("Illegal type passed to without_cream")



    ##### Lookup functions that return EFPs instead of just attribute values.
    
    


    
    ### Adder/getter/lookup for lists
    


    ### Add, lookup, and get for maps


    
    ### Getter/Setter for singletons.


    
    def get_children(self):
        """
        Get all the children of this :class:`EagleFilePart`.
        
        :rtype: List of :class:`EagleFilePart` objects
        """
        r = []




        return r

    def remove_child(self, efp):
        """
        Remove a child :class:`EagleFilePart` object.
        
        :param efp: the class:`EagleFilePart` object to remove.
        :return: Nothing
        """

    def _rekey_child(self, oldkey, efp):
        """
        Remove a child :class:`EagleFilePart` object.
        
        :param efp: the class:`EagleFilePart` object to remove.
        :return: Nothing
        """


    def __str__(self):
        r = "["+repr(self)+" "
        r = r + "name:" + str(self.get_name()) + " "
        r = r + "x:" + str(self.get_x()) + " "
        r = r + "y:" + str(self.get_y()) + " "
        r = r + "dx:" + str(self.get_dx()) + " "
        r = r + "dy:" + str(self.get_dy()) + " "
        r = r + "layer:" + str(self.get_layer()) + " "
        r = r + "roundness:" + str(self.get_roundness()) + " "
        r = r + "rot:" + str(self.get_rot()) + " "
        r = r + "stop:" + str(self.get_stop()) + " "
        r = r + "thermals:" + str(self.get_thermals()) + " "
        r = r + "cream:" + str(self.get_cream()) + " "
        r = r + "]"
        return r
            
    def dump(self, indent="", increment="   "):
        """
        Recursive debug dump.
        
        :param indent:  Indentation string.  The output will be indented by this much.
        :param increment: This will be appendeded to :code:`indent` on recursive invocations.

        :rtype: :code:`None`
        """
        print(indent + str(self.__class__.__name__), end=' ')
        try:
            print(self.get_name())
        except:
            print()
            pass
        for c in self.get_children():
            c.dump(indent + "   ")

        
EagleFile.class_map["smd"] = Smd
         


class Rectangle(EagleFilePart, RectGeometry, RotationGeometry):
    """
    Class representing the contents of a <rectangle> tag in Eagle files.

    Attributes:

    * :code:`x1`

    * :code:`y1`

    * :code:`x2`

    * :code:`y2`

    * :code:`layer`

    * :code:`rot`


    """
    def __init__(self):
        """
        Construct an empty :class:`Rectangle` object.
        """
        EagleFilePart.__init__(self)
        RectGeometry.__init__(self)
        RotationGeometry.__init__(self)
        
        self.x1=None
        self.y1=None
        self.x2=None
        self.y2=None
        self.layer=None
        self.rot=None


        
    @classmethod
    def _from_et(cls,root,parent):
        """
        Create a :class:`Rectangle` from a :code:`rectangle` element.
        
        :param root: The element tree tree to parse.
        :param parent: :class:`EagleFilePart` that should hold the resulting :class:`EagleFilePart`
        :rtype: :class:`Rectangle`
        """
        ## Call the constructor
        n = cls()
        n._init_from_et(root,parent)
        return n

    def _get_error_name(self):
        if hasattr(self, "get_name"):
            return self.get_name();
        else:
            return "Rectangle";
        
    def  _init_from_et(self, root, parent):
        """
        Initialized a :class:`Rectangle` from a :code:`rectangle` element.  This is useful if you have a subclass of :class:`Rectangle` .
        
        :param root: The element tree tree to parse.
        :param parent: :class:`EagleFilePart` that will become the parent of :code:`this` .
        :rtype: :class:`Rectangle`
        """
        try:
            self.root = root
            
            if root.tag != "rectangle":
                raise EagleFormatError("Tried to create rectangle from " + root.tag)

            self.x1=parseByType(parent, "float", None, root.get("x1"))
            self.y1=parseByType(parent, "float", None, root.get("y1"))
            self.x2=parseByType(parent, "float", None, root.get("x2"))
            self.y2=parseByType(parent, "float", None, root.get("y2"))
            self.layer=parseByType(parent, "layer_string", None, root.get("layer"))
            self.rot=parseByType(parent, "str", None, root.get("rot"))

            self.parent = parent

            ### populate the maps by searching for elements that match xpath and generating objects for them.


            ### Do the same for the lists


            ### Do the same for the attr lists


            ### And the singletons


            ### And, finally, if the objects wants the text from the tag.

        except SwoopError as e:
            e.text = "{}:{}".format(self._get_error_name(), e.text)
            raise e


    def sortkey(self):
        r = ""
        r = r + str(self.x1)
        r = r + str(self.y1)
        r = r + str(self.x2)
        r = r + str(self.y2)
        r = r + str(self.layer)
        r = r + str(self.rot)
        return r

    def get_et(self):
        """
        Generate a <rectangle> element tree for a :class:`Rectangle`.
        
        :rtype:  :class:`ElementTree`.
        
        """
        try:
            r = ET.Element("rectangle")

            ### Set the tag attributes 


            ## Unparse the values.

            v = unparseByType(self, "float", None,  self.x1)

            ## For required attributes None becomes "".  For optional attributes, we just leave the attribute out.
            if not (isinstance(self.get_parent(), LibraryFile) and False):  # special case for the name of library.
                if v is not None:
                    r.set("x1", v)
                else:
                    r.set("x1", "")


            ## Unparse the values.

            v = unparseByType(self, "float", None,  self.y1)

            ## For required attributes None becomes "".  For optional attributes, we just leave the attribute out.
            if not (isinstance(self.get_parent(), LibraryFile) and False):  # special case for the name of library.
                if v is not None:
                    r.set("y1", v)
                else:
                    r.set("y1", "")


            ## Unparse the values.

            v = unparseByType(self, "float", None,  self.x2)

            ## For required attributes None becomes "".  For optional attributes, we just leave the attribute out.
            if not (isinstance(self.get_parent(), LibraryFile) and False):  # special case for the name of library.
                if v is not None:
                    r.set("x2", v)
                else:
                    r.set("x2", "")


            ## Unparse the values.

            v = unparseByType(self, "float", None,  self.y2)

            ## For required attributes None becomes "".  For optional attributes, we just leave the attribute out.
            if not (isinstance(self.get_parent(), LibraryFile) and False):  # special case for the name of library.
                if v is not None:
                    r.set("y2", v)
                else:
                    r.set("y2", "")


            ## Unparse the values.

            v = unparseByType(self, "layer_string", None,  self.layer)

            ## For required attributes None becomes "".  For optional attributes, we just leave the attribute out.
            if not (isinstance(self.get_parent(), LibraryFile) and False):  # special case for the name of library.
                if v is not None:
                    r.set("layer", v)
                else:
                    r.set("layer", "")


            ## Unparse the values.

            v = unparseByType(self, "str", None,  self.rot)

            ## For required attributes None becomes "".  For optional attributes, we just leave the attribute out.
            if not (isinstance(self.get_parent(), LibraryFile) and False):  # special case for the name of library.
                if v is not None:
                    r.set("rot", v)


            ### process the sections in order.  They have to be in section order,
            ### because eagle files are order dependent.


            ## set the text, if its needed.

        except SwoopError as e:
            e.text = "{}:{}".format(self._get_error_name(), e.text)
            raise e
        return r

    def clone(self):
        """
        Recursively clone this :code:`Rectangle`.  It will be identical to the original, but it's parent will be :code:`None`.
        
        :rtype: :class:`Rectangle`
        """
        try:
            n = copy.copy(self)
            n.parent = None
        except SwoopError as e:
            e.text = "{}:{}".format(self._get_error_name(), e.text)
            raise e
        return n

    def accept_preorder_visitor(self, visitor):
        try:
            pre = getattr(visitor, "Rectangle_pre")
            return pre(self)
        except AttributeError:
            return visitor.default_pre(self)
        
    def accept_postorder_visitor(self, visitor, context):
        try:
            post = getattr(visitor, "Rectangle_post")
            post(self,context)
        except AttributeError:
            visitor.default_post(self,context)

    def is_equal(self, other):
        """
        Check whether two :code:`EagleFilePart` objects are identical.
        
        :param other: Object to compare to.
        :returns: :code:`True` if they are identical, otherwise, :code:`False`
        """
        return self.get_xml() == other.get_xml()
        
    ### Getters/Setters for attribute values

    def get_x1(self):
        """ Return the value of :code:`x1` for this :class:`Rectangle`.  This corresponds to the :code:`x1` attribute of a :code:`<rectangle>` in an Eagle file.
        
        :rtype: :code:`float`
        """
        return self.x1

    def set_x1(self,v):
        """ Set the value of :code:`x1` for this  :class:`Rectangle`.  This corresponds to the :code:`x1` attribute of a :code:`<rectangle>` in an Eagle file.

        :param v: new value
        :rtype: :code:`self`
        """
                        
        if not typeCheck("float", v, True):
            raise SwoopError("Illegal value ({}) of type {} for attribute 'x1' of Rectangle object (should be float).".format(v, type(v)))
        self.x1 = v
        
        return self

    def with_x1(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`x1`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`x1` equals :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_x1()` is :code:`True`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """

        if type(v) in [str, int, float, bool]:
            return self if self.x1 == v else None
        elif callable(v):
            return self if v(self.x1) else None
        else:
            raise SwoopError("Illegal type passed to with_x1")

    def without_x1(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`x1`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`x1` is not equal to :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_x1()` is :code:`False`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """
        
        if type(v) in [str, int, float, bool]:
            return self if self.x1 != v else None
        elif callable(v):
            return self if not v(self.x1) else None
        else:
            raise SwoopError("Illegal type passed to without_x1")


    def get_y1(self):
        """ Return the value of :code:`y1` for this :class:`Rectangle`.  This corresponds to the :code:`y1` attribute of a :code:`<rectangle>` in an Eagle file.
        
        :rtype: :code:`float`
        """
        return self.y1

    def set_y1(self,v):
        """ Set the value of :code:`y1` for this  :class:`Rectangle`.  This corresponds to the :code:`y1` attribute of a :code:`<rectangle>` in an Eagle file.

        :param v: new value
        :rtype: :code:`self`
        """
                        
        if not typeCheck("float", v, True):
            raise SwoopError("Illegal value ({}) of type {} for attribute 'y1' of Rectangle object (should be float).".format(v, type(v)))
        self.y1 = v
        
        return self

    def with_y1(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`y1`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`y1` equals :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_y1()` is :code:`True`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """

        if type(v) in [str, int, float, bool]:
            return self if self.y1 == v else None
        elif callable(v):
            return self if v(self.y1) else None
        else:
            raise SwoopError("Illegal type passed to with_y1")

    def without_y1(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`y1`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`y1` is not equal to :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_y1()` is :code:`False`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """
        
        if type(v) in [str, int, float, bool]:
            return self if self.y1 != v else None
        elif callable(v):
            return self if not v(self.y1) else None
        else:
            raise SwoopError("Illegal type passed to without_y1")


    def get_x2(self):
        """ Return the value of :code:`x2` for this :class:`Rectangle`.  This corresponds to the :code:`x2` attribute of a :code:`<rectangle>` in an Eagle file.
        
        :rtype: :code:`float`
        """
        return self.x2

    def set_x2(self,v):
        """ Set the value of :code:`x2` for this  :class:`Rectangle`.  This corresponds to the :code:`x2` attribute of a :code:`<rectangle>` in an Eagle file.

        :param v: new value
        :rtype: :code:`self`
        """
                        
        if not typeCheck("float", v, True):
            raise SwoopError("Illegal value ({}) of type {} for attribute 'x2' of Rectangle object (should be float).".format(v, type(v)))
        self.x2 = v
        
        return self

    def with_x2(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`x2`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`x2` equals :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_x2()` is :code:`True`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """

        if type(v) in [str, int, float, bool]:
            return self if self.x2 == v else None
        elif callable(v):
            return self if v(self.x2) else None
        else:
            raise SwoopError("Illegal type passed to with_x2")

    def without_x2(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`x2`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`x2` is not equal to :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_x2()` is :code:`False`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """
        
        if type(v) in [str, int, float, bool]:
            return self if self.x2 != v else None
        elif callable(v):
            return self if not v(self.x2) else None
        else:
            raise SwoopError("Illegal type passed to without_x2")


    def get_y2(self):
        """ Return the value of :code:`y2` for this :class:`Rectangle`.  This corresponds to the :code:`y2` attribute of a :code:`<rectangle>` in an Eagle file.
        
        :rtype: :code:`float`
        """
        return self.y2

    def set_y2(self,v):
        """ Set the value of :code:`y2` for this  :class:`Rectangle`.  This corresponds to the :code:`y2` attribute of a :code:`<rectangle>` in an Eagle file.

        :param v: new value
        :rtype: :code:`self`
        """
                        
        if not typeCheck("float", v, True):
            raise SwoopError("Illegal value ({}) of type {} for attribute 'y2' of Rectangle object (should be float).".format(v, type(v)))
        self.y2 = v
        
        return self

    def with_y2(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`y2`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`y2` equals :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_y2()` is :code:`True`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """

        if type(v) in [str, int, float, bool]:
            return self if self.y2 == v else None
        elif callable(v):
            return self if v(self.y2) else None
        else:
            raise SwoopError("Illegal type passed to with_y2")

    def without_y2(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`y2`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`y2` is not equal to :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_y2()` is :code:`False`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """
        
        if type(v) in [str, int, float, bool]:
            return self if self.y2 != v else None
        elif callable(v):
            return self if not v(self.y2) else None
        else:
            raise SwoopError("Illegal type passed to without_y2")


    def get_layer(self):
        """ Return the value of :code:`layer` for this :class:`Rectangle`.  This corresponds to the :code:`layer` attribute of a :code:`<rectangle>` in an Eagle file.
        
        :rtype: :code:`layer_string`
        """
        return self.layer

    def set_layer(self,v):
        """ Set the value of :code:`layer` for this  :class:`Rectangle`.  This corresponds to the :code:`layer` attribute of a :code:`<rectangle>` in an Eagle file.

        :param v: new value
        :rtype: :code:`self`
        """
                        
        if not typeCheck("layer_string", v, True):
            raise SwoopError("Illegal value ({}) of type {} for attribute 'layer' of Rectangle object (should be layer_string).".format(v, type(v)))
        self.layer = v
        
        return self

    def with_layer(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`layer`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`layer` equals :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_layer()` is :code:`True`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """

        if type(v) in [str, int, float, bool]:
            return self if self.layer == v else None
        elif callable(v):
            return self if v(self.layer) else None
        else:
            raise SwoopError("Illegal type passed to with_layer")

    def without_layer(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`layer`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`layer` is not equal to :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_layer()` is :code:`False`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """
        
        if type(v) in [str, int, float, bool]:
            return self if self.layer != v else None
        elif callable(v):
            return self if not v(self.layer) else None
        else:
            raise SwoopError("Illegal type passed to without_layer")


    def get_rot(self):
        """ Return the value of :code:`rot` for this :class:`Rectangle`.  This corresponds to the :code:`rot` attribute of a :code:`<rectangle>` in an Eagle file.
        
        :rtype: :code:`str`
        """
        return self.rot

    def set_rot(self,v):
        """ Set the value of :code:`rot` for this  :class:`Rectangle`.  This corresponds to the :code:`rot` attribute of a :code:`<rectangle>` in an Eagle file.

        :param v: new value
        :rtype: :code:`self`
        """
                        
        if not typeCheck("str", v, False):
            raise SwoopError("Illegal value ({}) of type {} for attribute 'rot' of Rectangle object (should be str).".format(v, type(v)))
        self.rot = v
        
        return self

    def with_rot(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`rot`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`rot` equals :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_rot()` is :code:`True`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """

        if type(v) in [str, int, float, bool]:
            return self if self.rot == v else None
        elif callable(v):
            return self if v(self.rot) else None
        else:
            raise SwoopError("Illegal type passed to with_rot")

    def without_rot(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`rot`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`rot` is not equal to :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_rot()` is :code:`False`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """
        
        if type(v) in [str, int, float, bool]:
            return self if self.rot != v else None
        elif callable(v):
            return self if not v(self.rot) else None
        else:
            raise SwoopError("Illegal type passed to without_rot")



    ##### Lookup functions that return EFPs instead of just attribute values.
    
    


    
    ### Adder/getter/lookup for lists
    


    ### Add, lookup, and get for maps


    
    ### Getter/Setter for singletons.


    
    def get_children(self):
        """
        Get all the children of this :class:`EagleFilePart`.
        
        :rtype: List of :class:`EagleFilePart` objects
        """
        r = []




        return r

    def remove_child(self, efp):
        """
        Remove a child :class:`EagleFilePart` object.
        
        :param efp: the class:`EagleFilePart` object to remove.
        :return: Nothing
        """

    def _rekey_child(self, oldkey, efp):
        """
        Remove a child :class:`EagleFilePart` object.
        
        :param efp: the class:`EagleFilePart` object to remove.
        :return: Nothing
        """


    def __str__(self):
        r = "["+repr(self)+" "
        r = r + "x1:" + str(self.get_x1()) + " "
        r = r + "y1:" + str(self.get_y1()) + " "
        r = r + "x2:" + str(self.get_x2()) + " "
        r = r + "y2:" + str(self.get_y2()) + " "
        r = r + "layer:" + str(self.get_layer()) + " "
        r = r + "rot:" + str(self.get_rot()) + " "
        r = r + "]"
        return r
            
    def dump(self, indent="", increment="   "):
        """
        Recursive debug dump.
        
        :param indent:  Indentation string.  The output will be indented by this much.
        :param increment: This will be appendeded to :code:`indent` on recursive invocations.

        :rtype: :code:`None`
        """
        print(indent + str(self.__class__.__name__), end=' ')
        try:
            print(self.get_name())
        except:
            print()
            pass
        for c in self.get_children():
            c.dump(indent + "   ")

        
EagleFile.class_map["rectangle"] = Rectangle
         


class Junction(EagleFilePart, OnePointGeometry):
    """
    Class representing the contents of a <junction> tag in Eagle files.

    Attributes:

    * :code:`x`

    * :code:`y`


    """
    def __init__(self):
        """
        Construct an empty :class:`Junction` object.
        """
        EagleFilePart.__init__(self)
        OnePointGeometry.__init__(self)
        
        self.x=None
        self.y=None


        
    @classmethod
    def _from_et(cls,root,parent):
        """
        Create a :class:`Junction` from a :code:`junction` element.
        
        :param root: The element tree tree to parse.
        :param parent: :class:`EagleFilePart` that should hold the resulting :class:`EagleFilePart`
        :rtype: :class:`Junction`
        """
        ## Call the constructor
        n = cls()
        n._init_from_et(root,parent)
        return n

    def _get_error_name(self):
        if hasattr(self, "get_name"):
            return self.get_name();
        else:
            return "Junction";
        
    def  _init_from_et(self, root, parent):
        """
        Initialized a :class:`Junction` from a :code:`junction` element.  This is useful if you have a subclass of :class:`Junction` .
        
        :param root: The element tree tree to parse.
        :param parent: :class:`EagleFilePart` that will become the parent of :code:`this` .
        :rtype: :class:`Junction`
        """
        try:
            self.root = root
            
            if root.tag != "junction":
                raise EagleFormatError("Tried to create junction from " + root.tag)

            self.x=parseByType(parent, "float", None, root.get("x"))
            self.y=parseByType(parent, "float", None, root.get("y"))

            self.parent = parent

            ### populate the maps by searching for elements that match xpath and generating objects for them.


            ### Do the same for the lists


            ### Do the same for the attr lists


            ### And the singletons


            ### And, finally, if the objects wants the text from the tag.

        except SwoopError as e:
            e.text = "{}:{}".format(self._get_error_name(), e.text)
            raise e


    def sortkey(self):
        r = ""
        r = r + str(self.x)
        r = r + str(self.y)
        return r

    def get_et(self):
        """
        Generate a <junction> element tree for a :class:`Junction`.
        
        :rtype:  :class:`ElementTree`.
        
        """
        try:
            r = ET.Element("junction")

            ### Set the tag attributes 


            ## Unparse the values.

            v = unparseByType(self, "float", None,  self.x)

            ## For required attributes None becomes "".  For optional attributes, we just leave the attribute out.
            if not (isinstance(self.get_parent(), LibraryFile) and False):  # special case for the name of library.
                if v is not None:
                    r.set("x", v)
                else:
                    r.set("x", "")


            ## Unparse the values.

            v = unparseByType(self, "float", None,  self.y)

            ## For required attributes None becomes "".  For optional attributes, we just leave the attribute out.
            if not (isinstance(self.get_parent(), LibraryFile) and False):  # special case for the name of library.
                if v is not None:
                    r.set("y", v)
                else:
                    r.set("y", "")


            ### process the sections in order.  They have to be in section order,
            ### because eagle files are order dependent.


            ## set the text, if its needed.

        except SwoopError as e:
            e.text = "{}:{}".format(self._get_error_name(), e.text)
            raise e
        return r

    def clone(self):
        """
        Recursively clone this :code:`Junction`.  It will be identical to the original, but it's parent will be :code:`None`.
        
        :rtype: :class:`Junction`
        """
        try:
            n = copy.copy(self)
            n.parent = None
        except SwoopError as e:
            e.text = "{}:{}".format(self._get_error_name(), e.text)
            raise e
        return n

    def accept_preorder_visitor(self, visitor):
        try:
            pre = getattr(visitor, "Junction_pre")
            return pre(self)
        except AttributeError:
            return visitor.default_pre(self)
        
    def accept_postorder_visitor(self, visitor, context):
        try:
            post = getattr(visitor, "Junction_post")
            post(self,context)
        except AttributeError:
            visitor.default_post(self,context)

    def is_equal(self, other):
        """
        Check whether two :code:`EagleFilePart` objects are identical.
        
        :param other: Object to compare to.
        :returns: :code:`True` if they are identical, otherwise, :code:`False`
        """
        return self.get_xml() == other.get_xml()
        
    ### Getters/Setters for attribute values

    def get_x(self):
        """ Return the value of :code:`x` for this :class:`Junction`.  This corresponds to the :code:`x` attribute of a :code:`<junction>` in an Eagle file.
        
        :rtype: :code:`float`
        """
        return self.x

    def set_x(self,v):
        """ Set the value of :code:`x` for this  :class:`Junction`.  This corresponds to the :code:`x` attribute of a :code:`<junction>` in an Eagle file.

        :param v: new value
        :rtype: :code:`self`
        """
                        
        if not typeCheck("float", v, True):
            raise SwoopError("Illegal value ({}) of type {} for attribute 'x' of Junction object (should be float).".format(v, type(v)))
        self.x = v
        
        return self

    def with_x(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`x`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`x` equals :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_x()` is :code:`True`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """

        if type(v) in [str, int, float, bool]:
            return self if self.x == v else None
        elif callable(v):
            return self if v(self.x) else None
        else:
            raise SwoopError("Illegal type passed to with_x")

    def without_x(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`x`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`x` is not equal to :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_x()` is :code:`False`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """
        
        if type(v) in [str, int, float, bool]:
            return self if self.x != v else None
        elif callable(v):
            return self if not v(self.x) else None
        else:
            raise SwoopError("Illegal type passed to without_x")


    def get_y(self):
        """ Return the value of :code:`y` for this :class:`Junction`.  This corresponds to the :code:`y` attribute of a :code:`<junction>` in an Eagle file.
        
        :rtype: :code:`float`
        """
        return self.y

    def set_y(self,v):
        """ Set the value of :code:`y` for this  :class:`Junction`.  This corresponds to the :code:`y` attribute of a :code:`<junction>` in an Eagle file.

        :param v: new value
        :rtype: :code:`self`
        """
                        
        if not typeCheck("float", v, True):
            raise SwoopError("Illegal value ({}) of type {} for attribute 'y' of Junction object (should be float).".format(v, type(v)))
        self.y = v
        
        return self

    def with_y(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`y`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`y` equals :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_y()` is :code:`True`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """

        if type(v) in [str, int, float, bool]:
            return self if self.y == v else None
        elif callable(v):
            return self if v(self.y) else None
        else:
            raise SwoopError("Illegal type passed to with_y")

    def without_y(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`y`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`y` is not equal to :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_y()` is :code:`False`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """
        
        if type(v) in [str, int, float, bool]:
            return self if self.y != v else None
        elif callable(v):
            return self if not v(self.y) else None
        else:
            raise SwoopError("Illegal type passed to without_y")



    ##### Lookup functions that return EFPs instead of just attribute values.
    
    


    
    ### Adder/getter/lookup for lists
    


    ### Add, lookup, and get for maps


    
    ### Getter/Setter for singletons.


    
    def get_children(self):
        """
        Get all the children of this :class:`EagleFilePart`.
        
        :rtype: List of :class:`EagleFilePart` objects
        """
        r = []




        return r

    def remove_child(self, efp):
        """
        Remove a child :class:`EagleFilePart` object.
        
        :param efp: the class:`EagleFilePart` object to remove.
        :return: Nothing
        """

    def _rekey_child(self, oldkey, efp):
        """
        Remove a child :class:`EagleFilePart` object.
        
        :param efp: the class:`EagleFilePart` object to remove.
        :return: Nothing
        """


    def __str__(self):
        r = "["+repr(self)+" "
        r = r + "x:" + str(self.get_x()) + " "
        r = r + "y:" + str(self.get_y()) + " "
        r = r + "]"
        return r
            
    def dump(self, indent="", increment="   "):
        """
        Recursive debug dump.
        
        :param indent:  Indentation string.  The output will be indented by this much.
        :param increment: This will be appendeded to :code:`indent` on recursive invocations.

        :rtype: :code:`None`
        """
        print(indent + str(self.__class__.__name__), end=' ')
        try:
            print(self.get_name())
        except:
            print()
            pass
        for c in self.get_children():
            c.dump(indent + "   ")

        
EagleFile.class_map["junction"] = Junction
         


class Description(EagleFilePart):
    """
    Class representing the contents of a <description> tag in Eagle files.

    Attributes:

    * :code:`language`


    """
    def __init__(self):
        """
        Construct an empty :class:`Description` object.
        """
        EagleFilePart.__init__(self)
        
        self.language=None

        self.text = ""

        
    @classmethod
    def _from_et(cls,root,parent):
        """
        Create a :class:`Description` from a :code:`description` element.
        
        :param root: The element tree tree to parse.
        :param parent: :class:`EagleFilePart` that should hold the resulting :class:`EagleFilePart`
        :rtype: :class:`Description`
        """
        ## Call the constructor
        n = cls()
        n._init_from_et(root,parent)
        return n

    def _get_error_name(self):
        if hasattr(self, "get_name"):
            return self.get_name();
        else:
            return "Description";
        
    def  _init_from_et(self, root, parent):
        """
        Initialized a :class:`Description` from a :code:`description` element.  This is useful if you have a subclass of :class:`Description` .
        
        :param root: The element tree tree to parse.
        :param parent: :class:`EagleFilePart` that will become the parent of :code:`this` .
        :rtype: :class:`Description`
        """
        try:
            self.root = root
            
            if root.tag != "description":
                raise EagleFormatError("Tried to create description from " + root.tag)

            self.language=parseByType(parent, "str", None, root.get("language"))

            self.parent = parent

            ### populate the maps by searching for elements that match xpath and generating objects for them.


            ### Do the same for the lists


            ### Do the same for the attr lists


            ### And the singletons


            ### And, finally, if the objects wants the text from the tag.

            self.text = root.text or "" # If root.text is None, we still need a string.
        except SwoopError as e:
            e.text = "{}:{}".format(self._get_error_name(), e.text)
            raise e


    def sortkey(self):
        r = ""
        r = r + str(self.language)
        return r

    def get_et(self):
        """
        Generate a <description> element tree for a :class:`Description`.
        
        :rtype:  :class:`ElementTree`.
        
        """
        try:
            r = ET.Element("description")

            ### Set the tag attributes 


            ## Unparse the values.

            v = unparseByType(self, "str", None,  self.language)

            ## For required attributes None becomes "".  For optional attributes, we just leave the attribute out.
            if not (isinstance(self.get_parent(), LibraryFile) and False):  # special case for the name of library.
                if v is not None:
                    r.set("language", v)


            ### process the sections in order.  They have to be in section order,
            ### because eagle files are order dependent.


            ## set the text, if its needed.

            r.text = self.text
        except SwoopError as e:
            e.text = "{}:{}".format(self._get_error_name(), e.text)
            raise e
        return r

    def clone(self):
        """
        Recursively clone this :code:`Description`.  It will be identical to the original, but it's parent will be :code:`None`.
        
        :rtype: :class:`Description`
        """
        try:
            n = copy.copy(self)
            n.parent = None
        except SwoopError as e:
            e.text = "{}:{}".format(self._get_error_name(), e.text)
            raise e
        return n

    def accept_preorder_visitor(self, visitor):
        try:
            pre = getattr(visitor, "Description_pre")
            return pre(self)
        except AttributeError:
            return visitor.default_pre(self)
        
    def accept_postorder_visitor(self, visitor, context):
        try:
            post = getattr(visitor, "Description_post")
            post(self,context)
        except AttributeError:
            visitor.default_post(self,context)

    def is_equal(self, other):
        """
        Check whether two :code:`EagleFilePart` objects are identical.
        
        :param other: Object to compare to.
        :returns: :code:`True` if they are identical, otherwise, :code:`False`
        """
        return self.get_xml() == other.get_xml()
        
    ### Getters/Setters for attribute values

    def get_language(self):
        """ Return the value of :code:`language` for this :class:`Description`.  This corresponds to the :code:`language` attribute of a :code:`<description>` in an Eagle file.
        
        :rtype: :code:`str`
        """
        return self.language

    def set_language(self,v):
        """ Set the value of :code:`language` for this  :class:`Description`.  This corresponds to the :code:`language` attribute of a :code:`<description>` in an Eagle file.

        :param v: new value
        :rtype: :code:`self`
        """
                        
        if not typeCheck("str", v, False):
            raise SwoopError("Illegal value ({}) of type {} for attribute 'language' of Description object (should be str).".format(v, type(v)))
        self.language = v
        
        return self

    def with_language(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`language`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`language` equals :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_language()` is :code:`True`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """

        if type(v) in [str, int, float, bool]:
            return self if self.language == v else None
        elif callable(v):
            return self if v(self.language) else None
        else:
            raise SwoopError("Illegal type passed to with_language")

    def without_language(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`language`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`language` is not equal to :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_language()` is :code:`False`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """
        
        if type(v) in [str, int, float, bool]:
            return self if self.language != v else None
        elif callable(v):
            return self if not v(self.language) else None
        else:
            raise SwoopError("Illegal type passed to without_language")



    ##### Lookup functions that return EFPs instead of just attribute values.
    
    
    def with_text(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`text`.  For use in combination with :class:`From` objects.
        
        Return :code:`self` if one of the following is true:

        1.  :code:`text` equals :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_text()` is :code:`True`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """

        if type(v) in [str, int, float]:
            return self if self.text == v else None
        elif callable(v):
            return self if v(self.text) else None
        else:
            raise SwoopError("Illegal type passed to with_text")

    def without_text(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`text`.
        
        Return :code:`self` if one of the following is true:

        1.  :code:`text` does not equal :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_text()` is :code:`False`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """

        if type(v) in [str, int, float]:
            return self if self.text == v else None
        elif callable(v):
            return self if v(self.text) else None
        else:
            raise SwoopError("Illegal type passed to without_text")


    
    ### Adder/getter/lookup for lists
    


    ### Add, lookup, and get for maps


    
    ### Getter/Setter for singletons.


    def set_text(self, s):
        """ Set the text content for this :class:`Description`.

        :param s: text to set.
        :rtype: :code:`self`
        """
        self.text = s
        return self

    def get_text(self):
        """ Get the text content from this :class:`Description`.
        
        :rtype: the text content.
        """
        return self.text
    
    
    def get_children(self):
        """
        Get all the children of this :class:`EagleFilePart`.
        
        :rtype: List of :class:`EagleFilePart` objects
        """
        r = []




        return r

    def remove_child(self, efp):
        """
        Remove a child :class:`EagleFilePart` object.
        
        :param efp: the class:`EagleFilePart` object to remove.
        :return: Nothing
        """

    def _rekey_child(self, oldkey, efp):
        """
        Remove a child :class:`EagleFilePart` object.
        
        :param efp: the class:`EagleFilePart` object to remove.
        :return: Nothing
        """


    def __str__(self):
        r = "["+repr(self)+" "
        r = r + "language:" + str(self.get_language()) + " "
        r = r + "]"
        return r
            
    def dump(self, indent="", increment="   "):
        """
        Recursive debug dump.
        
        :param indent:  Indentation string.  The output will be indented by this much.
        :param increment: This will be appendeded to :code:`indent` on recursive invocations.

        :rtype: :code:`None`
        """
        print(indent + str(self.__class__.__name__), end=' ')
        try:
            print(self.get_name())
        except:
            print()
            pass
        for c in self.get_children():
            c.dump(indent + "   ")

        
EagleFile.class_map["description"] = Description
         


class BoardFile(EagleFile):
    """
    Class representing the contents of a <eagle> tag in Eagle files.

    Attributes:

    * :code:`version`



    Collections:

    * :code:`grid`: Singleton :class:`Grid` object. 

    * :code:`description`: Singleton :class:`Description` object. 

    * :code:`designrules`: Singleton :class:`Designrules` object. 

    * :code:`compatibility`: Singleton :class:`Compatibility` object. 


    * :code:`setting`: List of :class:`Setting` objects.

    * :code:`plain_element`: List of :class:`Polygon`, :class:`Wire`, :class:`Text`, :class:`Dimension`, :class:`Circle`, :class:`Rectangle`, :class:`Frame` and :class:`Hole` objects.

    * :code:`mfgpreviewcolor`: List of :class:`Mfgpreviewcolor` objects.

    * :code:`approved`: List of :class:`Approved` objects.


    * :code:`layer`: Map of :class:`Layer` objects indexed by their :code:`number`.


    * :code:`library`: Map of :class:`Library` objects indexed by their :code:`name`.


    * :code:`attribute`: Map of :class:`Attribute` objects indexed by their :code:`name`.


    * :code:`variantdef`: Map of :class:`Variantdef` objects indexed by their :code:`name`.


    * :code:`class`: Map of :class:`Class` objects indexed by their :code:`name`.


    * :code:`pass`: Map of :class:`Pass` objects indexed by their :code:`name`.


    * :code:`element`: Map of :class:`Element` objects indexed by their :code:`name`.


    * :code:`signal`: Map of :class:`Signal` objects indexed by their :code:`name`.



    """
    def __init__(self):
        """
        Construct an empty :class:`BoardFile` object.
        """
        EagleFile.__init__(self)
        
        self.version=None
        self.settings=[]
        self.plain_elements=[]
        self.mfgpreviewcolors=[]
        self.approved_errors=[]
        self.layers={} #tecollections.OrderedDict()  For unclear reasons, this caused ordering to become more unpredictable, rather than less.
        self.libraries={} #tecollections.OrderedDict()  For unclear reasons, this caused ordering to become more unpredictable, rather than less.
        self.attributes={} #tecollections.OrderedDict()  For unclear reasons, this caused ordering to become more unpredictable, rather than less.
        self.variantdefs={} #tecollections.OrderedDict()  For unclear reasons, this caused ordering to become more unpredictable, rather than less.
        self.classes={} #tecollections.OrderedDict()  For unclear reasons, this caused ordering to become more unpredictable, rather than less.
        self.autorouter_passes={} #tecollections.OrderedDict()  For unclear reasons, this caused ordering to become more unpredictable, rather than less.
        self.elements={} #tecollections.OrderedDict()  For unclear reasons, this caused ordering to become more unpredictable, rather than less.
        self.signals={} #tecollections.OrderedDict()  For unclear reasons, this caused ordering to become more unpredictable, rather than less.
        self.grid=None
        self.description=None
        self.designrules=None
        self.compatibility=None


        
    @classmethod
    def _from_et(cls,root,parent):
        """
        Create a :class:`BoardFile` from a :code:`eagle` element.
        
        :param root: The element tree tree to parse.
        :param parent: :class:`EagleFilePart` that should hold the resulting :class:`EagleFilePart`
        :rtype: :class:`BoardFile`
        """
        ## Call the constructor
        n = cls()
        n._init_from_et(root,parent)
        return n

    def _get_error_name(self):
        if hasattr(self, "get_name"):
            return self.get_name();
        else:
            return "BoardFile";
        
    def  _init_from_et(self, root, parent):
        """
        Initialized a :class:`BoardFile` from a :code:`eagle` element.  This is useful if you have a subclass of :class:`BoardFile` .
        
        :param root: The element tree tree to parse.
        :param parent: :class:`EagleFilePart` that will become the parent of :code:`this` .
        :rtype: :class:`BoardFile`
        """
        try:
            self.root = root
            
            if root.tag != "eagle":
                raise EagleFormatError("Tried to create eagle from " + root.tag)

            self.version=parseByType(parent, "str", None, root.get("version"))

            self.parent = parent

            ### populate the maps by searching for elements that match xpath and generating objects for them.

            for c in root.xpath("./drawing/layers/layer"):
                self.add_layer(self.get_class_for_tag(c.tag)._from_et(c, self))
            for c in root.xpath("./drawing/board/libraries/library"):
                self.add_library(self.get_class_for_tag(c.tag)._from_et(c, self))
            for c in root.xpath("./drawing/board/attributes/attribute"):
                self.add_attribute(self.get_class_for_tag(c.tag)._from_et(c, self))
            for c in root.xpath("./drawing/board/variantdefs/variantdef"):
                self.add_variantdef(self.get_class_for_tag(c.tag)._from_et(c, self))
            for c in root.xpath("./drawing/board/classes/class"):
                self.add_class(self.get_class_for_tag(c.tag)._from_et(c, self))
            for c in root.xpath("./drawing/board/autorouter/pass"):
                self.add_pass(self.get_class_for_tag(c.tag)._from_et(c, self))
            for c in root.xpath("./drawing/board/elements/element"):
                self.add_element(self.get_class_for_tag(c.tag)._from_et(c, self))
            for c in root.xpath("./drawing/board/signals/signal"):
                self.add_signal(self.get_class_for_tag(c.tag)._from_et(c, self))

            ### Do the same for the lists

            for c in root.xpath("./drawing/settings/setting"):
                self.add_setting(self.get_class_for_tag(c.tag)._from_et(c,self))
            for c in root.xpath("./drawing/board/plain/polygon|./drawing/board/plain/wire|./drawing/board/plain/text|./drawing/board/plain/dimension|./drawing/board/plain/circle|./drawing/board/plain/rectangle|./drawing/board/plain/frame|./drawing/board/plain/hole"):
                self.add_plain_element(self.get_class_for_tag(c.tag)._from_et(c,self))
            for c in root.xpath("./drawing/board/mfgpreviewcolors/mfgpreviewcolor"):
                self.add_mfgpreviewcolor(self.get_class_for_tag(c.tag)._from_et(c,self))
            for c in root.xpath("./drawing/board/errors/approved"):
                self.add_approved(self.get_class_for_tag(c.tag)._from_et(c,self))

            ### Do the same for the attr lists


            ### And the singletons

            x = root.xpath("./drawing/grid")
            if len(x) is not 0:
                self.set_grid(self.get_class_for_tag(x[0].tag)._from_et(x[0],self))
            x = root.xpath("./drawing/board/description")
            if len(x) is not 0:
                self.set_description(self.get_class_for_tag(x[0].tag)._from_et(x[0],self))
            x = root.xpath("./drawing/board/designrules")
            if len(x) is not 0:
                self.set_designrules(self.get_class_for_tag(x[0].tag)._from_et(x[0],self))
            x = root.xpath("./compatibility")
            if len(x) is not 0:
                self.set_compatibility(self.get_class_for_tag(x[0].tag)._from_et(x[0],self))

            ### And, finally, if the objects wants the text from the tag.

        except SwoopError as e:
            e.text = "{}:{}".format(self._get_error_name(), e.text)
            raise e


    def sortkey(self):
        r = ""
        r = r + str(self.version)
        return r

    def get_et(self):
        """
        Generate a <eagle> element tree for a :class:`BoardFile`.
        
        :rtype:  :class:`ElementTree`.
        
        """
        try:
            r = ET.Element("eagle")

            ### Set the tag attributes 


            ## Unparse the values.

            v = unparseByType(self, "str", None,  self.version)

            ## For required attributes None becomes "".  For optional attributes, we just leave the attribute out.
            if not (isinstance(self.get_parent(), LibraryFile) and False):  # special case for the name of library.
                if v is not None:
                    r.set("version", v)
                else:
                    r.set("version", "")


            ### process the sections in order.  They have to be in section order,
            ### because eagle files are order dependent.


            ## For some tags, Eagle generates empty tags when there's no contant
            ## rather than just leaving the tag out.  We mark these with
            ## Tag.requireTag in GenerateSwoop.py and force their generation
            ## here.

            smartAddSubTags(r, "./drawing/settings/setting")


            ## add a list.

            if len(self.settings) is not 0:
                target = smartAddSubTags(r, "./drawing/settings/setting")
                # add them in sorted order.  This gives us a simple canonicalization that makes it feasible to use diff to compare files.
                target.extend([i.get_et() for i in sorted(self.settings,key=lambda x: x.sortkey())])


            ## For some tags, Eagle generates empty tags when there's no contant
            ## rather than just leaving the tag out.  We mark these with
            ## Tag.requireTag in GenerateSwoop.py and force their generation
            ## here.



            ## or add a singleton.

            if self.grid is not None:
                target = smartAddSubTags(r, "./drawing/grid")
                target.append(self.grid.get_et())

            ## For some tags, Eagle generates empty tags when there's no contant
            ## rather than just leaving the tag out.  We mark these with
            ## Tag.requireTag in GenerateSwoop.py and force their generation
            ## here.



            ## add a map.

            if len(self.layers) is not 0:
                target = smartAddSubTags(r, "./drawing/layers/layer")
                # add them in sorted order.  This gives us a simple canonicalization that makes it feasible to use diff to compare files.
                target.extend([i.get_et() for i in sorted(list(self.layers.values()),key=lambda x: x.sortkey())])


            ## For some tags, Eagle generates empty tags when there's no contant
            ## rather than just leaving the tag out.  We mark these with
            ## Tag.requireTag in GenerateSwoop.py and force their generation
            ## here.

            smartAddSubTags(r, "./drawing/board/description")


            ## or add a singleton.

            if self.description is not None:
                target = smartAddSubTags(r, "./drawing/board/description")
                target.append(self.description.get_et())

            ## For some tags, Eagle generates empty tags when there's no contant
            ## rather than just leaving the tag out.  We mark these with
            ## Tag.requireTag in GenerateSwoop.py and force their generation
            ## here.

            smartAddSubTags(r, "./drawing/board/plain/polygon|./drawing/board/plain/wire|./drawing/board/plain/text|./drawing/board/plain/dimension|./drawing/board/plain/circle|./drawing/board/plain/rectangle|./drawing/board/plain/frame|./drawing/board/plain/hole")


            ## add a list.

            if len(self.plain_elements) is not 0:
                target = smartAddSubTags(r, "./drawing/board/plain/polygon|./drawing/board/plain/wire|./drawing/board/plain/text|./drawing/board/plain/dimension|./drawing/board/plain/circle|./drawing/board/plain/rectangle|./drawing/board/plain/frame|./drawing/board/plain/hole")
                # add them in sorted order.  This gives us a simple canonicalization that makes it feasible to use diff to compare files.
                target.extend([i.get_et() for i in sorted(self.plain_elements,key=lambda x: x.sortkey())])


            ## For some tags, Eagle generates empty tags when there's no contant
            ## rather than just leaving the tag out.  We mark these with
            ## Tag.requireTag in GenerateSwoop.py and force their generation
            ## here.

            smartAddSubTags(r, "./drawing/board/libraries/library")


            ## add a map.

            if len(self.libraries) is not 0:
                target = smartAddSubTags(r, "./drawing/board/libraries/library")
                # add them in sorted order.  This gives us a simple canonicalization that makes it feasible to use diff to compare files.
                target.extend([i.get_et() for i in sorted(list(self.libraries.values()),key=lambda x: x.sortkey())])


            ## For some tags, Eagle generates empty tags when there's no contant
            ## rather than just leaving the tag out.  We mark these with
            ## Tag.requireTag in GenerateSwoop.py and force their generation
            ## here.

            smartAddSubTags(r, "./drawing/board/attributes/attribute")


            ## add a map.

            if len(self.attributes) is not 0:
                target = smartAddSubTags(r, "./drawing/board/attributes/attribute")
                # add them in sorted order.  This gives us a simple canonicalization that makes it feasible to use diff to compare files.
                target.extend([i.get_et() for i in sorted(list(self.attributes.values()),key=lambda x: x.sortkey())])


            ## For some tags, Eagle generates empty tags when there's no contant
            ## rather than just leaving the tag out.  We mark these with
            ## Tag.requireTag in GenerateSwoop.py and force their generation
            ## here.

            smartAddSubTags(r, "./drawing/board/variantdefs/variantdef")


            ## add a map.

            if len(self.variantdefs) is not 0:
                target = smartAddSubTags(r, "./drawing/board/variantdefs/variantdef")
                # add them in sorted order.  This gives us a simple canonicalization that makes it feasible to use diff to compare files.
                target.extend([i.get_et() for i in sorted(list(self.variantdefs.values()),key=lambda x: x.sortkey())])


            ## For some tags, Eagle generates empty tags when there's no contant
            ## rather than just leaving the tag out.  We mark these with
            ## Tag.requireTag in GenerateSwoop.py and force their generation
            ## here.



            ## add a map.

            if len(self.classes) is not 0:
                target = smartAddSubTags(r, "./drawing/board/classes/class")
                # add them in sorted order.  This gives us a simple canonicalization that makes it feasible to use diff to compare files.
                target.extend([i.get_et() for i in sorted(list(self.classes.values()),key=lambda x: x.sortkey())])


            ## For some tags, Eagle generates empty tags when there's no contant
            ## rather than just leaving the tag out.  We mark these with
            ## Tag.requireTag in GenerateSwoop.py and force their generation
            ## here.



            ## or add a singleton.

            if self.designrules is not None:
                target = smartAddSubTags(r, "./drawing/board/designrules")
                target.append(self.designrules.get_et())

            ## For some tags, Eagle generates empty tags when there's no contant
            ## rather than just leaving the tag out.  We mark these with
            ## Tag.requireTag in GenerateSwoop.py and force their generation
            ## here.



            ## add a map.

            if len(self.autorouter_passes) is not 0:
                target = smartAddSubTags(r, "./drawing/board/autorouter/pass")
                # add them in sorted order.  This gives us a simple canonicalization that makes it feasible to use diff to compare files.
                target.extend([i.get_et() for i in sorted(list(self.autorouter_passes.values()),key=lambda x: x.sortkey())])


            ## For some tags, Eagle generates empty tags when there's no contant
            ## rather than just leaving the tag out.  We mark these with
            ## Tag.requireTag in GenerateSwoop.py and force their generation
            ## here.

            smartAddSubTags(r, "./drawing/board/elements/element")


            ## add a map.

            if len(self.elements) is not 0:
                target = smartAddSubTags(r, "./drawing/board/elements/element")
                # add them in sorted order.  This gives us a simple canonicalization that makes it feasible to use diff to compare files.
                target.extend([i.get_et() for i in sorted(list(self.elements.values()),key=lambda x: x.sortkey())])


            ## For some tags, Eagle generates empty tags when there's no contant
            ## rather than just leaving the tag out.  We mark these with
            ## Tag.requireTag in GenerateSwoop.py and force their generation
            ## here.

            smartAddSubTags(r, "./drawing/board/signals/signal")


            ## add a map.

            if len(self.signals) is not 0:
                target = smartAddSubTags(r, "./drawing/board/signals/signal")
                # add them in sorted order.  This gives us a simple canonicalization that makes it feasible to use diff to compare files.
                target.extend([i.get_et() for i in sorted(list(self.signals.values()),key=lambda x: x.sortkey())])


            ## For some tags, Eagle generates empty tags when there's no contant
            ## rather than just leaving the tag out.  We mark these with
            ## Tag.requireTag in GenerateSwoop.py and force their generation
            ## here.



            ## add a list.

            if len(self.mfgpreviewcolors) is not 0:
                target = smartAddSubTags(r, "./drawing/board/mfgpreviewcolors/mfgpreviewcolor")
                # add them in sorted order.  This gives us a simple canonicalization that makes it feasible to use diff to compare files.
                target.extend([i.get_et() for i in sorted(self.mfgpreviewcolors,key=lambda x: x.sortkey())])


            ## For some tags, Eagle generates empty tags when there's no contant
            ## rather than just leaving the tag out.  We mark these with
            ## Tag.requireTag in GenerateSwoop.py and force their generation
            ## here.



            ## add a list.

            if len(self.approved_errors) is not 0:
                target = smartAddSubTags(r, "./drawing/board/errors/approved")
                # add them in sorted order.  This gives us a simple canonicalization that makes it feasible to use diff to compare files.
                target.extend([i.get_et() for i in sorted(self.approved_errors,key=lambda x: x.sortkey())])


            ## For some tags, Eagle generates empty tags when there's no contant
            ## rather than just leaving the tag out.  We mark these with
            ## Tag.requireTag in GenerateSwoop.py and force their generation
            ## here.



            ## or add a singleton.

            if self.compatibility is not None:
                target = smartAddSubTags(r, "./compatibility")
                target.append(self.compatibility.get_et())

            ## set the text, if its needed.

        except SwoopError as e:
            e.text = "{}:{}".format(self._get_error_name(), e.text)
            raise e
        return r

    def clone(self):
        """
        Recursively clone this :code:`BoardFile`.  It will be identical to the original, but it's parent will be :code:`None`.
        
        :rtype: :class:`BoardFile`
        """
        try:
            n = copy.copy(self)
            n.layers = {}
            for x in list(self.layers.values()):
                n.add_layer(x.clone())
            n.libraries = {}
            for x in list(self.libraries.values()):
                n.add_library(x.clone())
            n.attributes = {}
            for x in list(self.attributes.values()):
                n.add_attribute(x.clone())
            n.variantdefs = {}
            for x in list(self.variantdefs.values()):
                n.add_variantdef(x.clone())
            n.classes = {}
            for x in list(self.classes.values()):
                n.add_class(x.clone())
            n.autorouter_passes = {}
            for x in list(self.autorouter_passes.values()):
                n.add_pass(x.clone())
            n.elements = {}
            for x in list(self.elements.values()):
                n.add_element(x.clone())
            n.signals = {}
            for x in list(self.signals.values()):
                n.add_signal(x.clone())
            n.settings = []
            for x in self.settings:
                n.add_setting(x.clone())
            n.plain_elements = []
            for x in self.plain_elements:
                n.add_plain_element(x.clone())
            n.mfgpreviewcolors = []
            for x in self.mfgpreviewcolors:
                n.add_mfgpreviewcolor(x.clone())
            n.approved_errors = []
            for x in self.approved_errors:
                n.add_approved(x.clone())
            n.grid = None
            if self.grid is not None:
                n.set_grid(self.grid.clone())
            else:
                n.set_grid(None)
            n.description = None
            if self.description is not None:
                n.set_description(self.description.clone())
            else:
                n.set_description(None)
            n.designrules = None
            if self.designrules is not None:
                n.set_designrules(self.designrules.clone())
            else:
                n.set_designrules(None)
            n.compatibility = None
            if self.compatibility is not None:
                n.set_compatibility(self.compatibility.clone())
            else:
                n.set_compatibility(None)
            n.parent = None
        except SwoopError as e:
            e.text = "{}:{}".format(self._get_error_name(), e.text)
            raise e
        return n

    def accept_preorder_visitor(self, visitor):
        try:
            pre = getattr(visitor, "BoardFile_pre")
            return pre(self)
        except AttributeError:
            return visitor.default_pre(self)
        
    def accept_postorder_visitor(self, visitor, context):
        try:
            post = getattr(visitor, "BoardFile_post")
            post(self,context)
        except AttributeError:
            visitor.default_post(self,context)

    def is_equal(self, other):
        """
        Check whether two :code:`EagleFilePart` objects are identical.
        
        :param other: Object to compare to.
        :returns: :code:`True` if they are identical, otherwise, :code:`False`
        """
        return self.get_xml() == other.get_xml()
        
    ### Getters/Setters for attribute values

    def get_version(self):
        """ Return the value of :code:`version` for this :class:`BoardFile`.  This corresponds to the :code:`version` attribute of a :code:`<eagle>` in an Eagle file.
        
        :rtype: :code:`str`
        """
        return self.version

    def set_version(self,v):
        """ Set the value of :code:`version` for this  :class:`BoardFile`.  This corresponds to the :code:`version` attribute of a :code:`<eagle>` in an Eagle file.

        :param v: new value
        :rtype: :code:`self`
        """
                        
        if not typeCheck("str", v, True):
            raise SwoopError("Illegal value ({}) of type {} for attribute 'version' of BoardFile object (should be str).".format(v, type(v)))
        self.version = v
        
        return self

    def with_version(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`version`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`version` equals :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_version()` is :code:`True`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """

        if type(v) in [str, int, float, bool]:
            return self if self.version == v else None
        elif callable(v):
            return self if v(self.version) else None
        else:
            raise SwoopError("Illegal type passed to with_version")

    def without_version(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`version`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`version` is not equal to :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_version()` is :code:`False`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """
        
        if type(v) in [str, int, float, bool]:
            return self if self.version != v else None
        elif callable(v):
            return self if not v(self.version) else None
        else:
            raise SwoopError("Illegal type passed to without_version")



    ##### Lookup functions that return EFPs instead of just attribute values.
    
    


    
    ### Adder/getter/lookup for lists
    
    def add_setting(self, s):
        """ Add a :class:`Setting` to the :code:`settings` of this :class:`BoardFile`.

        :param s: The :class:`Setting` to add.
        :rtype: :code:`self`
        """
        if not any([
                isinstance(s, Setting),
            ]):
            raise SwoopError("Argument to BoardFile.add_setting() should be of type Setting.  Got " + str(type(s).__name__) + ".")
        
        self.settings.append(s)
        if s.parent is not None and s.parent is not self:
            s.parent.remove_setting(s)

        s.parent = self
        return self

    def get_nth_setting(self, n):
        """ get then nth :class:`Setting` object from the :code:`settings` of this :class:`BoardFile`.
        
        :param n: Index of the item to return.

        :rtype: :class:`Setting` object
        """
        return self.settings[n]

    def get_settings(self, attrs=None, type=None):
        """Return (and possibly filter) items in the the :code:`settings` list of :class:`Setting` objects for this :class:`BoardFile`.
        
        This functions provides a mechanism for filtering the items as well.
        The keys in :code:`attrs` are taken as attributes names and the
        values are requested values.  Items in the list that have all the
        requested values for the corresponding attributes will be returned.  

        A if :code:`type` is not :code:`None`, the item will match if it is an
        instance of the type provided.
        
        :param attrs: A set of key-value pairs that represent a filter to apply to the item's attributes.
        :param type:  A type to filter on.  Only items that are an instance of this type will be returned.
        :returns: A List of :class:`Setting` objects
        :rtype: List of :class:`Setting` objects
        """
        if attrs is not None or type is not None:
            raise NotImplementedError("filtered get not implemented.")
        return self.settings

    def clear_settings(self):
        """
        Remove all the :class:`Setting` objects from the :code:`settings` of this :class:`BoardFile`.
        
        :rtype: :code:`self`
        """
        for efp in self.settings:
            efp.parent = None
        self.settings = []
        return self

    def remove_setting(self, efp):
        """
        Remove a :class:`Setting` from the :code:`settings` of this :class:`BoardFile`.
        
        :param efp: The :class:`Setting` object to remove.

        :rtype: :code:`self`
        """
        self.settings = [x for x in self.settings if x != efp]

        if efp.parent is self:
            efp.parent = None
        return self

    def add_plain_element(self, s):
        """ Add a :class:`Polygon`, :class:`Wire`, :class:`Text`, :class:`Dimension`, :class:`Circle`, :class:`Rectangle`, :class:`Frame` or :class:`Hole` to the :code:`plain_elements` of this :class:`BoardFile`.

        :param s: The :class:`Polygon`, :class:`Wire`, :class:`Text`, :class:`Dimension`, :class:`Circle`, :class:`Rectangle`, :class:`Frame` or :class:`Hole` to add.
        :rtype: :code:`self`
        """
        if not any([
                isinstance(s, Polygon),
                isinstance(s, Wire),
                isinstance(s, Text),
                isinstance(s, Dimension),
                isinstance(s, Circle),
                isinstance(s, Rectangle),
                isinstance(s, Frame),
                isinstance(s, Hole),
            ]):
            raise SwoopError("Argument to BoardFile.add_plain_element() should be of type Polygon, Wire, Text, Dimension, Circle, Rectangle, Frame or Hole.  Got " + str(type(s).__name__) + ".")
        
        self.plain_elements.append(s)
        if s.parent is not None and s.parent is not self:
            s.parent.remove_plain_element(s)

        s.parent = self
        return self

    def get_nth_plain_element(self, n):
        """ get then nth :class:`Polygon`, :class:`Wire`, :class:`Text`, :class:`Dimension`, :class:`Circle`, :class:`Rectangle`, :class:`Frame` or :class:`Hole` object from the :code:`plain_elements` of this :class:`BoardFile`.
        
        :param n: Index of the item to return.

        :rtype: :class:`Polygon`, :class:`Wire`, :class:`Text`, :class:`Dimension`, :class:`Circle`, :class:`Rectangle`, :class:`Frame` or :class:`Hole` object
        """
        return self.plain_elements[n]

    def get_plain_elements(self, attrs=None, type=None):
        """Return (and possibly filter) items in the the :code:`plain_elements` list of :class:`Polygon`, :class:`Wire`, :class:`Text`, :class:`Dimension`, :class:`Circle`, :class:`Rectangle`, :class:`Frame` or :class:`Hole` objects for this :class:`BoardFile`.
        
        This functions provides a mechanism for filtering the items as well.
        The keys in :code:`attrs` are taken as attributes names and the
        values are requested values.  Items in the list that have all the
        requested values for the corresponding attributes will be returned.  

        A if :code:`type` is not :code:`None`, the item will match if it is an
        instance of the type provided.
        
        :param attrs: A set of key-value pairs that represent a filter to apply to the item's attributes.
        :param type:  A type to filter on.  Only items that are an instance of this type will be returned.
        :returns: A List of :class:`Polygon`, :class:`Wire`, :class:`Text`, :class:`Dimension`, :class:`Circle`, :class:`Rectangle`, :class:`Frame` and :class:`Hole` objects
        :rtype: List of :class:`Polygon`, :class:`Wire`, :class:`Text`, :class:`Dimension`, :class:`Circle`, :class:`Rectangle`, :class:`Frame` and :class:`Hole` objects
        """
        if attrs is not None or type is not None:
            raise NotImplementedError("filtered get not implemented.")
        return self.plain_elements

    def clear_plain_elements(self):
        """
        Remove all the :class:`Polygon`, :class:`Wire`, :class:`Text`, :class:`Dimension`, :class:`Circle`, :class:`Rectangle`, :class:`Frame` and :class:`Hole` objects from the :code:`plain_elements` of this :class:`BoardFile`.
        
        :rtype: :code:`self`
        """
        for efp in self.plain_elements:
            efp.parent = None
        self.plain_elements = []
        return self

    def remove_plain_element(self, efp):
        """
        Remove a :class:`Polygon`, :class:`Wire`, :class:`Text`, :class:`Dimension`, :class:`Circle`, :class:`Rectangle`, :class:`Frame` or :class:`Hole` from the :code:`plain_elements` of this :class:`BoardFile`.
        
        :param efp: The :class:`Polygon`, :class:`Wire`, :class:`Text`, :class:`Dimension`, :class:`Circle`, :class:`Rectangle`, :class:`Frame` or :class:`Hole` object to remove.

        :rtype: :code:`self`
        """
        self.plain_elements = [x for x in self.plain_elements if x != efp]

        if efp.parent is self:
            efp.parent = None
        return self

    def add_mfgpreviewcolor(self, s):
        """ Add a :class:`Mfgpreviewcolor` to the :code:`mfgpreviewcolors` of this :class:`BoardFile`.

        :param s: The :class:`Mfgpreviewcolor` to add.
        :rtype: :code:`self`
        """
        if not any([
                isinstance(s, Mfgpreviewcolor),
            ]):
            raise SwoopError("Argument to BoardFile.add_mfgpreviewcolor() should be of type Mfgpreviewcolor.  Got " + str(type(s).__name__) + ".")
        
        self.mfgpreviewcolors.append(s)
        if s.parent is not None and s.parent is not self:
            s.parent.remove_mfgpreviewcolor(s)

        s.parent = self
        return self

    def get_nth_mfgpreviewcolor(self, n):
        """ get then nth :class:`Mfgpreviewcolor` object from the :code:`mfgpreviewcolors` of this :class:`BoardFile`.
        
        :param n: Index of the item to return.

        :rtype: :class:`Mfgpreviewcolor` object
        """
        return self.mfgpreviewcolors[n]

    def get_mfgpreviewcolors(self, attrs=None, type=None):
        """Return (and possibly filter) items in the the :code:`mfgpreviewcolors` list of :class:`Mfgpreviewcolor` objects for this :class:`BoardFile`.
        
        This functions provides a mechanism for filtering the items as well.
        The keys in :code:`attrs` are taken as attributes names and the
        values are requested values.  Items in the list that have all the
        requested values for the corresponding attributes will be returned.  

        A if :code:`type` is not :code:`None`, the item will match if it is an
        instance of the type provided.
        
        :param attrs: A set of key-value pairs that represent a filter to apply to the item's attributes.
        :param type:  A type to filter on.  Only items that are an instance of this type will be returned.
        :returns: A List of :class:`Mfgpreviewcolor` objects
        :rtype: List of :class:`Mfgpreviewcolor` objects
        """
        if attrs is not None or type is not None:
            raise NotImplementedError("filtered get not implemented.")
        return self.mfgpreviewcolors

    def clear_mfgpreviewcolors(self):
        """
        Remove all the :class:`Mfgpreviewcolor` objects from the :code:`mfgpreviewcolors` of this :class:`BoardFile`.
        
        :rtype: :code:`self`
        """
        for efp in self.mfgpreviewcolors:
            efp.parent = None
        self.mfgpreviewcolors = []
        return self

    def remove_mfgpreviewcolor(self, efp):
        """
        Remove a :class:`Mfgpreviewcolor` from the :code:`mfgpreviewcolors` of this :class:`BoardFile`.
        
        :param efp: The :class:`Mfgpreviewcolor` object to remove.

        :rtype: :code:`self`
        """
        self.mfgpreviewcolors = [x for x in self.mfgpreviewcolors if x != efp]

        if efp.parent is self:
            efp.parent = None
        return self

    def add_approved(self, s):
        """ Add a :class:`Approved` to the :code:`approved_errors` of this :class:`BoardFile`.

        :param s: The :class:`Approved` to add.
        :rtype: :code:`self`
        """
        if not any([
                isinstance(s, Approved),
            ]):
            raise SwoopError("Argument to BoardFile.add_approved() should be of type Approved.  Got " + str(type(s).__name__) + ".")
        
        self.approved_errors.append(s)
        if s.parent is not None and s.parent is not self:
            s.parent.remove_approved(s)

        s.parent = self
        return self

    def get_nth_approved(self, n):
        """ get then nth :class:`Approved` object from the :code:`approved_errors` of this :class:`BoardFile`.
        
        :param n: Index of the item to return.

        :rtype: :class:`Approved` object
        """
        return self.approved_errors[n]

    def get_approved_errors(self, attrs=None, type=None):
        """Return (and possibly filter) items in the the :code:`approved_errors` list of :class:`Approved` objects for this :class:`BoardFile`.
        
        This functions provides a mechanism for filtering the items as well.
        The keys in :code:`attrs` are taken as attributes names and the
        values are requested values.  Items in the list that have all the
        requested values for the corresponding attributes will be returned.  

        A if :code:`type` is not :code:`None`, the item will match if it is an
        instance of the type provided.
        
        :param attrs: A set of key-value pairs that represent a filter to apply to the item's attributes.
        :param type:  A type to filter on.  Only items that are an instance of this type will be returned.
        :returns: A List of :class:`Approved` objects
        :rtype: List of :class:`Approved` objects
        """
        if attrs is not None or type is not None:
            raise NotImplementedError("filtered get not implemented.")
        return self.approved_errors

    def clear_approved_errors(self):
        """
        Remove all the :class:`Approved` objects from the :code:`approved_errors` of this :class:`BoardFile`.
        
        :rtype: :code:`self`
        """
        for efp in self.approved_errors:
            efp.parent = None
        self.approved_errors = []
        return self

    def remove_approved(self, efp):
        """
        Remove a :class:`Approved` from the :code:`approved_errors` of this :class:`BoardFile`.
        
        :param efp: The :class:`Approved` object to remove.

        :rtype: :code:`self`
        """
        self.approved_errors = [x for x in self.approved_errors if x != efp]

        if efp.parent is self:
            efp.parent = None
        return self



    ### Add, lookup, and get for maps
    def add_library(self, s):
        """ Add a :class:`Library` to the :code:`libraries` of this :class:`BoardFile`.

        :param s: The :class:`Library` to add.
        :rtype: :code:`self`
        """
        if not any([
                isinstance(s, Library),
            ]):
            raise SwoopError("Argument to BoardFile.add_library() should be of type Library.  Got " + str(type(s).__name__) + ".")
        

        self.libraries[s.get_name()] = s

        s.parent = self
        return self

    def get_nth_library(self, n):
        """ get then nth :class:`Library` object from the :code:`libraries` of this :class:`BoardFile`.
        
        :param n: Index of the item to return.

        :rtype: :class:`Library` object
        """
        return list(self.libraries.values())[n]

    def get_library(self, key):
        """ Lookup and return a :class:`Library` from the :code:`libraries` of  this :class:`BoardFile`.
        
        :param key: A :code:`str` to use for the lookup.  The lookup uses the :code:`name` of the :class:`Library` objects.

        :rtype: A :class:`Library` object or :code:`None`, if there is no such item.
        """
        return self.libraries.get(key)


    def get_libraries(self, attrs=None, type=None):
        """Return (and possibly filter) items in the the :code:`libraries` map of :class:`Library` objects for this :class:`BoardFile`.
        
        This functions provides a mechanism for filtering the items as well.
        The keys in :code:`attrs` are taken as attributes names and the
        values are requested values.  Items in the list that have all the
        requested values for the corresponding attributes will be returned.  

        A if :code:`type` is not :code:`None`, the item will match if it is an
        instance of the type provided.
        
        :param attrs: A set of key-value pairs that represent a filter to apply to the item's attributes.
        :param type:  A type to filter on.  Only items that are an instance of this type will be returned.
        :returns: A List of :class:`Library` objects
        :rtype: List of :class:`Library` objects
        """
        if attrs is not None or type is not None:
            raise NotImplementedError("filtered get not implemented")
        return list(self.libraries.values())
        

    def clear_libraries(self):
        """
        Remove all the :class:`Library` objects from the :code:`libraries` of this :class:`BoardFile`.
        
        :rtype: :code:`self`
        """
        for efp in list(self.libraries.values()):
            efp.parent = None
        self.libraries = {}
        return self

    def remove_library(self, efp):
        """
        Remove a :class:`Library` from the :code:`libraries` of this :class:`BoardFile`.
        
        :param efp: The :class:`Library` object to remove.

        :rtype: :code:`self`
        """
        if self.libraries[efp.get_name()] == efp:
            del self.libraries[efp.get_name()]
            efp.parent = None
            return self
        else:
            raise SwoopError("Tried to use remove_library() to delete the wrong kind of child?: {}".format(str(efp)))
    
    def add_attribute(self, s):
        """ Add a :class:`Attribute` to the :code:`attributes` of this :class:`BoardFile`.

        :param s: The :class:`Attribute` to add.
        :rtype: :code:`self`
        """
        if not any([
                isinstance(s, Attribute),
            ]):
            raise SwoopError("Argument to BoardFile.add_attribute() should be of type Attribute.  Got " + str(type(s).__name__) + ".")
        

        self.attributes[s.get_name()] = s

        s.parent = self
        return self

    def get_nth_attribute(self, n):
        """ get then nth :class:`Attribute` object from the :code:`attributes` of this :class:`BoardFile`.
        
        :param n: Index of the item to return.

        :rtype: :class:`Attribute` object
        """
        return list(self.attributes.values())[n]

    def get_attribute(self, key):
        """ Lookup and return a :class:`Attribute` from the :code:`attributes` of  this :class:`BoardFile`.
        
        :param key: A :code:`str` to use for the lookup.  The lookup uses the :code:`name` of the :class:`Attribute` objects.

        :rtype: A :class:`Attribute` object or :code:`None`, if there is no such item.
        """
        return self.attributes.get(key)


    def get_attributes(self, attrs=None, type=None):
        """Return (and possibly filter) items in the the :code:`attributes` map of :class:`Attribute` objects for this :class:`BoardFile`.
        
        This functions provides a mechanism for filtering the items as well.
        The keys in :code:`attrs` are taken as attributes names and the
        values are requested values.  Items in the list that have all the
        requested values for the corresponding attributes will be returned.  

        A if :code:`type` is not :code:`None`, the item will match if it is an
        instance of the type provided.
        
        :param attrs: A set of key-value pairs that represent a filter to apply to the item's attributes.
        :param type:  A type to filter on.  Only items that are an instance of this type will be returned.
        :returns: A List of :class:`Attribute` objects
        :rtype: List of :class:`Attribute` objects
        """
        if attrs is not None or type is not None:
            raise NotImplementedError("filtered get not implemented")
        return list(self.attributes.values())
        

    def clear_attributes(self):
        """
        Remove all the :class:`Attribute` objects from the :code:`attributes` of this :class:`BoardFile`.
        
        :rtype: :code:`self`
        """
        for efp in list(self.attributes.values()):
            efp.parent = None
        self.attributes = {}
        return self

    def remove_attribute(self, efp):
        """
        Remove a :class:`Attribute` from the :code:`attributes` of this :class:`BoardFile`.
        
        :param efp: The :class:`Attribute` object to remove.

        :rtype: :code:`self`
        """
        if self.attributes[efp.get_name()] == efp:
            del self.attributes[efp.get_name()]
            efp.parent = None
            return self
        else:
            raise SwoopError("Tried to use remove_attribute() to delete the wrong kind of child?: {}".format(str(efp)))
    
    def add_variantdef(self, s):
        """ Add a :class:`Variantdef` to the :code:`variantdefs` of this :class:`BoardFile`.

        :param s: The :class:`Variantdef` to add.
        :rtype: :code:`self`
        """
        if not any([
                isinstance(s, Variantdef),
            ]):
            raise SwoopError("Argument to BoardFile.add_variantdef() should be of type Variantdef.  Got " + str(type(s).__name__) + ".")
        

        self.variantdefs[s.get_name()] = s

        s.parent = self
        return self

    def get_nth_variantdef(self, n):
        """ get then nth :class:`Variantdef` object from the :code:`variantdefs` of this :class:`BoardFile`.
        
        :param n: Index of the item to return.

        :rtype: :class:`Variantdef` object
        """
        return list(self.variantdefs.values())[n]

    def get_variantdef(self, key):
        """ Lookup and return a :class:`Variantdef` from the :code:`variantdefs` of  this :class:`BoardFile`.
        
        :param key: A :code:`str` to use for the lookup.  The lookup uses the :code:`name` of the :class:`Variantdef` objects.

        :rtype: A :class:`Variantdef` object or :code:`None`, if there is no such item.
        """
        return self.variantdefs.get(key)


    def get_variantdefs(self, attrs=None, type=None):
        """Return (and possibly filter) items in the the :code:`variantdefs` map of :class:`Variantdef` objects for this :class:`BoardFile`.
        
        This functions provides a mechanism for filtering the items as well.
        The keys in :code:`attrs` are taken as attributes names and the
        values are requested values.  Items in the list that have all the
        requested values for the corresponding attributes will be returned.  

        A if :code:`type` is not :code:`None`, the item will match if it is an
        instance of the type provided.
        
        :param attrs: A set of key-value pairs that represent a filter to apply to the item's attributes.
        :param type:  A type to filter on.  Only items that are an instance of this type will be returned.
        :returns: A List of :class:`Variantdef` objects
        :rtype: List of :class:`Variantdef` objects
        """
        if attrs is not None or type is not None:
            raise NotImplementedError("filtered get not implemented")
        return list(self.variantdefs.values())
        

    def clear_variantdefs(self):
        """
        Remove all the :class:`Variantdef` objects from the :code:`variantdefs` of this :class:`BoardFile`.
        
        :rtype: :code:`self`
        """
        for efp in list(self.variantdefs.values()):
            efp.parent = None
        self.variantdefs = {}
        return self

    def remove_variantdef(self, efp):
        """
        Remove a :class:`Variantdef` from the :code:`variantdefs` of this :class:`BoardFile`.
        
        :param efp: The :class:`Variantdef` object to remove.

        :rtype: :code:`self`
        """
        if self.variantdefs[efp.get_name()] == efp:
            del self.variantdefs[efp.get_name()]
            efp.parent = None
            return self
        else:
            raise SwoopError("Tried to use remove_variantdef() to delete the wrong kind of child?: {}".format(str(efp)))
    
    def add_class(self, s):
        """ Add a :class:`Class` to the :code:`classes` of this :class:`BoardFile`.

        :param s: The :class:`Class` to add.
        :rtype: :code:`self`
        """
        if not any([
                isinstance(s, Class),
            ]):
            raise SwoopError("Argument to BoardFile.add_class() should be of type Class.  Got " + str(type(s).__name__) + ".")
        

        self.classes[s.get_name()] = s

        s.parent = self
        return self

    def get_nth_class(self, n):
        """ get then nth :class:`Class` object from the :code:`classes` of this :class:`BoardFile`.
        
        :param n: Index of the item to return.

        :rtype: :class:`Class` object
        """
        return list(self.classes.values())[n]

    def get_class(self, key):
        """ Lookup and return a :class:`Class` from the :code:`classes` of  this :class:`BoardFile`.
        
        :param key: A :code:`str` to use for the lookup.  The lookup uses the :code:`name` of the :class:`Class` objects.

        :rtype: A :class:`Class` object or :code:`None`, if there is no such item.
        """
        return self.classes.get(key)


    def get_classes(self, attrs=None, type=None):
        """Return (and possibly filter) items in the the :code:`classes` map of :class:`Class` objects for this :class:`BoardFile`.
        
        This functions provides a mechanism for filtering the items as well.
        The keys in :code:`attrs` are taken as attributes names and the
        values are requested values.  Items in the list that have all the
        requested values for the corresponding attributes will be returned.  

        A if :code:`type` is not :code:`None`, the item will match if it is an
        instance of the type provided.
        
        :param attrs: A set of key-value pairs that represent a filter to apply to the item's attributes.
        :param type:  A type to filter on.  Only items that are an instance of this type will be returned.
        :returns: A List of :class:`Class` objects
        :rtype: List of :class:`Class` objects
        """
        if attrs is not None or type is not None:
            raise NotImplementedError("filtered get not implemented")
        return list(self.classes.values())
        

    def clear_classes(self):
        """
        Remove all the :class:`Class` objects from the :code:`classes` of this :class:`BoardFile`.
        
        :rtype: :code:`self`
        """
        for efp in list(self.classes.values()):
            efp.parent = None
        self.classes = {}
        return self

    def remove_class(self, efp):
        """
        Remove a :class:`Class` from the :code:`classes` of this :class:`BoardFile`.
        
        :param efp: The :class:`Class` object to remove.

        :rtype: :code:`self`
        """
        if self.classes[efp.get_name()] == efp:
            del self.classes[efp.get_name()]
            efp.parent = None
            return self
        else:
            raise SwoopError("Tried to use remove_class() to delete the wrong kind of child?: {}".format(str(efp)))
    
    def add_pass(self, s):
        """ Add a :class:`Pass` to the :code:`autorouter_passes` of this :class:`BoardFile`.

        :param s: The :class:`Pass` to add.
        :rtype: :code:`self`
        """
        if not any([
                isinstance(s, Pass),
            ]):
            raise SwoopError("Argument to BoardFile.add_pass() should be of type Pass.  Got " + str(type(s).__name__) + ".")
        

        self.autorouter_passes[s.get_name()] = s

        s.parent = self
        return self

    def get_nth_pass(self, n):
        """ get then nth :class:`Pass` object from the :code:`autorouter_passes` of this :class:`BoardFile`.
        
        :param n: Index of the item to return.

        :rtype: :class:`Pass` object
        """
        return list(self.autorouter_passes.values())[n]

    def get_pass(self, key):
        """ Lookup and return a :class:`Pass` from the :code:`autorouter_passes` of  this :class:`BoardFile`.
        
        :param key: A :code:`str` to use for the lookup.  The lookup uses the :code:`name` of the :class:`Pass` objects.

        :rtype: A :class:`Pass` object or :code:`None`, if there is no such item.
        """
        return self.autorouter_passes.get(key)


    def get_autorouter_passes(self, attrs=None, type=None):
        """Return (and possibly filter) items in the the :code:`autorouter_passes` map of :class:`Pass` objects for this :class:`BoardFile`.
        
        This functions provides a mechanism for filtering the items as well.
        The keys in :code:`attrs` are taken as attributes names and the
        values are requested values.  Items in the list that have all the
        requested values for the corresponding attributes will be returned.  

        A if :code:`type` is not :code:`None`, the item will match if it is an
        instance of the type provided.
        
        :param attrs: A set of key-value pairs that represent a filter to apply to the item's attributes.
        :param type:  A type to filter on.  Only items that are an instance of this type will be returned.
        :returns: A List of :class:`Pass` objects
        :rtype: List of :class:`Pass` objects
        """
        if attrs is not None or type is not None:
            raise NotImplementedError("filtered get not implemented")
        return list(self.autorouter_passes.values())
        

    def clear_autorouter_passes(self):
        """
        Remove all the :class:`Pass` objects from the :code:`autorouter_passes` of this :class:`BoardFile`.
        
        :rtype: :code:`self`
        """
        for efp in list(self.autorouter_passes.values()):
            efp.parent = None
        self.autorouter_passes = {}
        return self

    def remove_pass(self, efp):
        """
        Remove a :class:`Pass` from the :code:`autorouter_passes` of this :class:`BoardFile`.
        
        :param efp: The :class:`Pass` object to remove.

        :rtype: :code:`self`
        """
        if self.autorouter_passes[efp.get_name()] == efp:
            del self.autorouter_passes[efp.get_name()]
            efp.parent = None
            return self
        else:
            raise SwoopError("Tried to use remove_pass() to delete the wrong kind of child?: {}".format(str(efp)))
    
    def add_element(self, s):
        """ Add a :class:`Element` to the :code:`elements` of this :class:`BoardFile`.

        :param s: The :class:`Element` to add.
        :rtype: :code:`self`
        """
        if not any([
                isinstance(s, Element),
            ]):
            raise SwoopError("Argument to BoardFile.add_element() should be of type Element.  Got " + str(type(s).__name__) + ".")
        

        self.elements[s.get_name()] = s

        s.parent = self
        return self

    def get_nth_element(self, n):
        """ get then nth :class:`Element` object from the :code:`elements` of this :class:`BoardFile`.
        
        :param n: Index of the item to return.

        :rtype: :class:`Element` object
        """
        return list(self.elements.values())[n]

    def get_element(self, key):
        """ Lookup and return a :class:`Element` from the :code:`elements` of  this :class:`BoardFile`.
        
        :param key: A :code:`str` to use for the lookup.  The lookup uses the :code:`name` of the :class:`Element` objects.

        :rtype: A :class:`Element` object or :code:`None`, if there is no such item.
        """
        return self.elements.get(key)


    def get_elements(self, attrs=None, type=None):
        """Return (and possibly filter) items in the the :code:`elements` map of :class:`Element` objects for this :class:`BoardFile`.
        
        This functions provides a mechanism for filtering the items as well.
        The keys in :code:`attrs` are taken as attributes names and the
        values are requested values.  Items in the list that have all the
        requested values for the corresponding attributes will be returned.  

        A if :code:`type` is not :code:`None`, the item will match if it is an
        instance of the type provided.
        
        :param attrs: A set of key-value pairs that represent a filter to apply to the item's attributes.
        :param type:  A type to filter on.  Only items that are an instance of this type will be returned.
        :returns: A List of :class:`Element` objects
        :rtype: List of :class:`Element` objects
        """
        if attrs is not None or type is not None:
            raise NotImplementedError("filtered get not implemented")
        return list(self.elements.values())
        

    def clear_elements(self):
        """
        Remove all the :class:`Element` objects from the :code:`elements` of this :class:`BoardFile`.
        
        :rtype: :code:`self`
        """
        for efp in list(self.elements.values()):
            efp.parent = None
        self.elements = {}
        return self

    def remove_element(self, efp):
        """
        Remove a :class:`Element` from the :code:`elements` of this :class:`BoardFile`.
        
        :param efp: The :class:`Element` object to remove.

        :rtype: :code:`self`
        """
        if self.elements[efp.get_name()] == efp:
            del self.elements[efp.get_name()]
            efp.parent = None
            return self
        else:
            raise SwoopError("Tried to use remove_element() to delete the wrong kind of child?: {}".format(str(efp)))
    
    def add_signal(self, s):
        """ Add a :class:`Signal` to the :code:`signals` of this :class:`BoardFile`.

        :param s: The :class:`Signal` to add.
        :rtype: :code:`self`
        """
        if not any([
                isinstance(s, Signal),
            ]):
            raise SwoopError("Argument to BoardFile.add_signal() should be of type Signal.  Got " + str(type(s).__name__) + ".")
        

        self.signals[s.get_name()] = s

        s.parent = self
        return self

    def get_nth_signal(self, n):
        """ get then nth :class:`Signal` object from the :code:`signals` of this :class:`BoardFile`.
        
        :param n: Index of the item to return.

        :rtype: :class:`Signal` object
        """
        return list(self.signals.values())[n]

    def get_signal(self, key):
        """ Lookup and return a :class:`Signal` from the :code:`signals` of  this :class:`BoardFile`.
        
        :param key: A :code:`str` to use for the lookup.  The lookup uses the :code:`name` of the :class:`Signal` objects.

        :rtype: A :class:`Signal` object or :code:`None`, if there is no such item.
        """
        return self.signals.get(key)


    def get_signals(self, attrs=None, type=None):
        """Return (and possibly filter) items in the the :code:`signals` map of :class:`Signal` objects for this :class:`BoardFile`.
        
        This functions provides a mechanism for filtering the items as well.
        The keys in :code:`attrs` are taken as attributes names and the
        values are requested values.  Items in the list that have all the
        requested values for the corresponding attributes will be returned.  

        A if :code:`type` is not :code:`None`, the item will match if it is an
        instance of the type provided.
        
        :param attrs: A set of key-value pairs that represent a filter to apply to the item's attributes.
        :param type:  A type to filter on.  Only items that are an instance of this type will be returned.
        :returns: A List of :class:`Signal` objects
        :rtype: List of :class:`Signal` objects
        """
        if attrs is not None or type is not None:
            raise NotImplementedError("filtered get not implemented")
        return list(self.signals.values())
        

    def clear_signals(self):
        """
        Remove all the :class:`Signal` objects from the :code:`signals` of this :class:`BoardFile`.
        
        :rtype: :code:`self`
        """
        for efp in list(self.signals.values()):
            efp.parent = None
        self.signals = {}
        return self

    def remove_signal(self, efp):
        """
        Remove a :class:`Signal` from the :code:`signals` of this :class:`BoardFile`.
        
        :param efp: The :class:`Signal` object to remove.

        :rtype: :code:`self`
        """
        if self.signals[efp.get_name()] == efp:
            del self.signals[efp.get_name()]
            efp.parent = None
            return self
        else:
            raise SwoopError("Tried to use remove_signal() to delete the wrong kind of child?: {}".format(str(efp)))
    


    
    ### Getter/Setter for singletons.

    def set_grid(self, s):
        """ Set the :class:`Grid` for this  :class:`BoardFile`.

        :param s: :class:`Grid` to set.
        :rtype: :code:`self`
        """
        if self.grid is not None:
            self.grid.parent = None
        self.grid = s
        if s is not None:
            s.parent = self
        return self

    def get_grid(self):
        """ Get the grid from this :class:`BoardFile`.
        
        :rtype: :class:`Grid` object
        """
        return self.grid

    def set_description(self, s):
        """ Set the :class:`Description` for this  :class:`BoardFile`.

        :param s: :class:`Description` to set.
        :rtype: :code:`self`
        """
        if self.description is not None:
            self.description.parent = None
        self.description = s
        if s is not None:
            s.parent = self
        return self

    def get_description(self):
        """ Get the description from this :class:`BoardFile`.
        
        :rtype: :class:`Description` object
        """
        return self.description

    def set_designrules(self, s):
        """ Set the :class:`Designrules` for this  :class:`BoardFile`.

        :param s: :class:`Designrules` to set.
        :rtype: :code:`self`
        """
        if self.designrules is not None:
            self.designrules.parent = None
        self.designrules = s
        if s is not None:
            s.parent = self
        return self

    def get_designrules(self):
        """ Get the designrules from this :class:`BoardFile`.
        
        :rtype: :class:`Designrules` object
        """
        return self.designrules

    def set_compatibility(self, s):
        """ Set the :class:`Compatibility` for this  :class:`BoardFile`.

        :param s: :class:`Compatibility` to set.
        :rtype: :code:`self`
        """
        if self.compatibility is not None:
            self.compatibility.parent = None
        self.compatibility = s
        if s is not None:
            s.parent = self
        return self

    def get_compatibility(self):
        """ Get the compatibility from this :class:`BoardFile`.
        
        :rtype: :class:`Compatibility` object
        """
        return self.compatibility


    
    def get_children(self):
        """
        Get all the children of this :class:`EagleFilePart`.
        
        :rtype: List of :class:`EagleFilePart` objects
        """
        r = []

        r = r + self.settings
        r = r + self.plain_elements
        r = r + self.mfgpreviewcolors
        r = r + self.approved_errors

        r = r + list(self.layers.values())
        r = r + list(self.libraries.values())
        r = r + list(self.attributes.values())
        r = r + list(self.variantdefs.values())
        r = r + list(self.classes.values())
        r = r + list(self.autorouter_passes.values())
        r = r + list(self.elements.values())
        r = r + list(self.signals.values())

        if self.grid is not None:
            r = r + [self.grid]
        if self.description is not None:
            r = r + [self.description]
        if self.designrules is not None:
            r = r + [self.designrules]
        if self.compatibility is not None:
            r = r + [self.compatibility]

        return r

    def remove_child(self, efp):
        """
        Remove a child :class:`EagleFilePart` object.
        
        :param efp: the class:`EagleFilePart` object to remove.
        :return: Nothing
        """
        try:
            self.remove_layer(efp)
        except:
            pass
        try:
            self.remove_library(efp)
        except:
            pass
        try:
            self.remove_attribute(efp)
        except:
            pass
        try:
            self.remove_variantdef(efp)
        except:
            pass
        try:
            self.remove_class(efp)
        except:
            pass
        try:
            self.remove_pass(efp)
        except:
            pass
        try:
            self.remove_element(efp)
        except:
            pass
        try:
            self.remove_signal(efp)
        except:
            pass
        try:
            self.remove_setting(efp)
        except:
            pass
        try:
            self.remove_plain_element(efp)
        except:
            pass
        try:
            self.remove_mfgpreviewcolor(efp)
        except:
            pass
        try:
            self.remove_approved(efp)
        except:
            pass
        if self.get_grid() == efp:
            self.set_grid(None)
        if self.get_description() == efp:
            self.set_description(None)
        if self.get_designrules() == efp:
            self.set_designrules(None)
        if self.get_compatibility() == efp:
            self.set_compatibility(None)

    def _rekey_child(self, oldkey, efp):
        """
        Remove a child :class:`EagleFilePart` object.
        
        :param efp: the class:`EagleFilePart` object to remove.
        :return: Nothing
        """
        try:
            if self.get_layer(oldkey) == efp:
                del self.layers[oldkey]
                self.add_layer(efp)
        except SwoopError:
            pass
        try:
            if self.get_library(oldkey) == efp:
                del self.libraries[oldkey]
                self.add_library(efp)
        except SwoopError:
            pass
        try:
            if self.get_attribute(oldkey) == efp:
                del self.attributes[oldkey]
                self.add_attribute(efp)
        except SwoopError:
            pass
        try:
            if self.get_variantdef(oldkey) == efp:
                del self.variantdefs[oldkey]
                self.add_variantdef(efp)
        except SwoopError:
            pass
        try:
            if self.get_class(oldkey) == efp:
                del self.classes[oldkey]
                self.add_class(efp)
        except SwoopError:
            pass
        try:
            if self.get_pass(oldkey) == efp:
                del self.autorouter_passes[oldkey]
                self.add_pass(efp)
        except SwoopError:
            pass
        try:
            if self.get_element(oldkey) == efp:
                del self.elements[oldkey]
                self.add_element(efp)
        except SwoopError:
            pass
        try:
            if self.get_signal(oldkey) == efp:
                del self.signals[oldkey]
                self.add_signal(efp)
        except SwoopError:
            pass

    def check_sanity(self, visited_efps = None):
        EagleFile.check_sanity(self, visited_efps)

        # Check whether keys in our maps match the keys in our children
        for k in self.layers:
            if self.layers[k].get_number() != k:
                raise SwoopError("Child's number ('{}') doesn't match key in parent's map ('{}')".format(self.layers[k].get_number(),k))
        for k in self.libraries:
            if self.libraries[k].get_name() != k:
                raise SwoopError("Child's name ('{}') doesn't match key in parent's map ('{}')".format(self.libraries[k].get_name(),k))
        for k in self.attributes:
            if self.attributes[k].get_name() != k:
                raise SwoopError("Child's name ('{}') doesn't match key in parent's map ('{}')".format(self.attributes[k].get_name(),k))
        for k in self.variantdefs:
            if self.variantdefs[k].get_name() != k:
                raise SwoopError("Child's name ('{}') doesn't match key in parent's map ('{}')".format(self.variantdefs[k].get_name(),k))
        for k in self.classes:
            if self.classes[k].get_name() != k:
                raise SwoopError("Child's name ('{}') doesn't match key in parent's map ('{}')".format(self.classes[k].get_name(),k))
        for k in self.autorouter_passes:
            if self.autorouter_passes[k].get_name() != k:
                raise SwoopError("Child's name ('{}') doesn't match key in parent's map ('{}')".format(self.autorouter_passes[k].get_name(),k))
        for k in self.elements:
            if self.elements[k].get_name() != k:
                raise SwoopError("Child's name ('{}') doesn't match key in parent's map ('{}')".format(self.elements[k].get_name(),k))
        for k in self.signals:
            if self.signals[k].get_name() != k:
                raise SwoopError("Child's name ('{}') doesn't match key in parent's map ('{}')".format(self.signals[k].get_name(),k))

    def __str__(self):
        r = "["+repr(self)+" "
        r = r + "version:" + str(self.get_version()) + " "
        r = r + "]"
        return r
            
    def dump(self, indent="", increment="   "):
        """
        Recursive debug dump.
        
        :param indent:  Indentation string.  The output will be indented by this much.
        :param increment: This will be appendeded to :code:`indent` on recursive invocations.

        :rtype: :code:`None`
        """
        print(indent + str(self.__class__.__name__), end=' ')
        try:
            print(self.get_name())
        except:
            print()
            pass
        for c in self.get_children():
            c.dump(indent + "   ")

        
EagleFile.class_map["eagle"] = BoardFile
         


class Bus(EagleFilePart):
    """
    Class representing the contents of a <bus> tag in Eagle files.

    Attributes:

    * :code:`name`



    Collections:


    * :code:`segment`: List of :class:`Segment` objects.



    """
    def __init__(self):
        """
        Construct an empty :class:`Bus` object.
        """
        EagleFilePart.__init__(self)
        
        self.name=None
        self.segments=[]


        
    @classmethod
    def _from_et(cls,root,parent):
        """
        Create a :class:`Bus` from a :code:`bus` element.
        
        :param root: The element tree tree to parse.
        :param parent: :class:`EagleFilePart` that should hold the resulting :class:`EagleFilePart`
        :rtype: :class:`Bus`
        """
        ## Call the constructor
        n = cls()
        n._init_from_et(root,parent)
        return n

    def _get_error_name(self):
        if hasattr(self, "get_name"):
            return self.get_name();
        else:
            return "Bus";
        
    def  _init_from_et(self, root, parent):
        """
        Initialized a :class:`Bus` from a :code:`bus` element.  This is useful if you have a subclass of :class:`Bus` .
        
        :param root: The element tree tree to parse.
        :param parent: :class:`EagleFilePart` that will become the parent of :code:`this` .
        :rtype: :class:`Bus`
        """
        try:
            self.root = root
            
            if root.tag != "bus":
                raise EagleFormatError("Tried to create bus from " + root.tag)

            self.name=parseByType(parent, "str", None, root.get("name"))

            self.parent = parent

            ### populate the maps by searching for elements that match xpath and generating objects for them.


            ### Do the same for the lists

            for c in root.xpath("./segment"):
                self.add_segment(self.get_class_for_tag(c.tag)._from_et(c,self))

            ### Do the same for the attr lists


            ### And the singletons


            ### And, finally, if the objects wants the text from the tag.

        except SwoopError as e:
            e.text = "{}:{}".format(self._get_error_name(), e.text)
            raise e


    def sortkey(self):
        r = ""
        r = r + str(self.name)
        return r

    def get_et(self):
        """
        Generate a <bus> element tree for a :class:`Bus`.
        
        :rtype:  :class:`ElementTree`.
        
        """
        try:
            r = ET.Element("bus")

            ### Set the tag attributes 


            ## Unparse the values.

            v = unparseByType(self, "str", None,  self.name)

            ## For required attributes None becomes "".  For optional attributes, we just leave the attribute out.
            if not (isinstance(self.get_parent(), LibraryFile) and False):  # special case for the name of library.
                if v is not None:
                    r.set("name", v)
                else:
                    r.set("name", "")


            ### process the sections in order.  They have to be in section order,
            ### because eagle files are order dependent.


            ## For some tags, Eagle generates empty tags when there's no contant
            ## rather than just leaving the tag out.  We mark these with
            ## Tag.requireTag in GenerateSwoop.py and force their generation
            ## here.



            ## add a list.

            if len(self.segments) is not 0:
                target = smartAddSubTags(r, "./segment")
                # add them in sorted order.  This gives us a simple canonicalization that makes it feasible to use diff to compare files.
                target.extend([i.get_et() for i in sorted(self.segments,key=lambda x: x.sortkey())])


            ## set the text, if its needed.

        except SwoopError as e:
            e.text = "{}:{}".format(self._get_error_name(), e.text)
            raise e
        return r

    def clone(self):
        """
        Recursively clone this :code:`Bus`.  It will be identical to the original, but it's parent will be :code:`None`.
        
        :rtype: :class:`Bus`
        """
        try:
            n = copy.copy(self)
            n.segments = []
            for x in self.segments:
                n.add_segment(x.clone())
            n.parent = None
        except SwoopError as e:
            e.text = "{}:{}".format(self._get_error_name(), e.text)
            raise e
        return n

    def accept_preorder_visitor(self, visitor):
        try:
            pre = getattr(visitor, "Bus_pre")
            return pre(self)
        except AttributeError:
            return visitor.default_pre(self)
        
    def accept_postorder_visitor(self, visitor, context):
        try:
            post = getattr(visitor, "Bus_post")
            post(self,context)
        except AttributeError:
            visitor.default_post(self,context)

    def is_equal(self, other):
        """
        Check whether two :code:`EagleFilePart` objects are identical.
        
        :param other: Object to compare to.
        :returns: :code:`True` if they are identical, otherwise, :code:`False`
        """
        return self.get_xml() == other.get_xml()
        
    ### Getters/Setters for attribute values

    def get_name(self):
        """ Return the value of :code:`name` for this :class:`Bus`.  This corresponds to the :code:`name` attribute of a :code:`<bus>` in an Eagle file.
        
        :rtype: :code:`str`
        """
        return self.name

    def set_name(self,v):
        """ Set the value of :code:`name` for this  :class:`Bus`.  This corresponds to the :code:`name` attribute of a :code:`<bus>` in an Eagle file.

        :param v: new value
        :rtype: :code:`self`
        """
                        
        oldkey = self.name
        if not typeCheck("str", v, True):
            raise SwoopError("Illegal value ({}) of type {} for attribute 'name' of Bus object (should be str).".format(v, type(v)))
        self.name = v
        
        if self.get_parent() is not None:
            self.get_parent()._rekey_child(oldkey, self);
        return self

    def with_name(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`name`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`name` equals :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_name()` is :code:`True`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """

        if type(v) in [str, int, float, bool]:
            return self if self.name == v else None
        elif callable(v):
            return self if v(self.name) else None
        else:
            raise SwoopError("Illegal type passed to with_name")

    def without_name(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`name`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`name` is not equal to :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_name()` is :code:`False`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """
        
        if type(v) in [str, int, float, bool]:
            return self if self.name != v else None
        elif callable(v):
            return self if not v(self.name) else None
        else:
            raise SwoopError("Illegal type passed to without_name")



    ##### Lookup functions that return EFPs instead of just attribute values.
    
    


    
    ### Adder/getter/lookup for lists
    
    def add_segment(self, s):
        """ Add a :class:`Segment` to the :code:`segments` of this :class:`Bus`.

        :param s: The :class:`Segment` to add.
        :rtype: :code:`self`
        """
        if not any([
                isinstance(s, Segment),
            ]):
            raise SwoopError("Argument to Bus.add_segment() should be of type Segment.  Got " + str(type(s).__name__) + ".")
        
        self.segments.append(s)
        if s.parent is not None and s.parent is not self:
            s.parent.remove_segment(s)

        s.parent = self
        return self

    def get_nth_segment(self, n):
        """ get then nth :class:`Segment` object from the :code:`segments` of this :class:`Bus`.
        
        :param n: Index of the item to return.

        :rtype: :class:`Segment` object
        """
        return self.segments[n]

    def get_segments(self, attrs=None, type=None):
        """Return (and possibly filter) items in the the :code:`segments` list of :class:`Segment` objects for this :class:`Bus`.
        
        This functions provides a mechanism for filtering the items as well.
        The keys in :code:`attrs` are taken as attributes names and the
        values are requested values.  Items in the list that have all the
        requested values for the corresponding attributes will be returned.  

        A if :code:`type` is not :code:`None`, the item will match if it is an
        instance of the type provided.
        
        :param attrs: A set of key-value pairs that represent a filter to apply to the item's attributes.
        :param type:  A type to filter on.  Only items that are an instance of this type will be returned.
        :returns: A List of :class:`Segment` objects
        :rtype: List of :class:`Segment` objects
        """
        if attrs is not None or type is not None:
            raise NotImplementedError("filtered get not implemented.")
        return self.segments

    def clear_segments(self):
        """
        Remove all the :class:`Segment` objects from the :code:`segments` of this :class:`Bus`.
        
        :rtype: :code:`self`
        """
        for efp in self.segments:
            efp.parent = None
        self.segments = []
        return self

    def remove_segment(self, efp):
        """
        Remove a :class:`Segment` from the :code:`segments` of this :class:`Bus`.
        
        :param efp: The :class:`Segment` object to remove.

        :rtype: :code:`self`
        """
        self.segments = [x for x in self.segments if x != efp]

        if efp.parent is self:
            efp.parent = None
        return self



    ### Add, lookup, and get for maps


    
    ### Getter/Setter for singletons.


    
    def get_children(self):
        """
        Get all the children of this :class:`EagleFilePart`.
        
        :rtype: List of :class:`EagleFilePart` objects
        """
        r = []

        r = r + self.segments



        return r

    def remove_child(self, efp):
        """
        Remove a child :class:`EagleFilePart` object.
        
        :param efp: the class:`EagleFilePart` object to remove.
        :return: Nothing
        """
        try:
            self.remove_segment(efp)
        except:
            pass

    def _rekey_child(self, oldkey, efp):
        """
        Remove a child :class:`EagleFilePart` object.
        
        :param efp: the class:`EagleFilePart` object to remove.
        :return: Nothing
        """


    def __str__(self):
        r = "["+repr(self)+" "
        r = r + "name:" + str(self.get_name()) + " "
        r = r + "]"
        return r
            
    def dump(self, indent="", increment="   "):
        """
        Recursive debug dump.
        
        :param indent:  Indentation string.  The output will be indented by this much.
        :param increment: This will be appendeded to :code:`indent` on recursive invocations.

        :rtype: :code:`None`
        """
        print(indent + str(self.__class__.__name__), end=' ')
        try:
            print(self.get_name())
        except:
            print()
            pass
        for c in self.get_children():
            c.dump(indent + "   ")

        
EagleFile.class_map["bus"] = Bus
         


class Symbol(EagleFilePart):
    """
    Class representing the contents of a <symbol> tag in Eagle files.

    Attributes:

    * :code:`name`

    * :code:`urn`

    * :code:`locally_modified`

    * :code:`library_version`

    * :code:`library_locally_modified`



    Collections:

    * :code:`description`: Singleton :class:`Description` object. 


    * :code:`drawing_element`: List of :class:`Polygon`, :class:`Wire`, :class:`Text`, :class:`Dimension`, :class:`Circle`, :class:`Rectangle`, :class:`Hole` and :class:`Frame` objects.


    * :code:`pin`: Map of :class:`Pin` objects indexed by their :code:`name`.



    """
    def __init__(self):
        """
        Construct an empty :class:`Symbol` object.
        """
        EagleFilePart.__init__(self)
        
        self.name=None
        self.urn=None
        self.locally_modified=None
        self.library_version=None
        self.library_locally_modified=None
        self.drawing_elements=[]
        self.pins={} #tecollections.OrderedDict()  For unclear reasons, this caused ordering to become more unpredictable, rather than less.
        self.description=None


        
    @classmethod
    def _from_et(cls,root,parent):
        """
        Create a :class:`Symbol` from a :code:`symbol` element.
        
        :param root: The element tree tree to parse.
        :param parent: :class:`EagleFilePart` that should hold the resulting :class:`EagleFilePart`
        :rtype: :class:`Symbol`
        """
        ## Call the constructor
        n = cls()
        n._init_from_et(root,parent)
        return n

    def _get_error_name(self):
        if hasattr(self, "get_name"):
            return self.get_name();
        else:
            return "Symbol";
        
    def  _init_from_et(self, root, parent):
        """
        Initialized a :class:`Symbol` from a :code:`symbol` element.  This is useful if you have a subclass of :class:`Symbol` .
        
        :param root: The element tree tree to parse.
        :param parent: :class:`EagleFilePart` that will become the parent of :code:`this` .
        :rtype: :class:`Symbol`
        """
        try:
            self.root = root
            
            if root.tag != "symbol":
                raise EagleFormatError("Tried to create symbol from " + root.tag)

            self.name=parseByType(parent, "str", None, root.get("name"))
            self.urn=parseByType(parent, "str", None, root.get("urn"))
            self.locally_modified=parseByType(parent, "bool", 'no', root.get("locally_modified"))
            self.library_version=parseByType(parent, "int", None, root.get("library_version"))
            self.library_locally_modified=parseByType(parent, "bool", 'no', root.get("library_locally_modified"))

            self.parent = parent

            ### populate the maps by searching for elements that match xpath and generating objects for them.

            for c in root.xpath("./pin"):
                self.add_pin(self.get_class_for_tag(c.tag)._from_et(c, self))

            ### Do the same for the lists

            for c in root.xpath("./polygon|./wire|./text|./dimension|./circle|./rectangle|./frame|./hole"):
                self.add_drawing_element(self.get_class_for_tag(c.tag)._from_et(c,self))

            ### Do the same for the attr lists


            ### And the singletons

            x = root.xpath("./description")
            if len(x) is not 0:
                self.set_description(self.get_class_for_tag(x[0].tag)._from_et(x[0],self))

            ### And, finally, if the objects wants the text from the tag.

        except SwoopError as e:
            e.text = "{}:{}".format(self._get_error_name(), e.text)
            raise e


    def sortkey(self):
        r = ""
        r = r + str(self.name)
        r = r + str(self.urn)
        r = r + str(self.locally_modified)
        r = r + str(self.library_version)
        r = r + str(self.library_locally_modified)
        return r

    def get_et(self):
        """
        Generate a <symbol> element tree for a :class:`Symbol`.
        
        :rtype:  :class:`ElementTree`.
        
        """
        try:
            r = ET.Element("symbol")

            ### Set the tag attributes 


            ## Unparse the values.

            v = unparseByType(self, "str", None,  self.name)

            ## For required attributes None becomes "".  For optional attributes, we just leave the attribute out.
            if not (isinstance(self.get_parent(), LibraryFile) and False):  # special case for the name of library.
                if v is not None:
                    r.set("name", v)
                else:
                    r.set("name", "")


            ## Unparse the values.

            v = unparseByType(self, "str", None,  self.urn)

            ## For required attributes None becomes "".  For optional attributes, we just leave the attribute out.
            if not (isinstance(self.get_parent(), LibraryFile) and False):  # special case for the name of library.
                if v is not None:
                    r.set("urn", v)


            ## Unparse the values.

            v = unparseByType(self, "bool", 'no',  self.locally_modified)

            ## For required attributes None becomes "".  For optional attributes, we just leave the attribute out.
            if not (isinstance(self.get_parent(), LibraryFile) and False):  # special case for the name of library.
                if v is not None:
                    r.set("locally_modified", v)


            ## Unparse the values.

            v = unparseByType(self, "int", None,  self.library_version)

            ## For required attributes None becomes "".  For optional attributes, we just leave the attribute out.
            if not (isinstance(self.get_parent(), LibraryFile) and False):  # special case for the name of library.
                if v is not None:
                    r.set("library_version", v)


            ## Unparse the values.

            v = unparseByType(self, "bool", 'no',  self.library_locally_modified)

            ## For required attributes None becomes "".  For optional attributes, we just leave the attribute out.
            if not (isinstance(self.get_parent(), LibraryFile) and False):  # special case for the name of library.
                if v is not None:
                    r.set("library_locally_modified", v)


            ### process the sections in order.  They have to be in section order,
            ### because eagle files are order dependent.


            ## For some tags, Eagle generates empty tags when there's no contant
            ## rather than just leaving the tag out.  We mark these with
            ## Tag.requireTag in GenerateSwoop.py and force their generation
            ## here.

            smartAddSubTags(r, "./description")


            ## or add a singleton.

            if self.description is not None:
                target = smartAddSubTags(r, "./description")
                target.append(self.description.get_et())

            ## For some tags, Eagle generates empty tags when there's no contant
            ## rather than just leaving the tag out.  We mark these with
            ## Tag.requireTag in GenerateSwoop.py and force their generation
            ## here.



            ## add a list.

            if len(self.drawing_elements) is not 0:
                target = smartAddSubTags(r, "./polygon|./wire|./text|./dimension|./circle|./rectangle|./frame|./hole")
                # add them in sorted order.  This gives us a simple canonicalization that makes it feasible to use diff to compare files.
                target.extend([i.get_et() for i in sorted(self.drawing_elements,key=lambda x: x.sortkey())])


            ## For some tags, Eagle generates empty tags when there's no contant
            ## rather than just leaving the tag out.  We mark these with
            ## Tag.requireTag in GenerateSwoop.py and force their generation
            ## here.



            ## add a map.

            if len(self.pins) is not 0:
                target = smartAddSubTags(r, "./pin")
                # add them in sorted order.  This gives us a simple canonicalization that makes it feasible to use diff to compare files.
                target.extend([i.get_et() for i in sorted(list(self.pins.values()),key=lambda x: x.sortkey())])


            ## set the text, if its needed.

        except SwoopError as e:
            e.text = "{}:{}".format(self._get_error_name(), e.text)
            raise e
        return r

    def clone(self):
        """
        Recursively clone this :code:`Symbol`.  It will be identical to the original, but it's parent will be :code:`None`.
        
        :rtype: :class:`Symbol`
        """
        try:
            n = copy.copy(self)
            n.pins = {}
            for x in list(self.pins.values()):
                n.add_pin(x.clone())
            n.drawing_elements = []
            for x in self.drawing_elements:
                n.add_drawing_element(x.clone())
            n.description = None
            if self.description is not None:
                n.set_description(self.description.clone())
            else:
                n.set_description(None)
            n.parent = None
        except SwoopError as e:
            e.text = "{}:{}".format(self._get_error_name(), e.text)
            raise e
        return n

    def accept_preorder_visitor(self, visitor):
        try:
            pre = getattr(visitor, "Symbol_pre")
            return pre(self)
        except AttributeError:
            return visitor.default_pre(self)
        
    def accept_postorder_visitor(self, visitor, context):
        try:
            post = getattr(visitor, "Symbol_post")
            post(self,context)
        except AttributeError:
            visitor.default_post(self,context)

    def is_equal(self, other):
        """
        Check whether two :code:`EagleFilePart` objects are identical.
        
        :param other: Object to compare to.
        :returns: :code:`True` if they are identical, otherwise, :code:`False`
        """
        return self.get_xml() == other.get_xml()
        
    ### Getters/Setters for attribute values

    def get_name(self):
        """ Return the value of :code:`name` for this :class:`Symbol`.  This corresponds to the :code:`name` attribute of a :code:`<symbol>` in an Eagle file.
        
        :rtype: :code:`str`
        """
        return self.name

    def set_name(self,v):
        """ Set the value of :code:`name` for this  :class:`Symbol`.  This corresponds to the :code:`name` attribute of a :code:`<symbol>` in an Eagle file.

        :param v: new value
        :rtype: :code:`self`
        """
                        
        oldkey = self.name
        if not typeCheck("str", v, True):
            raise SwoopError("Illegal value ({}) of type {} for attribute 'name' of Symbol object (should be str).".format(v, type(v)))
        self.name = v
        
        if self.get_parent() is not None:
            self.get_parent()._rekey_child(oldkey, self);
        return self

    def with_name(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`name`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`name` equals :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_name()` is :code:`True`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """

        if type(v) in [str, int, float, bool]:
            return self if self.name == v else None
        elif callable(v):
            return self if v(self.name) else None
        else:
            raise SwoopError("Illegal type passed to with_name")

    def without_name(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`name`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`name` is not equal to :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_name()` is :code:`False`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """
        
        if type(v) in [str, int, float, bool]:
            return self if self.name != v else None
        elif callable(v):
            return self if not v(self.name) else None
        else:
            raise SwoopError("Illegal type passed to without_name")


    def get_urn(self):
        """ Return the value of :code:`urn` for this :class:`Symbol`.  This corresponds to the :code:`urn` attribute of a :code:`<symbol>` in an Eagle file.
        
        :rtype: :code:`str`
        """
        return self.urn

    def set_urn(self,v):
        """ Set the value of :code:`urn` for this  :class:`Symbol`.  This corresponds to the :code:`urn` attribute of a :code:`<symbol>` in an Eagle file.

        :param v: new value
        :rtype: :code:`self`
        """
                        
        if not typeCheck("str", v, False):
            raise SwoopError("Illegal value ({}) of type {} for attribute 'urn' of Symbol object (should be str).".format(v, type(v)))
        self.urn = v
        
        return self

    def with_urn(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`urn`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`urn` equals :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_urn()` is :code:`True`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """

        if type(v) in [str, int, float, bool]:
            return self if self.urn == v else None
        elif callable(v):
            return self if v(self.urn) else None
        else:
            raise SwoopError("Illegal type passed to with_urn")

    def without_urn(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`urn`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`urn` is not equal to :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_urn()` is :code:`False`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """
        
        if type(v) in [str, int, float, bool]:
            return self if self.urn != v else None
        elif callable(v):
            return self if not v(self.urn) else None
        else:
            raise SwoopError("Illegal type passed to without_urn")


    def get_locally_modified(self):
        """ Return the value of :code:`locally_modified` for this :class:`Symbol`.  This corresponds to the :code:`locally_modified` attribute of a :code:`<symbol>` in an Eagle file.
        
        :rtype: :code:`bool`
        """
        return self.locally_modified

    def set_locally_modified(self,v):
        """ Set the value of :code:`locally_modified` for this  :class:`Symbol`.  This corresponds to the :code:`locally_modified` attribute of a :code:`<symbol>` in an Eagle file.

        :param v: new value
        :rtype: :code:`self`
        """
                        
        if not typeCheck("bool", v, False):
            raise SwoopError("Illegal value ({}) of type {} for attribute 'locally_modified' of Symbol object (should be bool).".format(v, type(v)))
        self.locally_modified = v
        
        return self

    def with_locally_modified(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`locally_modified`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`locally_modified` equals :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_locally_modified()` is :code:`True`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """

        if type(v) in [str, int, float, bool]:
            return self if self.locally_modified == v else None
        elif callable(v):
            return self if v(self.locally_modified) else None
        else:
            raise SwoopError("Illegal type passed to with_locally_modified")

    def without_locally_modified(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`locally_modified`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`locally_modified` is not equal to :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_locally_modified()` is :code:`False`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """
        
        if type(v) in [str, int, float, bool]:
            return self if self.locally_modified != v else None
        elif callable(v):
            return self if not v(self.locally_modified) else None
        else:
            raise SwoopError("Illegal type passed to without_locally_modified")


    def get_library_version(self):
        """ Return the value of :code:`library_version` for this :class:`Symbol`.  This corresponds to the :code:`library_version` attribute of a :code:`<symbol>` in an Eagle file.
        
        :rtype: :code:`int`
        """
        return self.library_version

    def set_library_version(self,v):
        """ Set the value of :code:`library_version` for this  :class:`Symbol`.  This corresponds to the :code:`library_version` attribute of a :code:`<symbol>` in an Eagle file.

        :param v: new value
        :rtype: :code:`self`
        """
                        
        if not typeCheck("int", v, False):
            raise SwoopError("Illegal value ({}) of type {} for attribute 'library_version' of Symbol object (should be int).".format(v, type(v)))
        self.library_version = v
        
        return self

    def with_library_version(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`library_version`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`library_version` equals :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_library_version()` is :code:`True`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """

        if type(v) in [str, int, float, bool]:
            return self if self.library_version == v else None
        elif callable(v):
            return self if v(self.library_version) else None
        else:
            raise SwoopError("Illegal type passed to with_library_version")

    def without_library_version(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`library_version`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`library_version` is not equal to :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_library_version()` is :code:`False`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """
        
        if type(v) in [str, int, float, bool]:
            return self if self.library_version != v else None
        elif callable(v):
            return self if not v(self.library_version) else None
        else:
            raise SwoopError("Illegal type passed to without_library_version")


    def get_library_locally_modified(self):
        """ Return the value of :code:`library_locally_modified` for this :class:`Symbol`.  This corresponds to the :code:`library_locally_modified` attribute of a :code:`<symbol>` in an Eagle file.
        
        :rtype: :code:`bool`
        """
        return self.library_locally_modified

    def set_library_locally_modified(self,v):
        """ Set the value of :code:`library_locally_modified` for this  :class:`Symbol`.  This corresponds to the :code:`library_locally_modified` attribute of a :code:`<symbol>` in an Eagle file.

        :param v: new value
        :rtype: :code:`self`
        """
                        
        if not typeCheck("bool", v, False):
            raise SwoopError("Illegal value ({}) of type {} for attribute 'library_locally_modified' of Symbol object (should be bool).".format(v, type(v)))
        self.library_locally_modified = v
        
        return self

    def with_library_locally_modified(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`library_locally_modified`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`library_locally_modified` equals :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_library_locally_modified()` is :code:`True`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """

        if type(v) in [str, int, float, bool]:
            return self if self.library_locally_modified == v else None
        elif callable(v):
            return self if v(self.library_locally_modified) else None
        else:
            raise SwoopError("Illegal type passed to with_library_locally_modified")

    def without_library_locally_modified(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`library_locally_modified`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`library_locally_modified` is not equal to :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_library_locally_modified()` is :code:`False`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """
        
        if type(v) in [str, int, float, bool]:
            return self if self.library_locally_modified != v else None
        elif callable(v):
            return self if not v(self.library_locally_modified) else None
        else:
            raise SwoopError("Illegal type passed to without_library_locally_modified")



    ##### Lookup functions that return EFPs instead of just attribute values.
    
    


    
    ### Adder/getter/lookup for lists
    
    def add_drawing_element(self, s):
        """ Add a :class:`Polygon`, :class:`Wire`, :class:`Text`, :class:`Dimension`, :class:`Circle`, :class:`Rectangle`, :class:`Hole` or :class:`Frame` to the :code:`drawing_elements` of this :class:`Symbol`.

        :param s: The :class:`Polygon`, :class:`Wire`, :class:`Text`, :class:`Dimension`, :class:`Circle`, :class:`Rectangle`, :class:`Hole` or :class:`Frame` to add.
        :rtype: :code:`self`
        """
        if not any([
                isinstance(s, Polygon),
                isinstance(s, Wire),
                isinstance(s, Text),
                isinstance(s, Dimension),
                isinstance(s, Circle),
                isinstance(s, Rectangle),
                isinstance(s, Hole),
                isinstance(s, Frame),
            ]):
            raise SwoopError("Argument to Symbol.add_drawing_element() should be of type Polygon, Wire, Text, Dimension, Circle, Rectangle, Hole or Frame.  Got " + str(type(s).__name__) + ".")
        
        self.drawing_elements.append(s)
        if s.parent is not None and s.parent is not self:
            s.parent.remove_drawing_element(s)

        s.parent = self
        return self

    def get_nth_drawing_element(self, n):
        """ get then nth :class:`Polygon`, :class:`Wire`, :class:`Text`, :class:`Dimension`, :class:`Circle`, :class:`Rectangle`, :class:`Hole` or :class:`Frame` object from the :code:`drawing_elements` of this :class:`Symbol`.
        
        :param n: Index of the item to return.

        :rtype: :class:`Polygon`, :class:`Wire`, :class:`Text`, :class:`Dimension`, :class:`Circle`, :class:`Rectangle`, :class:`Hole` or :class:`Frame` object
        """
        return self.drawing_elements[n]

    def get_drawing_elements(self, attrs=None, type=None):
        """Return (and possibly filter) items in the the :code:`drawing_elements` list of :class:`Polygon`, :class:`Wire`, :class:`Text`, :class:`Dimension`, :class:`Circle`, :class:`Rectangle`, :class:`Hole` or :class:`Frame` objects for this :class:`Symbol`.
        
        This functions provides a mechanism for filtering the items as well.
        The keys in :code:`attrs` are taken as attributes names and the
        values are requested values.  Items in the list that have all the
        requested values for the corresponding attributes will be returned.  

        A if :code:`type` is not :code:`None`, the item will match if it is an
        instance of the type provided.
        
        :param attrs: A set of key-value pairs that represent a filter to apply to the item's attributes.
        :param type:  A type to filter on.  Only items that are an instance of this type will be returned.
        :returns: A List of :class:`Polygon`, :class:`Wire`, :class:`Text`, :class:`Dimension`, :class:`Circle`, :class:`Rectangle`, :class:`Hole` and :class:`Frame` objects
        :rtype: List of :class:`Polygon`, :class:`Wire`, :class:`Text`, :class:`Dimension`, :class:`Circle`, :class:`Rectangle`, :class:`Hole` and :class:`Frame` objects
        """
        if attrs is not None or type is not None:
            raise NotImplementedError("filtered get not implemented.")
        return self.drawing_elements

    def clear_drawing_elements(self):
        """
        Remove all the :class:`Polygon`, :class:`Wire`, :class:`Text`, :class:`Dimension`, :class:`Circle`, :class:`Rectangle`, :class:`Hole` and :class:`Frame` objects from the :code:`drawing_elements` of this :class:`Symbol`.
        
        :rtype: :code:`self`
        """
        for efp in self.drawing_elements:
            efp.parent = None
        self.drawing_elements = []
        return self

    def remove_drawing_element(self, efp):
        """
        Remove a :class:`Polygon`, :class:`Wire`, :class:`Text`, :class:`Dimension`, :class:`Circle`, :class:`Rectangle`, :class:`Hole` or :class:`Frame` from the :code:`drawing_elements` of this :class:`Symbol`.
        
        :param efp: The :class:`Polygon`, :class:`Wire`, :class:`Text`, :class:`Dimension`, :class:`Circle`, :class:`Rectangle`, :class:`Hole` or :class:`Frame` object to remove.

        :rtype: :code:`self`
        """
        self.drawing_elements = [x for x in self.drawing_elements if x != efp]

        if efp.parent is self:
            efp.parent = None
        return self



    ### Add, lookup, and get for maps
    def add_pin(self, s):
        """ Add a :class:`Pin` to the :code:`pins` of this :class:`Symbol`.

        :param s: The :class:`Pin` to add.
        :rtype: :code:`self`
        """
        if not any([
                isinstance(s, Pin),
            ]):
            raise SwoopError("Argument to Symbol.add_pin() should be of type Pin.  Got " + str(type(s).__name__) + ".")
        

        self.pins[s.get_name()] = s

        s.parent = self
        return self

    def get_nth_pin(self, n):
        """ get then nth :class:`Pin` object from the :code:`pins` of this :class:`Symbol`.
        
        :param n: Index of the item to return.

        :rtype: :class:`Pin` object
        """
        return list(self.pins.values())[n]

    def get_pin(self, key):
        """ Lookup and return a :class:`Pin` from the :code:`pins` of  this :class:`Symbol`.
        
        :param key: A :code:`str` to use for the lookup.  The lookup uses the :code:`name` of the :class:`Pin` objects.

        :rtype: A :class:`Pin` object or :code:`None`, if there is no such item.
        """
        return self.pins.get(key)


    def get_pins(self, attrs=None, type=None):
        """Return (and possibly filter) items in the the :code:`pins` map of :class:`Pin` objects for this :class:`Symbol`.
        
        This functions provides a mechanism for filtering the items as well.
        The keys in :code:`attrs` are taken as attributes names and the
        values are requested values.  Items in the list that have all the
        requested values for the corresponding attributes will be returned.  

        A if :code:`type` is not :code:`None`, the item will match if it is an
        instance of the type provided.
        
        :param attrs: A set of key-value pairs that represent a filter to apply to the item's attributes.
        :param type:  A type to filter on.  Only items that are an instance of this type will be returned.
        :returns: A List of :class:`Pin` objects
        :rtype: List of :class:`Pin` objects
        """
        if attrs is not None or type is not None:
            raise NotImplementedError("filtered get not implemented")
        return list(self.pins.values())
        

    def clear_pins(self):
        """
        Remove all the :class:`Pin` objects from the :code:`pins` of this :class:`Symbol`.
        
        :rtype: :code:`self`
        """
        for efp in list(self.pins.values()):
            efp.parent = None
        self.pins = {}
        return self

    def remove_pin(self, efp):
        """
        Remove a :class:`Pin` from the :code:`pins` of this :class:`Symbol`.
        
        :param efp: The :class:`Pin` object to remove.

        :rtype: :code:`self`
        """
        if self.pins[efp.get_name()] == efp:
            del self.pins[efp.get_name()]
            efp.parent = None
            return self
        else:
            raise SwoopError("Tried to use remove_pin() to delete the wrong kind of child?: {}".format(str(efp)))
    


    
    ### Getter/Setter for singletons.

    def set_description(self, s):
        """ Set the :class:`Description` for this  :class:`Symbol`.

        :param s: :class:`Description` to set.
        :rtype: :code:`self`
        """
        if self.description is not None:
            self.description.parent = None
        self.description = s
        if s is not None:
            s.parent = self
        return self

    def get_description(self):
        """ Get the description from this :class:`Symbol`.
        
        :rtype: :class:`Description` object
        """
        return self.description


    
    def get_children(self):
        """
        Get all the children of this :class:`EagleFilePart`.
        
        :rtype: List of :class:`EagleFilePart` objects
        """
        r = []

        r = r + self.drawing_elements

        r = r + list(self.pins.values())

        if self.description is not None:
            r = r + [self.description]

        return r

    def remove_child(self, efp):
        """
        Remove a child :class:`EagleFilePart` object.
        
        :param efp: the class:`EagleFilePart` object to remove.
        :return: Nothing
        """
        try:
            self.remove_pin(efp)
        except:
            pass
        try:
            self.remove_drawing_element(efp)
        except:
            pass
        if self.get_description() == efp:
            self.set_description(None)

    def _rekey_child(self, oldkey, efp):
        """
        Remove a child :class:`EagleFilePart` object.
        
        :param efp: the class:`EagleFilePart` object to remove.
        :return: Nothing
        """
        try:
            if self.get_pin(oldkey) == efp:
                del self.pins[oldkey]
                self.add_pin(efp)
        except SwoopError:
            pass

    def check_sanity(self, visited_efps = None):
        EagleFilePart.check_sanity(self, visited_efps)

        # Check whether keys in our maps match the keys in our children
        for k in self.pins:
            if self.pins[k].get_name() != k:
                raise SwoopError("Child's name ('{}') doesn't match key in parent's map ('{}')".format(self.pins[k].get_name(),k))

    def __str__(self):
        r = "["+repr(self)+" "
        r = r + "name:" + str(self.get_name()) + " "
        r = r + "urn:" + str(self.get_urn()) + " "
        r = r + "locally_modified:" + str(self.get_locally_modified()) + " "
        r = r + "library_version:" + str(self.get_library_version()) + " "
        r = r + "library_locally_modified:" + str(self.get_library_locally_modified()) + " "
        r = r + "]"
        return r
            
    def dump(self, indent="", increment="   "):
        """
        Recursive debug dump.
        
        :param indent:  Indentation string.  The output will be indented by this much.
        :param increment: This will be appendeded to :code:`indent` on recursive invocations.

        :rtype: :code:`None`
        """
        print(indent + str(self.__class__.__name__), end=' ')
        try:
            print(self.get_name())
        except:
            print()
            pass
        for c in self.get_children():
            c.dump(indent + "   ")

        
EagleFile.class_map["symbol"] = Symbol
         


class Variant(EagleFilePart):
    """
    Class representing the contents of a <variant> tag in Eagle files.

    Attributes:

    * :code:`name`

    * :code:`populate`

    * :code:`value`

    * :code:`technology`


    """
    def __init__(self):
        """
        Construct an empty :class:`Variant` object.
        """
        EagleFilePart.__init__(self)
        
        self.name=None
        self.populate=None
        self.value=None
        self.technology=None


        
    @classmethod
    def _from_et(cls,root,parent):
        """
        Create a :class:`Variant` from a :code:`variant` element.
        
        :param root: The element tree tree to parse.
        :param parent: :class:`EagleFilePart` that should hold the resulting :class:`EagleFilePart`
        :rtype: :class:`Variant`
        """
        ## Call the constructor
        n = cls()
        n._init_from_et(root,parent)
        return n

    def _get_error_name(self):
        if hasattr(self, "get_name"):
            return self.get_name();
        else:
            return "Variant";
        
    def  _init_from_et(self, root, parent):
        """
        Initialized a :class:`Variant` from a :code:`variant` element.  This is useful if you have a subclass of :class:`Variant` .
        
        :param root: The element tree tree to parse.
        :param parent: :class:`EagleFilePart` that will become the parent of :code:`this` .
        :rtype: :class:`Variant`
        """
        try:
            self.root = root
            
            if root.tag != "variant":
                raise EagleFormatError("Tried to create variant from " + root.tag)

            self.name=parseByType(parent, "str", None, root.get("name"))
            self.populate=parseByType(parent, "bool", None, root.get("populate"))
            self.value=parseByType(parent, "str", None, root.get("value"))
            self.technology=parseByType(parent, "str", None, root.get("technology"))

            self.parent = parent

            ### populate the maps by searching for elements that match xpath and generating objects for them.


            ### Do the same for the lists


            ### Do the same for the attr lists


            ### And the singletons


            ### And, finally, if the objects wants the text from the tag.

        except SwoopError as e:
            e.text = "{}:{}".format(self._get_error_name(), e.text)
            raise e


    def sortkey(self):
        r = ""
        r = r + str(self.name)
        r = r + str(self.populate)
        r = r + str(self.value)
        r = r + str(self.technology)
        return r

    def get_et(self):
        """
        Generate a <variant> element tree for a :class:`Variant`.
        
        :rtype:  :class:`ElementTree`.
        
        """
        try:
            r = ET.Element("variant")

            ### Set the tag attributes 


            ## Unparse the values.

            v = unparseByType(self, "str", None,  self.name)

            ## For required attributes None becomes "".  For optional attributes, we just leave the attribute out.
            if not (isinstance(self.get_parent(), LibraryFile) and False):  # special case for the name of library.
                if v is not None:
                    r.set("name", v)
                else:
                    r.set("name", "")


            ## Unparse the values.

            v = unparseByType(self, "bool", None,  self.populate)

            ## For required attributes None becomes "".  For optional attributes, we just leave the attribute out.
            if not (isinstance(self.get_parent(), LibraryFile) and False):  # special case for the name of library.
                if v is not None:
                    r.set("populate", v)


            ## Unparse the values.

            v = unparseByType(self, "str", None,  self.value)

            ## For required attributes None becomes "".  For optional attributes, we just leave the attribute out.
            if not (isinstance(self.get_parent(), LibraryFile) and False):  # special case for the name of library.
                if v is not None:
                    r.set("value", v)


            ## Unparse the values.

            v = unparseByType(self, "str", None,  self.technology)

            ## For required attributes None becomes "".  For optional attributes, we just leave the attribute out.
            if not (isinstance(self.get_parent(), LibraryFile) and False):  # special case for the name of library.
                if v is not None:
                    r.set("technology", v)
                else:
                    r.set("technology", "")


            ### process the sections in order.  They have to be in section order,
            ### because eagle files are order dependent.


            ## set the text, if its needed.

        except SwoopError as e:
            e.text = "{}:{}".format(self._get_error_name(), e.text)
            raise e
        return r

    def clone(self):
        """
        Recursively clone this :code:`Variant`.  It will be identical to the original, but it's parent will be :code:`None`.
        
        :rtype: :class:`Variant`
        """
        try:
            n = copy.copy(self)
            n.parent = None
        except SwoopError as e:
            e.text = "{}:{}".format(self._get_error_name(), e.text)
            raise e
        return n

    def accept_preorder_visitor(self, visitor):
        try:
            pre = getattr(visitor, "Variant_pre")
            return pre(self)
        except AttributeError:
            return visitor.default_pre(self)
        
    def accept_postorder_visitor(self, visitor, context):
        try:
            post = getattr(visitor, "Variant_post")
            post(self,context)
        except AttributeError:
            visitor.default_post(self,context)

    def is_equal(self, other):
        """
        Check whether two :code:`EagleFilePart` objects are identical.
        
        :param other: Object to compare to.
        :returns: :code:`True` if they are identical, otherwise, :code:`False`
        """
        return self.get_xml() == other.get_xml()
        
    ### Getters/Setters for attribute values

    def get_name(self):
        """ Return the value of :code:`name` for this :class:`Variant`.  This corresponds to the :code:`name` attribute of a :code:`<variant>` in an Eagle file.
        
        :rtype: :code:`str`
        """
        return self.name

    def set_name(self,v):
        """ Set the value of :code:`name` for this  :class:`Variant`.  This corresponds to the :code:`name` attribute of a :code:`<variant>` in an Eagle file.

        :param v: new value
        :rtype: :code:`self`
        """
                        
        oldkey = self.name
        if not typeCheck("str", v, True):
            raise SwoopError("Illegal value ({}) of type {} for attribute 'name' of Variant object (should be str).".format(v, type(v)))
        self.name = v
        
        if self.get_parent() is not None:
            self.get_parent()._rekey_child(oldkey, self);
        return self

    def with_name(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`name`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`name` equals :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_name()` is :code:`True`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """

        if type(v) in [str, int, float, bool]:
            return self if self.name == v else None
        elif callable(v):
            return self if v(self.name) else None
        else:
            raise SwoopError("Illegal type passed to with_name")

    def without_name(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`name`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`name` is not equal to :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_name()` is :code:`False`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """
        
        if type(v) in [str, int, float, bool]:
            return self if self.name != v else None
        elif callable(v):
            return self if not v(self.name) else None
        else:
            raise SwoopError("Illegal type passed to without_name")


    def get_populate(self):
        """ Return the value of :code:`populate` for this :class:`Variant`.  This corresponds to the :code:`populate` attribute of a :code:`<variant>` in an Eagle file.
        
        :rtype: :code:`bool`
        """
        return self.populate

    def set_populate(self,v):
        """ Set the value of :code:`populate` for this  :class:`Variant`.  This corresponds to the :code:`populate` attribute of a :code:`<variant>` in an Eagle file.

        :param v: new value
        :rtype: :code:`self`
        """
                        
        if not typeCheck("bool", v, False):
            raise SwoopError("Illegal value ({}) of type {} for attribute 'populate' of Variant object (should be bool).".format(v, type(v)))
        self.populate = v
        
        return self

    def with_populate(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`populate`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`populate` equals :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_populate()` is :code:`True`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """

        if type(v) in [str, int, float, bool]:
            return self if self.populate == v else None
        elif callable(v):
            return self if v(self.populate) else None
        else:
            raise SwoopError("Illegal type passed to with_populate")

    def without_populate(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`populate`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`populate` is not equal to :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_populate()` is :code:`False`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """
        
        if type(v) in [str, int, float, bool]:
            return self if self.populate != v else None
        elif callable(v):
            return self if not v(self.populate) else None
        else:
            raise SwoopError("Illegal type passed to without_populate")


    def get_value(self):
        """ Return the value of :code:`value` for this :class:`Variant`.  This corresponds to the :code:`value` attribute of a :code:`<variant>` in an Eagle file.
        
        :rtype: :code:`str`
        """
        return self.value

    def set_value(self,v):
        """ Set the value of :code:`value` for this  :class:`Variant`.  This corresponds to the :code:`value` attribute of a :code:`<variant>` in an Eagle file.

        :param v: new value
        :rtype: :code:`self`
        """
                        
        if not typeCheck("str", v, False):
            raise SwoopError("Illegal value ({}) of type {} for attribute 'value' of Variant object (should be str).".format(v, type(v)))
        self.value = v
        
        return self

    def with_value(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`value`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`value` equals :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_value()` is :code:`True`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """

        if type(v) in [str, int, float, bool]:
            return self if self.value == v else None
        elif callable(v):
            return self if v(self.value) else None
        else:
            raise SwoopError("Illegal type passed to with_value")

    def without_value(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`value`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`value` is not equal to :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_value()` is :code:`False`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """
        
        if type(v) in [str, int, float, bool]:
            return self if self.value != v else None
        elif callable(v):
            return self if not v(self.value) else None
        else:
            raise SwoopError("Illegal type passed to without_value")


    def get_technology(self):
        """ Return the value of :code:`technology` for this :class:`Variant`.  This corresponds to the :code:`technology` attribute of a :code:`<variant>` in an Eagle file.
        
        :rtype: :code:`str`
        """
        return self.technology

    def set_technology(self,v):
        """ Set the value of :code:`technology` for this  :class:`Variant`.  This corresponds to the :code:`technology` attribute of a :code:`<variant>` in an Eagle file.

        :param v: new value
        :rtype: :code:`self`
        """
                        
        if not typeCheck("str", v, True):
            raise SwoopError("Illegal value ({}) of type {} for attribute 'technology' of Variant object (should be str).".format(v, type(v)))
        self.technology = v
        
        return self

    def with_technology(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`technology`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`technology` equals :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_technology()` is :code:`True`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """

        if type(v) in [str, int, float, bool]:
            return self if self.technology == v else None
        elif callable(v):
            return self if v(self.technology) else None
        else:
            raise SwoopError("Illegal type passed to with_technology")

    def without_technology(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`technology`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`technology` is not equal to :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_technology()` is :code:`False`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """
        
        if type(v) in [str, int, float, bool]:
            return self if self.technology != v else None
        elif callable(v):
            return self if not v(self.technology) else None
        else:
            raise SwoopError("Illegal type passed to without_technology")



    ##### Lookup functions that return EFPs instead of just attribute values.
    
    


    
    ### Adder/getter/lookup for lists
    


    ### Add, lookup, and get for maps


    
    ### Getter/Setter for singletons.


    
    def get_children(self):
        """
        Get all the children of this :class:`EagleFilePart`.
        
        :rtype: List of :class:`EagleFilePart` objects
        """
        r = []




        return r

    def remove_child(self, efp):
        """
        Remove a child :class:`EagleFilePart` object.
        
        :param efp: the class:`EagleFilePart` object to remove.
        :return: Nothing
        """

    def _rekey_child(self, oldkey, efp):
        """
        Remove a child :class:`EagleFilePart` object.
        
        :param efp: the class:`EagleFilePart` object to remove.
        :return: Nothing
        """


    def __str__(self):
        r = "["+repr(self)+" "
        r = r + "name:" + str(self.get_name()) + " "
        r = r + "populate:" + str(self.get_populate()) + " "
        r = r + "value:" + str(self.get_value()) + " "
        r = r + "technology:" + str(self.get_technology()) + " "
        r = r + "]"
        return r
            
    def dump(self, indent="", increment="   "):
        """
        Recursive debug dump.
        
        :param indent:  Indentation string.  The output will be indented by this much.
        :param increment: This will be appendeded to :code:`indent` on recursive invocations.

        :rtype: :code:`None`
        """
        print(indent + str(self.__class__.__name__), end=' ')
        try:
            print(self.get_name())
        except:
            print()
            pass
        for c in self.get_children():
            c.dump(indent + "   ")

        
EagleFile.class_map["variant"] = Variant
         


class Package3dinstance(EagleFilePart):
    """
    Class representing the contents of a <package3dinstance> tag in Eagle files.

    Attributes:

    * :code:`package3d_urn`


    """
    def __init__(self):
        """
        Construct an empty :class:`Package3dinstance` object.
        """
        EagleFilePart.__init__(self)
        
        self.package3d_urn=None


        
    @classmethod
    def _from_et(cls,root,parent):
        """
        Create a :class:`Package3dinstance` from a :code:`package3dinstance` element.
        
        :param root: The element tree tree to parse.
        :param parent: :class:`EagleFilePart` that should hold the resulting :class:`EagleFilePart`
        :rtype: :class:`Package3dinstance`
        """
        ## Call the constructor
        n = cls()
        n._init_from_et(root,parent)
        return n

    def _get_error_name(self):
        if hasattr(self, "get_name"):
            return self.get_name();
        else:
            return "Package3dinstance";
        
    def  _init_from_et(self, root, parent):
        """
        Initialized a :class:`Package3dinstance` from a :code:`package3dinstance` element.  This is useful if you have a subclass of :class:`Package3dinstance` .
        
        :param root: The element tree tree to parse.
        :param parent: :class:`EagleFilePart` that will become the parent of :code:`this` .
        :rtype: :class:`Package3dinstance`
        """
        try:
            self.root = root
            
            if root.tag != "package3dinstance":
                raise EagleFormatError("Tried to create package3dinstance from " + root.tag)

            self.package3d_urn=parseByType(parent, "str", None, root.get("package3d_urn"))

            self.parent = parent

            ### populate the maps by searching for elements that match xpath and generating objects for them.


            ### Do the same for the lists


            ### Do the same for the attr lists


            ### And the singletons


            ### And, finally, if the objects wants the text from the tag.

        except SwoopError as e:
            e.text = "{}:{}".format(self._get_error_name(), e.text)
            raise e


    def sortkey(self):
        r = ""
        r = r + str(self.package3d_urn)
        return r

    def get_et(self):
        """
        Generate a <package3dinstance> element tree for a :class:`Package3dinstance`.
        
        :rtype:  :class:`ElementTree`.
        
        """
        try:
            r = ET.Element("package3dinstance")

            ### Set the tag attributes 


            ## Unparse the values.

            v = unparseByType(self, "str", None,  self.package3d_urn)

            ## For required attributes None becomes "".  For optional attributes, we just leave the attribute out.
            if not (isinstance(self.get_parent(), LibraryFile) and False):  # special case for the name of library.
                if v is not None:
                    r.set("package3d_urn", v)


            ### process the sections in order.  They have to be in section order,
            ### because eagle files are order dependent.


            ## set the text, if its needed.

        except SwoopError as e:
            e.text = "{}:{}".format(self._get_error_name(), e.text)
            raise e
        return r

    def clone(self):
        """
        Recursively clone this :code:`Package3dinstance`.  It will be identical to the original, but it's parent will be :code:`None`.
        
        :rtype: :class:`Package3dinstance`
        """
        try:
            n = copy.copy(self)
            n.parent = None
        except SwoopError as e:
            e.text = "{}:{}".format(self._get_error_name(), e.text)
            raise e
        return n

    def accept_preorder_visitor(self, visitor):
        try:
            pre = getattr(visitor, "Package3dinstance_pre")
            return pre(self)
        except AttributeError:
            return visitor.default_pre(self)
        
    def accept_postorder_visitor(self, visitor, context):
        try:
            post = getattr(visitor, "Package3dinstance_post")
            post(self,context)
        except AttributeError:
            visitor.default_post(self,context)

    def is_equal(self, other):
        """
        Check whether two :code:`EagleFilePart` objects are identical.
        
        :param other: Object to compare to.
        :returns: :code:`True` if they are identical, otherwise, :code:`False`
        """
        return self.get_xml() == other.get_xml()
        
    ### Getters/Setters for attribute values

    def get_package3d_urn(self):
        """ Return the value of :code:`package3d_urn` for this :class:`Package3dinstance`.  This corresponds to the :code:`package3d_urn` attribute of a :code:`<package3dinstance>` in an Eagle file.
        
        :rtype: :code:`str`
        """
        return self.package3d_urn

    def set_package3d_urn(self,v):
        """ Set the value of :code:`package3d_urn` for this  :class:`Package3dinstance`.  This corresponds to the :code:`package3d_urn` attribute of a :code:`<package3dinstance>` in an Eagle file.

        :param v: new value
        :rtype: :code:`self`
        """
                        
        if not typeCheck("str", v, False):
            raise SwoopError("Illegal value ({}) of type {} for attribute 'package3d_urn' of Package3dinstance object (should be str).".format(v, type(v)))
        self.package3d_urn = v
        
        return self

    def with_package3d_urn(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`package3d_urn`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`package3d_urn` equals :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_package3d_urn()` is :code:`True`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """

        if type(v) in [str, int, float, bool]:
            return self if self.package3d_urn == v else None
        elif callable(v):
            return self if v(self.package3d_urn) else None
        else:
            raise SwoopError("Illegal type passed to with_package3d_urn")

    def without_package3d_urn(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`package3d_urn`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`package3d_urn` is not equal to :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_package3d_urn()` is :code:`False`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """
        
        if type(v) in [str, int, float, bool]:
            return self if self.package3d_urn != v else None
        elif callable(v):
            return self if not v(self.package3d_urn) else None
        else:
            raise SwoopError("Illegal type passed to without_package3d_urn")



    ##### Lookup functions that return EFPs instead of just attribute values.
    
    


    
    ### Adder/getter/lookup for lists
    


    ### Add, lookup, and get for maps


    
    ### Getter/Setter for singletons.


    
    def get_children(self):
        """
        Get all the children of this :class:`EagleFilePart`.
        
        :rtype: List of :class:`EagleFilePart` objects
        """
        r = []




        return r

    def remove_child(self, efp):
        """
        Remove a child :class:`EagleFilePart` object.
        
        :param efp: the class:`EagleFilePart` object to remove.
        :return: Nothing
        """

    def _rekey_child(self, oldkey, efp):
        """
        Remove a child :class:`EagleFilePart` object.
        
        :param efp: the class:`EagleFilePart` object to remove.
        :return: Nothing
        """


    def __str__(self):
        r = "["+repr(self)+" "
        r = r + "package3d_urn:" + str(self.get_package3d_urn()) + " "
        r = r + "]"
        return r
            
    def dump(self, indent="", increment="   "):
        """
        Recursive debug dump.
        
        :param indent:  Indentation string.  The output will be indented by this much.
        :param increment: This will be appendeded to :code:`indent` on recursive invocations.

        :rtype: :code:`None`
        """
        print(indent + str(self.__class__.__name__), end=' ')
        try:
            print(self.get_name())
        except:
            print()
            pass
        for c in self.get_children():
            c.dump(indent + "   ")

        
EagleFile.class_map["package3dinstance"] = Package3dinstance
         


class Class(EagleFilePart):
    """
    Class representing the contents of a <class> tag in Eagle files.

    Attributes:

    * :code:`number`

    * :code:`name`

    * :code:`width`

    * :code:`drill`



    Collections:



    * :code:`clearance`: Map of :class:`Clearance` objects indexed by their :code:`class`.



    """
    def __init__(self):
        """
        Construct an empty :class:`Class` object.
        """
        EagleFilePart.__init__(self)
        
        self.number=None
        self.name=None
        self.width=None
        self.drill=None
        self.clearances={} #tecollections.OrderedDict()  For unclear reasons, this caused ordering to become more unpredictable, rather than less.


        
    @classmethod
    def _from_et(cls,root,parent):
        """
        Create a :class:`Class` from a :code:`class` element.
        
        :param root: The element tree tree to parse.
        :param parent: :class:`EagleFilePart` that should hold the resulting :class:`EagleFilePart`
        :rtype: :class:`Class`
        """
        ## Call the constructor
        n = cls()
        n._init_from_et(root,parent)
        return n

    def _get_error_name(self):
        if hasattr(self, "get_name"):
            return self.get_name();
        else:
            return "Class";
        
    def  _init_from_et(self, root, parent):
        """
        Initialized a :class:`Class` from a :code:`class` element.  This is useful if you have a subclass of :class:`Class` .
        
        :param root: The element tree tree to parse.
        :param parent: :class:`EagleFilePart` that will become the parent of :code:`this` .
        :rtype: :class:`Class`
        """
        try:
            self.root = root
            
            if root.tag != "class":
                raise EagleFormatError("Tried to create class from " + root.tag)

            self.number=parseByType(parent, "str", None, root.get("number"))
            self.name=parseByType(parent, "str", None, root.get("name"))
            self.width=parseByType(parent, "float", None, root.get("width"))
            self.drill=parseByType(parent, "float", None, root.get("drill"))

            self.parent = parent

            ### populate the maps by searching for elements that match xpath and generating objects for them.

            for c in root.xpath("./clearance"):
                self.add_clearance(self.get_class_for_tag(c.tag)._from_et(c, self))

            ### Do the same for the lists


            ### Do the same for the attr lists


            ### And the singletons


            ### And, finally, if the objects wants the text from the tag.

        except SwoopError as e:
            e.text = "{}:{}".format(self._get_error_name(), e.text)
            raise e


    def sortkey(self):
        r = ""
        r = r + str(self.number)
        r = r + str(self.name)
        r = r + str(self.width)
        r = r + str(self.drill)
        return r

    def get_et(self):
        """
        Generate a <class> element tree for a :class:`Class`.
        
        :rtype:  :class:`ElementTree`.
        
        """
        try:
            r = ET.Element("class")

            ### Set the tag attributes 


            ## Unparse the values.

            v = unparseByType(self, "str", None,  self.number)

            ## For required attributes None becomes "".  For optional attributes, we just leave the attribute out.
            if not (isinstance(self.get_parent(), LibraryFile) and False):  # special case for the name of library.
                if v is not None:
                    r.set("number", v)
                else:
                    r.set("number", "")


            ## Unparse the values.

            v = unparseByType(self, "str", None,  self.name)

            ## For required attributes None becomes "".  For optional attributes, we just leave the attribute out.
            if not (isinstance(self.get_parent(), LibraryFile) and False):  # special case for the name of library.
                if v is not None:
                    r.set("name", v)
                else:
                    r.set("name", "")


            ## Unparse the values.

            v = unparseByType(self, "float", None,  self.width)

            ## For required attributes None becomes "".  For optional attributes, we just leave the attribute out.
            if not (isinstance(self.get_parent(), LibraryFile) and False):  # special case for the name of library.
                if v is not None:
                    r.set("width", v)


            ## Unparse the values.

            v = unparseByType(self, "float", None,  self.drill)

            ## For required attributes None becomes "".  For optional attributes, we just leave the attribute out.
            if not (isinstance(self.get_parent(), LibraryFile) and False):  # special case for the name of library.
                if v is not None:
                    r.set("drill", v)


            ### process the sections in order.  They have to be in section order,
            ### because eagle files are order dependent.


            ## For some tags, Eagle generates empty tags when there's no contant
            ## rather than just leaving the tag out.  We mark these with
            ## Tag.requireTag in GenerateSwoop.py and force their generation
            ## here.



            ## add a map.

            if len(self.clearances) is not 0:
                target = smartAddSubTags(r, "./clearance")
                # add them in sorted order.  This gives us a simple canonicalization that makes it feasible to use diff to compare files.
                target.extend([i.get_et() for i in sorted(list(self.clearances.values()),key=lambda x: x.sortkey())])


            ## set the text, if its needed.

        except SwoopError as e:
            e.text = "{}:{}".format(self._get_error_name(), e.text)
            raise e
        return r

    def clone(self):
        """
        Recursively clone this :code:`Class`.  It will be identical to the original, but it's parent will be :code:`None`.
        
        :rtype: :class:`Class`
        """
        try:
            n = copy.copy(self)
            n.clearances = {}
            for x in list(self.clearances.values()):
                n.add_clearance(x.clone())
            n.parent = None
        except SwoopError as e:
            e.text = "{}:{}".format(self._get_error_name(), e.text)
            raise e
        return n

    def accept_preorder_visitor(self, visitor):
        try:
            pre = getattr(visitor, "Class_pre")
            return pre(self)
        except AttributeError:
            return visitor.default_pre(self)
        
    def accept_postorder_visitor(self, visitor, context):
        try:
            post = getattr(visitor, "Class_post")
            post(self,context)
        except AttributeError:
            visitor.default_post(self,context)

    def is_equal(self, other):
        """
        Check whether two :code:`EagleFilePart` objects are identical.
        
        :param other: Object to compare to.
        :returns: :code:`True` if they are identical, otherwise, :code:`False`
        """
        return self.get_xml() == other.get_xml()
        
    ### Getters/Setters for attribute values

    def get_number(self):
        """ Return the value of :code:`number` for this :class:`Class`.  This corresponds to the :code:`number` attribute of a :code:`<class>` in an Eagle file.
        
        :rtype: :code:`str`
        """
        return self.number

    def set_number(self,v):
        """ Set the value of :code:`number` for this  :class:`Class`.  This corresponds to the :code:`number` attribute of a :code:`<class>` in an Eagle file.

        :param v: new value
        :rtype: :code:`self`
        """
                        
        if not typeCheck("str", v, True):
            raise SwoopError("Illegal value ({}) of type {} for attribute 'number' of Class object (should be str).".format(v, type(v)))
        self.number = v
        
        return self

    def with_number(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`number`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`number` equals :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_number()` is :code:`True`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """

        if type(v) in [str, int, float, bool]:
            return self if self.number == v else None
        elif callable(v):
            return self if v(self.number) else None
        else:
            raise SwoopError("Illegal type passed to with_number")

    def without_number(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`number`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`number` is not equal to :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_number()` is :code:`False`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """
        
        if type(v) in [str, int, float, bool]:
            return self if self.number != v else None
        elif callable(v):
            return self if not v(self.number) else None
        else:
            raise SwoopError("Illegal type passed to without_number")


    def get_name(self):
        """ Return the value of :code:`name` for this :class:`Class`.  This corresponds to the :code:`name` attribute of a :code:`<class>` in an Eagle file.
        
        :rtype: :code:`str`
        """
        return self.name

    def set_name(self,v):
        """ Set the value of :code:`name` for this  :class:`Class`.  This corresponds to the :code:`name` attribute of a :code:`<class>` in an Eagle file.

        :param v: new value
        :rtype: :code:`self`
        """
                        
        oldkey = self.name
        if not typeCheck("str", v, True):
            raise SwoopError("Illegal value ({}) of type {} for attribute 'name' of Class object (should be str).".format(v, type(v)))
        self.name = v
        
        if self.get_parent() is not None:
            self.get_parent()._rekey_child(oldkey, self);
        return self

    def with_name(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`name`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`name` equals :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_name()` is :code:`True`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """

        if type(v) in [str, int, float, bool]:
            return self if self.name == v else None
        elif callable(v):
            return self if v(self.name) else None
        else:
            raise SwoopError("Illegal type passed to with_name")

    def without_name(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`name`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`name` is not equal to :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_name()` is :code:`False`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """
        
        if type(v) in [str, int, float, bool]:
            return self if self.name != v else None
        elif callable(v):
            return self if not v(self.name) else None
        else:
            raise SwoopError("Illegal type passed to without_name")


    def get_width(self):
        """ Return the value of :code:`width` for this :class:`Class`.  This corresponds to the :code:`width` attribute of a :code:`<class>` in an Eagle file.
        
        :rtype: :code:`float`
        """
        return self.width

    def set_width(self,v):
        """ Set the value of :code:`width` for this  :class:`Class`.  This corresponds to the :code:`width` attribute of a :code:`<class>` in an Eagle file.

        :param v: new value
        :rtype: :code:`self`
        """
                        
        if not typeCheck("float", v, False):
            raise SwoopError("Illegal value ({}) of type {} for attribute 'width' of Class object (should be float).".format(v, type(v)))
        self.width = v
        
        return self

    def with_width(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`width`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`width` equals :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_width()` is :code:`True`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """

        if type(v) in [str, int, float, bool]:
            return self if self.width == v else None
        elif callable(v):
            return self if v(self.width) else None
        else:
            raise SwoopError("Illegal type passed to with_width")

    def without_width(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`width`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`width` is not equal to :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_width()` is :code:`False`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """
        
        if type(v) in [str, int, float, bool]:
            return self if self.width != v else None
        elif callable(v):
            return self if not v(self.width) else None
        else:
            raise SwoopError("Illegal type passed to without_width")


    def get_drill(self):
        """ Return the value of :code:`drill` for this :class:`Class`.  This corresponds to the :code:`drill` attribute of a :code:`<class>` in an Eagle file.
        
        :rtype: :code:`float`
        """
        return self.drill

    def set_drill(self,v):
        """ Set the value of :code:`drill` for this  :class:`Class`.  This corresponds to the :code:`drill` attribute of a :code:`<class>` in an Eagle file.

        :param v: new value
        :rtype: :code:`self`
        """
                        
        if not typeCheck("float", v, False):
            raise SwoopError("Illegal value ({}) of type {} for attribute 'drill' of Class object (should be float).".format(v, type(v)))
        self.drill = v
        
        return self

    def with_drill(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`drill`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`drill` equals :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_drill()` is :code:`True`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """

        if type(v) in [str, int, float, bool]:
            return self if self.drill == v else None
        elif callable(v):
            return self if v(self.drill) else None
        else:
            raise SwoopError("Illegal type passed to with_drill")

    def without_drill(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`drill`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`drill` is not equal to :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_drill()` is :code:`False`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """
        
        if type(v) in [str, int, float, bool]:
            return self if self.drill != v else None
        elif callable(v):
            return self if not v(self.drill) else None
        else:
            raise SwoopError("Illegal type passed to without_drill")



    ##### Lookup functions that return EFPs instead of just attribute values.
    
    


    
    ### Adder/getter/lookup for lists
    


    ### Add, lookup, and get for maps
    def add_clearance(self, s):
        """ Add a :class:`Clearance` to the :code:`clearances` of this :class:`Class`.

        :param s: The :class:`Clearance` to add.
        :rtype: :code:`self`
        """
        if not any([
                isinstance(s, Clearance),
            ]):
            raise SwoopError("Argument to Class.add_clearance() should be of type Clearance.  Got " + str(type(s).__name__) + ".")
        

        self.clearances[s.get_class()] = s

        s.parent = self
        return self

    def get_nth_clearance(self, n):
        """ get then nth :class:`Clearance` object from the :code:`clearances` of this :class:`Class`.
        
        :param n: Index of the item to return.

        :rtype: :class:`Clearance` object
        """
        return list(self.clearances.values())[n]

    def get_clearance(self, key):
        """ Lookup and return a :class:`Clearance` from the :code:`clearances` of  this :class:`Class`.
        
        :param key: A :code:`str` to use for the lookup.  The lookup uses the :code:`class` of the :class:`Clearance` objects.

        :rtype: A :class:`Clearance` object or :code:`None`, if there is no such item.
        """
        return self.clearances.get(key)


    def get_clearances(self, attrs=None, type=None):
        """Return (and possibly filter) items in the the :code:`clearances` map of :class:`Clearance` objects for this :class:`Class`.
        
        This functions provides a mechanism for filtering the items as well.
        The keys in :code:`attrs` are taken as attributes names and the
        values are requested values.  Items in the list that have all the
        requested values for the corresponding attributes will be returned.  

        A if :code:`type` is not :code:`None`, the item will match if it is an
        instance of the type provided.
        
        :param attrs: A set of key-value pairs that represent a filter to apply to the item's attributes.
        :param type:  A type to filter on.  Only items that are an instance of this type will be returned.
        :returns: A List of :class:`Clearance` objects
        :rtype: List of :class:`Clearance` objects
        """
        if attrs is not None or type is not None:
            raise NotImplementedError("filtered get not implemented")
        return list(self.clearances.values())
        

    def clear_clearances(self):
        """
        Remove all the :class:`Clearance` objects from the :code:`clearances` of this :class:`Class`.
        
        :rtype: :code:`self`
        """
        for efp in list(self.clearances.values()):
            efp.parent = None
        self.clearances = {}
        return self

    def remove_clearance(self, efp):
        """
        Remove a :class:`Clearance` from the :code:`clearances` of this :class:`Class`.
        
        :param efp: The :class:`Clearance` object to remove.

        :rtype: :code:`self`
        """
        if self.clearances[efp.get_class()] == efp:
            del self.clearances[efp.get_class()]
            efp.parent = None
            return self
        else:
            raise SwoopError("Tried to use remove_clearance() to delete the wrong kind of child?: {}".format(str(efp)))
    


    
    ### Getter/Setter for singletons.


    
    def get_children(self):
        """
        Get all the children of this :class:`EagleFilePart`.
        
        :rtype: List of :class:`EagleFilePart` objects
        """
        r = []


        r = r + list(self.clearances.values())


        return r

    def remove_child(self, efp):
        """
        Remove a child :class:`EagleFilePart` object.
        
        :param efp: the class:`EagleFilePart` object to remove.
        :return: Nothing
        """
        try:
            self.remove_clearance(efp)
        except:
            pass

    def _rekey_child(self, oldkey, efp):
        """
        Remove a child :class:`EagleFilePart` object.
        
        :param efp: the class:`EagleFilePart` object to remove.
        :return: Nothing
        """
        try:
            if self.get_clearance(oldkey) == efp:
                del self.clearances[oldkey]
                self.add_clearance(efp)
        except SwoopError:
            pass

    def check_sanity(self, visited_efps = None):
        EagleFilePart.check_sanity(self, visited_efps)

        # Check whether keys in our maps match the keys in our children
        for k in self.clearances:
            if self.clearances[k].get_class() != k:
                raise SwoopError("Child's class ('{}') doesn't match key in parent's map ('{}')".format(self.clearances[k].get_class(),k))

    def __str__(self):
        r = "["+repr(self)+" "
        r = r + "number:" + str(self.get_number()) + " "
        r = r + "name:" + str(self.get_name()) + " "
        r = r + "width:" + str(self.get_width()) + " "
        r = r + "drill:" + str(self.get_drill()) + " "
        r = r + "]"
        return r
            
    def dump(self, indent="", increment="   "):
        """
        Recursive debug dump.
        
        :param indent:  Indentation string.  The output will be indented by this much.
        :param increment: This will be appendeded to :code:`indent` on recursive invocations.

        :rtype: :code:`None`
        """
        print(indent + str(self.__class__.__name__), end=' ')
        try:
            print(self.get_name())
        except:
            print()
            pass
        for c in self.get_children():
            c.dump(indent + "   ")

        
EagleFile.class_map["class"] = Class
         


class Variantdef(EagleFilePart):
    """
    Class representing the contents of a <variantdef> tag in Eagle files.

    Attributes:

    * :code:`name`

    * :code:`current`


    """
    def __init__(self):
        """
        Construct an empty :class:`Variantdef` object.
        """
        EagleFilePart.__init__(self)
        
        self.name=None
        self.current=None


        
    @classmethod
    def _from_et(cls,root,parent):
        """
        Create a :class:`Variantdef` from a :code:`variantdef` element.
        
        :param root: The element tree tree to parse.
        :param parent: :class:`EagleFilePart` that should hold the resulting :class:`EagleFilePart`
        :rtype: :class:`Variantdef`
        """
        ## Call the constructor
        n = cls()
        n._init_from_et(root,parent)
        return n

    def _get_error_name(self):
        if hasattr(self, "get_name"):
            return self.get_name();
        else:
            return "Variantdef";
        
    def  _init_from_et(self, root, parent):
        """
        Initialized a :class:`Variantdef` from a :code:`variantdef` element.  This is useful if you have a subclass of :class:`Variantdef` .
        
        :param root: The element tree tree to parse.
        :param parent: :class:`EagleFilePart` that will become the parent of :code:`this` .
        :rtype: :class:`Variantdef`
        """
        try:
            self.root = root
            
            if root.tag != "variantdef":
                raise EagleFormatError("Tried to create variantdef from " + root.tag)

            self.name=parseByType(parent, "str", None, root.get("name"))
            self.current=parseByType(parent, "bool", None, root.get("current"))

            self.parent = parent

            ### populate the maps by searching for elements that match xpath and generating objects for them.


            ### Do the same for the lists


            ### Do the same for the attr lists


            ### And the singletons


            ### And, finally, if the objects wants the text from the tag.

        except SwoopError as e:
            e.text = "{}:{}".format(self._get_error_name(), e.text)
            raise e


    def sortkey(self):
        r = ""
        r = r + str(self.name)
        r = r + str(self.current)
        return r

    def get_et(self):
        """
        Generate a <variantdef> element tree for a :class:`Variantdef`.
        
        :rtype:  :class:`ElementTree`.
        
        """
        try:
            r = ET.Element("variantdef")

            ### Set the tag attributes 


            ## Unparse the values.

            v = unparseByType(self, "str", None,  self.name)

            ## For required attributes None becomes "".  For optional attributes, we just leave the attribute out.
            if not (isinstance(self.get_parent(), LibraryFile) and False):  # special case for the name of library.
                if v is not None:
                    r.set("name", v)
                else:
                    r.set("name", "")


            ## Unparse the values.

            v = unparseByType(self, "bool", None,  self.current)

            ## For required attributes None becomes "".  For optional attributes, we just leave the attribute out.
            if not (isinstance(self.get_parent(), LibraryFile) and False):  # special case for the name of library.
                if v is not None:
                    r.set("current", v)


            ### process the sections in order.  They have to be in section order,
            ### because eagle files are order dependent.


            ## set the text, if its needed.

        except SwoopError as e:
            e.text = "{}:{}".format(self._get_error_name(), e.text)
            raise e
        return r

    def clone(self):
        """
        Recursively clone this :code:`Variantdef`.  It will be identical to the original, but it's parent will be :code:`None`.
        
        :rtype: :class:`Variantdef`
        """
        try:
            n = copy.copy(self)
            n.parent = None
        except SwoopError as e:
            e.text = "{}:{}".format(self._get_error_name(), e.text)
            raise e
        return n

    def accept_preorder_visitor(self, visitor):
        try:
            pre = getattr(visitor, "Variantdef_pre")
            return pre(self)
        except AttributeError:
            return visitor.default_pre(self)
        
    def accept_postorder_visitor(self, visitor, context):
        try:
            post = getattr(visitor, "Variantdef_post")
            post(self,context)
        except AttributeError:
            visitor.default_post(self,context)

    def is_equal(self, other):
        """
        Check whether two :code:`EagleFilePart` objects are identical.
        
        :param other: Object to compare to.
        :returns: :code:`True` if they are identical, otherwise, :code:`False`
        """
        return self.get_xml() == other.get_xml()
        
    ### Getters/Setters for attribute values

    def get_name(self):
        """ Return the value of :code:`name` for this :class:`Variantdef`.  This corresponds to the :code:`name` attribute of a :code:`<variantdef>` in an Eagle file.
        
        :rtype: :code:`str`
        """
        return self.name

    def set_name(self,v):
        """ Set the value of :code:`name` for this  :class:`Variantdef`.  This corresponds to the :code:`name` attribute of a :code:`<variantdef>` in an Eagle file.

        :param v: new value
        :rtype: :code:`self`
        """
                        
        oldkey = self.name
        if not typeCheck("str", v, True):
            raise SwoopError("Illegal value ({}) of type {} for attribute 'name' of Variantdef object (should be str).".format(v, type(v)))
        self.name = v
        
        if self.get_parent() is not None:
            self.get_parent()._rekey_child(oldkey, self);
        return self

    def with_name(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`name`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`name` equals :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_name()` is :code:`True`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """

        if type(v) in [str, int, float, bool]:
            return self if self.name == v else None
        elif callable(v):
            return self if v(self.name) else None
        else:
            raise SwoopError("Illegal type passed to with_name")

    def without_name(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`name`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`name` is not equal to :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_name()` is :code:`False`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """
        
        if type(v) in [str, int, float, bool]:
            return self if self.name != v else None
        elif callable(v):
            return self if not v(self.name) else None
        else:
            raise SwoopError("Illegal type passed to without_name")


    def get_current(self):
        """ Return the value of :code:`current` for this :class:`Variantdef`.  This corresponds to the :code:`current` attribute of a :code:`<variantdef>` in an Eagle file.
        
        :rtype: :code:`bool`
        """
        return self.current

    def set_current(self,v):
        """ Set the value of :code:`current` for this  :class:`Variantdef`.  This corresponds to the :code:`current` attribute of a :code:`<variantdef>` in an Eagle file.

        :param v: new value
        :rtype: :code:`self`
        """
                        
        if not typeCheck("bool", v, False):
            raise SwoopError("Illegal value ({}) of type {} for attribute 'current' of Variantdef object (should be bool).".format(v, type(v)))
        self.current = v
        
        return self

    def with_current(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`current`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`current` equals :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_current()` is :code:`True`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """

        if type(v) in [str, int, float, bool]:
            return self if self.current == v else None
        elif callable(v):
            return self if v(self.current) else None
        else:
            raise SwoopError("Illegal type passed to with_current")

    def without_current(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`current`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`current` is not equal to :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_current()` is :code:`False`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """
        
        if type(v) in [str, int, float, bool]:
            return self if self.current != v else None
        elif callable(v):
            return self if not v(self.current) else None
        else:
            raise SwoopError("Illegal type passed to without_current")



    ##### Lookup functions that return EFPs instead of just attribute values.
    
    


    
    ### Adder/getter/lookup for lists
    


    ### Add, lookup, and get for maps


    
    ### Getter/Setter for singletons.


    
    def get_children(self):
        """
        Get all the children of this :class:`EagleFilePart`.
        
        :rtype: List of :class:`EagleFilePart` objects
        """
        r = []




        return r

    def remove_child(self, efp):
        """
        Remove a child :class:`EagleFilePart` object.
        
        :param efp: the class:`EagleFilePart` object to remove.
        :return: Nothing
        """

    def _rekey_child(self, oldkey, efp):
        """
        Remove a child :class:`EagleFilePart` object.
        
        :param efp: the class:`EagleFilePart` object to remove.
        :return: Nothing
        """


    def __str__(self):
        r = "["+repr(self)+" "
        r = r + "name:" + str(self.get_name()) + " "
        r = r + "current:" + str(self.get_current()) + " "
        r = r + "]"
        return r
            
    def dump(self, indent="", increment="   "):
        """
        Recursive debug dump.
        
        :param indent:  Indentation string.  The output will be indented by this much.
        :param increment: This will be appendeded to :code:`indent` on recursive invocations.

        :rtype: :code:`None`
        """
        print(indent + str(self.__class__.__name__), end=' ')
        try:
            print(self.get_name())
        except:
            print()
            pass
        for c in self.get_children():
            c.dump(indent + "   ")

        
EagleFile.class_map["variantdef"] = Variantdef
         


class Base_Part(EagleFilePart):
    """
    Class representing the contents of a <part> tag in Eagle files.

    Attributes:

    * :code:`name`

    * :code:`library`

    * :code:`library_urn`

    * :code:`deviceset`

    * :code:`device`

    * :code:`package3d_urn`

    * :code:`technology`

    * :code:`value`



    Collections:



    * :code:`attribute`: Map of :class:`Attribute` objects indexed by their :code:`name`.


    * :code:`variant`: Map of :class:`Variant` objects indexed by their :code:`name`.



    """
    def __init__(self):
        """
        Construct an empty :class:`Base_Part` object.
        """
        EagleFilePart.__init__(self)
        
        self.name=None
        self.library=None
        self.library_urn=None
        self.deviceset=None
        self.device=None
        self.package3d_urn=None
        self.technology=None
        self.value=None
        self.attributes={} #tecollections.OrderedDict()  For unclear reasons, this caused ordering to become more unpredictable, rather than less.
        self.variants={} #tecollections.OrderedDict()  For unclear reasons, this caused ordering to become more unpredictable, rather than less.


        
    @classmethod
    def _from_et(cls,root,parent):
        """
        Create a :class:`Part` from a :code:`part` element.
        
        :param root: The element tree tree to parse.
        :param parent: :class:`EagleFilePart` that should hold the resulting :class:`EagleFilePart`
        :rtype: :class:`Part`
        """
        ## Call the constructor
        n = cls()
        n._init_from_et(root,parent)
        return n

    def _get_error_name(self):
        if hasattr(self, "get_name"):
            return self.get_name();
        else:
            return "Part";
        
    def  _init_from_et(self, root, parent):
        """
        Initialized a :class:`Part` from a :code:`part` element.  This is useful if you have a subclass of :class:`Part` .
        
        :param root: The element tree tree to parse.
        :param parent: :class:`EagleFilePart` that will become the parent of :code:`this` .
        :rtype: :class:`Part`
        """
        try:
            self.root = root
            
            if root.tag != "part":
                raise EagleFormatError("Tried to create part from " + root.tag)

            self.name=parseByType(parent, "str", None, root.get("name"))
            self.library=parseByType(parent, "str", None, root.get("library"))
            self.library_urn=parseByType(parent, "str", None, root.get("library_urn"))
            self.deviceset=parseByType(parent, "str", None, root.get("deviceset"))
            self.device=parseByType(parent, "str", None, root.get("device"))
            self.package3d_urn=parseByType(parent, "str", None, root.get("package3d_urn"))
            self.technology=parseByType(parent, "None_is_default_string", '', root.get("technology"))
            self.value=parseByType(parent, "str", None, root.get("value"))

            self.parent = parent

            ### populate the maps by searching for elements that match xpath and generating objects for them.

            for c in root.xpath("./attribute"):
                self.add_attribute(self.get_class_for_tag(c.tag)._from_et(c, self))
            for c in root.xpath("./variant"):
                self.add_variant(self.get_class_for_tag(c.tag)._from_et(c, self))

            ### Do the same for the lists


            ### Do the same for the attr lists


            ### And the singletons


            ### And, finally, if the objects wants the text from the tag.

        except SwoopError as e:
            e.text = "{}:{}".format(self._get_error_name(), e.text)
            raise e


    def sortkey(self):
        r = ""
        r = r + str(self.name)
        r = r + str(self.library)
        r = r + str(self.library_urn)
        r = r + str(self.deviceset)
        r = r + str(self.device)
        r = r + str(self.package3d_urn)
        r = r + str(self.technology)
        r = r + str(self.value)
        return r

    def get_et(self):
        """
        Generate a <part> element tree for a :class:`Part`.
        
        :rtype:  :class:`ElementTree`.
        
        """
        try:
            r = ET.Element("part")

            ### Set the tag attributes 


            ## Unparse the values.

            v = unparseByType(self, "str", None,  self.name)

            ## For required attributes None becomes "".  For optional attributes, we just leave the attribute out.
            if not (isinstance(self.get_parent(), LibraryFile) and False):  # special case for the name of library.
                if v is not None:
                    r.set("name", v)
                else:
                    r.set("name", "")


            ## Unparse the values.

            v = unparseByType(self, "str", None,  self.library)

            ## For required attributes None becomes "".  For optional attributes, we just leave the attribute out.
            if not (isinstance(self.get_parent(), LibraryFile) and False):  # special case for the name of library.
                if v is not None:
                    r.set("library", v)
                else:
                    r.set("library", "")


            ## Unparse the values.

            v = unparseByType(self, "str", None,  self.library_urn)

            ## For required attributes None becomes "".  For optional attributes, we just leave the attribute out.
            if not (isinstance(self.get_parent(), LibraryFile) and False):  # special case for the name of library.
                if v is not None:
                    r.set("library_urn", v)


            ## Unparse the values.

            v = unparseByType(self, "str", None,  self.deviceset)

            ## For required attributes None becomes "".  For optional attributes, we just leave the attribute out.
            if not (isinstance(self.get_parent(), LibraryFile) and False):  # special case for the name of library.
                if v is not None:
                    r.set("deviceset", v)
                else:
                    r.set("deviceset", "")


            ## Unparse the values.

            v = unparseByType(self, "str", None,  self.device)

            ## For required attributes None becomes "".  For optional attributes, we just leave the attribute out.
            if not (isinstance(self.get_parent(), LibraryFile) and False):  # special case for the name of library.
                if v is not None:
                    r.set("device", v)
                else:
                    r.set("device", "")


            ## Unparse the values.

            v = unparseByType(self, "str", None,  self.package3d_urn)

            ## For required attributes None becomes "".  For optional attributes, we just leave the attribute out.
            if not (isinstance(self.get_parent(), LibraryFile) and False):  # special case for the name of library.
                if v is not None:
                    r.set("package3d_urn", v)


            ## Unparse the values.

            v = unparseByType(self, "None_is_default_string", '',  self.technology)

            ## For required attributes None becomes "".  For optional attributes, we just leave the attribute out.
            if not (isinstance(self.get_parent(), LibraryFile) and False):  # special case for the name of library.
                if v is not None:
                    r.set("technology", v)


            ## Unparse the values.

            v = unparseByType(self, "str", None,  self.value)

            ## For required attributes None becomes "".  For optional attributes, we just leave the attribute out.
            if not (isinstance(self.get_parent(), LibraryFile) and False):  # special case for the name of library.
                if v is not None:
                    r.set("value", v)


            ### process the sections in order.  They have to be in section order,
            ### because eagle files are order dependent.


            ## For some tags, Eagle generates empty tags when there's no contant
            ## rather than just leaving the tag out.  We mark these with
            ## Tag.requireTag in GenerateSwoop.py and force their generation
            ## here.

            smartAddSubTags(r, "./attribute")


            ## add a map.

            if len(self.attributes) is not 0:
                target = smartAddSubTags(r, "./attribute")
                # add them in sorted order.  This gives us a simple canonicalization that makes it feasible to use diff to compare files.
                target.extend([i.get_et() for i in sorted(list(self.attributes.values()),key=lambda x: x.sortkey())])


            ## For some tags, Eagle generates empty tags when there's no contant
            ## rather than just leaving the tag out.  We mark these with
            ## Tag.requireTag in GenerateSwoop.py and force their generation
            ## here.



            ## add a map.

            if len(self.variants) is not 0:
                target = smartAddSubTags(r, "./variant")
                # add them in sorted order.  This gives us a simple canonicalization that makes it feasible to use diff to compare files.
                target.extend([i.get_et() for i in sorted(list(self.variants.values()),key=lambda x: x.sortkey())])


            ## set the text, if its needed.

        except SwoopError as e:
            e.text = "{}:{}".format(self._get_error_name(), e.text)
            raise e
        return r

    def clone(self):
        """
        Recursively clone this :code:`Part`.  It will be identical to the original, but it's parent will be :code:`None`.
        
        :rtype: :class:`Part`
        """
        try:
            n = copy.copy(self)
            n.attributes = {}
            for x in list(self.attributes.values()):
                n.add_attribute(x.clone())
            n.variants = {}
            for x in list(self.variants.values()):
                n.add_variant(x.clone())
            n.parent = None
        except SwoopError as e:
            e.text = "{}:{}".format(self._get_error_name(), e.text)
            raise e
        return n

    def accept_preorder_visitor(self, visitor):
        try:
            pre = getattr(visitor, "Part_pre")
            return pre(self)
        except AttributeError:
            return visitor.default_pre(self)
        
    def accept_postorder_visitor(self, visitor, context):
        try:
            post = getattr(visitor, "Part_post")
            post(self,context)
        except AttributeError:
            visitor.default_post(self,context)

    def is_equal(self, other):
        """
        Check whether two :code:`EagleFilePart` objects are identical.
        
        :param other: Object to compare to.
        :returns: :code:`True` if they are identical, otherwise, :code:`False`
        """
        return self.get_xml() == other.get_xml()
        
    ### Getters/Setters for attribute values

    def get_name(self):
        """ Return the value of :code:`name` for this :class:`Part`.  This corresponds to the :code:`name` attribute of a :code:`<part>` in an Eagle file.
        
        :rtype: :code:`str`
        """
        return self.name

    def set_name(self,v):
        """ Set the value of :code:`name` for this  :class:`Part`.  This corresponds to the :code:`name` attribute of a :code:`<part>` in an Eagle file.

        :param v: new value
        :rtype: :code:`self`
        """
                        
        oldkey = self.name
        if not typeCheck("str", v, True):
            raise SwoopError("Illegal value ({}) of type {} for attribute 'name' of Part object (should be str).".format(v, type(v)))
        self.name = v
        
        if self.get_parent() is not None:
            self.get_parent()._rekey_child(oldkey, self);
        return self

    def with_name(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`name`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`name` equals :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_name()` is :code:`True`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """

        if type(v) in [str, int, float, bool]:
            return self if self.name == v else None
        elif callable(v):
            return self if v(self.name) else None
        else:
            raise SwoopError("Illegal type passed to with_name")

    def without_name(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`name`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`name` is not equal to :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_name()` is :code:`False`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """
        
        if type(v) in [str, int, float, bool]:
            return self if self.name != v else None
        elif callable(v):
            return self if not v(self.name) else None
        else:
            raise SwoopError("Illegal type passed to without_name")


    def get_library(self):
        """ Return the value of :code:`library` for this :class:`Part`.  This corresponds to the :code:`library` attribute of a :code:`<part>` in an Eagle file.
        
        :rtype: :code:`str`
        """
        return self.library

    def set_library(self,v):
        """ Set the value of :code:`library` for this  :class:`Part`.  This corresponds to the :code:`library` attribute of a :code:`<part>` in an Eagle file.

        :param v: new value
        :rtype: :code:`self`
        """
                        
        if not typeCheck("str", v, True):
            raise SwoopError("Illegal value ({}) of type {} for attribute 'library' of Part object (should be str).".format(v, type(v)))
        self.library = v
        
        return self

    def with_library(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`library`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`library` equals :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_library()` is :code:`True`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """

        if type(v) in [str, int, float, bool]:
            return self if self.library == v else None
        elif callable(v):
            return self if v(self.library) else None
        else:
            raise SwoopError("Illegal type passed to with_library")

    def without_library(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`library`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`library` is not equal to :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_library()` is :code:`False`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """
        
        if type(v) in [str, int, float, bool]:
            return self if self.library != v else None
        elif callable(v):
            return self if not v(self.library) else None
        else:
            raise SwoopError("Illegal type passed to without_library")


    def get_library_urn(self):
        """ Return the value of :code:`library_urn` for this :class:`Part`.  This corresponds to the :code:`library_urn` attribute of a :code:`<part>` in an Eagle file.
        
        :rtype: :code:`str`
        """
        return self.library_urn

    def set_library_urn(self,v):
        """ Set the value of :code:`library_urn` for this  :class:`Part`.  This corresponds to the :code:`library_urn` attribute of a :code:`<part>` in an Eagle file.

        :param v: new value
        :rtype: :code:`self`
        """
                        
        if not typeCheck("str", v, False):
            raise SwoopError("Illegal value ({}) of type {} for attribute 'library_urn' of Part object (should be str).".format(v, type(v)))
        self.library_urn = v
        
        return self

    def with_library_urn(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`library_urn`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`library_urn` equals :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_library_urn()` is :code:`True`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """

        if type(v) in [str, int, float, bool]:
            return self if self.library_urn == v else None
        elif callable(v):
            return self if v(self.library_urn) else None
        else:
            raise SwoopError("Illegal type passed to with_library_urn")

    def without_library_urn(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`library_urn`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`library_urn` is not equal to :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_library_urn()` is :code:`False`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """
        
        if type(v) in [str, int, float, bool]:
            return self if self.library_urn != v else None
        elif callable(v):
            return self if not v(self.library_urn) else None
        else:
            raise SwoopError("Illegal type passed to without_library_urn")


    def get_deviceset(self):
        """ Return the value of :code:`deviceset` for this :class:`Part`.  This corresponds to the :code:`deviceset` attribute of a :code:`<part>` in an Eagle file.
        
        :rtype: :code:`str`
        """
        return self.deviceset

    def set_deviceset(self,v):
        """ Set the value of :code:`deviceset` for this  :class:`Part`.  This corresponds to the :code:`deviceset` attribute of a :code:`<part>` in an Eagle file.

        :param v: new value
        :rtype: :code:`self`
        """
                        
        if not typeCheck("str", v, True):
            raise SwoopError("Illegal value ({}) of type {} for attribute 'deviceset' of Part object (should be str).".format(v, type(v)))
        self.deviceset = v
        
        return self

    def with_deviceset(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`deviceset`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`deviceset` equals :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_deviceset()` is :code:`True`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """

        if type(v) in [str, int, float, bool]:
            return self if self.deviceset == v else None
        elif callable(v):
            return self if v(self.deviceset) else None
        else:
            raise SwoopError("Illegal type passed to with_deviceset")

    def without_deviceset(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`deviceset`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`deviceset` is not equal to :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_deviceset()` is :code:`False`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """
        
        if type(v) in [str, int, float, bool]:
            return self if self.deviceset != v else None
        elif callable(v):
            return self if not v(self.deviceset) else None
        else:
            raise SwoopError("Illegal type passed to without_deviceset")


    def get_device(self):
        """ Return the value of :code:`device` for this :class:`Part`.  This corresponds to the :code:`device` attribute of a :code:`<part>` in an Eagle file.
        
        :rtype: :code:`str`
        """
        return self.device

    def set_device(self,v):
        """ Set the value of :code:`device` for this  :class:`Part`.  This corresponds to the :code:`device` attribute of a :code:`<part>` in an Eagle file.

        :param v: new value
        :rtype: :code:`self`
        """
                        
        if not typeCheck("str", v, True):
            raise SwoopError("Illegal value ({}) of type {} for attribute 'device' of Part object (should be str).".format(v, type(v)))
        self.device = v
        
        return self

    def with_device(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`device`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`device` equals :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_device()` is :code:`True`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """

        if type(v) in [str, int, float, bool]:
            return self if self.device == v else None
        elif callable(v):
            return self if v(self.device) else None
        else:
            raise SwoopError("Illegal type passed to with_device")

    def without_device(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`device`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`device` is not equal to :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_device()` is :code:`False`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """
        
        if type(v) in [str, int, float, bool]:
            return self if self.device != v else None
        elif callable(v):
            return self if not v(self.device) else None
        else:
            raise SwoopError("Illegal type passed to without_device")


    def get_package3d_urn(self):
        """ Return the value of :code:`package3d_urn` for this :class:`Part`.  This corresponds to the :code:`package3d_urn` attribute of a :code:`<part>` in an Eagle file.
        
        :rtype: :code:`str`
        """
        return self.package3d_urn

    def set_package3d_urn(self,v):
        """ Set the value of :code:`package3d_urn` for this  :class:`Part`.  This corresponds to the :code:`package3d_urn` attribute of a :code:`<part>` in an Eagle file.

        :param v: new value
        :rtype: :code:`self`
        """
                        
        if not typeCheck("str", v, False):
            raise SwoopError("Illegal value ({}) of type {} for attribute 'package3d_urn' of Part object (should be str).".format(v, type(v)))
        self.package3d_urn = v
        
        return self

    def with_package3d_urn(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`package3d_urn`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`package3d_urn` equals :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_package3d_urn()` is :code:`True`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """

        if type(v) in [str, int, float, bool]:
            return self if self.package3d_urn == v else None
        elif callable(v):
            return self if v(self.package3d_urn) else None
        else:
            raise SwoopError("Illegal type passed to with_package3d_urn")

    def without_package3d_urn(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`package3d_urn`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`package3d_urn` is not equal to :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_package3d_urn()` is :code:`False`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """
        
        if type(v) in [str, int, float, bool]:
            return self if self.package3d_urn != v else None
        elif callable(v):
            return self if not v(self.package3d_urn) else None
        else:
            raise SwoopError("Illegal type passed to without_package3d_urn")


    def get_technology(self):
        """ Return the value of :code:`technology` for this :class:`Part`.  This corresponds to the :code:`technology` attribute of a :code:`<part>` in an Eagle file.
        
        :rtype: :code:`None_is_default_string`
        """
        return self.technology

    def set_technology(self,v):
        """ Set the value of :code:`technology` for this  :class:`Part`.  This corresponds to the :code:`technology` attribute of a :code:`<part>` in an Eagle file.

        :param v: new value
        :rtype: :code:`self`
        """
                        
        if not typeCheck("None_is_default_string", v, False):
            raise SwoopError("Illegal value ({}) of type {} for attribute 'technology' of Part object (should be None_is_default_string).".format(v, type(v)))
        self.technology = v
        
        return self

    def with_technology(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`technology`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`technology` equals :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_technology()` is :code:`True`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """

        if type(v) in [str, int, float, bool]:
            return self if self.technology == v else None
        elif callable(v):
            return self if v(self.technology) else None
        else:
            raise SwoopError("Illegal type passed to with_technology")

    def without_technology(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`technology`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`technology` is not equal to :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_technology()` is :code:`False`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """
        
        if type(v) in [str, int, float, bool]:
            return self if self.technology != v else None
        elif callable(v):
            return self if not v(self.technology) else None
        else:
            raise SwoopError("Illegal type passed to without_technology")


    def get_value(self):
        """ Return the value of :code:`value` for this :class:`Part`.  This corresponds to the :code:`value` attribute of a :code:`<part>` in an Eagle file.
        
        :rtype: :code:`str`
        """
        return self.value

    def set_value(self,v):
        """ Set the value of :code:`value` for this  :class:`Part`.  This corresponds to the :code:`value` attribute of a :code:`<part>` in an Eagle file.

        :param v: new value
        :rtype: :code:`self`
        """
                        
        if not typeCheck("str", v, False):
            raise SwoopError("Illegal value ({}) of type {} for attribute 'value' of Part object (should be str).".format(v, type(v)))
        self.value = v
        
        return self

    def with_value(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`value`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`value` equals :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_value()` is :code:`True`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """

        if type(v) in [str, int, float, bool]:
            return self if self.value == v else None
        elif callable(v):
            return self if v(self.value) else None
        else:
            raise SwoopError("Illegal type passed to with_value")

    def without_value(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`value`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`value` is not equal to :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_value()` is :code:`False`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """
        
        if type(v) in [str, int, float, bool]:
            return self if self.value != v else None
        elif callable(v):
            return self if not v(self.value) else None
        else:
            raise SwoopError("Illegal type passed to without_value")



    ##### Lookup functions that return EFPs instead of just attribute values.
    
    def find_library(self):
        """Find the :class:`Library` object refered to by the :code:`library` attribute of this object.  This is like
        :meth:`get_library`, except it returns the :class:`Library` object instead of its name.
        
        :returns: The object
        :rtype: :class:`Library`

        """
        f = lambda efp, key: efp.get_parent().get_library(key)
        return f(self, self.library)
    def find_deviceset(self):
        """Find the :class:`Deviceset` object refered to by the :code:`deviceset` attribute of this object.  This is like
        :meth:`get_deviceset`, except it returns the :class:`Deviceset` object instead of its name.
        
        :returns: The object
        :rtype: :class:`Deviceset`

        """
        f = lambda efp, key: efp.find_library().get_deviceset(key)
        return f(self, self.deviceset)
    def find_device(self):
        """Find the :class:`Device` object refered to by the :code:`device` attribute of this object.  This is like
        :meth:`get_device`, except it returns the :class:`Device` object instead of its name.
        
        :returns: The object
        :rtype: :class:`Device`

        """
        f = lambda efp, key: efp.find_deviceset().get_device(key)
        return f(self, self.device)
    def find_technology(self):
        """Find the :class:`Technology` object refered to by the :code:`technology` attribute of this object.  This is like
        :meth:`get_technology`, except it returns the :class:`Technology` object instead of its name.
        
        :returns: The object
        :rtype: :class:`Technology`

        """
        f = lambda efp, key: efp.find_device().get_technology(key)
        return f(self, self.technology)
    


    
    ### Adder/getter/lookup for lists
    


    ### Add, lookup, and get for maps
    def add_attribute(self, s):
        """ Add a :class:`Attribute` to the :code:`attributes` of this :class:`Part`.

        :param s: The :class:`Attribute` to add.
        :rtype: :code:`self`
        """
        if not any([
                isinstance(s, Attribute),
            ]):
            raise SwoopError("Argument to Base_Part.add_attribute() should be of type Attribute.  Got " + str(type(s).__name__) + ".")
        

        self.attributes[s.get_name()] = s

        s.parent = self
        return self

    def get_nth_attribute(self, n):
        """ get then nth :class:`Attribute` object from the :code:`attributes` of this :class:`Part`.
        
        :param n: Index of the item to return.

        :rtype: :class:`Attribute` object
        """
        return list(self.attributes.values())[n]

    def get_attribute(self, key):
        """ Lookup and return a :class:`Attribute` from the :code:`attributes` of  this :class:`Part`.
        
        :param key: A :code:`str` to use for the lookup.  The lookup uses the :code:`name` of the :class:`Attribute` objects.

        :rtype: A :class:`Attribute` object or :code:`None`, if there is no such item.
        """
        return self.attributes.get(key)


    def get_attributes(self, attrs=None, type=None):
        """Return (and possibly filter) items in the the :code:`attributes` map of :class:`Attribute` objects for this :class:`Part`.
        
        This functions provides a mechanism for filtering the items as well.
        The keys in :code:`attrs` are taken as attributes names and the
        values are requested values.  Items in the list that have all the
        requested values for the corresponding attributes will be returned.  

        A if :code:`type` is not :code:`None`, the item will match if it is an
        instance of the type provided.
        
        :param attrs: A set of key-value pairs that represent a filter to apply to the item's attributes.
        :param type:  A type to filter on.  Only items that are an instance of this type will be returned.
        :returns: A List of :class:`Attribute` objects
        :rtype: List of :class:`Attribute` objects
        """
        if attrs is not None or type is not None:
            raise NotImplementedError("filtered get not implemented")
        return list(self.attributes.values())
        

    def clear_attributes(self):
        """
        Remove all the :class:`Attribute` objects from the :code:`attributes` of this :class:`Part`.
        
        :rtype: :code:`self`
        """
        for efp in list(self.attributes.values()):
            efp.parent = None
        self.attributes = {}
        return self

    def remove_attribute(self, efp):
        """
        Remove a :class:`Attribute` from the :code:`attributes` of this :class:`Part`.
        
        :param efp: The :class:`Attribute` object to remove.

        :rtype: :code:`self`
        """
        if self.attributes[efp.get_name()] == efp:
            del self.attributes[efp.get_name()]
            efp.parent = None
            return self
        else:
            raise SwoopError("Tried to use remove_attribute() to delete the wrong kind of child?: {}".format(str(efp)))
    
    def add_variant(self, s):
        """ Add a :class:`Variant` to the :code:`variants` of this :class:`Part`.

        :param s: The :class:`Variant` to add.
        :rtype: :code:`self`
        """
        if not any([
                isinstance(s, Variant),
            ]):
            raise SwoopError("Argument to Base_Part.add_variant() should be of type Variant.  Got " + str(type(s).__name__) + ".")
        

        self.variants[s.get_name()] = s

        s.parent = self
        return self

    def get_nth_variant(self, n):
        """ get then nth :class:`Variant` object from the :code:`variants` of this :class:`Part`.
        
        :param n: Index of the item to return.

        :rtype: :class:`Variant` object
        """
        return list(self.variants.values())[n]

    def get_variant(self, key):
        """ Lookup and return a :class:`Variant` from the :code:`variants` of  this :class:`Part`.
        
        :param key: A :code:`str` to use for the lookup.  The lookup uses the :code:`name` of the :class:`Variant` objects.

        :rtype: A :class:`Variant` object or :code:`None`, if there is no such item.
        """
        return self.variants.get(key)


    def get_variants(self, attrs=None, type=None):
        """Return (and possibly filter) items in the the :code:`variants` map of :class:`Variant` objects for this :class:`Part`.
        
        This functions provides a mechanism for filtering the items as well.
        The keys in :code:`attrs` are taken as attributes names and the
        values are requested values.  Items in the list that have all the
        requested values for the corresponding attributes will be returned.  

        A if :code:`type` is not :code:`None`, the item will match if it is an
        instance of the type provided.
        
        :param attrs: A set of key-value pairs that represent a filter to apply to the item's attributes.
        :param type:  A type to filter on.  Only items that are an instance of this type will be returned.
        :returns: A List of :class:`Variant` objects
        :rtype: List of :class:`Variant` objects
        """
        if attrs is not None or type is not None:
            raise NotImplementedError("filtered get not implemented")
        return list(self.variants.values())
        

    def clear_variants(self):
        """
        Remove all the :class:`Variant` objects from the :code:`variants` of this :class:`Part`.
        
        :rtype: :code:`self`
        """
        for efp in list(self.variants.values()):
            efp.parent = None
        self.variants = {}
        return self

    def remove_variant(self, efp):
        """
        Remove a :class:`Variant` from the :code:`variants` of this :class:`Part`.
        
        :param efp: The :class:`Variant` object to remove.

        :rtype: :code:`self`
        """
        if self.variants[efp.get_name()] == efp:
            del self.variants[efp.get_name()]
            efp.parent = None
            return self
        else:
            raise SwoopError("Tried to use remove_variant() to delete the wrong kind of child?: {}".format(str(efp)))
    


    
    ### Getter/Setter for singletons.


    
    def get_children(self):
        """
        Get all the children of this :class:`EagleFilePart`.
        
        :rtype: List of :class:`EagleFilePart` objects
        """
        r = []


        r = r + list(self.attributes.values())
        r = r + list(self.variants.values())


        return r

    def remove_child(self, efp):
        """
        Remove a child :class:`EagleFilePart` object.
        
        :param efp: the class:`EagleFilePart` object to remove.
        :return: Nothing
        """
        try:
            self.remove_attribute(efp)
        except:
            pass
        try:
            self.remove_variant(efp)
        except:
            pass

    def _rekey_child(self, oldkey, efp):
        """
        Remove a child :class:`EagleFilePart` object.
        
        :param efp: the class:`EagleFilePart` object to remove.
        :return: Nothing
        """
        try:
            if self.get_attribute(oldkey) == efp:
                del self.attributes[oldkey]
                self.add_attribute(efp)
        except SwoopError:
            pass
        try:
            if self.get_variant(oldkey) == efp:
                del self.variants[oldkey]
                self.add_variant(efp)
        except SwoopError:
            pass

    def check_sanity(self, visited_efps = None):
        EagleFilePart.check_sanity(self, visited_efps)

        # Check whether keys in our maps match the keys in our children
        for k in self.attributes:
            if self.attributes[k].get_name() != k:
                raise SwoopError("Child's name ('{}') doesn't match key in parent's map ('{}')".format(self.attributes[k].get_name(),k))
        for k in self.variants:
            if self.variants[k].get_name() != k:
                raise SwoopError("Child's name ('{}') doesn't match key in parent's map ('{}')".format(self.variants[k].get_name(),k))

    def __str__(self):
        r = "["+repr(self)+" "
        r = r + "name:" + str(self.get_name()) + " "
        r = r + "library:" + str(self.get_library()) + " "
        r = r + "library_urn:" + str(self.get_library_urn()) + " "
        r = r + "deviceset:" + str(self.get_deviceset()) + " "
        r = r + "device:" + str(self.get_device()) + " "
        r = r + "package3d_urn:" + str(self.get_package3d_urn()) + " "
        r = r + "technology:" + str(self.get_technology()) + " "
        r = r + "value:" + str(self.get_value()) + " "
        r = r + "]"
        return r
            
    def dump(self, indent="", increment="   "):
        """
        Recursive debug dump.
        
        :param indent:  Indentation string.  The output will be indented by this much.
        :param increment: This will be appendeded to :code:`indent` on recursive invocations.

        :rtype: :code:`None`
        """
        print(indent + str(self.__class__.__name__), end=' ')
        try:
            print(self.get_name())
        except:
            print()
            pass
        for c in self.get_children():
            c.dump(indent + "   ")

        
EagleFile.class_map["part"] = Base_Part
         


class Grid(EagleFilePart):
    """
    Class representing the contents of a <grid> tag in Eagle files.

    Attributes:

    * :code:`distance`

    * :code:`unitdist`

    * :code:`unit`

    * :code:`style`

    * :code:`multiple`

    * :code:`display`

    * :code:`altdistance`

    * :code:`altunitdist`

    * :code:`altunit`


    """
    def __init__(self):
        """
        Construct an empty :class:`Grid` object.
        """
        EagleFilePart.__init__(self)
        
        self.distance=None
        self.unitdist=None
        self.unit=None
        self.style=None
        self.multiple=None
        self.display=None
        self.altdistance=None
        self.altunitdist=None
        self.altunit=None


        
    @classmethod
    def _from_et(cls,root,parent):
        """
        Create a :class:`Grid` from a :code:`grid` element.
        
        :param root: The element tree tree to parse.
        :param parent: :class:`EagleFilePart` that should hold the resulting :class:`EagleFilePart`
        :rtype: :class:`Grid`
        """
        ## Call the constructor
        n = cls()
        n._init_from_et(root,parent)
        return n

    def _get_error_name(self):
        if hasattr(self, "get_name"):
            return self.get_name();
        else:
            return "Grid";
        
    def  _init_from_et(self, root, parent):
        """
        Initialized a :class:`Grid` from a :code:`grid` element.  This is useful if you have a subclass of :class:`Grid` .
        
        :param root: The element tree tree to parse.
        :param parent: :class:`EagleFilePart` that will become the parent of :code:`this` .
        :rtype: :class:`Grid`
        """
        try:
            self.root = root
            
            if root.tag != "grid":
                raise EagleFormatError("Tried to create grid from " + root.tag)

            self.distance=parseByType(parent, "float", None, root.get("distance"))
            self.unitdist=parseByType(parent, "str", None, root.get("unitdist"))
            self.unit=parseByType(parent, "str", None, root.get("unit"))
            self.style=parseByType(parent, "str", None, root.get("style"))
            self.multiple=parseByType(parent, "int", None, root.get("multiple"))
            self.display=parseByType(parent, "bool", None, root.get("display"))
            self.altdistance=parseByType(parent, "float", None, root.get("altdistance"))
            self.altunitdist=parseByType(parent, "str", None, root.get("altunitdist"))
            self.altunit=parseByType(parent, "str", None, root.get("altunit"))

            self.parent = parent

            ### populate the maps by searching for elements that match xpath and generating objects for them.


            ### Do the same for the lists


            ### Do the same for the attr lists


            ### And the singletons


            ### And, finally, if the objects wants the text from the tag.

        except SwoopError as e:
            e.text = "{}:{}".format(self._get_error_name(), e.text)
            raise e


    def sortkey(self):
        r = ""
        r = r + str(self.distance)
        r = r + str(self.unitdist)
        r = r + str(self.unit)
        r = r + str(self.style)
        r = r + str(self.multiple)
        r = r + str(self.display)
        r = r + str(self.altdistance)
        r = r + str(self.altunitdist)
        r = r + str(self.altunit)
        return r

    def get_et(self):
        """
        Generate a <grid> element tree for a :class:`Grid`.
        
        :rtype:  :class:`ElementTree`.
        
        """
        try:
            r = ET.Element("grid")

            ### Set the tag attributes 


            ## Unparse the values.

            v = unparseByType(self, "float", None,  self.distance)

            ## For required attributes None becomes "".  For optional attributes, we just leave the attribute out.
            if not (isinstance(self.get_parent(), LibraryFile) and False):  # special case for the name of library.
                if v is not None:
                    r.set("distance", v)


            ## Unparse the values.

            v = unparseByType(self, "str", None,  self.unitdist)

            ## For required attributes None becomes "".  For optional attributes, we just leave the attribute out.
            if not (isinstance(self.get_parent(), LibraryFile) and False):  # special case for the name of library.
                if v is not None:
                    r.set("unitdist", v)


            ## Unparse the values.

            v = unparseByType(self, "str", None,  self.unit)

            ## For required attributes None becomes "".  For optional attributes, we just leave the attribute out.
            if not (isinstance(self.get_parent(), LibraryFile) and False):  # special case for the name of library.
                if v is not None:
                    r.set("unit", v)


            ## Unparse the values.

            v = unparseByType(self, "str", None,  self.style)

            ## For required attributes None becomes "".  For optional attributes, we just leave the attribute out.
            if not (isinstance(self.get_parent(), LibraryFile) and False):  # special case for the name of library.
                if v is not None:
                    r.set("style", v)


            ## Unparse the values.

            v = unparseByType(self, "int", None,  self.multiple)

            ## For required attributes None becomes "".  For optional attributes, we just leave the attribute out.
            if not (isinstance(self.get_parent(), LibraryFile) and False):  # special case for the name of library.
                if v is not None:
                    r.set("multiple", v)


            ## Unparse the values.

            v = unparseByType(self, "bool", None,  self.display)

            ## For required attributes None becomes "".  For optional attributes, we just leave the attribute out.
            if not (isinstance(self.get_parent(), LibraryFile) and False):  # special case for the name of library.
                if v is not None:
                    r.set("display", v)


            ## Unparse the values.

            v = unparseByType(self, "float", None,  self.altdistance)

            ## For required attributes None becomes "".  For optional attributes, we just leave the attribute out.
            if not (isinstance(self.get_parent(), LibraryFile) and False):  # special case for the name of library.
                if v is not None:
                    r.set("altdistance", v)


            ## Unparse the values.

            v = unparseByType(self, "str", None,  self.altunitdist)

            ## For required attributes None becomes "".  For optional attributes, we just leave the attribute out.
            if not (isinstance(self.get_parent(), LibraryFile) and False):  # special case for the name of library.
                if v is not None:
                    r.set("altunitdist", v)


            ## Unparse the values.

            v = unparseByType(self, "str", None,  self.altunit)

            ## For required attributes None becomes "".  For optional attributes, we just leave the attribute out.
            if not (isinstance(self.get_parent(), LibraryFile) and False):  # special case for the name of library.
                if v is not None:
                    r.set("altunit", v)


            ### process the sections in order.  They have to be in section order,
            ### because eagle files are order dependent.


            ## set the text, if its needed.

        except SwoopError as e:
            e.text = "{}:{}".format(self._get_error_name(), e.text)
            raise e
        return r

    def clone(self):
        """
        Recursively clone this :code:`Grid`.  It will be identical to the original, but it's parent will be :code:`None`.
        
        :rtype: :class:`Grid`
        """
        try:
            n = copy.copy(self)
            n.parent = None
        except SwoopError as e:
            e.text = "{}:{}".format(self._get_error_name(), e.text)
            raise e
        return n

    def accept_preorder_visitor(self, visitor):
        try:
            pre = getattr(visitor, "Grid_pre")
            return pre(self)
        except AttributeError:
            return visitor.default_pre(self)
        
    def accept_postorder_visitor(self, visitor, context):
        try:
            post = getattr(visitor, "Grid_post")
            post(self,context)
        except AttributeError:
            visitor.default_post(self,context)

    def is_equal(self, other):
        """
        Check whether two :code:`EagleFilePart` objects are identical.
        
        :param other: Object to compare to.
        :returns: :code:`True` if they are identical, otherwise, :code:`False`
        """
        return self.get_xml() == other.get_xml()
        
    ### Getters/Setters for attribute values

    def get_distance(self):
        """ Return the value of :code:`distance` for this :class:`Grid`.  This corresponds to the :code:`distance` attribute of a :code:`<grid>` in an Eagle file.
        
        :rtype: :code:`float`
        """
        return self.distance

    def set_distance(self,v):
        """ Set the value of :code:`distance` for this  :class:`Grid`.  This corresponds to the :code:`distance` attribute of a :code:`<grid>` in an Eagle file.

        :param v: new value
        :rtype: :code:`self`
        """
                        
        if not typeCheck("float", v, False):
            raise SwoopError("Illegal value ({}) of type {} for attribute 'distance' of Grid object (should be float).".format(v, type(v)))
        self.distance = v
        
        return self

    def with_distance(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`distance`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`distance` equals :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_distance()` is :code:`True`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """

        if type(v) in [str, int, float, bool]:
            return self if self.distance == v else None
        elif callable(v):
            return self if v(self.distance) else None
        else:
            raise SwoopError("Illegal type passed to with_distance")

    def without_distance(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`distance`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`distance` is not equal to :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_distance()` is :code:`False`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """
        
        if type(v) in [str, int, float, bool]:
            return self if self.distance != v else None
        elif callable(v):
            return self if not v(self.distance) else None
        else:
            raise SwoopError("Illegal type passed to without_distance")


    def get_unitdist(self):
        """ Return the value of :code:`unitdist` for this :class:`Grid`.  This corresponds to the :code:`unitdist` attribute of a :code:`<grid>` in an Eagle file.
        
        :rtype: :code:`str`
        """
        return self.unitdist

    def set_unitdist(self,v):
        """ Set the value of :code:`unitdist` for this  :class:`Grid`.  This corresponds to the :code:`unitdist` attribute of a :code:`<grid>` in an Eagle file.

        :param v: new value
        :rtype: :code:`self`
        """
                        
        if not typeCheck("str", v, False):
            raise SwoopError("Illegal value ({}) of type {} for attribute 'unitdist' of Grid object (should be str).".format(v, type(v)))
        self.unitdist = v
        
        return self

    def with_unitdist(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`unitdist`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`unitdist` equals :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_unitdist()` is :code:`True`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """

        if type(v) in [str, int, float, bool]:
            return self if self.unitdist == v else None
        elif callable(v):
            return self if v(self.unitdist) else None
        else:
            raise SwoopError("Illegal type passed to with_unitdist")

    def without_unitdist(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`unitdist`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`unitdist` is not equal to :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_unitdist()` is :code:`False`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """
        
        if type(v) in [str, int, float, bool]:
            return self if self.unitdist != v else None
        elif callable(v):
            return self if not v(self.unitdist) else None
        else:
            raise SwoopError("Illegal type passed to without_unitdist")


    def get_unit(self):
        """ Return the value of :code:`unit` for this :class:`Grid`.  This corresponds to the :code:`unit` attribute of a :code:`<grid>` in an Eagle file.
        
        :rtype: :code:`str`
        """
        return self.unit

    def set_unit(self,v):
        """ Set the value of :code:`unit` for this  :class:`Grid`.  This corresponds to the :code:`unit` attribute of a :code:`<grid>` in an Eagle file.

        :param v: new value
        :rtype: :code:`self`
        """
                        
        if not typeCheck("str", v, False):
            raise SwoopError("Illegal value ({}) of type {} for attribute 'unit' of Grid object (should be str).".format(v, type(v)))
        self.unit = v
        
        return self

    def with_unit(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`unit`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`unit` equals :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_unit()` is :code:`True`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """

        if type(v) in [str, int, float, bool]:
            return self if self.unit == v else None
        elif callable(v):
            return self if v(self.unit) else None
        else:
            raise SwoopError("Illegal type passed to with_unit")

    def without_unit(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`unit`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`unit` is not equal to :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_unit()` is :code:`False`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """
        
        if type(v) in [str, int, float, bool]:
            return self if self.unit != v else None
        elif callable(v):
            return self if not v(self.unit) else None
        else:
            raise SwoopError("Illegal type passed to without_unit")


    def get_style(self):
        """ Return the value of :code:`style` for this :class:`Grid`.  This corresponds to the :code:`style` attribute of a :code:`<grid>` in an Eagle file.
        
        :rtype: :code:`str`
        """
        return self.style

    def set_style(self,v):
        """ Set the value of :code:`style` for this  :class:`Grid`.  This corresponds to the :code:`style` attribute of a :code:`<grid>` in an Eagle file.

        :param v: new value
        :rtype: :code:`self`
        """
                        
        if not typeCheck("str", v, False):
            raise SwoopError("Illegal value ({}) of type {} for attribute 'style' of Grid object (should be str).".format(v, type(v)))
        self.style = v
        
        return self

    def with_style(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`style`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`style` equals :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_style()` is :code:`True`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """

        if type(v) in [str, int, float, bool]:
            return self if self.style == v else None
        elif callable(v):
            return self if v(self.style) else None
        else:
            raise SwoopError("Illegal type passed to with_style")

    def without_style(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`style`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`style` is not equal to :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_style()` is :code:`False`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """
        
        if type(v) in [str, int, float, bool]:
            return self if self.style != v else None
        elif callable(v):
            return self if not v(self.style) else None
        else:
            raise SwoopError("Illegal type passed to without_style")


    def get_multiple(self):
        """ Return the value of :code:`multiple` for this :class:`Grid`.  This corresponds to the :code:`multiple` attribute of a :code:`<grid>` in an Eagle file.
        
        :rtype: :code:`int`
        """
        return self.multiple

    def set_multiple(self,v):
        """ Set the value of :code:`multiple` for this  :class:`Grid`.  This corresponds to the :code:`multiple` attribute of a :code:`<grid>` in an Eagle file.

        :param v: new value
        :rtype: :code:`self`
        """
                        
        if not typeCheck("int", v, False):
            raise SwoopError("Illegal value ({}) of type {} for attribute 'multiple' of Grid object (should be int).".format(v, type(v)))
        self.multiple = v
        
        return self

    def with_multiple(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`multiple`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`multiple` equals :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_multiple()` is :code:`True`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """

        if type(v) in [str, int, float, bool]:
            return self if self.multiple == v else None
        elif callable(v):
            return self if v(self.multiple) else None
        else:
            raise SwoopError("Illegal type passed to with_multiple")

    def without_multiple(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`multiple`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`multiple` is not equal to :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_multiple()` is :code:`False`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """
        
        if type(v) in [str, int, float, bool]:
            return self if self.multiple != v else None
        elif callable(v):
            return self if not v(self.multiple) else None
        else:
            raise SwoopError("Illegal type passed to without_multiple")


    def get_display(self):
        """ Return the value of :code:`display` for this :class:`Grid`.  This corresponds to the :code:`display` attribute of a :code:`<grid>` in an Eagle file.
        
        :rtype: :code:`bool`
        """
        return self.display

    def set_display(self,v):
        """ Set the value of :code:`display` for this  :class:`Grid`.  This corresponds to the :code:`display` attribute of a :code:`<grid>` in an Eagle file.

        :param v: new value
        :rtype: :code:`self`
        """
                        
        if not typeCheck("bool", v, False):
            raise SwoopError("Illegal value ({}) of type {} for attribute 'display' of Grid object (should be bool).".format(v, type(v)))
        self.display = v
        
        return self

    def with_display(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`display`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`display` equals :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_display()` is :code:`True`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """

        if type(v) in [str, int, float, bool]:
            return self if self.display == v else None
        elif callable(v):
            return self if v(self.display) else None
        else:
            raise SwoopError("Illegal type passed to with_display")

    def without_display(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`display`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`display` is not equal to :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_display()` is :code:`False`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """
        
        if type(v) in [str, int, float, bool]:
            return self if self.display != v else None
        elif callable(v):
            return self if not v(self.display) else None
        else:
            raise SwoopError("Illegal type passed to without_display")


    def get_altdistance(self):
        """ Return the value of :code:`altdistance` for this :class:`Grid`.  This corresponds to the :code:`altdistance` attribute of a :code:`<grid>` in an Eagle file.
        
        :rtype: :code:`float`
        """
        return self.altdistance

    def set_altdistance(self,v):
        """ Set the value of :code:`altdistance` for this  :class:`Grid`.  This corresponds to the :code:`altdistance` attribute of a :code:`<grid>` in an Eagle file.

        :param v: new value
        :rtype: :code:`self`
        """
                        
        if not typeCheck("float", v, False):
            raise SwoopError("Illegal value ({}) of type {} for attribute 'altdistance' of Grid object (should be float).".format(v, type(v)))
        self.altdistance = v
        
        return self

    def with_altdistance(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`altdistance`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`altdistance` equals :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_altdistance()` is :code:`True`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """

        if type(v) in [str, int, float, bool]:
            return self if self.altdistance == v else None
        elif callable(v):
            return self if v(self.altdistance) else None
        else:
            raise SwoopError("Illegal type passed to with_altdistance")

    def without_altdistance(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`altdistance`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`altdistance` is not equal to :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_altdistance()` is :code:`False`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """
        
        if type(v) in [str, int, float, bool]:
            return self if self.altdistance != v else None
        elif callable(v):
            return self if not v(self.altdistance) else None
        else:
            raise SwoopError("Illegal type passed to without_altdistance")


    def get_altunitdist(self):
        """ Return the value of :code:`altunitdist` for this :class:`Grid`.  This corresponds to the :code:`altunitdist` attribute of a :code:`<grid>` in an Eagle file.
        
        :rtype: :code:`str`
        """
        return self.altunitdist

    def set_altunitdist(self,v):
        """ Set the value of :code:`altunitdist` for this  :class:`Grid`.  This corresponds to the :code:`altunitdist` attribute of a :code:`<grid>` in an Eagle file.

        :param v: new value
        :rtype: :code:`self`
        """
                        
        if not typeCheck("str", v, False):
            raise SwoopError("Illegal value ({}) of type {} for attribute 'altunitdist' of Grid object (should be str).".format(v, type(v)))
        self.altunitdist = v
        
        return self

    def with_altunitdist(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`altunitdist`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`altunitdist` equals :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_altunitdist()` is :code:`True`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """

        if type(v) in [str, int, float, bool]:
            return self if self.altunitdist == v else None
        elif callable(v):
            return self if v(self.altunitdist) else None
        else:
            raise SwoopError("Illegal type passed to with_altunitdist")

    def without_altunitdist(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`altunitdist`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`altunitdist` is not equal to :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_altunitdist()` is :code:`False`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """
        
        if type(v) in [str, int, float, bool]:
            return self if self.altunitdist != v else None
        elif callable(v):
            return self if not v(self.altunitdist) else None
        else:
            raise SwoopError("Illegal type passed to without_altunitdist")


    def get_altunit(self):
        """ Return the value of :code:`altunit` for this :class:`Grid`.  This corresponds to the :code:`altunit` attribute of a :code:`<grid>` in an Eagle file.
        
        :rtype: :code:`str`
        """
        return self.altunit

    def set_altunit(self,v):
        """ Set the value of :code:`altunit` for this  :class:`Grid`.  This corresponds to the :code:`altunit` attribute of a :code:`<grid>` in an Eagle file.

        :param v: new value
        :rtype: :code:`self`
        """
                        
        if not typeCheck("str", v, False):
            raise SwoopError("Illegal value ({}) of type {} for attribute 'altunit' of Grid object (should be str).".format(v, type(v)))
        self.altunit = v
        
        return self

    def with_altunit(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`altunit`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`altunit` equals :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_altunit()` is :code:`True`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """

        if type(v) in [str, int, float, bool]:
            return self if self.altunit == v else None
        elif callable(v):
            return self if v(self.altunit) else None
        else:
            raise SwoopError("Illegal type passed to with_altunit")

    def without_altunit(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`altunit`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`altunit` is not equal to :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_altunit()` is :code:`False`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """
        
        if type(v) in [str, int, float, bool]:
            return self if self.altunit != v else None
        elif callable(v):
            return self if not v(self.altunit) else None
        else:
            raise SwoopError("Illegal type passed to without_altunit")



    ##### Lookup functions that return EFPs instead of just attribute values.
    
    


    
    ### Adder/getter/lookup for lists
    


    ### Add, lookup, and get for maps


    
    ### Getter/Setter for singletons.


    
    def get_children(self):
        """
        Get all the children of this :class:`EagleFilePart`.
        
        :rtype: List of :class:`EagleFilePart` objects
        """
        r = []




        return r

    def remove_child(self, efp):
        """
        Remove a child :class:`EagleFilePart` object.
        
        :param efp: the class:`EagleFilePart` object to remove.
        :return: Nothing
        """

    def _rekey_child(self, oldkey, efp):
        """
        Remove a child :class:`EagleFilePart` object.
        
        :param efp: the class:`EagleFilePart` object to remove.
        :return: Nothing
        """


    def __str__(self):
        r = "["+repr(self)+" "
        r = r + "distance:" + str(self.get_distance()) + " "
        r = r + "unitdist:" + str(self.get_unitdist()) + " "
        r = r + "unit:" + str(self.get_unit()) + " "
        r = r + "style:" + str(self.get_style()) + " "
        r = r + "multiple:" + str(self.get_multiple()) + " "
        r = r + "display:" + str(self.get_display()) + " "
        r = r + "altdistance:" + str(self.get_altdistance()) + " "
        r = r + "altunitdist:" + str(self.get_altunitdist()) + " "
        r = r + "altunit:" + str(self.get_altunit()) + " "
        r = r + "]"
        return r
            
    def dump(self, indent="", increment="   "):
        """
        Recursive debug dump.
        
        :param indent:  Indentation string.  The output will be indented by this much.
        :param increment: This will be appendeded to :code:`indent` on recursive invocations.

        :rtype: :code:`None`
        """
        print(indent + str(self.__class__.__name__), end=' ')
        try:
            print(self.get_name())
        except:
            print()
            pass
        for c in self.get_children():
            c.dump(indent + "   ")

        
EagleFile.class_map["grid"] = Grid
         


class Library(EagleFilePart):
    """
    Class representing the contents of a <library> tag in Eagle files.

    Attributes:

    * :code:`name`

    * :code:`urn`



    Collections:

    * :code:`description`: Singleton :class:`Description` object. 



    * :code:`package`: Map of :class:`Package` objects indexed by their :code:`name`.


    * :code:`package3d`: Map of :class:`Package3d` objects indexed by their :code:`name`.


    * :code:`symbol`: Map of :class:`Symbol` objects indexed by their :code:`name`.


    * :code:`deviceset`: Map of :class:`Deviceset` objects indexed by their :code:`name`.



    """
    def __init__(self):
        """
        Construct an empty :class:`Library` object.
        """
        EagleFilePart.__init__(self)
        
        self.name=None
        self.urn=None
        self.packages={} #tecollections.OrderedDict()  For unclear reasons, this caused ordering to become more unpredictable, rather than less.
        self.packages3d={} #tecollections.OrderedDict()  For unclear reasons, this caused ordering to become more unpredictable, rather than less.
        self.symbols={} #tecollections.OrderedDict()  For unclear reasons, this caused ordering to become more unpredictable, rather than less.
        self.devicesets={} #tecollections.OrderedDict()  For unclear reasons, this caused ordering to become more unpredictable, rather than less.
        self.description=None


        
    @classmethod
    def _from_et(cls,root,parent):
        """
        Create a :class:`Library` from a :code:`library` element.
        
        :param root: The element tree tree to parse.
        :param parent: :class:`EagleFilePart` that should hold the resulting :class:`EagleFilePart`
        :rtype: :class:`Library`
        """
        ## Call the constructor
        n = cls()
        n._init_from_et(root,parent)
        return n

    def _get_error_name(self):
        if hasattr(self, "get_name"):
            return self.get_name();
        else:
            return "Library";
        
    def  _init_from_et(self, root, parent):
        """
        Initialized a :class:`Library` from a :code:`library` element.  This is useful if you have a subclass of :class:`Library` .
        
        :param root: The element tree tree to parse.
        :param parent: :class:`EagleFilePart` that will become the parent of :code:`this` .
        :rtype: :class:`Library`
        """
        try:
            self.root = root
            
            if root.tag != "library":
                raise EagleFormatError("Tried to create library from " + root.tag)

            self.name=parseByType(parent, "str", None, root.get("name"))
            self.urn=parseByType(parent, "str", None, root.get("urn"))

            self.parent = parent

            ### populate the maps by searching for elements that match xpath and generating objects for them.

            for c in root.xpath("./packages/package"):
                self.add_package(self.get_class_for_tag(c.tag)._from_et(c, self))
            for c in root.xpath("./packages3d/package3d"):
                self.add_package3d(self.get_class_for_tag(c.tag)._from_et(c, self))
            for c in root.xpath("./symbols/symbol"):
                self.add_symbol(self.get_class_for_tag(c.tag)._from_et(c, self))
            for c in root.xpath("./devicesets/deviceset"):
                self.add_deviceset(self.get_class_for_tag(c.tag)._from_et(c, self))

            ### Do the same for the lists


            ### Do the same for the attr lists


            ### And the singletons

            x = root.xpath("./description")
            if len(x) is not 0:
                self.set_description(self.get_class_for_tag(x[0].tag)._from_et(x[0],self))

            ### And, finally, if the objects wants the text from the tag.

        except SwoopError as e:
            e.text = "{}:{}".format(self._get_error_name(), e.text)
            raise e


    def sortkey(self):
        r = ""
        r = r + str(self.name)
        r = r + str(self.urn)
        return r

    def get_et(self):
        """
        Generate a <library> element tree for a :class:`Library`.
        
        :rtype:  :class:`ElementTree`.
        
        """
        try:
            r = ET.Element("library")

            ### Set the tag attributes 


            ## Unparse the values.

            v = unparseByType(self, "str", None,  self.name)

            ## For required attributes None becomes "".  For optional attributes, we just leave the attribute out.
            if not (isinstance(self.get_parent(), LibraryFile) and True):  # special case for the name of library.
                if v is not None:
                    r.set("name", v)


            ## Unparse the values.

            v = unparseByType(self, "str", None,  self.urn)

            ## For required attributes None becomes "".  For optional attributes, we just leave the attribute out.
            if not (isinstance(self.get_parent(), LibraryFile) and False):  # special case for the name of library.
                if v is not None:
                    r.set("urn", v)


            ### process the sections in order.  They have to be in section order,
            ### because eagle files are order dependent.


            ## For some tags, Eagle generates empty tags when there's no contant
            ## rather than just leaving the tag out.  We mark these with
            ## Tag.requireTag in GenerateSwoop.py and force their generation
            ## here.



            ## or add a singleton.

            if self.description is not None:
                target = smartAddSubTags(r, "./description")
                target.append(self.description.get_et())

            ## For some tags, Eagle generates empty tags when there's no contant
            ## rather than just leaving the tag out.  We mark these with
            ## Tag.requireTag in GenerateSwoop.py and force their generation
            ## here.

            smartAddSubTags(r, "./packages/package")


            ## add a map.

            if len(self.packages) is not 0:
                target = smartAddSubTags(r, "./packages/package")
                # add them in sorted order.  This gives us a simple canonicalization that makes it feasible to use diff to compare files.
                target.extend([i.get_et() for i in sorted(list(self.packages.values()),key=lambda x: x.sortkey())])


            ## For some tags, Eagle generates empty tags when there's no contant
            ## rather than just leaving the tag out.  We mark these with
            ## Tag.requireTag in GenerateSwoop.py and force their generation
            ## here.



            ## add a map.

            if len(self.packages3d) is not 0:
                target = smartAddSubTags(r, "./packages3d/package3d")
                # add them in sorted order.  This gives us a simple canonicalization that makes it feasible to use diff to compare files.
                target.extend([i.get_et() for i in sorted(list(self.packages3d.values()),key=lambda x: x.sortkey())])


            ## For some tags, Eagle generates empty tags when there's no contant
            ## rather than just leaving the tag out.  We mark these with
            ## Tag.requireTag in GenerateSwoop.py and force their generation
            ## here.

            smartAddSubTags(r, "./symbols/symbol")


            ## add a map.

            if len(self.symbols) is not 0:
                target = smartAddSubTags(r, "./symbols/symbol")
                # add them in sorted order.  This gives us a simple canonicalization that makes it feasible to use diff to compare files.
                target.extend([i.get_et() for i in sorted(list(self.symbols.values()),key=lambda x: x.sortkey())])


            ## For some tags, Eagle generates empty tags when there's no contant
            ## rather than just leaving the tag out.  We mark these with
            ## Tag.requireTag in GenerateSwoop.py and force their generation
            ## here.

            smartAddSubTags(r, "./devicesets/deviceset")


            ## add a map.

            if len(self.devicesets) is not 0:
                target = smartAddSubTags(r, "./devicesets/deviceset")
                # add them in sorted order.  This gives us a simple canonicalization that makes it feasible to use diff to compare files.
                target.extend([i.get_et() for i in sorted(list(self.devicesets.values()),key=lambda x: x.sortkey())])


            ## set the text, if its needed.

        except SwoopError as e:
            e.text = "{}:{}".format(self._get_error_name(), e.text)
            raise e
        return r

    def clone(self):
        """
        Recursively clone this :code:`Library`.  It will be identical to the original, but it's parent will be :code:`None`.
        
        :rtype: :class:`Library`
        """
        try:
            n = copy.copy(self)
            n.packages = {}
            for x in list(self.packages.values()):
                n.add_package(x.clone())
            n.packages3d = {}
            for x in list(self.packages3d.values()):
                n.add_package3d(x.clone())
            n.symbols = {}
            for x in list(self.symbols.values()):
                n.add_symbol(x.clone())
            n.devicesets = {}
            for x in list(self.devicesets.values()):
                n.add_deviceset(x.clone())
            n.description = None
            if self.description is not None:
                n.set_description(self.description.clone())
            else:
                n.set_description(None)
            n.parent = None
        except SwoopError as e:
            e.text = "{}:{}".format(self._get_error_name(), e.text)
            raise e
        return n

    def accept_preorder_visitor(self, visitor):
        try:
            pre = getattr(visitor, "Library_pre")
            return pre(self)
        except AttributeError:
            return visitor.default_pre(self)
        
    def accept_postorder_visitor(self, visitor, context):
        try:
            post = getattr(visitor, "Library_post")
            post(self,context)
        except AttributeError:
            visitor.default_post(self,context)

    def is_equal(self, other):
        """
        Check whether two :code:`EagleFilePart` objects are identical.
        
        :param other: Object to compare to.
        :returns: :code:`True` if they are identical, otherwise, :code:`False`
        """
        return self.get_xml() == other.get_xml()
        
    ### Getters/Setters for attribute values

    def get_name(self):
        """ Return the value of :code:`name` for this :class:`Library`.  This corresponds to the :code:`name` attribute of a :code:`<library>` in an Eagle file.
        
        :rtype: :code:`str`
        """
        return self.name

    def set_name(self,v):
        """ Set the value of :code:`name` for this  :class:`Library`.  This corresponds to the :code:`name` attribute of a :code:`<library>` in an Eagle file.

        :param v: new value
        :rtype: :code:`self`
        """
                        
        if not typeCheck("str", v, False):
            raise SwoopError("Illegal value ({}) of type {} for attribute 'name' of Library object (should be str).".format(v, type(v)))
        self.name = v
        
        return self

    def with_name(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`name`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`name` equals :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_name()` is :code:`True`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """

        if type(v) in [str, int, float, bool]:
            return self if self.name == v else None
        elif callable(v):
            return self if v(self.name) else None
        else:
            raise SwoopError("Illegal type passed to with_name")

    def without_name(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`name`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`name` is not equal to :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_name()` is :code:`False`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """
        
        if type(v) in [str, int, float, bool]:
            return self if self.name != v else None
        elif callable(v):
            return self if not v(self.name) else None
        else:
            raise SwoopError("Illegal type passed to without_name")


    def get_urn(self):
        """ Return the value of :code:`urn` for this :class:`Library`.  This corresponds to the :code:`urn` attribute of a :code:`<library>` in an Eagle file.
        
        :rtype: :code:`str`
        """
        return self.urn

    def set_urn(self,v):
        """ Set the value of :code:`urn` for this  :class:`Library`.  This corresponds to the :code:`urn` attribute of a :code:`<library>` in an Eagle file.

        :param v: new value
        :rtype: :code:`self`
        """
                        
        if not typeCheck("str", v, False):
            raise SwoopError("Illegal value ({}) of type {} for attribute 'urn' of Library object (should be str).".format(v, type(v)))
        self.urn = v
        
        return self

    def with_urn(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`urn`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`urn` equals :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_urn()` is :code:`True`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """

        if type(v) in [str, int, float, bool]:
            return self if self.urn == v else None
        elif callable(v):
            return self if v(self.urn) else None
        else:
            raise SwoopError("Illegal type passed to with_urn")

    def without_urn(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`urn`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`urn` is not equal to :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_urn()` is :code:`False`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """
        
        if type(v) in [str, int, float, bool]:
            return self if self.urn != v else None
        elif callable(v):
            return self if not v(self.urn) else None
        else:
            raise SwoopError("Illegal type passed to without_urn")



    ##### Lookup functions that return EFPs instead of just attribute values.
    
    


    
    ### Adder/getter/lookup for lists
    


    ### Add, lookup, and get for maps
    def add_package(self, s):
        """ Add a :class:`Package` to the :code:`packages` of this :class:`Library`.

        :param s: The :class:`Package` to add.
        :rtype: :code:`self`
        """
        if not any([
                isinstance(s, Package),
            ]):
            raise SwoopError("Argument to Library.add_package() should be of type Package.  Got " + str(type(s).__name__) + ".")
        

        self.packages[s.get_name()] = s

        s.parent = self
        return self

    def get_nth_package(self, n):
        """ get then nth :class:`Package` object from the :code:`packages` of this :class:`Library`.
        
        :param n: Index of the item to return.

        :rtype: :class:`Package` object
        """
        return list(self.packages.values())[n]

    def get_package(self, key):
        """ Lookup and return a :class:`Package` from the :code:`packages` of  this :class:`Library`.
        
        :param key: A :code:`str` to use for the lookup.  The lookup uses the :code:`name` of the :class:`Package` objects.

        :rtype: A :class:`Package` object or :code:`None`, if there is no such item.
        """
        return self.packages.get(key)


    def get_packages(self, attrs=None, type=None):
        """Return (and possibly filter) items in the the :code:`packages` map of :class:`Package` objects for this :class:`Library`.
        
        This functions provides a mechanism for filtering the items as well.
        The keys in :code:`attrs` are taken as attributes names and the
        values are requested values.  Items in the list that have all the
        requested values for the corresponding attributes will be returned.  

        A if :code:`type` is not :code:`None`, the item will match if it is an
        instance of the type provided.
        
        :param attrs: A set of key-value pairs that represent a filter to apply to the item's attributes.
        :param type:  A type to filter on.  Only items that are an instance of this type will be returned.
        :returns: A List of :class:`Package` objects
        :rtype: List of :class:`Package` objects
        """
        if attrs is not None or type is not None:
            raise NotImplementedError("filtered get not implemented")
        return list(self.packages.values())
        

    def clear_packages(self):
        """
        Remove all the :class:`Package` objects from the :code:`packages` of this :class:`Library`.
        
        :rtype: :code:`self`
        """
        for efp in list(self.packages.values()):
            efp.parent = None
        self.packages = {}
        return self

    def remove_package(self, efp):
        """
        Remove a :class:`Package` from the :code:`packages` of this :class:`Library`.
        
        :param efp: The :class:`Package` object to remove.

        :rtype: :code:`self`
        """
        if self.packages[efp.get_name()] == efp:
            del self.packages[efp.get_name()]
            efp.parent = None
            return self
        else:
            raise SwoopError("Tried to use remove_package() to delete the wrong kind of child?: {}".format(str(efp)))
    
    def add_package3d(self, s):
        """ Add a :class:`Package3d` to the :code:`packages3d` of this :class:`Library`.

        :param s: The :class:`Package3d` to add.
        :rtype: :code:`self`
        """
        if not any([
                isinstance(s, Package3d),
            ]):
            raise SwoopError("Argument to Library.add_package3d() should be of type Package3d.  Got " + str(type(s).__name__) + ".")
        

        self.packages3d[s.get_name()] = s

        s.parent = self
        return self

    def get_nth_package3d(self, n):
        """ get then nth :class:`Package3d` object from the :code:`packages3d` of this :class:`Library`.
        
        :param n: Index of the item to return.

        :rtype: :class:`Package3d` object
        """
        return list(self.packages3d.values())[n]

    def get_package3d(self, key):
        """ Lookup and return a :class:`Package3d` from the :code:`packages3d` of  this :class:`Library`.
        
        :param key: A :code:`str` to use for the lookup.  The lookup uses the :code:`name` of the :class:`Package3d` objects.

        :rtype: A :class:`Package3d` object or :code:`None`, if there is no such item.
        """
        return self.packages3d.get(key)


    def get_packages3d(self, attrs=None, type=None):
        """Return (and possibly filter) items in the the :code:`packages3d` map of :class:`Package3d` objects for this :class:`Library`.
        
        This functions provides a mechanism for filtering the items as well.
        The keys in :code:`attrs` are taken as attributes names and the
        values are requested values.  Items in the list that have all the
        requested values for the corresponding attributes will be returned.  

        A if :code:`type` is not :code:`None`, the item will match if it is an
        instance of the type provided.
        
        :param attrs: A set of key-value pairs that represent a filter to apply to the item's attributes.
        :param type:  A type to filter on.  Only items that are an instance of this type will be returned.
        :returns: A List of :class:`Package3d` objects
        :rtype: List of :class:`Package3d` objects
        """
        if attrs is not None or type is not None:
            raise NotImplementedError("filtered get not implemented")
        return list(self.packages3d.values())
        

    def clear_packages3d(self):
        """
        Remove all the :class:`Package3d` objects from the :code:`packages3d` of this :class:`Library`.
        
        :rtype: :code:`self`
        """
        for efp in list(self.packages3d.values()):
            efp.parent = None
        self.packages3d = {}
        return self

    def remove_package3d(self, efp):
        """
        Remove a :class:`Package3d` from the :code:`packages3d` of this :class:`Library`.
        
        :param efp: The :class:`Package3d` object to remove.

        :rtype: :code:`self`
        """
        if self.packages3d[efp.get_name()] == efp:
            del self.packages3d[efp.get_name()]
            efp.parent = None
            return self
        else:
            raise SwoopError("Tried to use remove_package3d() to delete the wrong kind of child?: {}".format(str(efp)))
    
    def add_symbol(self, s):
        """ Add a :class:`Symbol` to the :code:`symbols` of this :class:`Library`.

        :param s: The :class:`Symbol` to add.
        :rtype: :code:`self`
        """
        if not any([
                isinstance(s, Symbol),
            ]):
            raise SwoopError("Argument to Library.add_symbol() should be of type Symbol.  Got " + str(type(s).__name__) + ".")
        

        self.symbols[s.get_name()] = s

        s.parent = self
        return self

    def get_nth_symbol(self, n):
        """ get then nth :class:`Symbol` object from the :code:`symbols` of this :class:`Library`.
        
        :param n: Index of the item to return.

        :rtype: :class:`Symbol` object
        """
        return list(self.symbols.values())[n]

    def get_symbol(self, key):
        """ Lookup and return a :class:`Symbol` from the :code:`symbols` of  this :class:`Library`.
        
        :param key: A :code:`str` to use for the lookup.  The lookup uses the :code:`name` of the :class:`Symbol` objects.

        :rtype: A :class:`Symbol` object or :code:`None`, if there is no such item.
        """
        return self.symbols.get(key)


    def get_symbols(self, attrs=None, type=None):
        """Return (and possibly filter) items in the the :code:`symbols` map of :class:`Symbol` objects for this :class:`Library`.
        
        This functions provides a mechanism for filtering the items as well.
        The keys in :code:`attrs` are taken as attributes names and the
        values are requested values.  Items in the list that have all the
        requested values for the corresponding attributes will be returned.  

        A if :code:`type` is not :code:`None`, the item will match if it is an
        instance of the type provided.
        
        :param attrs: A set of key-value pairs that represent a filter to apply to the item's attributes.
        :param type:  A type to filter on.  Only items that are an instance of this type will be returned.
        :returns: A List of :class:`Symbol` objects
        :rtype: List of :class:`Symbol` objects
        """
        if attrs is not None or type is not None:
            raise NotImplementedError("filtered get not implemented")
        return list(self.symbols.values())
        

    def clear_symbols(self):
        """
        Remove all the :class:`Symbol` objects from the :code:`symbols` of this :class:`Library`.
        
        :rtype: :code:`self`
        """
        for efp in list(self.symbols.values()):
            efp.parent = None
        self.symbols = {}
        return self

    def remove_symbol(self, efp):
        """
        Remove a :class:`Symbol` from the :code:`symbols` of this :class:`Library`.
        
        :param efp: The :class:`Symbol` object to remove.

        :rtype: :code:`self`
        """
        if self.symbols[efp.get_name()] == efp:
            del self.symbols[efp.get_name()]
            efp.parent = None
            return self
        else:
            raise SwoopError("Tried to use remove_symbol() to delete the wrong kind of child?: {}".format(str(efp)))
    
    def add_deviceset(self, s):
        """ Add a :class:`Deviceset` to the :code:`devicesets` of this :class:`Library`.

        :param s: The :class:`Deviceset` to add.
        :rtype: :code:`self`
        """
        if not any([
                isinstance(s, Deviceset),
            ]):
            raise SwoopError("Argument to Library.add_deviceset() should be of type Deviceset.  Got " + str(type(s).__name__) + ".")
        

        self.devicesets[s.get_name()] = s

        s.parent = self
        return self

    def get_nth_deviceset(self, n):
        """ get then nth :class:`Deviceset` object from the :code:`devicesets` of this :class:`Library`.
        
        :param n: Index of the item to return.

        :rtype: :class:`Deviceset` object
        """
        return list(self.devicesets.values())[n]

    def get_deviceset(self, key):
        """ Lookup and return a :class:`Deviceset` from the :code:`devicesets` of  this :class:`Library`.
        
        :param key: A :code:`str` to use for the lookup.  The lookup uses the :code:`name` of the :class:`Deviceset` objects.

        :rtype: A :class:`Deviceset` object or :code:`None`, if there is no such item.
        """
        return self.devicesets.get(key)


    def get_devicesets(self, attrs=None, type=None):
        """Return (and possibly filter) items in the the :code:`devicesets` map of :class:`Deviceset` objects for this :class:`Library`.
        
        This functions provides a mechanism for filtering the items as well.
        The keys in :code:`attrs` are taken as attributes names and the
        values are requested values.  Items in the list that have all the
        requested values for the corresponding attributes will be returned.  

        A if :code:`type` is not :code:`None`, the item will match if it is an
        instance of the type provided.
        
        :param attrs: A set of key-value pairs that represent a filter to apply to the item's attributes.
        :param type:  A type to filter on.  Only items that are an instance of this type will be returned.
        :returns: A List of :class:`Deviceset` objects
        :rtype: List of :class:`Deviceset` objects
        """
        if attrs is not None or type is not None:
            raise NotImplementedError("filtered get not implemented")
        return list(self.devicesets.values())
        

    def clear_devicesets(self):
        """
        Remove all the :class:`Deviceset` objects from the :code:`devicesets` of this :class:`Library`.
        
        :rtype: :code:`self`
        """
        for efp in list(self.devicesets.values()):
            efp.parent = None
        self.devicesets = {}
        return self

    def remove_deviceset(self, efp):
        """
        Remove a :class:`Deviceset` from the :code:`devicesets` of this :class:`Library`.
        
        :param efp: The :class:`Deviceset` object to remove.

        :rtype: :code:`self`
        """
        if self.devicesets[efp.get_name()] == efp:
            del self.devicesets[efp.get_name()]
            efp.parent = None
            return self
        else:
            raise SwoopError("Tried to use remove_deviceset() to delete the wrong kind of child?: {}".format(str(efp)))
    


    
    ### Getter/Setter for singletons.

    def set_description(self, s):
        """ Set the :class:`Description` for this  :class:`Library`.

        :param s: :class:`Description` to set.
        :rtype: :code:`self`
        """
        if self.description is not None:
            self.description.parent = None
        self.description = s
        if s is not None:
            s.parent = self
        return self

    def get_description(self):
        """ Get the description from this :class:`Library`.
        
        :rtype: :class:`Description` object
        """
        return self.description


    
    def get_children(self):
        """
        Get all the children of this :class:`EagleFilePart`.
        
        :rtype: List of :class:`EagleFilePart` objects
        """
        r = []


        r = r + list(self.packages.values())
        r = r + list(self.packages3d.values())
        r = r + list(self.symbols.values())
        r = r + list(self.devicesets.values())

        if self.description is not None:
            r = r + [self.description]

        return r

    def remove_child(self, efp):
        """
        Remove a child :class:`EagleFilePart` object.
        
        :param efp: the class:`EagleFilePart` object to remove.
        :return: Nothing
        """
        try:
            self.remove_package(efp)
        except:
            pass
        try:
            self.remove_package3d(efp)
        except:
            pass
        try:
            self.remove_symbol(efp)
        except:
            pass
        try:
            self.remove_deviceset(efp)
        except:
            pass
        if self.get_description() == efp:
            self.set_description(None)

    def _rekey_child(self, oldkey, efp):
        """
        Remove a child :class:`EagleFilePart` object.
        
        :param efp: the class:`EagleFilePart` object to remove.
        :return: Nothing
        """
        try:
            if self.get_package(oldkey) == efp:
                del self.packages[oldkey]
                self.add_package(efp)
        except SwoopError:
            pass
        try:
            if self.get_package3d(oldkey) == efp:
                del self.packages3d[oldkey]
                self.add_package3d(efp)
        except SwoopError:
            pass
        try:
            if self.get_symbol(oldkey) == efp:
                del self.symbols[oldkey]
                self.add_symbol(efp)
        except SwoopError:
            pass
        try:
            if self.get_deviceset(oldkey) == efp:
                del self.devicesets[oldkey]
                self.add_deviceset(efp)
        except SwoopError:
            pass

    def check_sanity(self, visited_efps = None):
        EagleFilePart.check_sanity(self, visited_efps)

        # Check whether keys in our maps match the keys in our children
        for k in self.packages:
            if self.packages[k].get_name() != k:
                raise SwoopError("Child's name ('{}') doesn't match key in parent's map ('{}')".format(self.packages[k].get_name(),k))
        for k in self.packages3d:
            if self.packages3d[k].get_name() != k:
                raise SwoopError("Child's name ('{}') doesn't match key in parent's map ('{}')".format(self.packages3d[k].get_name(),k))
        for k in self.symbols:
            if self.symbols[k].get_name() != k:
                raise SwoopError("Child's name ('{}') doesn't match key in parent's map ('{}')".format(self.symbols[k].get_name(),k))
        for k in self.devicesets:
            if self.devicesets[k].get_name() != k:
                raise SwoopError("Child's name ('{}') doesn't match key in parent's map ('{}')".format(self.devicesets[k].get_name(),k))

    def __str__(self):
        r = "["+repr(self)+" "
        r = r + "name:" + str(self.get_name()) + " "
        r = r + "urn:" + str(self.get_urn()) + " "
        r = r + "]"
        return r
            
    def dump(self, indent="", increment="   "):
        """
        Recursive debug dump.
        
        :param indent:  Indentation string.  The output will be indented by this much.
        :param increment: This will be appendeded to :code:`indent` on recursive invocations.

        :rtype: :code:`None`
        """
        print(indent + str(self.__class__.__name__), end=' ')
        try:
            print(self.get_name())
        except:
            print()
            pass
        for c in self.get_children():
            c.dump(indent + "   ")

        
EagleFile.class_map["library"] = Library
         


class Pinref(EagleFilePart):
    """
    Class representing the contents of a <pinref> tag in Eagle files.

    Attributes:

    * :code:`part`

    * :code:`gate`

    * :code:`pin`


    """
    def __init__(self):
        """
        Construct an empty :class:`Pinref` object.
        """
        EagleFilePart.__init__(self)
        
        self.part=None
        self.gate=None
        self.pin=None


        
    @classmethod
    def _from_et(cls,root,parent):
        """
        Create a :class:`Pinref` from a :code:`pinref` element.
        
        :param root: The element tree tree to parse.
        :param parent: :class:`EagleFilePart` that should hold the resulting :class:`EagleFilePart`
        :rtype: :class:`Pinref`
        """
        ## Call the constructor
        n = cls()
        n._init_from_et(root,parent)
        return n

    def _get_error_name(self):
        if hasattr(self, "get_name"):
            return self.get_name();
        else:
            return "Pinref";
        
    def  _init_from_et(self, root, parent):
        """
        Initialized a :class:`Pinref` from a :code:`pinref` element.  This is useful if you have a subclass of :class:`Pinref` .
        
        :param root: The element tree tree to parse.
        :param parent: :class:`EagleFilePart` that will become the parent of :code:`this` .
        :rtype: :class:`Pinref`
        """
        try:
            self.root = root
            
            if root.tag != "pinref":
                raise EagleFormatError("Tried to create pinref from " + root.tag)

            self.part=parseByType(parent, "str", None, root.get("part"))
            self.gate=parseByType(parent, "str", None, root.get("gate"))
            self.pin=parseByType(parent, "str", None, root.get("pin"))

            self.parent = parent

            ### populate the maps by searching for elements that match xpath and generating objects for them.


            ### Do the same for the lists


            ### Do the same for the attr lists


            ### And the singletons


            ### And, finally, if the objects wants the text from the tag.

        except SwoopError as e:
            e.text = "{}:{}".format(self._get_error_name(), e.text)
            raise e


    def sortkey(self):
        r = ""
        r = r + str(self.part)
        r = r + str(self.gate)
        r = r + str(self.pin)
        return r

    def get_et(self):
        """
        Generate a <pinref> element tree for a :class:`Pinref`.
        
        :rtype:  :class:`ElementTree`.
        
        """
        try:
            r = ET.Element("pinref")

            ### Set the tag attributes 


            ## Unparse the values.

            v = unparseByType(self, "str", None,  self.part)

            ## For required attributes None becomes "".  For optional attributes, we just leave the attribute out.
            if not (isinstance(self.get_parent(), LibraryFile) and False):  # special case for the name of library.
                if v is not None:
                    r.set("part", v)
                else:
                    r.set("part", "")


            ## Unparse the values.

            v = unparseByType(self, "str", None,  self.gate)

            ## For required attributes None becomes "".  For optional attributes, we just leave the attribute out.
            if not (isinstance(self.get_parent(), LibraryFile) and False):  # special case for the name of library.
                if v is not None:
                    r.set("gate", v)
                else:
                    r.set("gate", "")


            ## Unparse the values.

            v = unparseByType(self, "str", None,  self.pin)

            ## For required attributes None becomes "".  For optional attributes, we just leave the attribute out.
            if not (isinstance(self.get_parent(), LibraryFile) and False):  # special case for the name of library.
                if v is not None:
                    r.set("pin", v)
                else:
                    r.set("pin", "")


            ### process the sections in order.  They have to be in section order,
            ### because eagle files are order dependent.


            ## set the text, if its needed.

        except SwoopError as e:
            e.text = "{}:{}".format(self._get_error_name(), e.text)
            raise e
        return r

    def clone(self):
        """
        Recursively clone this :code:`Pinref`.  It will be identical to the original, but it's parent will be :code:`None`.
        
        :rtype: :class:`Pinref`
        """
        try:
            n = copy.copy(self)
            n.parent = None
        except SwoopError as e:
            e.text = "{}:{}".format(self._get_error_name(), e.text)
            raise e
        return n

    def accept_preorder_visitor(self, visitor):
        try:
            pre = getattr(visitor, "Pinref_pre")
            return pre(self)
        except AttributeError:
            return visitor.default_pre(self)
        
    def accept_postorder_visitor(self, visitor, context):
        try:
            post = getattr(visitor, "Pinref_post")
            post(self,context)
        except AttributeError:
            visitor.default_post(self,context)

    def is_equal(self, other):
        """
        Check whether two :code:`EagleFilePart` objects are identical.
        
        :param other: Object to compare to.
        :returns: :code:`True` if they are identical, otherwise, :code:`False`
        """
        return self.get_xml() == other.get_xml()
        
    ### Getters/Setters for attribute values

    def get_part(self):
        """ Return the value of :code:`part` for this :class:`Pinref`.  This corresponds to the :code:`part` attribute of a :code:`<pinref>` in an Eagle file.
        
        :rtype: :code:`str`
        """
        return self.part

    def set_part(self,v):
        """ Set the value of :code:`part` for this  :class:`Pinref`.  This corresponds to the :code:`part` attribute of a :code:`<pinref>` in an Eagle file.

        :param v: new value
        :rtype: :code:`self`
        """
                        
        if not typeCheck("str", v, True):
            raise SwoopError("Illegal value ({}) of type {} for attribute 'part' of Pinref object (should be str).".format(v, type(v)))
        self.part = v
        
        return self

    def with_part(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`part`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`part` equals :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_part()` is :code:`True`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """

        if type(v) in [str, int, float, bool]:
            return self if self.part == v else None
        elif callable(v):
            return self if v(self.part) else None
        else:
            raise SwoopError("Illegal type passed to with_part")

    def without_part(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`part`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`part` is not equal to :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_part()` is :code:`False`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """
        
        if type(v) in [str, int, float, bool]:
            return self if self.part != v else None
        elif callable(v):
            return self if not v(self.part) else None
        else:
            raise SwoopError("Illegal type passed to without_part")


    def get_gate(self):
        """ Return the value of :code:`gate` for this :class:`Pinref`.  This corresponds to the :code:`gate` attribute of a :code:`<pinref>` in an Eagle file.
        
        :rtype: :code:`str`
        """
        return self.gate

    def set_gate(self,v):
        """ Set the value of :code:`gate` for this  :class:`Pinref`.  This corresponds to the :code:`gate` attribute of a :code:`<pinref>` in an Eagle file.

        :param v: new value
        :rtype: :code:`self`
        """
                        
        if not typeCheck("str", v, True):
            raise SwoopError("Illegal value ({}) of type {} for attribute 'gate' of Pinref object (should be str).".format(v, type(v)))
        self.gate = v
        
        return self

    def with_gate(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`gate`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`gate` equals :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_gate()` is :code:`True`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """

        if type(v) in [str, int, float, bool]:
            return self if self.gate == v else None
        elif callable(v):
            return self if v(self.gate) else None
        else:
            raise SwoopError("Illegal type passed to with_gate")

    def without_gate(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`gate`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`gate` is not equal to :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_gate()` is :code:`False`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """
        
        if type(v) in [str, int, float, bool]:
            return self if self.gate != v else None
        elif callable(v):
            return self if not v(self.gate) else None
        else:
            raise SwoopError("Illegal type passed to without_gate")


    def get_pin(self):
        """ Return the value of :code:`pin` for this :class:`Pinref`.  This corresponds to the :code:`pin` attribute of a :code:`<pinref>` in an Eagle file.
        
        :rtype: :code:`str`
        """
        return self.pin

    def set_pin(self,v):
        """ Set the value of :code:`pin` for this  :class:`Pinref`.  This corresponds to the :code:`pin` attribute of a :code:`<pinref>` in an Eagle file.

        :param v: new value
        :rtype: :code:`self`
        """
                        
        if not typeCheck("str", v, True):
            raise SwoopError("Illegal value ({}) of type {} for attribute 'pin' of Pinref object (should be str).".format(v, type(v)))
        self.pin = v
        
        return self

    def with_pin(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`pin`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`pin` equals :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_pin()` is :code:`True`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """

        if type(v) in [str, int, float, bool]:
            return self if self.pin == v else None
        elif callable(v):
            return self if v(self.pin) else None
        else:
            raise SwoopError("Illegal type passed to with_pin")

    def without_pin(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`pin`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`pin` is not equal to :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_pin()` is :code:`False`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """
        
        if type(v) in [str, int, float, bool]:
            return self if self.pin != v else None
        elif callable(v):
            return self if not v(self.pin) else None
        else:
            raise SwoopError("Illegal type passed to without_pin")



    ##### Lookup functions that return EFPs instead of just attribute values.
    
    def find_part(self):
        """Find the :class:`Part` object refered to by the :code:`part` attribute of this object.  This is like
        :meth:`get_part`, except it returns the :class:`Part` object instead of its name.
        
        :returns: The object
        :rtype: :class:`Part`

        """
        f = lambda efp, key: NotImplemented('Lookup of part from pinref not implemented.')
        return f(self, self.part)
    def find_gate(self):
        """Find the :class:`Gate` object refered to by the :code:`gate` attribute of this object.  This is like
        :meth:`get_gate`, except it returns the :class:`Gate` object instead of its name.
        
        :returns: The object
        :rtype: :class:`Gate`

        """
        f = lambda efp, key: NotImplemented('Lookup of gate from pinref not implemented.')
        return f(self, self.gate)
    def find_pin(self):
        """Find the :class:`Pin` object refered to by the :code:`pin` attribute of this object.  This is like
        :meth:`get_pin`, except it returns the :class:`Pin` object instead of its name.
        
        :returns: The object
        :rtype: :class:`Pin`

        """
        f = lambda efp, key: NotImplemented('Lookup of pin from pinref not implemented.')
        return f(self, self.pin)
    


    
    ### Adder/getter/lookup for lists
    


    ### Add, lookup, and get for maps


    
    ### Getter/Setter for singletons.


    
    def get_children(self):
        """
        Get all the children of this :class:`EagleFilePart`.
        
        :rtype: List of :class:`EagleFilePart` objects
        """
        r = []




        return r

    def remove_child(self, efp):
        """
        Remove a child :class:`EagleFilePart` object.
        
        :param efp: the class:`EagleFilePart` object to remove.
        :return: Nothing
        """

    def _rekey_child(self, oldkey, efp):
        """
        Remove a child :class:`EagleFilePart` object.
        
        :param efp: the class:`EagleFilePart` object to remove.
        :return: Nothing
        """


    def __str__(self):
        r = "["+repr(self)+" "
        r = r + "part:" + str(self.get_part()) + " "
        r = r + "gate:" + str(self.get_gate()) + " "
        r = r + "pin:" + str(self.get_pin()) + " "
        r = r + "]"
        return r
            
    def dump(self, indent="", increment="   "):
        """
        Recursive debug dump.
        
        :param indent:  Indentation string.  The output will be indented by this much.
        :param increment: This will be appendeded to :code:`indent` on recursive invocations.

        :rtype: :code:`None`
        """
        print(indent + str(self.__class__.__name__), end=' ')
        try:
            print(self.get_name())
        except:
            print()
            pass
        for c in self.get_children():
            c.dump(indent + "   ")

        
EagleFile.class_map["pinref"] = Pinref
         


class Device(EagleFilePart):
    """
    Class representing the contents of a <device> tag in Eagle files.

    Attributes:

    * :code:`name`

    * :code:`package`



    Collections:


    * :code:`connect`: List of :class:`Connect` objects.

    * :code:`package3dinstance`: List of :class:`Package3dinstance` objects.


    * :code:`technology`: Map of :class:`Technology` objects indexed by their :code:`name`.



    """
    def __init__(self):
        """
        Construct an empty :class:`Device` object.
        """
        EagleFilePart.__init__(self)
        
        self.name=None
        self.package=None
        self.connects=[]
        self.package3dinstances=[]
        self.technologies={} #tecollections.OrderedDict()  For unclear reasons, this caused ordering to become more unpredictable, rather than less.


        
    @classmethod
    def _from_et(cls,root,parent):
        """
        Create a :class:`Device` from a :code:`device` element.
        
        :param root: The element tree tree to parse.
        :param parent: :class:`EagleFilePart` that should hold the resulting :class:`EagleFilePart`
        :rtype: :class:`Device`
        """
        ## Call the constructor
        n = cls()
        n._init_from_et(root,parent)
        return n

    def _get_error_name(self):
        if hasattr(self, "get_name"):
            return self.get_name();
        else:
            return "Device";
        
    def  _init_from_et(self, root, parent):
        """
        Initialized a :class:`Device` from a :code:`device` element.  This is useful if you have a subclass of :class:`Device` .
        
        :param root: The element tree tree to parse.
        :param parent: :class:`EagleFilePart` that will become the parent of :code:`this` .
        :rtype: :class:`Device`
        """
        try:
            self.root = root
            
            if root.tag != "device":
                raise EagleFormatError("Tried to create device from " + root.tag)

            self.name=parseByType(parent, "str", None, root.get("name"))
            self.package=parseByType(parent, "str", None, root.get("package"))

            self.parent = parent

            ### populate the maps by searching for elements that match xpath and generating objects for them.

            for c in root.xpath("./technologies/technology"):
                self.add_technology(self.get_class_for_tag(c.tag)._from_et(c, self))

            ### Do the same for the lists

            for c in root.xpath("./connects/connect"):
                self.add_connect(self.get_class_for_tag(c.tag)._from_et(c,self))
            for c in root.xpath("./package3dinstances/package3dinstance"):
                self.add_package3dinstance(self.get_class_for_tag(c.tag)._from_et(c,self))

            ### Do the same for the attr lists


            ### And the singletons


            ### And, finally, if the objects wants the text from the tag.

        except SwoopError as e:
            e.text = "{}:{}".format(self._get_error_name(), e.text)
            raise e


    def sortkey(self):
        r = ""
        r = r + str(self.name)
        r = r + str(self.package)
        return r

    def get_et(self):
        """
        Generate a <device> element tree for a :class:`Device`.
        
        :rtype:  :class:`ElementTree`.
        
        """
        try:
            r = ET.Element("device")

            ### Set the tag attributes 


            ## Unparse the values.

            v = unparseByType(self, "str", None,  self.name)

            ## For required attributes None becomes "".  For optional attributes, we just leave the attribute out.
            if not (isinstance(self.get_parent(), LibraryFile) and False):  # special case for the name of library.
                if v is not None:
                    r.set("name", v)
                else:
                    r.set("name", "")


            ## Unparse the values.

            v = unparseByType(self, "str", None,  self.package)

            ## For required attributes None becomes "".  For optional attributes, we just leave the attribute out.
            if not (isinstance(self.get_parent(), LibraryFile) and False):  # special case for the name of library.
                if v is not None:
                    r.set("package", v)


            ### process the sections in order.  They have to be in section order,
            ### because eagle files are order dependent.


            ## For some tags, Eagle generates empty tags when there's no contant
            ## rather than just leaving the tag out.  We mark these with
            ## Tag.requireTag in GenerateSwoop.py and force their generation
            ## here.



            ## add a list.

            if len(self.connects) is not 0:
                target = smartAddSubTags(r, "./connects/connect")
                # add them in sorted order.  This gives us a simple canonicalization that makes it feasible to use diff to compare files.
                target.extend([i.get_et() for i in sorted(self.connects,key=lambda x: x.sortkey())])


            ## For some tags, Eagle generates empty tags when there's no contant
            ## rather than just leaving the tag out.  We mark these with
            ## Tag.requireTag in GenerateSwoop.py and force their generation
            ## here.



            ## add a list.

            if len(self.package3dinstances) is not 0:
                target = smartAddSubTags(r, "./package3dinstances/package3dinstance")
                # add them in sorted order.  This gives us a simple canonicalization that makes it feasible to use diff to compare files.
                target.extend([i.get_et() for i in sorted(self.package3dinstances,key=lambda x: x.sortkey())])


            ## For some tags, Eagle generates empty tags when there's no contant
            ## rather than just leaving the tag out.  We mark these with
            ## Tag.requireTag in GenerateSwoop.py and force their generation
            ## here.



            ## add a map.

            if len(self.technologies) is not 0:
                target = smartAddSubTags(r, "./technologies/technology")
                # add them in sorted order.  This gives us a simple canonicalization that makes it feasible to use diff to compare files.
                target.extend([i.get_et() for i in sorted(list(self.technologies.values()),key=lambda x: x.sortkey())])


            ## set the text, if its needed.

        except SwoopError as e:
            e.text = "{}:{}".format(self._get_error_name(), e.text)
            raise e
        return r

    def clone(self):
        """
        Recursively clone this :code:`Device`.  It will be identical to the original, but it's parent will be :code:`None`.
        
        :rtype: :class:`Device`
        """
        try:
            n = copy.copy(self)
            n.technologies = {}
            for x in list(self.technologies.values()):
                n.add_technology(x.clone())
            n.connects = []
            for x in self.connects:
                n.add_connect(x.clone())
            n.package3dinstances = []
            for x in self.package3dinstances:
                n.add_package3dinstance(x.clone())
            n.parent = None
        except SwoopError as e:
            e.text = "{}:{}".format(self._get_error_name(), e.text)
            raise e
        return n

    def accept_preorder_visitor(self, visitor):
        try:
            pre = getattr(visitor, "Device_pre")
            return pre(self)
        except AttributeError:
            return visitor.default_pre(self)
        
    def accept_postorder_visitor(self, visitor, context):
        try:
            post = getattr(visitor, "Device_post")
            post(self,context)
        except AttributeError:
            visitor.default_post(self,context)

    def is_equal(self, other):
        """
        Check whether two :code:`EagleFilePart` objects are identical.
        
        :param other: Object to compare to.
        :returns: :code:`True` if they are identical, otherwise, :code:`False`
        """
        return self.get_xml() == other.get_xml()
        
    ### Getters/Setters for attribute values

    def get_name(self):
        """ Return the value of :code:`name` for this :class:`Device`.  This corresponds to the :code:`name` attribute of a :code:`<device>` in an Eagle file.
        
        :rtype: :code:`str`
        """
        return self.name

    def set_name(self,v):
        """ Set the value of :code:`name` for this  :class:`Device`.  This corresponds to the :code:`name` attribute of a :code:`<device>` in an Eagle file.

        :param v: new value
        :rtype: :code:`self`
        """
                        
        if not typeCheck("str", v, True):
            raise SwoopError("Illegal value ({}) of type {} for attribute 'name' of Device object (should be str).".format(v, type(v)))
        self.name = v
        
        return self

    def with_name(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`name`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`name` equals :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_name()` is :code:`True`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """

        if type(v) in [str, int, float, bool]:
            return self if self.name == v else None
        elif callable(v):
            return self if v(self.name) else None
        else:
            raise SwoopError("Illegal type passed to with_name")

    def without_name(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`name`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`name` is not equal to :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_name()` is :code:`False`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """
        
        if type(v) in [str, int, float, bool]:
            return self if self.name != v else None
        elif callable(v):
            return self if not v(self.name) else None
        else:
            raise SwoopError("Illegal type passed to without_name")


    def get_package(self):
        """ Return the value of :code:`package` for this :class:`Device`.  This corresponds to the :code:`package` attribute of a :code:`<device>` in an Eagle file.
        
        :rtype: :code:`str`
        """
        return self.package

    def set_package(self,v):
        """ Set the value of :code:`package` for this  :class:`Device`.  This corresponds to the :code:`package` attribute of a :code:`<device>` in an Eagle file.

        :param v: new value
        :rtype: :code:`self`
        """
                        
        if not typeCheck("str", v, False):
            raise SwoopError("Illegal value ({}) of type {} for attribute 'package' of Device object (should be str).".format(v, type(v)))
        self.package = v
        
        return self

    def with_package(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`package`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`package` equals :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_package()` is :code:`True`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """

        if type(v) in [str, int, float, bool]:
            return self if self.package == v else None
        elif callable(v):
            return self if v(self.package) else None
        else:
            raise SwoopError("Illegal type passed to with_package")

    def without_package(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`package`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`package` is not equal to :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_package()` is :code:`False`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """
        
        if type(v) in [str, int, float, bool]:
            return self if self.package != v else None
        elif callable(v):
            return self if not v(self.package) else None
        else:
            raise SwoopError("Illegal type passed to without_package")



    ##### Lookup functions that return EFPs instead of just attribute values.
    
    def find_package(self):
        """Find the :class:`Package` object refered to by the :code:`package` attribute of this object.  This is like
        :meth:`get_package`, except it returns the :class:`Package` object instead of its name.
        
        :returns: The object
        :rtype: :class:`Package`

        """
        f = lambda efp, key: efp.get_parent().get_parent().get_package(key)
        return f(self, self.package)
    


    
    ### Adder/getter/lookup for lists
    
    def add_connect(self, s):
        """ Add a :class:`Connect` to the :code:`connects` of this :class:`Device`.

        :param s: The :class:`Connect` to add.
        :rtype: :code:`self`
        """
        if not any([
                isinstance(s, Connect),
            ]):
            raise SwoopError("Argument to Device.add_connect() should be of type Connect.  Got " + str(type(s).__name__) + ".")
        
        self.connects.append(s)
        if s.parent is not None and s.parent is not self:
            s.parent.remove_connect(s)

        s.parent = self
        return self

    def get_nth_connect(self, n):
        """ get then nth :class:`Connect` object from the :code:`connects` of this :class:`Device`.
        
        :param n: Index of the item to return.

        :rtype: :class:`Connect` object
        """
        return self.connects[n]

    def get_connects(self, attrs=None, type=None):
        """Return (and possibly filter) items in the the :code:`connects` list of :class:`Connect` objects for this :class:`Device`.
        
        This functions provides a mechanism for filtering the items as well.
        The keys in :code:`attrs` are taken as attributes names and the
        values are requested values.  Items in the list that have all the
        requested values for the corresponding attributes will be returned.  

        A if :code:`type` is not :code:`None`, the item will match if it is an
        instance of the type provided.
        
        :param attrs: A set of key-value pairs that represent a filter to apply to the item's attributes.
        :param type:  A type to filter on.  Only items that are an instance of this type will be returned.
        :returns: A List of :class:`Connect` objects
        :rtype: List of :class:`Connect` objects
        """
        if attrs is not None or type is not None:
            raise NotImplementedError("filtered get not implemented.")
        return self.connects

    def clear_connects(self):
        """
        Remove all the :class:`Connect` objects from the :code:`connects` of this :class:`Device`.
        
        :rtype: :code:`self`
        """
        for efp in self.connects:
            efp.parent = None
        self.connects = []
        return self

    def remove_connect(self, efp):
        """
        Remove a :class:`Connect` from the :code:`connects` of this :class:`Device`.
        
        :param efp: The :class:`Connect` object to remove.

        :rtype: :code:`self`
        """
        self.connects = [x for x in self.connects if x != efp]

        if efp.parent is self:
            efp.parent = None
        return self

    def add_package3dinstance(self, s):
        """ Add a :class:`Package3dinstance` to the :code:`package3dinstances` of this :class:`Device`.

        :param s: The :class:`Package3dinstance` to add.
        :rtype: :code:`self`
        """
        if not any([
                isinstance(s, Package3dinstance),
            ]):
            raise SwoopError("Argument to Device.add_package3dinstance() should be of type Package3dinstance.  Got " + str(type(s).__name__) + ".")
        
        self.package3dinstances.append(s)
        if s.parent is not None and s.parent is not self:
            s.parent.remove_package3dinstance(s)

        s.parent = self
        return self

    def get_nth_package3dinstance(self, n):
        """ get then nth :class:`Package3dinstance` object from the :code:`package3dinstances` of this :class:`Device`.
        
        :param n: Index of the item to return.

        :rtype: :class:`Package3dinstance` object
        """
        return self.package3dinstances[n]

    def get_package3dinstances(self, attrs=None, type=None):
        """Return (and possibly filter) items in the the :code:`package3dinstances` list of :class:`Package3dinstance` objects for this :class:`Device`.
        
        This functions provides a mechanism for filtering the items as well.
        The keys in :code:`attrs` are taken as attributes names and the
        values are requested values.  Items in the list that have all the
        requested values for the corresponding attributes will be returned.  

        A if :code:`type` is not :code:`None`, the item will match if it is an
        instance of the type provided.
        
        :param attrs: A set of key-value pairs that represent a filter to apply to the item's attributes.
        :param type:  A type to filter on.  Only items that are an instance of this type will be returned.
        :returns: A List of :class:`Package3dinstance` objects
        :rtype: List of :class:`Package3dinstance` objects
        """
        if attrs is not None or type is not None:
            raise NotImplementedError("filtered get not implemented.")
        return self.package3dinstances

    def clear_package3dinstances(self):
        """
        Remove all the :class:`Package3dinstance` objects from the :code:`package3dinstances` of this :class:`Device`.
        
        :rtype: :code:`self`
        """
        for efp in self.package3dinstances:
            efp.parent = None
        self.package3dinstances = []
        return self

    def remove_package3dinstance(self, efp):
        """
        Remove a :class:`Package3dinstance` from the :code:`package3dinstances` of this :class:`Device`.
        
        :param efp: The :class:`Package3dinstance` object to remove.

        :rtype: :code:`self`
        """
        self.package3dinstances = [x for x in self.package3dinstances if x != efp]

        if efp.parent is self:
            efp.parent = None
        return self



    ### Add, lookup, and get for maps
    def add_technology(self, s):
        """ Add a :class:`Technology` to the :code:`technologies` of this :class:`Device`.

        :param s: The :class:`Technology` to add.
        :rtype: :code:`self`
        """
        if not any([
                isinstance(s, Technology),
            ]):
            raise SwoopError("Argument to Device.add_technology() should be of type Technology.  Got " + str(type(s).__name__) + ".")
        

        self.technologies[s.get_name()] = s

        s.parent = self
        return self

    def get_nth_technology(self, n):
        """ get then nth :class:`Technology` object from the :code:`technologies` of this :class:`Device`.
        
        :param n: Index of the item to return.

        :rtype: :class:`Technology` object
        """
        return list(self.technologies.values())[n]

    def get_technology(self, key):
        """ Lookup and return a :class:`Technology` from the :code:`technologies` of  this :class:`Device`.
        
        :param key: A :code:`str` to use for the lookup.  The lookup uses the :code:`name` of the :class:`Technology` objects.

        :rtype: A :class:`Technology` object or :code:`None`, if there is no such item.
        """
        return self.technologies.get(key)


    def get_technologies(self, attrs=None, type=None):
        """Return (and possibly filter) items in the the :code:`technologies` map of :class:`Technology` objects for this :class:`Device`.
        
        This functions provides a mechanism for filtering the items as well.
        The keys in :code:`attrs` are taken as attributes names and the
        values are requested values.  Items in the list that have all the
        requested values for the corresponding attributes will be returned.  

        A if :code:`type` is not :code:`None`, the item will match if it is an
        instance of the type provided.
        
        :param attrs: A set of key-value pairs that represent a filter to apply to the item's attributes.
        :param type:  A type to filter on.  Only items that are an instance of this type will be returned.
        :returns: A List of :class:`Technology` objects
        :rtype: List of :class:`Technology` objects
        """
        if attrs is not None or type is not None:
            raise NotImplementedError("filtered get not implemented")
        return list(self.technologies.values())
        

    def clear_technologies(self):
        """
        Remove all the :class:`Technology` objects from the :code:`technologies` of this :class:`Device`.
        
        :rtype: :code:`self`
        """
        for efp in list(self.technologies.values()):
            efp.parent = None
        self.technologies = {}
        return self

    def remove_technology(self, efp):
        """
        Remove a :class:`Technology` from the :code:`technologies` of this :class:`Device`.
        
        :param efp: The :class:`Technology` object to remove.

        :rtype: :code:`self`
        """
        if self.technologies[efp.get_name()] == efp:
            del self.technologies[efp.get_name()]
            efp.parent = None
            return self
        else:
            raise SwoopError("Tried to use remove_technology() to delete the wrong kind of child?: {}".format(str(efp)))
    


    
    ### Getter/Setter for singletons.


    
    def get_children(self):
        """
        Get all the children of this :class:`EagleFilePart`.
        
        :rtype: List of :class:`EagleFilePart` objects
        """
        r = []

        r = r + self.connects
        r = r + self.package3dinstances

        r = r + list(self.technologies.values())


        return r

    def remove_child(self, efp):
        """
        Remove a child :class:`EagleFilePart` object.
        
        :param efp: the class:`EagleFilePart` object to remove.
        :return: Nothing
        """
        try:
            self.remove_technology(efp)
        except:
            pass
        try:
            self.remove_connect(efp)
        except:
            pass
        try:
            self.remove_package3dinstance(efp)
        except:
            pass

    def _rekey_child(self, oldkey, efp):
        """
        Remove a child :class:`EagleFilePart` object.
        
        :param efp: the class:`EagleFilePart` object to remove.
        :return: Nothing
        """
        try:
            if self.get_technology(oldkey) == efp:
                del self.technologies[oldkey]
                self.add_technology(efp)
        except SwoopError:
            pass

    def check_sanity(self, visited_efps = None):
        EagleFilePart.check_sanity(self, visited_efps)

        # Check whether keys in our maps match the keys in our children
        for k in self.technologies:
            if self.technologies[k].get_name() != k:
                raise SwoopError("Child's name ('{}') doesn't match key in parent's map ('{}')".format(self.technologies[k].get_name(),k))

    def __str__(self):
        r = "["+repr(self)+" "
        r = r + "name:" + str(self.get_name()) + " "
        r = r + "package:" + str(self.get_package()) + " "
        r = r + "]"
        return r
            
    def dump(self, indent="", increment="   "):
        """
        Recursive debug dump.
        
        :param indent:  Indentation string.  The output will be indented by this much.
        :param increment: This will be appendeded to :code:`indent` on recursive invocations.

        :rtype: :code:`None`
        """
        print(indent + str(self.__class__.__name__), end=' ')
        try:
            print(self.get_name())
        except:
            print()
            pass
        for c in self.get_children():
            c.dump(indent + "   ")

        
EagleFile.class_map["device"] = Device
         


class Hole(EagleFilePart, OnePointGeometry):
    """
    Class representing the contents of a <hole> tag in Eagle files.

    Attributes:

    * :code:`x`

    * :code:`y`

    * :code:`drill`


    """
    def __init__(self):
        """
        Construct an empty :class:`Hole` object.
        """
        EagleFilePart.__init__(self)
        OnePointGeometry.__init__(self)
        
        self.x=None
        self.y=None
        self.drill=None


        
    @classmethod
    def _from_et(cls,root,parent):
        """
        Create a :class:`Hole` from a :code:`hole` element.
        
        :param root: The element tree tree to parse.
        :param parent: :class:`EagleFilePart` that should hold the resulting :class:`EagleFilePart`
        :rtype: :class:`Hole`
        """
        ## Call the constructor
        n = cls()
        n._init_from_et(root,parent)
        return n

    def _get_error_name(self):
        if hasattr(self, "get_name"):
            return self.get_name();
        else:
            return "Hole";
        
    def  _init_from_et(self, root, parent):
        """
        Initialized a :class:`Hole` from a :code:`hole` element.  This is useful if you have a subclass of :class:`Hole` .
        
        :param root: The element tree tree to parse.
        :param parent: :class:`EagleFilePart` that will become the parent of :code:`this` .
        :rtype: :class:`Hole`
        """
        try:
            self.root = root
            
            if root.tag != "hole":
                raise EagleFormatError("Tried to create hole from " + root.tag)

            self.x=parseByType(parent, "float", None, root.get("x"))
            self.y=parseByType(parent, "float", None, root.get("y"))
            self.drill=parseByType(parent, "float", None, root.get("drill"))

            self.parent = parent

            ### populate the maps by searching for elements that match xpath and generating objects for them.


            ### Do the same for the lists


            ### Do the same for the attr lists


            ### And the singletons


            ### And, finally, if the objects wants the text from the tag.

        except SwoopError as e:
            e.text = "{}:{}".format(self._get_error_name(), e.text)
            raise e


    def sortkey(self):
        r = ""
        r = r + str(self.x)
        r = r + str(self.y)
        r = r + str(self.drill)
        return r

    def get_et(self):
        """
        Generate a <hole> element tree for a :class:`Hole`.
        
        :rtype:  :class:`ElementTree`.
        
        """
        try:
            r = ET.Element("hole")

            ### Set the tag attributes 


            ## Unparse the values.

            v = unparseByType(self, "float", None,  self.x)

            ## For required attributes None becomes "".  For optional attributes, we just leave the attribute out.
            if not (isinstance(self.get_parent(), LibraryFile) and False):  # special case for the name of library.
                if v is not None:
                    r.set("x", v)
                else:
                    r.set("x", "")


            ## Unparse the values.

            v = unparseByType(self, "float", None,  self.y)

            ## For required attributes None becomes "".  For optional attributes, we just leave the attribute out.
            if not (isinstance(self.get_parent(), LibraryFile) and False):  # special case for the name of library.
                if v is not None:
                    r.set("y", v)
                else:
                    r.set("y", "")


            ## Unparse the values.

            v = unparseByType(self, "float", None,  self.drill)

            ## For required attributes None becomes "".  For optional attributes, we just leave the attribute out.
            if not (isinstance(self.get_parent(), LibraryFile) and False):  # special case for the name of library.
                if v is not None:
                    r.set("drill", v)
                else:
                    r.set("drill", "")


            ### process the sections in order.  They have to be in section order,
            ### because eagle files are order dependent.


            ## set the text, if its needed.

        except SwoopError as e:
            e.text = "{}:{}".format(self._get_error_name(), e.text)
            raise e
        return r

    def clone(self):
        """
        Recursively clone this :code:`Hole`.  It will be identical to the original, but it's parent will be :code:`None`.
        
        :rtype: :class:`Hole`
        """
        try:
            n = copy.copy(self)
            n.parent = None
        except SwoopError as e:
            e.text = "{}:{}".format(self._get_error_name(), e.text)
            raise e
        return n

    def accept_preorder_visitor(self, visitor):
        try:
            pre = getattr(visitor, "Hole_pre")
            return pre(self)
        except AttributeError:
            return visitor.default_pre(self)
        
    def accept_postorder_visitor(self, visitor, context):
        try:
            post = getattr(visitor, "Hole_post")
            post(self,context)
        except AttributeError:
            visitor.default_post(self,context)

    def is_equal(self, other):
        """
        Check whether two :code:`EagleFilePart` objects are identical.
        
        :param other: Object to compare to.
        :returns: :code:`True` if they are identical, otherwise, :code:`False`
        """
        return self.get_xml() == other.get_xml()
        
    ### Getters/Setters for attribute values

    def get_x(self):
        """ Return the value of :code:`x` for this :class:`Hole`.  This corresponds to the :code:`x` attribute of a :code:`<hole>` in an Eagle file.
        
        :rtype: :code:`float`
        """
        return self.x

    def set_x(self,v):
        """ Set the value of :code:`x` for this  :class:`Hole`.  This corresponds to the :code:`x` attribute of a :code:`<hole>` in an Eagle file.

        :param v: new value
        :rtype: :code:`self`
        """
                        
        if not typeCheck("float", v, True):
            raise SwoopError("Illegal value ({}) of type {} for attribute 'x' of Hole object (should be float).".format(v, type(v)))
        self.x = v
        
        return self

    def with_x(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`x`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`x` equals :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_x()` is :code:`True`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """

        if type(v) in [str, int, float, bool]:
            return self if self.x == v else None
        elif callable(v):
            return self if v(self.x) else None
        else:
            raise SwoopError("Illegal type passed to with_x")

    def without_x(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`x`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`x` is not equal to :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_x()` is :code:`False`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """
        
        if type(v) in [str, int, float, bool]:
            return self if self.x != v else None
        elif callable(v):
            return self if not v(self.x) else None
        else:
            raise SwoopError("Illegal type passed to without_x")


    def get_y(self):
        """ Return the value of :code:`y` for this :class:`Hole`.  This corresponds to the :code:`y` attribute of a :code:`<hole>` in an Eagle file.
        
        :rtype: :code:`float`
        """
        return self.y

    def set_y(self,v):
        """ Set the value of :code:`y` for this  :class:`Hole`.  This corresponds to the :code:`y` attribute of a :code:`<hole>` in an Eagle file.

        :param v: new value
        :rtype: :code:`self`
        """
                        
        if not typeCheck("float", v, True):
            raise SwoopError("Illegal value ({}) of type {} for attribute 'y' of Hole object (should be float).".format(v, type(v)))
        self.y = v
        
        return self

    def with_y(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`y`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`y` equals :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_y()` is :code:`True`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """

        if type(v) in [str, int, float, bool]:
            return self if self.y == v else None
        elif callable(v):
            return self if v(self.y) else None
        else:
            raise SwoopError("Illegal type passed to with_y")

    def without_y(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`y`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`y` is not equal to :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_y()` is :code:`False`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """
        
        if type(v) in [str, int, float, bool]:
            return self if self.y != v else None
        elif callable(v):
            return self if not v(self.y) else None
        else:
            raise SwoopError("Illegal type passed to without_y")


    def get_drill(self):
        """ Return the value of :code:`drill` for this :class:`Hole`.  This corresponds to the :code:`drill` attribute of a :code:`<hole>` in an Eagle file.
        
        :rtype: :code:`float`
        """
        return self.drill

    def set_drill(self,v):
        """ Set the value of :code:`drill` for this  :class:`Hole`.  This corresponds to the :code:`drill` attribute of a :code:`<hole>` in an Eagle file.

        :param v: new value
        :rtype: :code:`self`
        """
                        
        if not typeCheck("float", v, True):
            raise SwoopError("Illegal value ({}) of type {} for attribute 'drill' of Hole object (should be float).".format(v, type(v)))
        self.drill = v
        
        return self

    def with_drill(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`drill`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`drill` equals :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_drill()` is :code:`True`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """

        if type(v) in [str, int, float, bool]:
            return self if self.drill == v else None
        elif callable(v):
            return self if v(self.drill) else None
        else:
            raise SwoopError("Illegal type passed to with_drill")

    def without_drill(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`drill`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`drill` is not equal to :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_drill()` is :code:`False`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """
        
        if type(v) in [str, int, float, bool]:
            return self if self.drill != v else None
        elif callable(v):
            return self if not v(self.drill) else None
        else:
            raise SwoopError("Illegal type passed to without_drill")



    ##### Lookup functions that return EFPs instead of just attribute values.
    
    


    
    ### Adder/getter/lookup for lists
    


    ### Add, lookup, and get for maps


    
    ### Getter/Setter for singletons.


    
    def get_children(self):
        """
        Get all the children of this :class:`EagleFilePart`.
        
        :rtype: List of :class:`EagleFilePart` objects
        """
        r = []




        return r

    def remove_child(self, efp):
        """
        Remove a child :class:`EagleFilePart` object.
        
        :param efp: the class:`EagleFilePart` object to remove.
        :return: Nothing
        """

    def _rekey_child(self, oldkey, efp):
        """
        Remove a child :class:`EagleFilePart` object.
        
        :param efp: the class:`EagleFilePart` object to remove.
        :return: Nothing
        """


    def __str__(self):
        r = "["+repr(self)+" "
        r = r + "x:" + str(self.get_x()) + " "
        r = r + "y:" + str(self.get_y()) + " "
        r = r + "drill:" + str(self.get_drill()) + " "
        r = r + "]"
        return r
            
    def dump(self, indent="", increment="   "):
        """
        Recursive debug dump.
        
        :param indent:  Indentation string.  The output will be indented by this much.
        :param increment: This will be appendeded to :code:`indent` on recursive invocations.

        :rtype: :code:`None`
        """
        print(indent + str(self.__class__.__name__), end=' ')
        try:
            print(self.get_name())
        except:
            print()
            pass
        for c in self.get_children():
            c.dump(indent + "   ")

        
EagleFile.class_map["hole"] = Hole
         


class Segment(EagleFilePart):
    """
    Class representing the contents of a <segment> tag in Eagle files.

    Attributes:



    Collections:


    * :code:`pinref`: List of :class:`Pinref` objects.

    * :code:`portref`: List of :class:`Portref` objects.

    * :code:`wire`: List of :class:`Wire` objects.

    * :code:`junction`: List of :class:`Junction` objects.

    * :code:`label`: List of :class:`Label` objects.



    """
    def __init__(self):
        """
        Construct an empty :class:`Segment` object.
        """
        EagleFilePart.__init__(self)
        
        self.pinrefs=[]
        self.portrefs=[]
        self.wires=[]
        self.junctions=[]
        self.labels=[]


        
    @classmethod
    def _from_et(cls,root,parent):
        """
        Create a :class:`Segment` from a :code:`segment` element.
        
        :param root: The element tree tree to parse.
        :param parent: :class:`EagleFilePart` that should hold the resulting :class:`EagleFilePart`
        :rtype: :class:`Segment`
        """
        ## Call the constructor
        n = cls()
        n._init_from_et(root,parent)
        return n

    def _get_error_name(self):
        if hasattr(self, "get_name"):
            return self.get_name();
        else:
            return "Segment";
        
    def  _init_from_et(self, root, parent):
        """
        Initialized a :class:`Segment` from a :code:`segment` element.  This is useful if you have a subclass of :class:`Segment` .
        
        :param root: The element tree tree to parse.
        :param parent: :class:`EagleFilePart` that will become the parent of :code:`this` .
        :rtype: :class:`Segment`
        """
        try:
            self.root = root
            
            if root.tag != "segment":
                raise EagleFormatError("Tried to create segment from " + root.tag)


            self.parent = parent

            ### populate the maps by searching for elements that match xpath and generating objects for them.


            ### Do the same for the lists

            for c in root.xpath("./pinref"):
                self.add_pinref(self.get_class_for_tag(c.tag)._from_et(c,self))
            for c in root.xpath("./portref"):
                self.add_portref(self.get_class_for_tag(c.tag)._from_et(c,self))
            for c in root.xpath("./wire"):
                self.add_wire(self.get_class_for_tag(c.tag)._from_et(c,self))
            for c in root.xpath("./junction"):
                self.add_junction(self.get_class_for_tag(c.tag)._from_et(c,self))
            for c in root.xpath("./label"):
                self.add_label(self.get_class_for_tag(c.tag)._from_et(c,self))

            ### Do the same for the attr lists


            ### And the singletons


            ### And, finally, if the objects wants the text from the tag.

        except SwoopError as e:
            e.text = "{}:{}".format(self._get_error_name(), e.text)
            raise e


    def sortkey(self):
        r = ""
        return r

    def get_et(self):
        """
        Generate a <segment> element tree for a :class:`Segment`.
        
        :rtype:  :class:`ElementTree`.
        
        """
        try:
            r = ET.Element("segment")

            ### Set the tag attributes 


            ### process the sections in order.  They have to be in section order,
            ### because eagle files are order dependent.


            ## For some tags, Eagle generates empty tags when there's no contant
            ## rather than just leaving the tag out.  We mark these with
            ## Tag.requireTag in GenerateSwoop.py and force their generation
            ## here.



            ## add a list.

            if len(self.pinrefs) is not 0:
                target = smartAddSubTags(r, "./pinref")
                # add them in sorted order.  This gives us a simple canonicalization that makes it feasible to use diff to compare files.
                target.extend([i.get_et() for i in sorted(self.pinrefs,key=lambda x: x.sortkey())])


            ## For some tags, Eagle generates empty tags when there's no contant
            ## rather than just leaving the tag out.  We mark these with
            ## Tag.requireTag in GenerateSwoop.py and force their generation
            ## here.



            ## add a list.

            if len(self.portrefs) is not 0:
                target = smartAddSubTags(r, "./portref")
                # add them in sorted order.  This gives us a simple canonicalization that makes it feasible to use diff to compare files.
                target.extend([i.get_et() for i in sorted(self.portrefs,key=lambda x: x.sortkey())])


            ## For some tags, Eagle generates empty tags when there's no contant
            ## rather than just leaving the tag out.  We mark these with
            ## Tag.requireTag in GenerateSwoop.py and force their generation
            ## here.



            ## add a list.

            if len(self.wires) is not 0:
                target = smartAddSubTags(r, "./wire")
                # add them in sorted order.  This gives us a simple canonicalization that makes it feasible to use diff to compare files.
                target.extend([i.get_et() for i in sorted(self.wires,key=lambda x: x.sortkey())])


            ## For some tags, Eagle generates empty tags when there's no contant
            ## rather than just leaving the tag out.  We mark these with
            ## Tag.requireTag in GenerateSwoop.py and force their generation
            ## here.



            ## add a list.

            if len(self.junctions) is not 0:
                target = smartAddSubTags(r, "./junction")
                # add them in sorted order.  This gives us a simple canonicalization that makes it feasible to use diff to compare files.
                target.extend([i.get_et() for i in sorted(self.junctions,key=lambda x: x.sortkey())])


            ## For some tags, Eagle generates empty tags when there's no contant
            ## rather than just leaving the tag out.  We mark these with
            ## Tag.requireTag in GenerateSwoop.py and force their generation
            ## here.



            ## add a list.

            if len(self.labels) is not 0:
                target = smartAddSubTags(r, "./label")
                # add them in sorted order.  This gives us a simple canonicalization that makes it feasible to use diff to compare files.
                target.extend([i.get_et() for i in sorted(self.labels,key=lambda x: x.sortkey())])


            ## set the text, if its needed.

        except SwoopError as e:
            e.text = "{}:{}".format(self._get_error_name(), e.text)
            raise e
        return r

    def clone(self):
        """
        Recursively clone this :code:`Segment`.  It will be identical to the original, but it's parent will be :code:`None`.
        
        :rtype: :class:`Segment`
        """
        try:
            n = copy.copy(self)
            n.pinrefs = []
            for x in self.pinrefs:
                n.add_pinref(x.clone())
            n.portrefs = []
            for x in self.portrefs:
                n.add_portref(x.clone())
            n.wires = []
            for x in self.wires:
                n.add_wire(x.clone())
            n.junctions = []
            for x in self.junctions:
                n.add_junction(x.clone())
            n.labels = []
            for x in self.labels:
                n.add_label(x.clone())
            n.parent = None
        except SwoopError as e:
            e.text = "{}:{}".format(self._get_error_name(), e.text)
            raise e
        return n

    def accept_preorder_visitor(self, visitor):
        try:
            pre = getattr(visitor, "Segment_pre")
            return pre(self)
        except AttributeError:
            return visitor.default_pre(self)
        
    def accept_postorder_visitor(self, visitor, context):
        try:
            post = getattr(visitor, "Segment_post")
            post(self,context)
        except AttributeError:
            visitor.default_post(self,context)

    def is_equal(self, other):
        """
        Check whether two :code:`EagleFilePart` objects are identical.
        
        :param other: Object to compare to.
        :returns: :code:`True` if they are identical, otherwise, :code:`False`
        """
        return self.get_xml() == other.get_xml()
        
    ### Getters/Setters for attribute values


    ##### Lookup functions that return EFPs instead of just attribute values.
    
    


    
    ### Adder/getter/lookup for lists
    
    def add_pinref(self, s):
        """ Add a :class:`Pinref` to the :code:`pinrefs` of this :class:`Segment`.

        :param s: The :class:`Pinref` to add.
        :rtype: :code:`self`
        """
        if not any([
                isinstance(s, Pinref),
            ]):
            raise SwoopError("Argument to Segment.add_pinref() should be of type Pinref.  Got " + str(type(s).__name__) + ".")
        
        self.pinrefs.append(s)
        if s.parent is not None and s.parent is not self:
            s.parent.remove_pinref(s)

        s.parent = self
        return self

    def get_nth_pinref(self, n):
        """ get then nth :class:`Pinref` object from the :code:`pinrefs` of this :class:`Segment`.
        
        :param n: Index of the item to return.

        :rtype: :class:`Pinref` object
        """
        return self.pinrefs[n]

    def get_pinrefs(self, attrs=None, type=None):
        """Return (and possibly filter) items in the the :code:`pinrefs` list of :class:`Pinref` objects for this :class:`Segment`.
        
        This functions provides a mechanism for filtering the items as well.
        The keys in :code:`attrs` are taken as attributes names and the
        values are requested values.  Items in the list that have all the
        requested values for the corresponding attributes will be returned.  

        A if :code:`type` is not :code:`None`, the item will match if it is an
        instance of the type provided.
        
        :param attrs: A set of key-value pairs that represent a filter to apply to the item's attributes.
        :param type:  A type to filter on.  Only items that are an instance of this type will be returned.
        :returns: A List of :class:`Pinref` objects
        :rtype: List of :class:`Pinref` objects
        """
        if attrs is not None or type is not None:
            raise NotImplementedError("filtered get not implemented.")
        return self.pinrefs

    def clear_pinrefs(self):
        """
        Remove all the :class:`Pinref` objects from the :code:`pinrefs` of this :class:`Segment`.
        
        :rtype: :code:`self`
        """
        for efp in self.pinrefs:
            efp.parent = None
        self.pinrefs = []
        return self

    def remove_pinref(self, efp):
        """
        Remove a :class:`Pinref` from the :code:`pinrefs` of this :class:`Segment`.
        
        :param efp: The :class:`Pinref` object to remove.

        :rtype: :code:`self`
        """
        self.pinrefs = [x for x in self.pinrefs if x != efp]

        if efp.parent is self:
            efp.parent = None
        return self

    def add_portref(self, s):
        """ Add a :class:`Portref` to the :code:`portrefs` of this :class:`Segment`.

        :param s: The :class:`Portref` to add.
        :rtype: :code:`self`
        """
        if not any([
                isinstance(s, Portref),
            ]):
            raise SwoopError("Argument to Segment.add_portref() should be of type Portref.  Got " + str(type(s).__name__) + ".")
        
        self.portrefs.append(s)
        if s.parent is not None and s.parent is not self:
            s.parent.remove_portref(s)

        s.parent = self
        return self

    def get_nth_portref(self, n):
        """ get then nth :class:`Portref` object from the :code:`portrefs` of this :class:`Segment`.
        
        :param n: Index of the item to return.

        :rtype: :class:`Portref` object
        """
        return self.portrefs[n]

    def get_portrefs(self, attrs=None, type=None):
        """Return (and possibly filter) items in the the :code:`portrefs` list of :class:`Portref` objects for this :class:`Segment`.
        
        This functions provides a mechanism for filtering the items as well.
        The keys in :code:`attrs` are taken as attributes names and the
        values are requested values.  Items in the list that have all the
        requested values for the corresponding attributes will be returned.  

        A if :code:`type` is not :code:`None`, the item will match if it is an
        instance of the type provided.
        
        :param attrs: A set of key-value pairs that represent a filter to apply to the item's attributes.
        :param type:  A type to filter on.  Only items that are an instance of this type will be returned.
        :returns: A List of :class:`Portref` objects
        :rtype: List of :class:`Portref` objects
        """
        if attrs is not None or type is not None:
            raise NotImplementedError("filtered get not implemented.")
        return self.portrefs

    def clear_portrefs(self):
        """
        Remove all the :class:`Portref` objects from the :code:`portrefs` of this :class:`Segment`.
        
        :rtype: :code:`self`
        """
        for efp in self.portrefs:
            efp.parent = None
        self.portrefs = []
        return self

    def remove_portref(self, efp):
        """
        Remove a :class:`Portref` from the :code:`portrefs` of this :class:`Segment`.
        
        :param efp: The :class:`Portref` object to remove.

        :rtype: :code:`self`
        """
        self.portrefs = [x for x in self.portrefs if x != efp]

        if efp.parent is self:
            efp.parent = None
        return self

    def add_wire(self, s):
        """ Add a :class:`Wire` to the :code:`wires` of this :class:`Segment`.

        :param s: The :class:`Wire` to add.
        :rtype: :code:`self`
        """
        if not any([
                isinstance(s, Wire),
            ]):
            raise SwoopError("Argument to Segment.add_wire() should be of type Wire.  Got " + str(type(s).__name__) + ".")
        
        self.wires.append(s)
        if s.parent is not None and s.parent is not self:
            s.parent.remove_wire(s)

        s.parent = self
        return self

    def get_nth_wire(self, n):
        """ get then nth :class:`Wire` object from the :code:`wires` of this :class:`Segment`.
        
        :param n: Index of the item to return.

        :rtype: :class:`Wire` object
        """
        return self.wires[n]

    def get_wires(self, attrs=None, type=None):
        """Return (and possibly filter) items in the the :code:`wires` list of :class:`Wire` objects for this :class:`Segment`.
        
        This functions provides a mechanism for filtering the items as well.
        The keys in :code:`attrs` are taken as attributes names and the
        values are requested values.  Items in the list that have all the
        requested values for the corresponding attributes will be returned.  

        A if :code:`type` is not :code:`None`, the item will match if it is an
        instance of the type provided.
        
        :param attrs: A set of key-value pairs that represent a filter to apply to the item's attributes.
        :param type:  A type to filter on.  Only items that are an instance of this type will be returned.
        :returns: A List of :class:`Wire` objects
        :rtype: List of :class:`Wire` objects
        """
        if attrs is not None or type is not None:
            raise NotImplementedError("filtered get not implemented.")
        return self.wires

    def clear_wires(self):
        """
        Remove all the :class:`Wire` objects from the :code:`wires` of this :class:`Segment`.
        
        :rtype: :code:`self`
        """
        for efp in self.wires:
            efp.parent = None
        self.wires = []
        return self

    def remove_wire(self, efp):
        """
        Remove a :class:`Wire` from the :code:`wires` of this :class:`Segment`.
        
        :param efp: The :class:`Wire` object to remove.

        :rtype: :code:`self`
        """
        self.wires = [x for x in self.wires if x != efp]

        if efp.parent is self:
            efp.parent = None
        return self

    def add_junction(self, s):
        """ Add a :class:`Junction` to the :code:`junctions` of this :class:`Segment`.

        :param s: The :class:`Junction` to add.
        :rtype: :code:`self`
        """
        if not any([
                isinstance(s, Junction),
            ]):
            raise SwoopError("Argument to Segment.add_junction() should be of type Junction.  Got " + str(type(s).__name__) + ".")
        
        self.junctions.append(s)
        if s.parent is not None and s.parent is not self:
            s.parent.remove_junction(s)

        s.parent = self
        return self

    def get_nth_junction(self, n):
        """ get then nth :class:`Junction` object from the :code:`junctions` of this :class:`Segment`.
        
        :param n: Index of the item to return.

        :rtype: :class:`Junction` object
        """
        return self.junctions[n]

    def get_junctions(self, attrs=None, type=None):
        """Return (and possibly filter) items in the the :code:`junctions` list of :class:`Junction` objects for this :class:`Segment`.
        
        This functions provides a mechanism for filtering the items as well.
        The keys in :code:`attrs` are taken as attributes names and the
        values are requested values.  Items in the list that have all the
        requested values for the corresponding attributes will be returned.  

        A if :code:`type` is not :code:`None`, the item will match if it is an
        instance of the type provided.
        
        :param attrs: A set of key-value pairs that represent a filter to apply to the item's attributes.
        :param type:  A type to filter on.  Only items that are an instance of this type will be returned.
        :returns: A List of :class:`Junction` objects
        :rtype: List of :class:`Junction` objects
        """
        if attrs is not None or type is not None:
            raise NotImplementedError("filtered get not implemented.")
        return self.junctions

    def clear_junctions(self):
        """
        Remove all the :class:`Junction` objects from the :code:`junctions` of this :class:`Segment`.
        
        :rtype: :code:`self`
        """
        for efp in self.junctions:
            efp.parent = None
        self.junctions = []
        return self

    def remove_junction(self, efp):
        """
        Remove a :class:`Junction` from the :code:`junctions` of this :class:`Segment`.
        
        :param efp: The :class:`Junction` object to remove.

        :rtype: :code:`self`
        """
        self.junctions = [x for x in self.junctions if x != efp]

        if efp.parent is self:
            efp.parent = None
        return self

    def add_label(self, s):
        """ Add a :class:`Label` to the :code:`labels` of this :class:`Segment`.

        :param s: The :class:`Label` to add.
        :rtype: :code:`self`
        """
        if not any([
                isinstance(s, Label),
            ]):
            raise SwoopError("Argument to Segment.add_label() should be of type Label.  Got " + str(type(s).__name__) + ".")
        
        self.labels.append(s)
        if s.parent is not None and s.parent is not self:
            s.parent.remove_label(s)

        s.parent = self
        return self

    def get_nth_label(self, n):
        """ get then nth :class:`Label` object from the :code:`labels` of this :class:`Segment`.
        
        :param n: Index of the item to return.

        :rtype: :class:`Label` object
        """
        return self.labels[n]

    def get_labels(self, attrs=None, type=None):
        """Return (and possibly filter) items in the the :code:`labels` list of :class:`Label` objects for this :class:`Segment`.
        
        This functions provides a mechanism for filtering the items as well.
        The keys in :code:`attrs` are taken as attributes names and the
        values are requested values.  Items in the list that have all the
        requested values for the corresponding attributes will be returned.  

        A if :code:`type` is not :code:`None`, the item will match if it is an
        instance of the type provided.
        
        :param attrs: A set of key-value pairs that represent a filter to apply to the item's attributes.
        :param type:  A type to filter on.  Only items that are an instance of this type will be returned.
        :returns: A List of :class:`Label` objects
        :rtype: List of :class:`Label` objects
        """
        if attrs is not None or type is not None:
            raise NotImplementedError("filtered get not implemented.")
        return self.labels

    def clear_labels(self):
        """
        Remove all the :class:`Label` objects from the :code:`labels` of this :class:`Segment`.
        
        :rtype: :code:`self`
        """
        for efp in self.labels:
            efp.parent = None
        self.labels = []
        return self

    def remove_label(self, efp):
        """
        Remove a :class:`Label` from the :code:`labels` of this :class:`Segment`.
        
        :param efp: The :class:`Label` object to remove.

        :rtype: :code:`self`
        """
        self.labels = [x for x in self.labels if x != efp]

        if efp.parent is self:
            efp.parent = None
        return self



    ### Add, lookup, and get for maps


    
    ### Getter/Setter for singletons.


    
    def get_children(self):
        """
        Get all the children of this :class:`EagleFilePart`.
        
        :rtype: List of :class:`EagleFilePart` objects
        """
        r = []

        r = r + self.pinrefs
        r = r + self.portrefs
        r = r + self.wires
        r = r + self.junctions
        r = r + self.labels



        return r

    def remove_child(self, efp):
        """
        Remove a child :class:`EagleFilePart` object.
        
        :param efp: the class:`EagleFilePart` object to remove.
        :return: Nothing
        """
        try:
            self.remove_pinref(efp)
        except:
            pass
        try:
            self.remove_portref(efp)
        except:
            pass
        try:
            self.remove_wire(efp)
        except:
            pass
        try:
            self.remove_junction(efp)
        except:
            pass
        try:
            self.remove_label(efp)
        except:
            pass

    def _rekey_child(self, oldkey, efp):
        """
        Remove a child :class:`EagleFilePart` object.
        
        :param efp: the class:`EagleFilePart` object to remove.
        :return: Nothing
        """


    def __str__(self):
        r = "["+repr(self)+" "
        r = r + "]"
        return r
            
    def dump(self, indent="", increment="   "):
        """
        Recursive debug dump.
        
        :param indent:  Indentation string.  The output will be indented by this much.
        :param increment: This will be appendeded to :code:`indent` on recursive invocations.

        :rtype: :code:`None`
        """
        print(indent + str(self.__class__.__name__), end=' ')
        try:
            print(self.get_name())
        except:
            print()
            pass
        for c in self.get_children():
            c.dump(indent + "   ")

        
EagleFile.class_map["segment"] = Segment
         


class Net(EagleFilePart):
    """
    Class representing the contents of a <net> tag in Eagle files.

    Attributes:

    * :code:`name`

    * :code:`class`



    Collections:


    * :code:`segment`: List of :class:`Segment` objects.



    """
    def __init__(self):
        """
        Construct an empty :class:`Net` object.
        """
        EagleFilePart.__init__(self)
        
        self.name=None
        self.netclass=None
        self.segments=[]


        
    @classmethod
    def _from_et(cls,root,parent):
        """
        Create a :class:`Net` from a :code:`net` element.
        
        :param root: The element tree tree to parse.
        :param parent: :class:`EagleFilePart` that should hold the resulting :class:`EagleFilePart`
        :rtype: :class:`Net`
        """
        ## Call the constructor
        n = cls()
        n._init_from_et(root,parent)
        return n

    def _get_error_name(self):
        if hasattr(self, "get_name"):
            return self.get_name();
        else:
            return "Net";
        
    def  _init_from_et(self, root, parent):
        """
        Initialized a :class:`Net` from a :code:`net` element.  This is useful if you have a subclass of :class:`Net` .
        
        :param root: The element tree tree to parse.
        :param parent: :class:`EagleFilePart` that will become the parent of :code:`this` .
        :rtype: :class:`Net`
        """
        try:
            self.root = root
            
            if root.tag != "net":
                raise EagleFormatError("Tried to create net from " + root.tag)

            self.name=parseByType(parent, "str", None, root.get("name"))
            self.netclass=parseByType(parent, "str", None, root.get("class"))

            self.parent = parent

            ### populate the maps by searching for elements that match xpath and generating objects for them.


            ### Do the same for the lists

            for c in root.xpath("./segment"):
                self.add_segment(self.get_class_for_tag(c.tag)._from_et(c,self))

            ### Do the same for the attr lists


            ### And the singletons


            ### And, finally, if the objects wants the text from the tag.

        except SwoopError as e:
            e.text = "{}:{}".format(self._get_error_name(), e.text)
            raise e


    def sortkey(self):
        r = ""
        r = r + str(self.name)
        r = r + str(self.netclass)
        return r

    def get_et(self):
        """
        Generate a <net> element tree for a :class:`Net`.
        
        :rtype:  :class:`ElementTree`.
        
        """
        try:
            r = ET.Element("net")

            ### Set the tag attributes 


            ## Unparse the values.

            v = unparseByType(self, "str", None,  self.name)

            ## For required attributes None becomes "".  For optional attributes, we just leave the attribute out.
            if not (isinstance(self.get_parent(), LibraryFile) and False):  # special case for the name of library.
                if v is not None:
                    r.set("name", v)
                else:
                    r.set("name", "")


            ## Unparse the values.

            v = unparseByType(self, "str", None,  self.netclass)

            ## For required attributes None becomes "".  For optional attributes, we just leave the attribute out.
            if not (isinstance(self.get_parent(), LibraryFile) and False):  # special case for the name of library.
                if v is not None:
                    r.set("class", v)


            ### process the sections in order.  They have to be in section order,
            ### because eagle files are order dependent.


            ## For some tags, Eagle generates empty tags when there's no contant
            ## rather than just leaving the tag out.  We mark these with
            ## Tag.requireTag in GenerateSwoop.py and force their generation
            ## here.



            ## add a list.

            if len(self.segments) is not 0:
                target = smartAddSubTags(r, "./segment")
                # add them in sorted order.  This gives us a simple canonicalization that makes it feasible to use diff to compare files.
                target.extend([i.get_et() for i in sorted(self.segments,key=lambda x: x.sortkey())])


            ## set the text, if its needed.

        except SwoopError as e:
            e.text = "{}:{}".format(self._get_error_name(), e.text)
            raise e
        return r

    def clone(self):
        """
        Recursively clone this :code:`Net`.  It will be identical to the original, but it's parent will be :code:`None`.
        
        :rtype: :class:`Net`
        """
        try:
            n = copy.copy(self)
            n.segments = []
            for x in self.segments:
                n.add_segment(x.clone())
            n.parent = None
        except SwoopError as e:
            e.text = "{}:{}".format(self._get_error_name(), e.text)
            raise e
        return n

    def accept_preorder_visitor(self, visitor):
        try:
            pre = getattr(visitor, "Net_pre")
            return pre(self)
        except AttributeError:
            return visitor.default_pre(self)
        
    def accept_postorder_visitor(self, visitor, context):
        try:
            post = getattr(visitor, "Net_post")
            post(self,context)
        except AttributeError:
            visitor.default_post(self,context)

    def is_equal(self, other):
        """
        Check whether two :code:`EagleFilePart` objects are identical.
        
        :param other: Object to compare to.
        :returns: :code:`True` if they are identical, otherwise, :code:`False`
        """
        return self.get_xml() == other.get_xml()
        
    ### Getters/Setters for attribute values

    def get_name(self):
        """ Return the value of :code:`name` for this :class:`Net`.  This corresponds to the :code:`name` attribute of a :code:`<net>` in an Eagle file.
        
        :rtype: :code:`str`
        """
        return self.name

    def set_name(self,v):
        """ Set the value of :code:`name` for this  :class:`Net`.  This corresponds to the :code:`name` attribute of a :code:`<net>` in an Eagle file.

        :param v: new value
        :rtype: :code:`self`
        """
                        
        oldkey = self.name
        if not typeCheck("str", v, True):
            raise SwoopError("Illegal value ({}) of type {} for attribute 'name' of Net object (should be str).".format(v, type(v)))
        self.name = v
        
        if self.get_parent() is not None:
            self.get_parent()._rekey_child(oldkey, self);
        return self

    def with_name(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`name`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`name` equals :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_name()` is :code:`True`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """

        if type(v) in [str, int, float, bool]:
            return self if self.name == v else None
        elif callable(v):
            return self if v(self.name) else None
        else:
            raise SwoopError("Illegal type passed to with_name")

    def without_name(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`name`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`name` is not equal to :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_name()` is :code:`False`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """
        
        if type(v) in [str, int, float, bool]:
            return self if self.name != v else None
        elif callable(v):
            return self if not v(self.name) else None
        else:
            raise SwoopError("Illegal type passed to without_name")


    def get_class(self):
        """ Return the value of :code:`netclass` for this :class:`Net`.  This corresponds to the :code:`netclass` attribute of a :code:`<net>` in an Eagle file.
        
        :rtype: :code:`str`
        """
        return self.netclass

    def set_class(self,v):
        """ Set the value of :code:`netclass` for this  :class:`Net`.  This corresponds to the :code:`netclass` attribute of a :code:`<net>` in an Eagle file.

        :param v: new value
        :rtype: :code:`self`
        """
                        
        if not typeCheck("str", v, False):
            raise SwoopError("Illegal value ({}) of type {} for attribute 'netclass' of Net object (should be str).".format(v, type(v)))
        self.netclass = v
        
        return self

    def with_class(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`netclass`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`netclass` equals :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_class()` is :code:`True`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """

        if type(v) in [str, int, float, bool]:
            return self if self.netclass == v else None
        elif callable(v):
            return self if v(self.netclass) else None
        else:
            raise SwoopError("Illegal type passed to with_class")

    def without_class(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`netclass`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`netclass` is not equal to :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_class()` is :code:`False`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """
        
        if type(v) in [str, int, float, bool]:
            return self if self.netclass != v else None
        elif callable(v):
            return self if not v(self.netclass) else None
        else:
            raise SwoopError("Illegal type passed to without_class")



    ##### Lookup functions that return EFPs instead of just attribute values.
    
    


    
    ### Adder/getter/lookup for lists
    
    def add_segment(self, s):
        """ Add a :class:`Segment` to the :code:`segments` of this :class:`Net`.

        :param s: The :class:`Segment` to add.
        :rtype: :code:`self`
        """
        if not any([
                isinstance(s, Segment),
            ]):
            raise SwoopError("Argument to Net.add_segment() should be of type Segment.  Got " + str(type(s).__name__) + ".")
        
        self.segments.append(s)
        if s.parent is not None and s.parent is not self:
            s.parent.remove_segment(s)

        s.parent = self
        return self

    def get_nth_segment(self, n):
        """ get then nth :class:`Segment` object from the :code:`segments` of this :class:`Net`.
        
        :param n: Index of the item to return.

        :rtype: :class:`Segment` object
        """
        return self.segments[n]

    def get_segments(self, attrs=None, type=None):
        """Return (and possibly filter) items in the the :code:`segments` list of :class:`Segment` objects for this :class:`Net`.
        
        This functions provides a mechanism for filtering the items as well.
        The keys in :code:`attrs` are taken as attributes names and the
        values are requested values.  Items in the list that have all the
        requested values for the corresponding attributes will be returned.  

        A if :code:`type` is not :code:`None`, the item will match if it is an
        instance of the type provided.
        
        :param attrs: A set of key-value pairs that represent a filter to apply to the item's attributes.
        :param type:  A type to filter on.  Only items that are an instance of this type will be returned.
        :returns: A List of :class:`Segment` objects
        :rtype: List of :class:`Segment` objects
        """
        if attrs is not None or type is not None:
            raise NotImplementedError("filtered get not implemented.")
        return self.segments

    def clear_segments(self):
        """
        Remove all the :class:`Segment` objects from the :code:`segments` of this :class:`Net`.
        
        :rtype: :code:`self`
        """
        for efp in self.segments:
            efp.parent = None
        self.segments = []
        return self

    def remove_segment(self, efp):
        """
        Remove a :class:`Segment` from the :code:`segments` of this :class:`Net`.
        
        :param efp: The :class:`Segment` object to remove.

        :rtype: :code:`self`
        """
        self.segments = [x for x in self.segments if x != efp]

        if efp.parent is self:
            efp.parent = None
        return self



    ### Add, lookup, and get for maps


    
    ### Getter/Setter for singletons.


    
    def get_children(self):
        """
        Get all the children of this :class:`EagleFilePart`.
        
        :rtype: List of :class:`EagleFilePart` objects
        """
        r = []

        r = r + self.segments



        return r

    def remove_child(self, efp):
        """
        Remove a child :class:`EagleFilePart` object.
        
        :param efp: the class:`EagleFilePart` object to remove.
        :return: Nothing
        """
        try:
            self.remove_segment(efp)
        except:
            pass

    def _rekey_child(self, oldkey, efp):
        """
        Remove a child :class:`EagleFilePart` object.
        
        :param efp: the class:`EagleFilePart` object to remove.
        :return: Nothing
        """


    def __str__(self):
        r = "["+repr(self)+" "
        r = r + "name:" + str(self.get_name()) + " "
        r = r + "netclass:" + str(self.get_class()) + " "
        r = r + "]"
        return r
            
    def dump(self, indent="", increment="   "):
        """
        Recursive debug dump.
        
        :param indent:  Indentation string.  The output will be indented by this much.
        :param increment: This will be appendeded to :code:`indent` on recursive invocations.

        :rtype: :code:`None`
        """
        print(indent + str(self.__class__.__name__), end=' ')
        try:
            print(self.get_name())
        except:
            print()
            pass
        for c in self.get_children():
            c.dump(indent + "   ")

        
EagleFile.class_map["net"] = Net
         


class Contactref(EagleFilePart):
    """
    Class representing the contents of a <contactref> tag in Eagle files.

    Attributes:

    * :code:`element`

    * :code:`pad`

    * :code:`route`

    * :code:`routetag`


    """
    def __init__(self):
        """
        Construct an empty :class:`Contactref` object.
        """
        EagleFilePart.__init__(self)
        
        self.element=None
        self.pad=None
        self.route=None
        self.routetag=None


        
    @classmethod
    def _from_et(cls,root,parent):
        """
        Create a :class:`Contactref` from a :code:`contactref` element.
        
        :param root: The element tree tree to parse.
        :param parent: :class:`EagleFilePart` that should hold the resulting :class:`EagleFilePart`
        :rtype: :class:`Contactref`
        """
        ## Call the constructor
        n = cls()
        n._init_from_et(root,parent)
        return n

    def _get_error_name(self):
        if hasattr(self, "get_name"):
            return self.get_name();
        else:
            return "Contactref";
        
    def  _init_from_et(self, root, parent):
        """
        Initialized a :class:`Contactref` from a :code:`contactref` element.  This is useful if you have a subclass of :class:`Contactref` .
        
        :param root: The element tree tree to parse.
        :param parent: :class:`EagleFilePart` that will become the parent of :code:`this` .
        :rtype: :class:`Contactref`
        """
        try:
            self.root = root
            
            if root.tag != "contactref":
                raise EagleFormatError("Tried to create contactref from " + root.tag)

            self.element=parseByType(parent, "str", None, root.get("element"))
            self.pad=parseByType(parent, "str", None, root.get("pad"))
            self.route=parseByType(parent, "str", None, root.get("route"))
            self.routetag=parseByType(parent, "str", None, root.get("routetag"))

            self.parent = parent

            ### populate the maps by searching for elements that match xpath and generating objects for them.


            ### Do the same for the lists


            ### Do the same for the attr lists


            ### And the singletons


            ### And, finally, if the objects wants the text from the tag.

        except SwoopError as e:
            e.text = "{}:{}".format(self._get_error_name(), e.text)
            raise e


    def sortkey(self):
        r = ""
        r = r + str(self.element)
        r = r + str(self.pad)
        r = r + str(self.route)
        r = r + str(self.routetag)
        return r

    def get_et(self):
        """
        Generate a <contactref> element tree for a :class:`Contactref`.
        
        :rtype:  :class:`ElementTree`.
        
        """
        try:
            r = ET.Element("contactref")

            ### Set the tag attributes 


            ## Unparse the values.

            v = unparseByType(self, "str", None,  self.element)

            ## For required attributes None becomes "".  For optional attributes, we just leave the attribute out.
            if not (isinstance(self.get_parent(), LibraryFile) and False):  # special case for the name of library.
                if v is not None:
                    r.set("element", v)
                else:
                    r.set("element", "")


            ## Unparse the values.

            v = unparseByType(self, "str", None,  self.pad)

            ## For required attributes None becomes "".  For optional attributes, we just leave the attribute out.
            if not (isinstance(self.get_parent(), LibraryFile) and False):  # special case for the name of library.
                if v is not None:
                    r.set("pad", v)
                else:
                    r.set("pad", "")


            ## Unparse the values.

            v = unparseByType(self, "str", None,  self.route)

            ## For required attributes None becomes "".  For optional attributes, we just leave the attribute out.
            if not (isinstance(self.get_parent(), LibraryFile) and False):  # special case for the name of library.
                if v is not None:
                    r.set("route", v)


            ## Unparse the values.

            v = unparseByType(self, "str", None,  self.routetag)

            ## For required attributes None becomes "".  For optional attributes, we just leave the attribute out.
            if not (isinstance(self.get_parent(), LibraryFile) and False):  # special case for the name of library.
                if v is not None:
                    r.set("routetag", v)


            ### process the sections in order.  They have to be in section order,
            ### because eagle files are order dependent.


            ## set the text, if its needed.

        except SwoopError as e:
            e.text = "{}:{}".format(self._get_error_name(), e.text)
            raise e
        return r

    def clone(self):
        """
        Recursively clone this :code:`Contactref`.  It will be identical to the original, but it's parent will be :code:`None`.
        
        :rtype: :class:`Contactref`
        """
        try:
            n = copy.copy(self)
            n.parent = None
        except SwoopError as e:
            e.text = "{}:{}".format(self._get_error_name(), e.text)
            raise e
        return n

    def accept_preorder_visitor(self, visitor):
        try:
            pre = getattr(visitor, "Contactref_pre")
            return pre(self)
        except AttributeError:
            return visitor.default_pre(self)
        
    def accept_postorder_visitor(self, visitor, context):
        try:
            post = getattr(visitor, "Contactref_post")
            post(self,context)
        except AttributeError:
            visitor.default_post(self,context)

    def is_equal(self, other):
        """
        Check whether two :code:`EagleFilePart` objects are identical.
        
        :param other: Object to compare to.
        :returns: :code:`True` if they are identical, otherwise, :code:`False`
        """
        return self.get_xml() == other.get_xml()
        
    ### Getters/Setters for attribute values

    def get_element(self):
        """ Return the value of :code:`element` for this :class:`Contactref`.  This corresponds to the :code:`element` attribute of a :code:`<contactref>` in an Eagle file.
        
        :rtype: :code:`str`
        """
        return self.element

    def set_element(self,v):
        """ Set the value of :code:`element` for this  :class:`Contactref`.  This corresponds to the :code:`element` attribute of a :code:`<contactref>` in an Eagle file.

        :param v: new value
        :rtype: :code:`self`
        """
                        
        if not typeCheck("str", v, True):
            raise SwoopError("Illegal value ({}) of type {} for attribute 'element' of Contactref object (should be str).".format(v, type(v)))
        self.element = v
        
        return self

    def with_element(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`element`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`element` equals :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_element()` is :code:`True`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """

        if type(v) in [str, int, float, bool]:
            return self if self.element == v else None
        elif callable(v):
            return self if v(self.element) else None
        else:
            raise SwoopError("Illegal type passed to with_element")

    def without_element(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`element`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`element` is not equal to :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_element()` is :code:`False`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """
        
        if type(v) in [str, int, float, bool]:
            return self if self.element != v else None
        elif callable(v):
            return self if not v(self.element) else None
        else:
            raise SwoopError("Illegal type passed to without_element")


    def get_pad(self):
        """ Return the value of :code:`pad` for this :class:`Contactref`.  This corresponds to the :code:`pad` attribute of a :code:`<contactref>` in an Eagle file.
        
        :rtype: :code:`str`
        """
        return self.pad

    def set_pad(self,v):
        """ Set the value of :code:`pad` for this  :class:`Contactref`.  This corresponds to the :code:`pad` attribute of a :code:`<contactref>` in an Eagle file.

        :param v: new value
        :rtype: :code:`self`
        """
                        
        if not typeCheck("str", v, True):
            raise SwoopError("Illegal value ({}) of type {} for attribute 'pad' of Contactref object (should be str).".format(v, type(v)))
        self.pad = v
        
        return self

    def with_pad(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`pad`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`pad` equals :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_pad()` is :code:`True`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """

        if type(v) in [str, int, float, bool]:
            return self if self.pad == v else None
        elif callable(v):
            return self if v(self.pad) else None
        else:
            raise SwoopError("Illegal type passed to with_pad")

    def without_pad(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`pad`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`pad` is not equal to :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_pad()` is :code:`False`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """
        
        if type(v) in [str, int, float, bool]:
            return self if self.pad != v else None
        elif callable(v):
            return self if not v(self.pad) else None
        else:
            raise SwoopError("Illegal type passed to without_pad")


    def get_route(self):
        """ Return the value of :code:`route` for this :class:`Contactref`.  This corresponds to the :code:`route` attribute of a :code:`<contactref>` in an Eagle file.
        
        :rtype: :code:`str`
        """
        return self.route

    def set_route(self,v):
        """ Set the value of :code:`route` for this  :class:`Contactref`.  This corresponds to the :code:`route` attribute of a :code:`<contactref>` in an Eagle file.

        :param v: new value
        :rtype: :code:`self`
        """
                        
        if not typeCheck("str", v, False):
            raise SwoopError("Illegal value ({}) of type {} for attribute 'route' of Contactref object (should be str).".format(v, type(v)))
        self.route = v
        
        return self

    def with_route(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`route`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`route` equals :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_route()` is :code:`True`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """

        if type(v) in [str, int, float, bool]:
            return self if self.route == v else None
        elif callable(v):
            return self if v(self.route) else None
        else:
            raise SwoopError("Illegal type passed to with_route")

    def without_route(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`route`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`route` is not equal to :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_route()` is :code:`False`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """
        
        if type(v) in [str, int, float, bool]:
            return self if self.route != v else None
        elif callable(v):
            return self if not v(self.route) else None
        else:
            raise SwoopError("Illegal type passed to without_route")


    def get_routetag(self):
        """ Return the value of :code:`routetag` for this :class:`Contactref`.  This corresponds to the :code:`routetag` attribute of a :code:`<contactref>` in an Eagle file.
        
        :rtype: :code:`str`
        """
        return self.routetag

    def set_routetag(self,v):
        """ Set the value of :code:`routetag` for this  :class:`Contactref`.  This corresponds to the :code:`routetag` attribute of a :code:`<contactref>` in an Eagle file.

        :param v: new value
        :rtype: :code:`self`
        """
                        
        if not typeCheck("str", v, False):
            raise SwoopError("Illegal value ({}) of type {} for attribute 'routetag' of Contactref object (should be str).".format(v, type(v)))
        self.routetag = v
        
        return self

    def with_routetag(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`routetag`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`routetag` equals :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_routetag()` is :code:`True`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """

        if type(v) in [str, int, float, bool]:
            return self if self.routetag == v else None
        elif callable(v):
            return self if v(self.routetag) else None
        else:
            raise SwoopError("Illegal type passed to with_routetag")

    def without_routetag(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`routetag`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`routetag` is not equal to :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_routetag()` is :code:`False`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """
        
        if type(v) in [str, int, float, bool]:
            return self if self.routetag != v else None
        elif callable(v):
            return self if not v(self.routetag) else None
        else:
            raise SwoopError("Illegal type passed to without_routetag")



    ##### Lookup functions that return EFPs instead of just attribute values.
    
    def find_element(self):
        """Find the :class:`Element` object refered to by the :code:`element` attribute of this object.  This is like
        :meth:`get_element`, except it returns the :class:`Element` object instead of its name.
        
        :returns: The object
        :rtype: :class:`Element`

        """
        f = lambda efp, key: NotImplemented('Lookup of element from contactref not implemented.')
        return f(self, self.element)
    def find_pad(self):
        """Find the :class:`Pad` object refered to by the :code:`pad` attribute of this object.  This is like
        :meth:`get_pad`, except it returns the :class:`Pad` object instead of its name.
        
        :returns: The object
        :rtype: :class:`Pad`

        """
        f = lambda efp, key: NotImplemented('Lookup of pad from contactref not implemented.')
        return f(self, self.pad)
    


    
    ### Adder/getter/lookup for lists
    


    ### Add, lookup, and get for maps


    
    ### Getter/Setter for singletons.


    
    def get_children(self):
        """
        Get all the children of this :class:`EagleFilePart`.
        
        :rtype: List of :class:`EagleFilePart` objects
        """
        r = []




        return r

    def remove_child(self, efp):
        """
        Remove a child :class:`EagleFilePart` object.
        
        :param efp: the class:`EagleFilePart` object to remove.
        :return: Nothing
        """

    def _rekey_child(self, oldkey, efp):
        """
        Remove a child :class:`EagleFilePart` object.
        
        :param efp: the class:`EagleFilePart` object to remove.
        :return: Nothing
        """


    def __str__(self):
        r = "["+repr(self)+" "
        r = r + "element:" + str(self.get_element()) + " "
        r = r + "pad:" + str(self.get_pad()) + " "
        r = r + "route:" + str(self.get_route()) + " "
        r = r + "routetag:" + str(self.get_routetag()) + " "
        r = r + "]"
        return r
            
    def dump(self, indent="", increment="   "):
        """
        Recursive debug dump.
        
        :param indent:  Indentation string.  The output will be indented by this much.
        :param increment: This will be appendeded to :code:`indent` on recursive invocations.

        :rtype: :code:`None`
        """
        print(indent + str(self.__class__.__name__), end=' ')
        try:
            print(self.get_name())
        except:
            print()
            pass
        for c in self.get_children():
            c.dump(indent + "   ")

        
EagleFile.class_map["contactref"] = Contactref
         


class Package(EagleFilePart):
    """
    Class representing the contents of a <package> tag in Eagle files.

    Attributes:

    * :code:`name`

    * :code:`urn`

    * :code:`locally_modified`

    * :code:`library_version`

    * :code:`library_locally_modified`



    Collections:

    * :code:`description`: Singleton :class:`Description` object. 


    * :code:`drawing_element`: List of :class:`Polygon`, :class:`Wire`, :class:`Text`, :class:`Dimension`, :class:`Circle`, :class:`Rectangle`, :class:`Hole` and :class:`Frame` objects.


    * :code:`pad`: Map of :class:`Pad` objects indexed by their :code:`name`.


    * :code:`smd`: Map of :class:`Smd` objects indexed by their :code:`name`.



    """
    def __init__(self):
        """
        Construct an empty :class:`Package` object.
        """
        EagleFilePart.__init__(self)
        
        self.name=None
        self.urn=None
        self.locally_modified=None
        self.library_version=None
        self.library_locally_modified=None
        self.drawing_elements=[]
        self.pads={} #tecollections.OrderedDict()  For unclear reasons, this caused ordering to become more unpredictable, rather than less.
        self.smds={} #tecollections.OrderedDict()  For unclear reasons, this caused ordering to become more unpredictable, rather than less.
        self.description=None


        
    @classmethod
    def _from_et(cls,root,parent):
        """
        Create a :class:`Package` from a :code:`package` element.
        
        :param root: The element tree tree to parse.
        :param parent: :class:`EagleFilePart` that should hold the resulting :class:`EagleFilePart`
        :rtype: :class:`Package`
        """
        ## Call the constructor
        n = cls()
        n._init_from_et(root,parent)
        return n

    def _get_error_name(self):
        if hasattr(self, "get_name"):
            return self.get_name();
        else:
            return "Package";
        
    def  _init_from_et(self, root, parent):
        """
        Initialized a :class:`Package` from a :code:`package` element.  This is useful if you have a subclass of :class:`Package` .
        
        :param root: The element tree tree to parse.
        :param parent: :class:`EagleFilePart` that will become the parent of :code:`this` .
        :rtype: :class:`Package`
        """
        try:
            self.root = root
            
            if root.tag != "package":
                raise EagleFormatError("Tried to create package from " + root.tag)

            self.name=parseByType(parent, "str", None, root.get("name"))
            self.urn=parseByType(parent, "str", None, root.get("urn"))
            self.locally_modified=parseByType(parent, "bool", 'no', root.get("locally_modified"))
            self.library_version=parseByType(parent, "int", None, root.get("library_version"))
            self.library_locally_modified=parseByType(parent, "bool", 'no', root.get("library_locally_modified"))

            self.parent = parent

            ### populate the maps by searching for elements that match xpath and generating objects for them.

            for c in root.xpath("./pad"):
                self.add_pad(self.get_class_for_tag(c.tag)._from_et(c, self))
            for c in root.xpath("./smd"):
                self.add_smd(self.get_class_for_tag(c.tag)._from_et(c, self))

            ### Do the same for the lists

            for c in root.xpath("./polygon|./wire|./text|./dimension|./circle|./rectangle|./hole|./frame"):
                self.add_drawing_element(self.get_class_for_tag(c.tag)._from_et(c,self))

            ### Do the same for the attr lists


            ### And the singletons

            x = root.xpath("./description")
            if len(x) is not 0:
                self.set_description(self.get_class_for_tag(x[0].tag)._from_et(x[0],self))

            ### And, finally, if the objects wants the text from the tag.

        except SwoopError as e:
            e.text = "{}:{}".format(self._get_error_name(), e.text)
            raise e


    def sortkey(self):
        r = ""
        r = r + str(self.name)
        r = r + str(self.urn)
        r = r + str(self.locally_modified)
        r = r + str(self.library_version)
        r = r + str(self.library_locally_modified)
        return r

    def get_et(self):
        """
        Generate a <package> element tree for a :class:`Package`.
        
        :rtype:  :class:`ElementTree`.
        
        """
        try:
            r = ET.Element("package")

            ### Set the tag attributes 


            ## Unparse the values.

            v = unparseByType(self, "str", None,  self.name)

            ## For required attributes None becomes "".  For optional attributes, we just leave the attribute out.
            if not (isinstance(self.get_parent(), LibraryFile) and False):  # special case for the name of library.
                if v is not None:
                    r.set("name", v)
                else:
                    r.set("name", "")


            ## Unparse the values.

            v = unparseByType(self, "str", None,  self.urn)

            ## For required attributes None becomes "".  For optional attributes, we just leave the attribute out.
            if not (isinstance(self.get_parent(), LibraryFile) and False):  # special case for the name of library.
                if v is not None:
                    r.set("urn", v)


            ## Unparse the values.

            v = unparseByType(self, "bool", 'no',  self.locally_modified)

            ## For required attributes None becomes "".  For optional attributes, we just leave the attribute out.
            if not (isinstance(self.get_parent(), LibraryFile) and False):  # special case for the name of library.
                if v is not None:
                    r.set("locally_modified", v)


            ## Unparse the values.

            v = unparseByType(self, "int", None,  self.library_version)

            ## For required attributes None becomes "".  For optional attributes, we just leave the attribute out.
            if not (isinstance(self.get_parent(), LibraryFile) and False):  # special case for the name of library.
                if v is not None:
                    r.set("library_version", v)


            ## Unparse the values.

            v = unparseByType(self, "bool", 'no',  self.library_locally_modified)

            ## For required attributes None becomes "".  For optional attributes, we just leave the attribute out.
            if not (isinstance(self.get_parent(), LibraryFile) and False):  # special case for the name of library.
                if v is not None:
                    r.set("library_locally_modified", v)


            ### process the sections in order.  They have to be in section order,
            ### because eagle files are order dependent.


            ## For some tags, Eagle generates empty tags when there's no contant
            ## rather than just leaving the tag out.  We mark these with
            ## Tag.requireTag in GenerateSwoop.py and force their generation
            ## here.

            smartAddSubTags(r, "./description")


            ## or add a singleton.

            if self.description is not None:
                target = smartAddSubTags(r, "./description")
                target.append(self.description.get_et())

            ## For some tags, Eagle generates empty tags when there's no contant
            ## rather than just leaving the tag out.  We mark these with
            ## Tag.requireTag in GenerateSwoop.py and force their generation
            ## here.



            ## add a list.

            if len(self.drawing_elements) is not 0:
                target = smartAddSubTags(r, "./polygon|./wire|./text|./dimension|./circle|./rectangle|./hole|./frame")
                # add them in sorted order.  This gives us a simple canonicalization that makes it feasible to use diff to compare files.
                target.extend([i.get_et() for i in sorted(self.drawing_elements,key=lambda x: x.sortkey())])


            ## For some tags, Eagle generates empty tags when there's no contant
            ## rather than just leaving the tag out.  We mark these with
            ## Tag.requireTag in GenerateSwoop.py and force their generation
            ## here.



            ## add a map.

            if len(self.pads) is not 0:
                target = smartAddSubTags(r, "./pad")
                # add them in sorted order.  This gives us a simple canonicalization that makes it feasible to use diff to compare files.
                target.extend([i.get_et() for i in sorted(list(self.pads.values()),key=lambda x: x.sortkey())])


            ## For some tags, Eagle generates empty tags when there's no contant
            ## rather than just leaving the tag out.  We mark these with
            ## Tag.requireTag in GenerateSwoop.py and force their generation
            ## here.



            ## add a map.

            if len(self.smds) is not 0:
                target = smartAddSubTags(r, "./smd")
                # add them in sorted order.  This gives us a simple canonicalization that makes it feasible to use diff to compare files.
                target.extend([i.get_et() for i in sorted(list(self.smds.values()),key=lambda x: x.sortkey())])


            ## set the text, if its needed.

        except SwoopError as e:
            e.text = "{}:{}".format(self._get_error_name(), e.text)
            raise e
        return r

    def clone(self):
        """
        Recursively clone this :code:`Package`.  It will be identical to the original, but it's parent will be :code:`None`.
        
        :rtype: :class:`Package`
        """
        try:
            n = copy.copy(self)
            n.pads = {}
            for x in list(self.pads.values()):
                n.add_pad(x.clone())
            n.smds = {}
            for x in list(self.smds.values()):
                n.add_smd(x.clone())
            n.drawing_elements = []
            for x in self.drawing_elements:
                n.add_drawing_element(x.clone())
            n.description = None
            if self.description is not None:
                n.set_description(self.description.clone())
            else:
                n.set_description(None)
            n.parent = None
        except SwoopError as e:
            e.text = "{}:{}".format(self._get_error_name(), e.text)
            raise e
        return n

    def accept_preorder_visitor(self, visitor):
        try:
            pre = getattr(visitor, "Package_pre")
            return pre(self)
        except AttributeError:
            return visitor.default_pre(self)
        
    def accept_postorder_visitor(self, visitor, context):
        try:
            post = getattr(visitor, "Package_post")
            post(self,context)
        except AttributeError:
            visitor.default_post(self,context)

    def is_equal(self, other):
        """
        Check whether two :code:`EagleFilePart` objects are identical.
        
        :param other: Object to compare to.
        :returns: :code:`True` if they are identical, otherwise, :code:`False`
        """
        return self.get_xml() == other.get_xml()
        
    ### Getters/Setters for attribute values

    def get_name(self):
        """ Return the value of :code:`name` for this :class:`Package`.  This corresponds to the :code:`name` attribute of a :code:`<package>` in an Eagle file.
        
        :rtype: :code:`str`
        """
        return self.name

    def set_name(self,v):
        """ Set the value of :code:`name` for this  :class:`Package`.  This corresponds to the :code:`name` attribute of a :code:`<package>` in an Eagle file.

        :param v: new value
        :rtype: :code:`self`
        """
                        
        oldkey = self.name
        if not typeCheck("str", v, True):
            raise SwoopError("Illegal value ({}) of type {} for attribute 'name' of Package object (should be str).".format(v, type(v)))
        self.name = v
        
        if self.get_parent() is not None:
            self.get_parent()._rekey_child(oldkey, self);
        return self

    def with_name(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`name`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`name` equals :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_name()` is :code:`True`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """

        if type(v) in [str, int, float, bool]:
            return self if self.name == v else None
        elif callable(v):
            return self if v(self.name) else None
        else:
            raise SwoopError("Illegal type passed to with_name")

    def without_name(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`name`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`name` is not equal to :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_name()` is :code:`False`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """
        
        if type(v) in [str, int, float, bool]:
            return self if self.name != v else None
        elif callable(v):
            return self if not v(self.name) else None
        else:
            raise SwoopError("Illegal type passed to without_name")


    def get_urn(self):
        """ Return the value of :code:`urn` for this :class:`Package`.  This corresponds to the :code:`urn` attribute of a :code:`<package>` in an Eagle file.
        
        :rtype: :code:`str`
        """
        return self.urn

    def set_urn(self,v):
        """ Set the value of :code:`urn` for this  :class:`Package`.  This corresponds to the :code:`urn` attribute of a :code:`<package>` in an Eagle file.

        :param v: new value
        :rtype: :code:`self`
        """
                        
        if not typeCheck("str", v, False):
            raise SwoopError("Illegal value ({}) of type {} for attribute 'urn' of Package object (should be str).".format(v, type(v)))
        self.urn = v
        
        return self

    def with_urn(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`urn`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`urn` equals :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_urn()` is :code:`True`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """

        if type(v) in [str, int, float, bool]:
            return self if self.urn == v else None
        elif callable(v):
            return self if v(self.urn) else None
        else:
            raise SwoopError("Illegal type passed to with_urn")

    def without_urn(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`urn`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`urn` is not equal to :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_urn()` is :code:`False`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """
        
        if type(v) in [str, int, float, bool]:
            return self if self.urn != v else None
        elif callable(v):
            return self if not v(self.urn) else None
        else:
            raise SwoopError("Illegal type passed to without_urn")


    def get_locally_modified(self):
        """ Return the value of :code:`locally_modified` for this :class:`Package`.  This corresponds to the :code:`locally_modified` attribute of a :code:`<package>` in an Eagle file.
        
        :rtype: :code:`bool`
        """
        return self.locally_modified

    def set_locally_modified(self,v):
        """ Set the value of :code:`locally_modified` for this  :class:`Package`.  This corresponds to the :code:`locally_modified` attribute of a :code:`<package>` in an Eagle file.

        :param v: new value
        :rtype: :code:`self`
        """
                        
        if not typeCheck("bool", v, False):
            raise SwoopError("Illegal value ({}) of type {} for attribute 'locally_modified' of Package object (should be bool).".format(v, type(v)))
        self.locally_modified = v
        
        return self

    def with_locally_modified(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`locally_modified`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`locally_modified` equals :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_locally_modified()` is :code:`True`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """

        if type(v) in [str, int, float, bool]:
            return self if self.locally_modified == v else None
        elif callable(v):
            return self if v(self.locally_modified) else None
        else:
            raise SwoopError("Illegal type passed to with_locally_modified")

    def without_locally_modified(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`locally_modified`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`locally_modified` is not equal to :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_locally_modified()` is :code:`False`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """
        
        if type(v) in [str, int, float, bool]:
            return self if self.locally_modified != v else None
        elif callable(v):
            return self if not v(self.locally_modified) else None
        else:
            raise SwoopError("Illegal type passed to without_locally_modified")


    def get_library_version(self):
        """ Return the value of :code:`library_version` for this :class:`Package`.  This corresponds to the :code:`library_version` attribute of a :code:`<package>` in an Eagle file.
        
        :rtype: :code:`int`
        """
        return self.library_version

    def set_library_version(self,v):
        """ Set the value of :code:`library_version` for this  :class:`Package`.  This corresponds to the :code:`library_version` attribute of a :code:`<package>` in an Eagle file.

        :param v: new value
        :rtype: :code:`self`
        """
                        
        if not typeCheck("int", v, False):
            raise SwoopError("Illegal value ({}) of type {} for attribute 'library_version' of Package object (should be int).".format(v, type(v)))
        self.library_version = v
        
        return self

    def with_library_version(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`library_version`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`library_version` equals :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_library_version()` is :code:`True`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """

        if type(v) in [str, int, float, bool]:
            return self if self.library_version == v else None
        elif callable(v):
            return self if v(self.library_version) else None
        else:
            raise SwoopError("Illegal type passed to with_library_version")

    def without_library_version(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`library_version`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`library_version` is not equal to :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_library_version()` is :code:`False`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """
        
        if type(v) in [str, int, float, bool]:
            return self if self.library_version != v else None
        elif callable(v):
            return self if not v(self.library_version) else None
        else:
            raise SwoopError("Illegal type passed to without_library_version")


    def get_library_locally_modified(self):
        """ Return the value of :code:`library_locally_modified` for this :class:`Package`.  This corresponds to the :code:`library_locally_modified` attribute of a :code:`<package>` in an Eagle file.
        
        :rtype: :code:`bool`
        """
        return self.library_locally_modified

    def set_library_locally_modified(self,v):
        """ Set the value of :code:`library_locally_modified` for this  :class:`Package`.  This corresponds to the :code:`library_locally_modified` attribute of a :code:`<package>` in an Eagle file.

        :param v: new value
        :rtype: :code:`self`
        """
                        
        if not typeCheck("bool", v, False):
            raise SwoopError("Illegal value ({}) of type {} for attribute 'library_locally_modified' of Package object (should be bool).".format(v, type(v)))
        self.library_locally_modified = v
        
        return self

    def with_library_locally_modified(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`library_locally_modified`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`library_locally_modified` equals :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_library_locally_modified()` is :code:`True`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """

        if type(v) in [str, int, float, bool]:
            return self if self.library_locally_modified == v else None
        elif callable(v):
            return self if v(self.library_locally_modified) else None
        else:
            raise SwoopError("Illegal type passed to with_library_locally_modified")

    def without_library_locally_modified(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`library_locally_modified`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`library_locally_modified` is not equal to :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_library_locally_modified()` is :code:`False`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """
        
        if type(v) in [str, int, float, bool]:
            return self if self.library_locally_modified != v else None
        elif callable(v):
            return self if not v(self.library_locally_modified) else None
        else:
            raise SwoopError("Illegal type passed to without_library_locally_modified")



    ##### Lookup functions that return EFPs instead of just attribute values.
    
    


    
    ### Adder/getter/lookup for lists
    
    def add_drawing_element(self, s):
        """ Add a :class:`Polygon`, :class:`Wire`, :class:`Text`, :class:`Dimension`, :class:`Circle`, :class:`Rectangle`, :class:`Hole` or :class:`Frame` to the :code:`drawing_elements` of this :class:`Package`.

        :param s: The :class:`Polygon`, :class:`Wire`, :class:`Text`, :class:`Dimension`, :class:`Circle`, :class:`Rectangle`, :class:`Hole` or :class:`Frame` to add.
        :rtype: :code:`self`
        """
        if not any([
                isinstance(s, Polygon),
                isinstance(s, Wire),
                isinstance(s, Text),
                isinstance(s, Dimension),
                isinstance(s, Circle),
                isinstance(s, Rectangle),
                isinstance(s, Hole),
                isinstance(s, Frame),
            ]):
            raise SwoopError("Argument to Package.add_drawing_element() should be of type Polygon, Wire, Text, Dimension, Circle, Rectangle, Hole or Frame.  Got " + str(type(s).__name__) + ".")
        
        self.drawing_elements.append(s)
        if s.parent is not None and s.parent is not self:
            s.parent.remove_drawing_element(s)

        s.parent = self
        return self

    def get_nth_drawing_element(self, n):
        """ get then nth :class:`Polygon`, :class:`Wire`, :class:`Text`, :class:`Dimension`, :class:`Circle`, :class:`Rectangle`, :class:`Hole` or :class:`Frame` object from the :code:`drawing_elements` of this :class:`Package`.
        
        :param n: Index of the item to return.

        :rtype: :class:`Polygon`, :class:`Wire`, :class:`Text`, :class:`Dimension`, :class:`Circle`, :class:`Rectangle`, :class:`Hole` or :class:`Frame` object
        """
        return self.drawing_elements[n]

    def get_drawing_elements(self, attrs=None, type=None):
        """Return (and possibly filter) items in the the :code:`drawing_elements` list of :class:`Polygon`, :class:`Wire`, :class:`Text`, :class:`Dimension`, :class:`Circle`, :class:`Rectangle`, :class:`Hole` or :class:`Frame` objects for this :class:`Package`.
        
        This functions provides a mechanism for filtering the items as well.
        The keys in :code:`attrs` are taken as attributes names and the
        values are requested values.  Items in the list that have all the
        requested values for the corresponding attributes will be returned.  

        A if :code:`type` is not :code:`None`, the item will match if it is an
        instance of the type provided.
        
        :param attrs: A set of key-value pairs that represent a filter to apply to the item's attributes.
        :param type:  A type to filter on.  Only items that are an instance of this type will be returned.
        :returns: A List of :class:`Polygon`, :class:`Wire`, :class:`Text`, :class:`Dimension`, :class:`Circle`, :class:`Rectangle`, :class:`Hole` and :class:`Frame` objects
        :rtype: List of :class:`Polygon`, :class:`Wire`, :class:`Text`, :class:`Dimension`, :class:`Circle`, :class:`Rectangle`, :class:`Hole` and :class:`Frame` objects
        """
        if attrs is not None or type is not None:
            raise NotImplementedError("filtered get not implemented.")
        return self.drawing_elements

    def clear_drawing_elements(self):
        """
        Remove all the :class:`Polygon`, :class:`Wire`, :class:`Text`, :class:`Dimension`, :class:`Circle`, :class:`Rectangle`, :class:`Hole` and :class:`Frame` objects from the :code:`drawing_elements` of this :class:`Package`.
        
        :rtype: :code:`self`
        """
        for efp in self.drawing_elements:
            efp.parent = None
        self.drawing_elements = []
        return self

    def remove_drawing_element(self, efp):
        """
        Remove a :class:`Polygon`, :class:`Wire`, :class:`Text`, :class:`Dimension`, :class:`Circle`, :class:`Rectangle`, :class:`Hole` or :class:`Frame` from the :code:`drawing_elements` of this :class:`Package`.
        
        :param efp: The :class:`Polygon`, :class:`Wire`, :class:`Text`, :class:`Dimension`, :class:`Circle`, :class:`Rectangle`, :class:`Hole` or :class:`Frame` object to remove.

        :rtype: :code:`self`
        """
        self.drawing_elements = [x for x in self.drawing_elements if x != efp]

        if efp.parent is self:
            efp.parent = None
        return self



    ### Add, lookup, and get for maps
    def add_pad(self, s):
        """ Add a :class:`Pad` to the :code:`pads` of this :class:`Package`.

        :param s: The :class:`Pad` to add.
        :rtype: :code:`self`
        """
        if not any([
                isinstance(s, Pad),
            ]):
            raise SwoopError("Argument to Package.add_pad() should be of type Pad.  Got " + str(type(s).__name__) + ".")
        

        self.pads[s.get_name()] = s

        s.parent = self
        return self

    def get_nth_pad(self, n):
        """ get then nth :class:`Pad` object from the :code:`pads` of this :class:`Package`.
        
        :param n: Index of the item to return.

        :rtype: :class:`Pad` object
        """
        return list(self.pads.values())[n]

    def get_pad(self, key):
        """ Lookup and return a :class:`Pad` from the :code:`pads` of  this :class:`Package`.
        
        :param key: A :code:`str` to use for the lookup.  The lookup uses the :code:`name` of the :class:`Pad` objects.

        :rtype: A :class:`Pad` object or :code:`None`, if there is no such item.
        """
        return self.pads.get(key)


    def get_pads(self, attrs=None, type=None):
        """Return (and possibly filter) items in the the :code:`pads` map of :class:`Pad` objects for this :class:`Package`.
        
        This functions provides a mechanism for filtering the items as well.
        The keys in :code:`attrs` are taken as attributes names and the
        values are requested values.  Items in the list that have all the
        requested values for the corresponding attributes will be returned.  

        A if :code:`type` is not :code:`None`, the item will match if it is an
        instance of the type provided.
        
        :param attrs: A set of key-value pairs that represent a filter to apply to the item's attributes.
        :param type:  A type to filter on.  Only items that are an instance of this type will be returned.
        :returns: A List of :class:`Pad` objects
        :rtype: List of :class:`Pad` objects
        """
        if attrs is not None or type is not None:
            raise NotImplementedError("filtered get not implemented")
        return list(self.pads.values())
        

    def clear_pads(self):
        """
        Remove all the :class:`Pad` objects from the :code:`pads` of this :class:`Package`.
        
        :rtype: :code:`self`
        """
        for efp in list(self.pads.values()):
            efp.parent = None
        self.pads = {}
        return self

    def remove_pad(self, efp):
        """
        Remove a :class:`Pad` from the :code:`pads` of this :class:`Package`.
        
        :param efp: The :class:`Pad` object to remove.

        :rtype: :code:`self`
        """
        if self.pads[efp.get_name()] == efp:
            del self.pads[efp.get_name()]
            efp.parent = None
            return self
        else:
            raise SwoopError("Tried to use remove_pad() to delete the wrong kind of child?: {}".format(str(efp)))
    
    def add_smd(self, s):
        """ Add a :class:`Smd` to the :code:`smds` of this :class:`Package`.

        :param s: The :class:`Smd` to add.
        :rtype: :code:`self`
        """
        if not any([
                isinstance(s, Smd),
            ]):
            raise SwoopError("Argument to Package.add_smd() should be of type Smd.  Got " + str(type(s).__name__) + ".")
        

        self.smds[s.get_name()] = s

        s.parent = self
        return self

    def get_nth_smd(self, n):
        """ get then nth :class:`Smd` object from the :code:`smds` of this :class:`Package`.
        
        :param n: Index of the item to return.

        :rtype: :class:`Smd` object
        """
        return list(self.smds.values())[n]

    def get_smd(self, key):
        """ Lookup and return a :class:`Smd` from the :code:`smds` of  this :class:`Package`.
        
        :param key: A :code:`str` to use for the lookup.  The lookup uses the :code:`name` of the :class:`Smd` objects.

        :rtype: A :class:`Smd` object or :code:`None`, if there is no such item.
        """
        return self.smds.get(key)


    def get_smds(self, attrs=None, type=None):
        """Return (and possibly filter) items in the the :code:`smds` map of :class:`Smd` objects for this :class:`Package`.
        
        This functions provides a mechanism for filtering the items as well.
        The keys in :code:`attrs` are taken as attributes names and the
        values are requested values.  Items in the list that have all the
        requested values for the corresponding attributes will be returned.  

        A if :code:`type` is not :code:`None`, the item will match if it is an
        instance of the type provided.
        
        :param attrs: A set of key-value pairs that represent a filter to apply to the item's attributes.
        :param type:  A type to filter on.  Only items that are an instance of this type will be returned.
        :returns: A List of :class:`Smd` objects
        :rtype: List of :class:`Smd` objects
        """
        if attrs is not None or type is not None:
            raise NotImplementedError("filtered get not implemented")
        return list(self.smds.values())
        

    def clear_smds(self):
        """
        Remove all the :class:`Smd` objects from the :code:`smds` of this :class:`Package`.
        
        :rtype: :code:`self`
        """
        for efp in list(self.smds.values()):
            efp.parent = None
        self.smds = {}
        return self

    def remove_smd(self, efp):
        """
        Remove a :class:`Smd` from the :code:`smds` of this :class:`Package`.
        
        :param efp: The :class:`Smd` object to remove.

        :rtype: :code:`self`
        """
        if self.smds[efp.get_name()] == efp:
            del self.smds[efp.get_name()]
            efp.parent = None
            return self
        else:
            raise SwoopError("Tried to use remove_smd() to delete the wrong kind of child?: {}".format(str(efp)))
    


    
    ### Getter/Setter for singletons.

    def set_description(self, s):
        """ Set the :class:`Description` for this  :class:`Package`.

        :param s: :class:`Description` to set.
        :rtype: :code:`self`
        """
        if self.description is not None:
            self.description.parent = None
        self.description = s
        if s is not None:
            s.parent = self
        return self

    def get_description(self):
        """ Get the description from this :class:`Package`.
        
        :rtype: :class:`Description` object
        """
        return self.description


    
    def get_children(self):
        """
        Get all the children of this :class:`EagleFilePart`.
        
        :rtype: List of :class:`EagleFilePart` objects
        """
        r = []

        r = r + self.drawing_elements

        r = r + list(self.pads.values())
        r = r + list(self.smds.values())

        if self.description is not None:
            r = r + [self.description]

        return r

    def remove_child(self, efp):
        """
        Remove a child :class:`EagleFilePart` object.
        
        :param efp: the class:`EagleFilePart` object to remove.
        :return: Nothing
        """
        try:
            self.remove_pad(efp)
        except:
            pass
        try:
            self.remove_smd(efp)
        except:
            pass
        try:
            self.remove_drawing_element(efp)
        except:
            pass
        if self.get_description() == efp:
            self.set_description(None)

    def _rekey_child(self, oldkey, efp):
        """
        Remove a child :class:`EagleFilePart` object.
        
        :param efp: the class:`EagleFilePart` object to remove.
        :return: Nothing
        """
        try:
            if self.get_pad(oldkey) == efp:
                del self.pads[oldkey]
                self.add_pad(efp)
        except SwoopError:
            pass
        try:
            if self.get_smd(oldkey) == efp:
                del self.smds[oldkey]
                self.add_smd(efp)
        except SwoopError:
            pass

    def check_sanity(self, visited_efps = None):
        EagleFilePart.check_sanity(self, visited_efps)

        # Check whether keys in our maps match the keys in our children
        for k in self.pads:
            if self.pads[k].get_name() != k:
                raise SwoopError("Child's name ('{}') doesn't match key in parent's map ('{}')".format(self.pads[k].get_name(),k))
        for k in self.smds:
            if self.smds[k].get_name() != k:
                raise SwoopError("Child's name ('{}') doesn't match key in parent's map ('{}')".format(self.smds[k].get_name(),k))

    def __str__(self):
        r = "["+repr(self)+" "
        r = r + "name:" + str(self.get_name()) + " "
        r = r + "urn:" + str(self.get_urn()) + " "
        r = r + "locally_modified:" + str(self.get_locally_modified()) + " "
        r = r + "library_version:" + str(self.get_library_version()) + " "
        r = r + "library_locally_modified:" + str(self.get_library_locally_modified()) + " "
        r = r + "]"
        return r
            
    def dump(self, indent="", increment="   "):
        """
        Recursive debug dump.
        
        :param indent:  Indentation string.  The output will be indented by this much.
        :param increment: This will be appendeded to :code:`indent` on recursive invocations.

        :rtype: :code:`None`
        """
        print(indent + str(self.__class__.__name__), end=' ')
        try:
            print(self.get_name())
        except:
            print()
            pass
        for c in self.get_children():
            c.dump(indent + "   ")

        
EagleFile.class_map["package"] = Package
         


class Designrules(EagleFilePart):
    """
    Class representing the contents of a <designrules> tag in Eagle files.

    Attributes:

    * :code:`name`



    Collections:


    * :code:`description`: List of :class:`Description` objects.


    * :code:`param`: Map of :class:`Param` objects indexed by their :code:`name`.



    """
    def __init__(self):
        """
        Construct an empty :class:`Designrules` object.
        """
        EagleFilePart.__init__(self)
        
        self.name=None
        self.description=[]
        self.params={} #tecollections.OrderedDict()  For unclear reasons, this caused ordering to become more unpredictable, rather than less.


        
    @classmethod
    def _from_et(cls,root,parent):
        """
        Create a :class:`Designrules` from a :code:`designrules` element.
        
        :param root: The element tree tree to parse.
        :param parent: :class:`EagleFilePart` that should hold the resulting :class:`EagleFilePart`
        :rtype: :class:`Designrules`
        """
        ## Call the constructor
        n = cls()
        n._init_from_et(root,parent)
        return n

    def _get_error_name(self):
        if hasattr(self, "get_name"):
            return self.get_name();
        else:
            return "Designrules";
        
    def  _init_from_et(self, root, parent):
        """
        Initialized a :class:`Designrules` from a :code:`designrules` element.  This is useful if you have a subclass of :class:`Designrules` .
        
        :param root: The element tree tree to parse.
        :param parent: :class:`EagleFilePart` that will become the parent of :code:`this` .
        :rtype: :class:`Designrules`
        """
        try:
            self.root = root
            
            if root.tag != "designrules":
                raise EagleFormatError("Tried to create designrules from " + root.tag)

            self.name=parseByType(parent, "str", None, root.get("name"))

            self.parent = parent

            ### populate the maps by searching for elements that match xpath and generating objects for them.

            for c in root.xpath("./param"):
                self.add_param(self.get_class_for_tag(c.tag)._from_et(c, self))

            ### Do the same for the lists

            for c in root.xpath("./description"):
                self.add_description(self.get_class_for_tag(c.tag)._from_et(c,self))

            ### Do the same for the attr lists


            ### And the singletons


            ### And, finally, if the objects wants the text from the tag.

        except SwoopError as e:
            e.text = "{}:{}".format(self._get_error_name(), e.text)
            raise e


    def sortkey(self):
        r = ""
        r = r + str(self.name)
        return r

    def get_et(self):
        """
        Generate a <designrules> element tree for a :class:`Designrules`.
        
        :rtype:  :class:`ElementTree`.
        
        """
        try:
            r = ET.Element("designrules")

            ### Set the tag attributes 


            ## Unparse the values.

            v = unparseByType(self, "str", None,  self.name)

            ## For required attributes None becomes "".  For optional attributes, we just leave the attribute out.
            if not (isinstance(self.get_parent(), LibraryFile) and False):  # special case for the name of library.
                if v is not None:
                    r.set("name", v)
                else:
                    r.set("name", "")


            ### process the sections in order.  They have to be in section order,
            ### because eagle files are order dependent.


            ## For some tags, Eagle generates empty tags when there's no contant
            ## rather than just leaving the tag out.  We mark these with
            ## Tag.requireTag in GenerateSwoop.py and force their generation
            ## here.

            smartAddSubTags(r, "./description")


            ## add a list.

            if len(self.description) is not 0:
                target = smartAddSubTags(r, "./description")
                # add them in sorted order.  This gives us a simple canonicalization that makes it feasible to use diff to compare files.
                target.extend([i.get_et() for i in sorted(self.description,key=lambda x: x.sortkey())])


            ## For some tags, Eagle generates empty tags when there's no contant
            ## rather than just leaving the tag out.  We mark these with
            ## Tag.requireTag in GenerateSwoop.py and force their generation
            ## here.



            ## add a map.

            if len(self.params) is not 0:
                target = smartAddSubTags(r, "./param")
                # add them in sorted order.  This gives us a simple canonicalization that makes it feasible to use diff to compare files.
                target.extend([i.get_et() for i in sorted(list(self.params.values()),key=lambda x: x.sortkey())])


            ## set the text, if its needed.

        except SwoopError as e:
            e.text = "{}:{}".format(self._get_error_name(), e.text)
            raise e
        return r

    def clone(self):
        """
        Recursively clone this :code:`Designrules`.  It will be identical to the original, but it's parent will be :code:`None`.
        
        :rtype: :class:`Designrules`
        """
        try:
            n = copy.copy(self)
            n.params = {}
            for x in list(self.params.values()):
                n.add_param(x.clone())
            n.description = []
            for x in self.description:
                n.add_description(x.clone())
            n.parent = None
        except SwoopError as e:
            e.text = "{}:{}".format(self._get_error_name(), e.text)
            raise e
        return n

    def accept_preorder_visitor(self, visitor):
        try:
            pre = getattr(visitor, "Designrules_pre")
            return pre(self)
        except AttributeError:
            return visitor.default_pre(self)
        
    def accept_postorder_visitor(self, visitor, context):
        try:
            post = getattr(visitor, "Designrules_post")
            post(self,context)
        except AttributeError:
            visitor.default_post(self,context)

    def is_equal(self, other):
        """
        Check whether two :code:`EagleFilePart` objects are identical.
        
        :param other: Object to compare to.
        :returns: :code:`True` if they are identical, otherwise, :code:`False`
        """
        return self.get_xml() == other.get_xml()
        
    ### Getters/Setters for attribute values

    def get_name(self):
        """ Return the value of :code:`name` for this :class:`Designrules`.  This corresponds to the :code:`name` attribute of a :code:`<designrules>` in an Eagle file.
        
        :rtype: :code:`str`
        """
        return self.name

    def set_name(self,v):
        """ Set the value of :code:`name` for this  :class:`Designrules`.  This corresponds to the :code:`name` attribute of a :code:`<designrules>` in an Eagle file.

        :param v: new value
        :rtype: :code:`self`
        """
                        
        oldkey = self.name
        if not typeCheck("str", v, True):
            raise SwoopError("Illegal value ({}) of type {} for attribute 'name' of Designrules object (should be str).".format(v, type(v)))
        self.name = v
        
        if self.get_parent() is not None:
            self.get_parent()._rekey_child(oldkey, self);
        return self

    def with_name(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`name`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`name` equals :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_name()` is :code:`True`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """

        if type(v) in [str, int, float, bool]:
            return self if self.name == v else None
        elif callable(v):
            return self if v(self.name) else None
        else:
            raise SwoopError("Illegal type passed to with_name")

    def without_name(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`name`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`name` is not equal to :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_name()` is :code:`False`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """
        
        if type(v) in [str, int, float, bool]:
            return self if self.name != v else None
        elif callable(v):
            return self if not v(self.name) else None
        else:
            raise SwoopError("Illegal type passed to without_name")



    ##### Lookup functions that return EFPs instead of just attribute values.
    
    


    
    ### Adder/getter/lookup for lists
    
    def add_description(self, s):
        """ Add a :class:`Description` to the :code:`description` of this :class:`Designrules`.

        :param s: The :class:`Description` to add.
        :rtype: :code:`self`
        """
        if not any([
                isinstance(s, Description),
            ]):
            raise SwoopError("Argument to Designrules.add_description() should be of type Description.  Got " + str(type(s).__name__) + ".")
        
        self.description.append(s)
        if s.parent is not None and s.parent is not self:
            s.parent.remove_description(s)

        s.parent = self
        return self

    def get_nth_description(self, n):
        """ get then nth :class:`Description` object from the :code:`description` of this :class:`Designrules`.
        
        :param n: Index of the item to return.

        :rtype: :class:`Description` object
        """
        return self.description[n]

    def get_description(self, attrs=None, type=None):
        """Return (and possibly filter) items in the the :code:`description` list of :class:`Description` objects for this :class:`Designrules`.
        
        This functions provides a mechanism for filtering the items as well.
        The keys in :code:`attrs` are taken as attributes names and the
        values are requested values.  Items in the list that have all the
        requested values for the corresponding attributes will be returned.  

        A if :code:`type` is not :code:`None`, the item will match if it is an
        instance of the type provided.
        
        :param attrs: A set of key-value pairs that represent a filter to apply to the item's attributes.
        :param type:  A type to filter on.  Only items that are an instance of this type will be returned.
        :returns: A List of :class:`Description` objects
        :rtype: List of :class:`Description` objects
        """
        if attrs is not None or type is not None:
            raise NotImplementedError("filtered get not implemented.")
        return self.description

    def clear_description(self):
        """
        Remove all the :class:`Description` objects from the :code:`description` of this :class:`Designrules`.
        
        :rtype: :code:`self`
        """
        for efp in self.description:
            efp.parent = None
        self.description = []
        return self

    def remove_description(self, efp):
        """
        Remove a :class:`Description` from the :code:`description` of this :class:`Designrules`.
        
        :param efp: The :class:`Description` object to remove.

        :rtype: :code:`self`
        """
        self.description = [x for x in self.description if x != efp]

        if efp.parent is self:
            efp.parent = None
        return self



    ### Add, lookup, and get for maps
    def add_param(self, s):
        """ Add a :class:`Param` to the :code:`params` of this :class:`Designrules`.

        :param s: The :class:`Param` to add.
        :rtype: :code:`self`
        """
        if not any([
                isinstance(s, Param),
            ]):
            raise SwoopError("Argument to Designrules.add_param() should be of type Param.  Got " + str(type(s).__name__) + ".")
        

        self.params[s.get_name()] = s

        s.parent = self
        return self

    def get_nth_param(self, n):
        """ get then nth :class:`Param` object from the :code:`params` of this :class:`Designrules`.
        
        :param n: Index of the item to return.

        :rtype: :class:`Param` object
        """
        return list(self.params.values())[n]

    def get_param(self, key):
        """ Lookup and return a :class:`Param` from the :code:`params` of  this :class:`Designrules`.
        
        :param key: A :code:`str` to use for the lookup.  The lookup uses the :code:`name` of the :class:`Param` objects.

        :rtype: A :class:`Param` object or :code:`None`, if there is no such item.
        """
        return self.params.get(key)


    def get_params(self, attrs=None, type=None):
        """Return (and possibly filter) items in the the :code:`params` map of :class:`Param` objects for this :class:`Designrules`.
        
        This functions provides a mechanism for filtering the items as well.
        The keys in :code:`attrs` are taken as attributes names and the
        values are requested values.  Items in the list that have all the
        requested values for the corresponding attributes will be returned.  

        A if :code:`type` is not :code:`None`, the item will match if it is an
        instance of the type provided.
        
        :param attrs: A set of key-value pairs that represent a filter to apply to the item's attributes.
        :param type:  A type to filter on.  Only items that are an instance of this type will be returned.
        :returns: A List of :class:`Param` objects
        :rtype: List of :class:`Param` objects
        """
        if attrs is not None or type is not None:
            raise NotImplementedError("filtered get not implemented")
        return list(self.params.values())
        

    def clear_params(self):
        """
        Remove all the :class:`Param` objects from the :code:`params` of this :class:`Designrules`.
        
        :rtype: :code:`self`
        """
        for efp in list(self.params.values()):
            efp.parent = None
        self.params = {}
        return self

    def remove_param(self, efp):
        """
        Remove a :class:`Param` from the :code:`params` of this :class:`Designrules`.
        
        :param efp: The :class:`Param` object to remove.

        :rtype: :code:`self`
        """
        if self.params[efp.get_name()] == efp:
            del self.params[efp.get_name()]
            efp.parent = None
            return self
        else:
            raise SwoopError("Tried to use remove_param() to delete the wrong kind of child?: {}".format(str(efp)))
    


    
    ### Getter/Setter for singletons.


    
    def get_children(self):
        """
        Get all the children of this :class:`EagleFilePart`.
        
        :rtype: List of :class:`EagleFilePart` objects
        """
        r = []

        r = r + self.description

        r = r + list(self.params.values())


        return r

    def remove_child(self, efp):
        """
        Remove a child :class:`EagleFilePart` object.
        
        :param efp: the class:`EagleFilePart` object to remove.
        :return: Nothing
        """
        try:
            self.remove_param(efp)
        except:
            pass
        try:
            self.remove_description(efp)
        except:
            pass

    def _rekey_child(self, oldkey, efp):
        """
        Remove a child :class:`EagleFilePart` object.
        
        :param efp: the class:`EagleFilePart` object to remove.
        :return: Nothing
        """
        try:
            if self.get_param(oldkey) == efp:
                del self.params[oldkey]
                self.add_param(efp)
        except SwoopError:
            pass

    def check_sanity(self, visited_efps = None):
        EagleFilePart.check_sanity(self, visited_efps)

        # Check whether keys in our maps match the keys in our children
        for k in self.params:
            if self.params[k].get_name() != k:
                raise SwoopError("Child's name ('{}') doesn't match key in parent's map ('{}')".format(self.params[k].get_name(),k))

    def __str__(self):
        r = "["+repr(self)+" "
        r = r + "name:" + str(self.get_name()) + " "
        r = r + "]"
        return r
            
    def dump(self, indent="", increment="   "):
        """
        Recursive debug dump.
        
        :param indent:  Indentation string.  The output will be indented by this much.
        :param increment: This will be appendeded to :code:`indent` on recursive invocations.

        :rtype: :code:`None`
        """
        print(indent + str(self.__class__.__name__), end=' ')
        try:
            print(self.get_name())
        except:
            print()
            pass
        for c in self.get_children():
            c.dump(indent + "   ")

        
EagleFile.class_map["designrules"] = Designrules
         


class Signal(EagleFilePart):
    """
    Class representing the contents of a <signal> tag in Eagle files.

    Attributes:

    * :code:`name`

    * :code:`class`

    * :code:`airwireshidden`



    Collections:


    * :code:`contactref`: List of :class:`Contactref` objects.

    * :code:`polygon`: List of :class:`Polygon` objects.

    * :code:`wire`: List of :class:`Wire` objects.

    * :code:`via`: List of :class:`Via` objects.



    """
    def __init__(self):
        """
        Construct an empty :class:`Signal` object.
        """
        EagleFilePart.__init__(self)
        
        self.name=None
        self.netclass=None
        self.airwireshidden=None
        self.contactrefs=[]
        self.polygons=[]
        self.wires=[]
        self.vias=[]


        
    @classmethod
    def _from_et(cls,root,parent):
        """
        Create a :class:`Signal` from a :code:`signal` element.
        
        :param root: The element tree tree to parse.
        :param parent: :class:`EagleFilePart` that should hold the resulting :class:`EagleFilePart`
        :rtype: :class:`Signal`
        """
        ## Call the constructor
        n = cls()
        n._init_from_et(root,parent)
        return n

    def _get_error_name(self):
        if hasattr(self, "get_name"):
            return self.get_name();
        else:
            return "Signal";
        
    def  _init_from_et(self, root, parent):
        """
        Initialized a :class:`Signal` from a :code:`signal` element.  This is useful if you have a subclass of :class:`Signal` .
        
        :param root: The element tree tree to parse.
        :param parent: :class:`EagleFilePart` that will become the parent of :code:`this` .
        :rtype: :class:`Signal`
        """
        try:
            self.root = root
            
            if root.tag != "signal":
                raise EagleFormatError("Tried to create signal from " + root.tag)

            self.name=parseByType(parent, "str", None, root.get("name"))
            self.netclass=parseByType(parent, "str", None, root.get("class"))
            self.airwireshidden=parseByType(parent, "bool", None, root.get("airwireshidden"))

            self.parent = parent

            ### populate the maps by searching for elements that match xpath and generating objects for them.


            ### Do the same for the lists

            for c in root.xpath("./contactref"):
                self.add_contactref(self.get_class_for_tag(c.tag)._from_et(c,self))
            for c in root.xpath("./polygon"):
                self.add_polygon(self.get_class_for_tag(c.tag)._from_et(c,self))
            for c in root.xpath("./wire"):
                self.add_wire(self.get_class_for_tag(c.tag)._from_et(c,self))
            for c in root.xpath("./via"):
                self.add_via(self.get_class_for_tag(c.tag)._from_et(c,self))

            ### Do the same for the attr lists


            ### And the singletons


            ### And, finally, if the objects wants the text from the tag.

        except SwoopError as e:
            e.text = "{}:{}".format(self._get_error_name(), e.text)
            raise e


    def sortkey(self):
        r = ""
        r = r + str(self.name)
        r = r + str(self.netclass)
        r = r + str(self.airwireshidden)
        return r

    def get_et(self):
        """
        Generate a <signal> element tree for a :class:`Signal`.
        
        :rtype:  :class:`ElementTree`.
        
        """
        try:
            r = ET.Element("signal")

            ### Set the tag attributes 


            ## Unparse the values.

            v = unparseByType(self, "str", None,  self.name)

            ## For required attributes None becomes "".  For optional attributes, we just leave the attribute out.
            if not (isinstance(self.get_parent(), LibraryFile) and False):  # special case for the name of library.
                if v is not None:
                    r.set("name", v)
                else:
                    r.set("name", "")


            ## Unparse the values.

            v = unparseByType(self, "str", None,  self.netclass)

            ## For required attributes None becomes "".  For optional attributes, we just leave the attribute out.
            if not (isinstance(self.get_parent(), LibraryFile) and False):  # special case for the name of library.
                if v is not None:
                    r.set("class", v)


            ## Unparse the values.

            v = unparseByType(self, "bool", None,  self.airwireshidden)

            ## For required attributes None becomes "".  For optional attributes, we just leave the attribute out.
            if not (isinstance(self.get_parent(), LibraryFile) and False):  # special case for the name of library.
                if v is not None:
                    r.set("airwireshidden", v)


            ### process the sections in order.  They have to be in section order,
            ### because eagle files are order dependent.


            ## For some tags, Eagle generates empty tags when there's no contant
            ## rather than just leaving the tag out.  We mark these with
            ## Tag.requireTag in GenerateSwoop.py and force their generation
            ## here.



            ## add a list.

            if len(self.contactrefs) is not 0:
                target = smartAddSubTags(r, "./contactref")
                # add them in sorted order.  This gives us a simple canonicalization that makes it feasible to use diff to compare files.
                target.extend([i.get_et() for i in sorted(self.contactrefs,key=lambda x: x.sortkey())])


            ## For some tags, Eagle generates empty tags when there's no contant
            ## rather than just leaving the tag out.  We mark these with
            ## Tag.requireTag in GenerateSwoop.py and force their generation
            ## here.



            ## add a list.

            if len(self.polygons) is not 0:
                target = smartAddSubTags(r, "./polygon")
                # add them in sorted order.  This gives us a simple canonicalization that makes it feasible to use diff to compare files.
                target.extend([i.get_et() for i in sorted(self.polygons,key=lambda x: x.sortkey())])


            ## For some tags, Eagle generates empty tags when there's no contant
            ## rather than just leaving the tag out.  We mark these with
            ## Tag.requireTag in GenerateSwoop.py and force their generation
            ## here.



            ## add a list.

            if len(self.wires) is not 0:
                target = smartAddSubTags(r, "./wire")
                # add them in sorted order.  This gives us a simple canonicalization that makes it feasible to use diff to compare files.
                target.extend([i.get_et() for i in sorted(self.wires,key=lambda x: x.sortkey())])


            ## For some tags, Eagle generates empty tags when there's no contant
            ## rather than just leaving the tag out.  We mark these with
            ## Tag.requireTag in GenerateSwoop.py and force their generation
            ## here.



            ## add a list.

            if len(self.vias) is not 0:
                target = smartAddSubTags(r, "./via")
                # add them in sorted order.  This gives us a simple canonicalization that makes it feasible to use diff to compare files.
                target.extend([i.get_et() for i in sorted(self.vias,key=lambda x: x.sortkey())])


            ## set the text, if its needed.

        except SwoopError as e:
            e.text = "{}:{}".format(self._get_error_name(), e.text)
            raise e
        return r

    def clone(self):
        """
        Recursively clone this :code:`Signal`.  It will be identical to the original, but it's parent will be :code:`None`.
        
        :rtype: :class:`Signal`
        """
        try:
            n = copy.copy(self)
            n.contactrefs = []
            for x in self.contactrefs:
                n.add_contactref(x.clone())
            n.polygons = []
            for x in self.polygons:
                n.add_polygon(x.clone())
            n.wires = []
            for x in self.wires:
                n.add_wire(x.clone())
            n.vias = []
            for x in self.vias:
                n.add_via(x.clone())
            n.parent = None
        except SwoopError as e:
            e.text = "{}:{}".format(self._get_error_name(), e.text)
            raise e
        return n

    def accept_preorder_visitor(self, visitor):
        try:
            pre = getattr(visitor, "Signal_pre")
            return pre(self)
        except AttributeError:
            return visitor.default_pre(self)
        
    def accept_postorder_visitor(self, visitor, context):
        try:
            post = getattr(visitor, "Signal_post")
            post(self,context)
        except AttributeError:
            visitor.default_post(self,context)

    def is_equal(self, other):
        """
        Check whether two :code:`EagleFilePart` objects are identical.
        
        :param other: Object to compare to.
        :returns: :code:`True` if they are identical, otherwise, :code:`False`
        """
        return self.get_xml() == other.get_xml()
        
    ### Getters/Setters for attribute values

    def get_name(self):
        """ Return the value of :code:`name` for this :class:`Signal`.  This corresponds to the :code:`name` attribute of a :code:`<signal>` in an Eagle file.
        
        :rtype: :code:`str`
        """
        return self.name

    def set_name(self,v):
        """ Set the value of :code:`name` for this  :class:`Signal`.  This corresponds to the :code:`name` attribute of a :code:`<signal>` in an Eagle file.

        :param v: new value
        :rtype: :code:`self`
        """
                        
        oldkey = self.name
        if not typeCheck("str", v, True):
            raise SwoopError("Illegal value ({}) of type {} for attribute 'name' of Signal object (should be str).".format(v, type(v)))
        self.name = v
        
        if self.get_parent() is not None:
            self.get_parent()._rekey_child(oldkey, self);
        return self

    def with_name(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`name`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`name` equals :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_name()` is :code:`True`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """

        if type(v) in [str, int, float, bool]:
            return self if self.name == v else None
        elif callable(v):
            return self if v(self.name) else None
        else:
            raise SwoopError("Illegal type passed to with_name")

    def without_name(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`name`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`name` is not equal to :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_name()` is :code:`False`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """
        
        if type(v) in [str, int, float, bool]:
            return self if self.name != v else None
        elif callable(v):
            return self if not v(self.name) else None
        else:
            raise SwoopError("Illegal type passed to without_name")


    def get_class(self):
        """ Return the value of :code:`netclass` for this :class:`Signal`.  This corresponds to the :code:`netclass` attribute of a :code:`<signal>` in an Eagle file.
        
        :rtype: :code:`str`
        """
        return self.netclass

    def set_class(self,v):
        """ Set the value of :code:`netclass` for this  :class:`Signal`.  This corresponds to the :code:`netclass` attribute of a :code:`<signal>` in an Eagle file.

        :param v: new value
        :rtype: :code:`self`
        """
                        
        if not typeCheck("str", v, False):
            raise SwoopError("Illegal value ({}) of type {} for attribute 'netclass' of Signal object (should be str).".format(v, type(v)))
        self.netclass = v
        
        return self

    def with_class(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`netclass`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`netclass` equals :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_class()` is :code:`True`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """

        if type(v) in [str, int, float, bool]:
            return self if self.netclass == v else None
        elif callable(v):
            return self if v(self.netclass) else None
        else:
            raise SwoopError("Illegal type passed to with_class")

    def without_class(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`netclass`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`netclass` is not equal to :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_class()` is :code:`False`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """
        
        if type(v) in [str, int, float, bool]:
            return self if self.netclass != v else None
        elif callable(v):
            return self if not v(self.netclass) else None
        else:
            raise SwoopError("Illegal type passed to without_class")


    def get_airwireshidden(self):
        """ Return the value of :code:`airwireshidden` for this :class:`Signal`.  This corresponds to the :code:`airwireshidden` attribute of a :code:`<signal>` in an Eagle file.
        
        :rtype: :code:`bool`
        """
        return self.airwireshidden

    def set_airwireshidden(self,v):
        """ Set the value of :code:`airwireshidden` for this  :class:`Signal`.  This corresponds to the :code:`airwireshidden` attribute of a :code:`<signal>` in an Eagle file.

        :param v: new value
        :rtype: :code:`self`
        """
                        
        if not typeCheck("bool", v, False):
            raise SwoopError("Illegal value ({}) of type {} for attribute 'airwireshidden' of Signal object (should be bool).".format(v, type(v)))
        self.airwireshidden = v
        
        return self

    def with_airwireshidden(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`airwireshidden`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`airwireshidden` equals :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_airwireshidden()` is :code:`True`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """

        if type(v) in [str, int, float, bool]:
            return self if self.airwireshidden == v else None
        elif callable(v):
            return self if v(self.airwireshidden) else None
        else:
            raise SwoopError("Illegal type passed to with_airwireshidden")

    def without_airwireshidden(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`airwireshidden`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`airwireshidden` is not equal to :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_airwireshidden()` is :code:`False`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """
        
        if type(v) in [str, int, float, bool]:
            return self if self.airwireshidden != v else None
        elif callable(v):
            return self if not v(self.airwireshidden) else None
        else:
            raise SwoopError("Illegal type passed to without_airwireshidden")



    ##### Lookup functions that return EFPs instead of just attribute values.
    
    def find_class(self):
        """Find the :class:`Class` object refered to by the :code:`netclass` attribute of this object.  This is like
        :meth:`get_netclass`, except it returns the :class:`Class` object instead of its name.
        
        :returns: The object
        :rtype: :class:`Class`

        """
        f = lambda efp, key: NotImplemented('class lookup from signal not implemented')
        return f(self, self.netclass)
    


    
    ### Adder/getter/lookup for lists
    
    def add_contactref(self, s):
        """ Add a :class:`Contactref` to the :code:`contactrefs` of this :class:`Signal`.

        :param s: The :class:`Contactref` to add.
        :rtype: :code:`self`
        """
        if not any([
                isinstance(s, Contactref),
            ]):
            raise SwoopError("Argument to Signal.add_contactref() should be of type Contactref.  Got " + str(type(s).__name__) + ".")
        
        self.contactrefs.append(s)
        if s.parent is not None and s.parent is not self:
            s.parent.remove_contactref(s)

        s.parent = self
        return self

    def get_nth_contactref(self, n):
        """ get then nth :class:`Contactref` object from the :code:`contactrefs` of this :class:`Signal`.
        
        :param n: Index of the item to return.

        :rtype: :class:`Contactref` object
        """
        return self.contactrefs[n]

    def get_contactrefs(self, attrs=None, type=None):
        """Return (and possibly filter) items in the the :code:`contactrefs` list of :class:`Contactref` objects for this :class:`Signal`.
        
        This functions provides a mechanism for filtering the items as well.
        The keys in :code:`attrs` are taken as attributes names and the
        values are requested values.  Items in the list that have all the
        requested values for the corresponding attributes will be returned.  

        A if :code:`type` is not :code:`None`, the item will match if it is an
        instance of the type provided.
        
        :param attrs: A set of key-value pairs that represent a filter to apply to the item's attributes.
        :param type:  A type to filter on.  Only items that are an instance of this type will be returned.
        :returns: A List of :class:`Contactref` objects
        :rtype: List of :class:`Contactref` objects
        """
        if attrs is not None or type is not None:
            raise NotImplementedError("filtered get not implemented.")
        return self.contactrefs

    def clear_contactrefs(self):
        """
        Remove all the :class:`Contactref` objects from the :code:`contactrefs` of this :class:`Signal`.
        
        :rtype: :code:`self`
        """
        for efp in self.contactrefs:
            efp.parent = None
        self.contactrefs = []
        return self

    def remove_contactref(self, efp):
        """
        Remove a :class:`Contactref` from the :code:`contactrefs` of this :class:`Signal`.
        
        :param efp: The :class:`Contactref` object to remove.

        :rtype: :code:`self`
        """
        self.contactrefs = [x for x in self.contactrefs if x != efp]

        if efp.parent is self:
            efp.parent = None
        return self

    def add_polygon(self, s):
        """ Add a :class:`Polygon` to the :code:`polygons` of this :class:`Signal`.

        :param s: The :class:`Polygon` to add.
        :rtype: :code:`self`
        """
        if not any([
                isinstance(s, Polygon),
            ]):
            raise SwoopError("Argument to Signal.add_polygon() should be of type Polygon.  Got " + str(type(s).__name__) + ".")
        
        self.polygons.append(s)
        if s.parent is not None and s.parent is not self:
            s.parent.remove_polygon(s)

        s.parent = self
        return self

    def get_nth_polygon(self, n):
        """ get then nth :class:`Polygon` object from the :code:`polygons` of this :class:`Signal`.
        
        :param n: Index of the item to return.

        :rtype: :class:`Polygon` object
        """
        return self.polygons[n]

    def get_polygons(self, attrs=None, type=None):
        """Return (and possibly filter) items in the the :code:`polygons` list of :class:`Polygon` objects for this :class:`Signal`.
        
        This functions provides a mechanism for filtering the items as well.
        The keys in :code:`attrs` are taken as attributes names and the
        values are requested values.  Items in the list that have all the
        requested values for the corresponding attributes will be returned.  

        A if :code:`type` is not :code:`None`, the item will match if it is an
        instance of the type provided.
        
        :param attrs: A set of key-value pairs that represent a filter to apply to the item's attributes.
        :param type:  A type to filter on.  Only items that are an instance of this type will be returned.
        :returns: A List of :class:`Polygon` objects
        :rtype: List of :class:`Polygon` objects
        """
        if attrs is not None or type is not None:
            raise NotImplementedError("filtered get not implemented.")
        return self.polygons

    def clear_polygons(self):
        """
        Remove all the :class:`Polygon` objects from the :code:`polygons` of this :class:`Signal`.
        
        :rtype: :code:`self`
        """
        for efp in self.polygons:
            efp.parent = None
        self.polygons = []
        return self

    def remove_polygon(self, efp):
        """
        Remove a :class:`Polygon` from the :code:`polygons` of this :class:`Signal`.
        
        :param efp: The :class:`Polygon` object to remove.

        :rtype: :code:`self`
        """
        self.polygons = [x for x in self.polygons if x != efp]

        if efp.parent is self:
            efp.parent = None
        return self

    def add_wire(self, s):
        """ Add a :class:`Wire` to the :code:`wires` of this :class:`Signal`.

        :param s: The :class:`Wire` to add.
        :rtype: :code:`self`
        """
        if not any([
                isinstance(s, Wire),
            ]):
            raise SwoopError("Argument to Signal.add_wire() should be of type Wire.  Got " + str(type(s).__name__) + ".")
        
        self.wires.append(s)
        if s.parent is not None and s.parent is not self:
            s.parent.remove_wire(s)

        s.parent = self
        return self

    def get_nth_wire(self, n):
        """ get then nth :class:`Wire` object from the :code:`wires` of this :class:`Signal`.
        
        :param n: Index of the item to return.

        :rtype: :class:`Wire` object
        """
        return self.wires[n]

    def get_wires(self, attrs=None, type=None):
        """Return (and possibly filter) items in the the :code:`wires` list of :class:`Wire` objects for this :class:`Signal`.
        
        This functions provides a mechanism for filtering the items as well.
        The keys in :code:`attrs` are taken as attributes names and the
        values are requested values.  Items in the list that have all the
        requested values for the corresponding attributes will be returned.  

        A if :code:`type` is not :code:`None`, the item will match if it is an
        instance of the type provided.
        
        :param attrs: A set of key-value pairs that represent a filter to apply to the item's attributes.
        :param type:  A type to filter on.  Only items that are an instance of this type will be returned.
        :returns: A List of :class:`Wire` objects
        :rtype: List of :class:`Wire` objects
        """
        if attrs is not None or type is not None:
            raise NotImplementedError("filtered get not implemented.")
        return self.wires

    def clear_wires(self):
        """
        Remove all the :class:`Wire` objects from the :code:`wires` of this :class:`Signal`.
        
        :rtype: :code:`self`
        """
        for efp in self.wires:
            efp.parent = None
        self.wires = []
        return self

    def remove_wire(self, efp):
        """
        Remove a :class:`Wire` from the :code:`wires` of this :class:`Signal`.
        
        :param efp: The :class:`Wire` object to remove.

        :rtype: :code:`self`
        """
        self.wires = [x for x in self.wires if x != efp]

        if efp.parent is self:
            efp.parent = None
        return self

    def add_via(self, s):
        """ Add a :class:`Via` to the :code:`vias` of this :class:`Signal`.

        :param s: The :class:`Via` to add.
        :rtype: :code:`self`
        """
        if not any([
                isinstance(s, Via),
            ]):
            raise SwoopError("Argument to Signal.add_via() should be of type Via.  Got " + str(type(s).__name__) + ".")
        
        self.vias.append(s)
        if s.parent is not None and s.parent is not self:
            s.parent.remove_via(s)

        s.parent = self
        return self

    def get_nth_via(self, n):
        """ get then nth :class:`Via` object from the :code:`vias` of this :class:`Signal`.
        
        :param n: Index of the item to return.

        :rtype: :class:`Via` object
        """
        return self.vias[n]

    def get_vias(self, attrs=None, type=None):
        """Return (and possibly filter) items in the the :code:`vias` list of :class:`Via` objects for this :class:`Signal`.
        
        This functions provides a mechanism for filtering the items as well.
        The keys in :code:`attrs` are taken as attributes names and the
        values are requested values.  Items in the list that have all the
        requested values for the corresponding attributes will be returned.  

        A if :code:`type` is not :code:`None`, the item will match if it is an
        instance of the type provided.
        
        :param attrs: A set of key-value pairs that represent a filter to apply to the item's attributes.
        :param type:  A type to filter on.  Only items that are an instance of this type will be returned.
        :returns: A List of :class:`Via` objects
        :rtype: List of :class:`Via` objects
        """
        if attrs is not None or type is not None:
            raise NotImplementedError("filtered get not implemented.")
        return self.vias

    def clear_vias(self):
        """
        Remove all the :class:`Via` objects from the :code:`vias` of this :class:`Signal`.
        
        :rtype: :code:`self`
        """
        for efp in self.vias:
            efp.parent = None
        self.vias = []
        return self

    def remove_via(self, efp):
        """
        Remove a :class:`Via` from the :code:`vias` of this :class:`Signal`.
        
        :param efp: The :class:`Via` object to remove.

        :rtype: :code:`self`
        """
        self.vias = [x for x in self.vias if x != efp]

        if efp.parent is self:
            efp.parent = None
        return self



    ### Add, lookup, and get for maps


    
    ### Getter/Setter for singletons.


    
    def get_children(self):
        """
        Get all the children of this :class:`EagleFilePart`.
        
        :rtype: List of :class:`EagleFilePart` objects
        """
        r = []

        r = r + self.contactrefs
        r = r + self.polygons
        r = r + self.wires
        r = r + self.vias



        return r

    def remove_child(self, efp):
        """
        Remove a child :class:`EagleFilePart` object.
        
        :param efp: the class:`EagleFilePart` object to remove.
        :return: Nothing
        """
        try:
            self.remove_contactref(efp)
        except:
            pass
        try:
            self.remove_polygon(efp)
        except:
            pass
        try:
            self.remove_wire(efp)
        except:
            pass
        try:
            self.remove_via(efp)
        except:
            pass

    def _rekey_child(self, oldkey, efp):
        """
        Remove a child :class:`EagleFilePart` object.
        
        :param efp: the class:`EagleFilePart` object to remove.
        :return: Nothing
        """


    def __str__(self):
        r = "["+repr(self)+" "
        r = r + "name:" + str(self.get_name()) + " "
        r = r + "netclass:" + str(self.get_class()) + " "
        r = r + "airwireshidden:" + str(self.get_airwireshidden()) + " "
        r = r + "]"
        return r
            
    def dump(self, indent="", increment="   "):
        """
        Recursive debug dump.
        
        :param indent:  Indentation string.  The output will be indented by this much.
        :param increment: This will be appendeded to :code:`indent` on recursive invocations.

        :rtype: :code:`None`
        """
        print(indent + str(self.__class__.__name__), end=' ')
        try:
            print(self.get_name())
        except:
            print()
            pass
        for c in self.get_children():
            c.dump(indent + "   ")

        
EagleFile.class_map["signal"] = Signal
         


class Vertex(EagleFilePart, OnePointGeometry):
    """
    Class representing the contents of a <vertex> tag in Eagle files.

    Attributes:

    * :code:`x`

    * :code:`y`

    * :code:`curve`


    """
    def __init__(self):
        """
        Construct an empty :class:`Vertex` object.
        """
        EagleFilePart.__init__(self)
        OnePointGeometry.__init__(self)
        
        self.x=None
        self.y=None
        self.curve=None


        
    @classmethod
    def _from_et(cls,root,parent):
        """
        Create a :class:`Vertex` from a :code:`vertex` element.
        
        :param root: The element tree tree to parse.
        :param parent: :class:`EagleFilePart` that should hold the resulting :class:`EagleFilePart`
        :rtype: :class:`Vertex`
        """
        ## Call the constructor
        n = cls()
        n._init_from_et(root,parent)
        return n

    def _get_error_name(self):
        if hasattr(self, "get_name"):
            return self.get_name();
        else:
            return "Vertex";
        
    def  _init_from_et(self, root, parent):
        """
        Initialized a :class:`Vertex` from a :code:`vertex` element.  This is useful if you have a subclass of :class:`Vertex` .
        
        :param root: The element tree tree to parse.
        :param parent: :class:`EagleFilePart` that will become the parent of :code:`this` .
        :rtype: :class:`Vertex`
        """
        try:
            self.root = root
            
            if root.tag != "vertex":
                raise EagleFormatError("Tried to create vertex from " + root.tag)

            self.x=parseByType(parent, "float", None, root.get("x"))
            self.y=parseByType(parent, "float", None, root.get("y"))
            self.curve=parseByType(parent, "float", None, root.get("curve"))

            self.parent = parent

            ### populate the maps by searching for elements that match xpath and generating objects for them.


            ### Do the same for the lists


            ### Do the same for the attr lists


            ### And the singletons


            ### And, finally, if the objects wants the text from the tag.

        except SwoopError as e:
            e.text = "{}:{}".format(self._get_error_name(), e.text)
            raise e


    def sortkey(self):
        return ""

    def get_et(self):
        """
        Generate a <vertex> element tree for a :class:`Vertex`.
        
        :rtype:  :class:`ElementTree`.
        
        """
        try:
            r = ET.Element("vertex")

            ### Set the tag attributes 


            ## Unparse the values.

            v = unparseByType(self, "float", None,  self.x)

            ## For required attributes None becomes "".  For optional attributes, we just leave the attribute out.
            if not (isinstance(self.get_parent(), LibraryFile) and False):  # special case for the name of library.
                if v is not None:
                    r.set("x", v)
                else:
                    r.set("x", "")


            ## Unparse the values.

            v = unparseByType(self, "float", None,  self.y)

            ## For required attributes None becomes "".  For optional attributes, we just leave the attribute out.
            if not (isinstance(self.get_parent(), LibraryFile) and False):  # special case for the name of library.
                if v is not None:
                    r.set("y", v)
                else:
                    r.set("y", "")


            ## Unparse the values.

            v = unparseByType(self, "float", None,  self.curve)

            ## For required attributes None becomes "".  For optional attributes, we just leave the attribute out.
            if not (isinstance(self.get_parent(), LibraryFile) and False):  # special case for the name of library.
                if v is not None:
                    r.set("curve", v)


            ### process the sections in order.  They have to be in section order,
            ### because eagle files are order dependent.


            ## set the text, if its needed.

        except SwoopError as e:
            e.text = "{}:{}".format(self._get_error_name(), e.text)
            raise e
        return r

    def clone(self):
        """
        Recursively clone this :code:`Vertex`.  It will be identical to the original, but it's parent will be :code:`None`.
        
        :rtype: :class:`Vertex`
        """
        try:
            n = copy.copy(self)
            n.parent = None
        except SwoopError as e:
            e.text = "{}:{}".format(self._get_error_name(), e.text)
            raise e
        return n

    def accept_preorder_visitor(self, visitor):
        try:
            pre = getattr(visitor, "Vertex_pre")
            return pre(self)
        except AttributeError:
            return visitor.default_pre(self)
        
    def accept_postorder_visitor(self, visitor, context):
        try:
            post = getattr(visitor, "Vertex_post")
            post(self,context)
        except AttributeError:
            visitor.default_post(self,context)

    def is_equal(self, other):
        """
        Check whether two :code:`EagleFilePart` objects are identical.
        
        :param other: Object to compare to.
        :returns: :code:`True` if they are identical, otherwise, :code:`False`
        """
        return self.get_xml() == other.get_xml()
        
    ### Getters/Setters for attribute values

    def get_x(self):
        """ Return the value of :code:`x` for this :class:`Vertex`.  This corresponds to the :code:`x` attribute of a :code:`<vertex>` in an Eagle file.
        
        :rtype: :code:`float`
        """
        return self.x

    def set_x(self,v):
        """ Set the value of :code:`x` for this  :class:`Vertex`.  This corresponds to the :code:`x` attribute of a :code:`<vertex>` in an Eagle file.

        :param v: new value
        :rtype: :code:`self`
        """
                        
        if not typeCheck("float", v, True):
            raise SwoopError("Illegal value ({}) of type {} for attribute 'x' of Vertex object (should be float).".format(v, type(v)))
        self.x = v
        
        return self

    def with_x(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`x`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`x` equals :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_x()` is :code:`True`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """

        if type(v) in [str, int, float, bool]:
            return self if self.x == v else None
        elif callable(v):
            return self if v(self.x) else None
        else:
            raise SwoopError("Illegal type passed to with_x")

    def without_x(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`x`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`x` is not equal to :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_x()` is :code:`False`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """
        
        if type(v) in [str, int, float, bool]:
            return self if self.x != v else None
        elif callable(v):
            return self if not v(self.x) else None
        else:
            raise SwoopError("Illegal type passed to without_x")


    def get_y(self):
        """ Return the value of :code:`y` for this :class:`Vertex`.  This corresponds to the :code:`y` attribute of a :code:`<vertex>` in an Eagle file.
        
        :rtype: :code:`float`
        """
        return self.y

    def set_y(self,v):
        """ Set the value of :code:`y` for this  :class:`Vertex`.  This corresponds to the :code:`y` attribute of a :code:`<vertex>` in an Eagle file.

        :param v: new value
        :rtype: :code:`self`
        """
                        
        if not typeCheck("float", v, True):
            raise SwoopError("Illegal value ({}) of type {} for attribute 'y' of Vertex object (should be float).".format(v, type(v)))
        self.y = v
        
        return self

    def with_y(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`y`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`y` equals :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_y()` is :code:`True`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """

        if type(v) in [str, int, float, bool]:
            return self if self.y == v else None
        elif callable(v):
            return self if v(self.y) else None
        else:
            raise SwoopError("Illegal type passed to with_y")

    def without_y(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`y`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`y` is not equal to :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_y()` is :code:`False`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """
        
        if type(v) in [str, int, float, bool]:
            return self if self.y != v else None
        elif callable(v):
            return self if not v(self.y) else None
        else:
            raise SwoopError("Illegal type passed to without_y")


    def get_curve(self):
        """ Return the value of :code:`curve` for this :class:`Vertex`.  This corresponds to the :code:`curve` attribute of a :code:`<vertex>` in an Eagle file.
        
        :rtype: :code:`float`
        """
        return self.curve

    def set_curve(self,v):
        """ Set the value of :code:`curve` for this  :class:`Vertex`.  This corresponds to the :code:`curve` attribute of a :code:`<vertex>` in an Eagle file.

        :param v: new value
        :rtype: :code:`self`
        """
                        
        if not typeCheck("float", v, False):
            raise SwoopError("Illegal value ({}) of type {} for attribute 'curve' of Vertex object (should be float).".format(v, type(v)))
        self.curve = v
        
        return self

    def with_curve(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`curve`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`curve` equals :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_curve()` is :code:`True`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """

        if type(v) in [str, int, float, bool]:
            return self if self.curve == v else None
        elif callable(v):
            return self if v(self.curve) else None
        else:
            raise SwoopError("Illegal type passed to with_curve")

    def without_curve(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`curve`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`curve` is not equal to :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_curve()` is :code:`False`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """
        
        if type(v) in [str, int, float, bool]:
            return self if self.curve != v else None
        elif callable(v):
            return self if not v(self.curve) else None
        else:
            raise SwoopError("Illegal type passed to without_curve")



    ##### Lookup functions that return EFPs instead of just attribute values.
    
    


    
    ### Adder/getter/lookup for lists
    


    ### Add, lookup, and get for maps


    
    ### Getter/Setter for singletons.


    
    def get_children(self):
        """
        Get all the children of this :class:`EagleFilePart`.
        
        :rtype: List of :class:`EagleFilePart` objects
        """
        r = []




        return r

    def remove_child(self, efp):
        """
        Remove a child :class:`EagleFilePart` object.
        
        :param efp: the class:`EagleFilePart` object to remove.
        :return: Nothing
        """

    def _rekey_child(self, oldkey, efp):
        """
        Remove a child :class:`EagleFilePart` object.
        
        :param efp: the class:`EagleFilePart` object to remove.
        :return: Nothing
        """


    def __str__(self):
        r = "["+repr(self)+" "
        r = r + "x:" + str(self.get_x()) + " "
        r = r + "y:" + str(self.get_y()) + " "
        r = r + "curve:" + str(self.get_curve()) + " "
        r = r + "]"
        return r
            
    def dump(self, indent="", increment="   "):
        """
        Recursive debug dump.
        
        :param indent:  Indentation string.  The output will be indented by this much.
        :param increment: This will be appendeded to :code:`indent` on recursive invocations.

        :rtype: :code:`None`
        """
        print(indent + str(self.__class__.__name__), end=' ')
        try:
            print(self.get_name())
        except:
            print()
            pass
        for c in self.get_children():
            c.dump(indent + "   ")

        
EagleFile.class_map["vertex"] = Vertex
         


class SchematicFile(EagleFile):
    """
    Class representing the contents of a <eagle> tag in Eagle files.

    Attributes:

    * :code:`version`



    Collections:

    * :code:`grid`: Singleton :class:`Grid` object. 

    * :code:`schematic`: Singleton :class:`Schematic` object. 

    * :code:`description`: Singleton :class:`Description` object. 

    * :code:`compatibility`: Singleton :class:`Compatibility` object. 


    * :code:`setting`: List of :class:`Setting` objects.

    * :code:`sheet`: List of :class:`Sheet` objects.

    * :code:`approved`: List of :class:`Approved` objects.


    * :code:`layer`: Map of :class:`Layer` objects indexed by their :code:`number`.


    * :code:`library`: Map of :class:`Library` objects indexed by their :code:`name`.


    * :code:`attribute`: Map of :class:`Attribute` objects indexed by their :code:`name`.


    * :code:`variantdef`: Map of :class:`Variantdef` objects indexed by their :code:`name`.


    * :code:`class`: Map of :class:`Class` objects indexed by their :code:`name`.


    * :code:`module`: Map of :class:`Module` objects indexed by their :code:`name`.


    * :code:`part`: Map of :class:`Part` objects indexed by their :code:`name`.



    """
    def __init__(self):
        """
        Construct an empty :class:`SchematicFile` object.
        """
        EagleFile.__init__(self)
        
        self.version=None
        self.settings=[]
        self.sheets=[]
        self.approved_errors=[]
        self.layers={} #tecollections.OrderedDict()  For unclear reasons, this caused ordering to become more unpredictable, rather than less.
        self.libraries={} #tecollections.OrderedDict()  For unclear reasons, this caused ordering to become more unpredictable, rather than less.
        self.attributes={} #tecollections.OrderedDict()  For unclear reasons, this caused ordering to become more unpredictable, rather than less.
        self.variantdefs={} #tecollections.OrderedDict()  For unclear reasons, this caused ordering to become more unpredictable, rather than less.
        self.classes={} #tecollections.OrderedDict()  For unclear reasons, this caused ordering to become more unpredictable, rather than less.
        self.modules={} #tecollections.OrderedDict()  For unclear reasons, this caused ordering to become more unpredictable, rather than less.
        self.parts={} #tecollections.OrderedDict()  For unclear reasons, this caused ordering to become more unpredictable, rather than less.
        self.grid=None
        self.schematic=None
        self.description=None
        self.compatibility=None


        
    @classmethod
    def _from_et(cls,root,parent):
        """
        Create a :class:`SchematicFile` from a :code:`eagle` element.
        
        :param root: The element tree tree to parse.
        :param parent: :class:`EagleFilePart` that should hold the resulting :class:`EagleFilePart`
        :rtype: :class:`SchematicFile`
        """
        ## Call the constructor
        n = cls()
        n._init_from_et(root,parent)
        return n

    def _get_error_name(self):
        if hasattr(self, "get_name"):
            return self.get_name();
        else:
            return "SchematicFile";
        
    def  _init_from_et(self, root, parent):
        """
        Initialized a :class:`SchematicFile` from a :code:`eagle` element.  This is useful if you have a subclass of :class:`SchematicFile` .
        
        :param root: The element tree tree to parse.
        :param parent: :class:`EagleFilePart` that will become the parent of :code:`this` .
        :rtype: :class:`SchematicFile`
        """
        try:
            self.root = root
            
            if root.tag != "eagle":
                raise EagleFormatError("Tried to create eagle from " + root.tag)

            self.version=parseByType(parent, "str", None, root.get("version"))

            self.parent = parent

            ### populate the maps by searching for elements that match xpath and generating objects for them.

            for c in root.xpath("./drawing/layers/layer"):
                self.add_layer(self.get_class_for_tag(c.tag)._from_et(c, self))
            for c in root.xpath("./drawing/schematic/libraries/library"):
                self.add_library(self.get_class_for_tag(c.tag)._from_et(c, self))
            for c in root.xpath("./drawing/schematic/attributes/attribute"):
                self.add_attribute(self.get_class_for_tag(c.tag)._from_et(c, self))
            for c in root.xpath("./drawing/schematic/variantdefs/variantdef"):
                self.add_variantdef(self.get_class_for_tag(c.tag)._from_et(c, self))
            for c in root.xpath("./drawing/schematic/classes/class"):
                self.add_class(self.get_class_for_tag(c.tag)._from_et(c, self))
            for c in root.xpath("./drawing/schematic/modules/module"):
                self.add_module(self.get_class_for_tag(c.tag)._from_et(c, self))
            for c in root.xpath("./drawing/schematic/parts/part"):
                self.add_part(self.get_class_for_tag(c.tag)._from_et(c, self))

            ### Do the same for the lists

            for c in root.xpath("./drawing/settings/setting"):
                self.add_setting(self.get_class_for_tag(c.tag)._from_et(c,self))
            for c in root.xpath("./drawing/schematic/sheets/sheet"):
                self.add_sheet(self.get_class_for_tag(c.tag)._from_et(c,self))
            for c in root.xpath("./drawing/schematic/errors/approved"):
                self.add_approved(self.get_class_for_tag(c.tag)._from_et(c,self))

            ### Do the same for the attr lists


            ### And the singletons

            x = root.xpath("./drawing/grid")
            if len(x) is not 0:
                self.set_grid(self.get_class_for_tag(x[0].tag)._from_et(x[0],self))
            x = root.xpath("./drawing/schematic")
            if len(x) is not 0:
                self.set_schematic(self.get_class_for_tag(x[0].tag)._from_et(x[0],self))
            x = root.xpath("./drawing/schematic/description")
            if len(x) is not 0:
                self.set_description(self.get_class_for_tag(x[0].tag)._from_et(x[0],self))
            x = root.xpath("./compatibility")
            if len(x) is not 0:
                self.set_compatibility(self.get_class_for_tag(x[0].tag)._from_et(x[0],self))

            ### And, finally, if the objects wants the text from the tag.

        except SwoopError as e:
            e.text = "{}:{}".format(self._get_error_name(), e.text)
            raise e


    def sortkey(self):
        r = ""
        r = r + str(self.version)
        return r

    def get_et(self):
        """
        Generate a <eagle> element tree for a :class:`SchematicFile`.
        
        :rtype:  :class:`ElementTree`.
        
        """
        try:
            r = ET.Element("eagle")

            ### Set the tag attributes 


            ## Unparse the values.

            v = unparseByType(self, "str", None,  self.version)

            ## For required attributes None becomes "".  For optional attributes, we just leave the attribute out.
            if not (isinstance(self.get_parent(), LibraryFile) and False):  # special case for the name of library.
                if v is not None:
                    r.set("version", v)
                else:
                    r.set("version", "")


            ### process the sections in order.  They have to be in section order,
            ### because eagle files are order dependent.


            ## For some tags, Eagle generates empty tags when there's no contant
            ## rather than just leaving the tag out.  We mark these with
            ## Tag.requireTag in GenerateSwoop.py and force their generation
            ## here.

            smartAddSubTags(r, "./drawing/settings/setting")


            ## add a list.

            if len(self.settings) is not 0:
                target = smartAddSubTags(r, "./drawing/settings/setting")
                # add them in sorted order.  This gives us a simple canonicalization that makes it feasible to use diff to compare files.
                target.extend([i.get_et() for i in sorted(self.settings,key=lambda x: x.sortkey())])


            ## For some tags, Eagle generates empty tags when there's no contant
            ## rather than just leaving the tag out.  We mark these with
            ## Tag.requireTag in GenerateSwoop.py and force their generation
            ## here.



            ## or add a singleton.

            if self.grid is not None:
                target = smartAddSubTags(r, "./drawing/grid")
                target.append(self.grid.get_et())

            ## For some tags, Eagle generates empty tags when there's no contant
            ## rather than just leaving the tag out.  We mark these with
            ## Tag.requireTag in GenerateSwoop.py and force their generation
            ## here.



            ## add a map.

            if len(self.layers) is not 0:
                target = smartAddSubTags(r, "./drawing/layers/layer")
                # add them in sorted order.  This gives us a simple canonicalization that makes it feasible to use diff to compare files.
                target.extend([i.get_et() for i in sorted(list(self.layers.values()),key=lambda x: x.sortkey())])


            ## For some tags, Eagle generates empty tags when there's no contant
            ## rather than just leaving the tag out.  We mark these with
            ## Tag.requireTag in GenerateSwoop.py and force their generation
            ## here.



            ## or add a singleton.

            if self.schematic is not None:
                target = smartAddSubTags(r, "./drawing/schematic")
                target.append(self.schematic.get_et())

            ## For some tags, Eagle generates empty tags when there's no contant
            ## rather than just leaving the tag out.  We mark these with
            ## Tag.requireTag in GenerateSwoop.py and force their generation
            ## here.

            smartAddSubTags(r, "./drawing/schematic/description")


            ## or add a singleton.

            if self.description is not None:
                target = smartAddSubTags(r, "./drawing/schematic/description")
                target.append(self.description.get_et())

            ## For some tags, Eagle generates empty tags when there's no contant
            ## rather than just leaving the tag out.  We mark these with
            ## Tag.requireTag in GenerateSwoop.py and force their generation
            ## here.

            smartAddSubTags(r, "./drawing/schematic/libraries/library")


            ## add a map.

            if len(self.libraries) is not 0:
                target = smartAddSubTags(r, "./drawing/schematic/libraries/library")
                # add them in sorted order.  This gives us a simple canonicalization that makes it feasible to use diff to compare files.
                target.extend([i.get_et() for i in sorted(list(self.libraries.values()),key=lambda x: x.sortkey())])


            ## For some tags, Eagle generates empty tags when there's no contant
            ## rather than just leaving the tag out.  We mark these with
            ## Tag.requireTag in GenerateSwoop.py and force their generation
            ## here.

            smartAddSubTags(r, "./drawing/schematic/attributes/attribute")


            ## add a map.

            if len(self.attributes) is not 0:
                target = smartAddSubTags(r, "./drawing/schematic/attributes/attribute")
                # add them in sorted order.  This gives us a simple canonicalization that makes it feasible to use diff to compare files.
                target.extend([i.get_et() for i in sorted(list(self.attributes.values()),key=lambda x: x.sortkey())])


            ## For some tags, Eagle generates empty tags when there's no contant
            ## rather than just leaving the tag out.  We mark these with
            ## Tag.requireTag in GenerateSwoop.py and force their generation
            ## here.

            smartAddSubTags(r, "./drawing/schematic/variantdefs/variantdef")


            ## add a map.

            if len(self.variantdefs) is not 0:
                target = smartAddSubTags(r, "./drawing/schematic/variantdefs/variantdef")
                # add them in sorted order.  This gives us a simple canonicalization that makes it feasible to use diff to compare files.
                target.extend([i.get_et() for i in sorted(list(self.variantdefs.values()),key=lambda x: x.sortkey())])


            ## For some tags, Eagle generates empty tags when there's no contant
            ## rather than just leaving the tag out.  We mark these with
            ## Tag.requireTag in GenerateSwoop.py and force their generation
            ## here.



            ## add a map.

            if len(self.classes) is not 0:
                target = smartAddSubTags(r, "./drawing/schematic/classes/class")
                # add them in sorted order.  This gives us a simple canonicalization that makes it feasible to use diff to compare files.
                target.extend([i.get_et() for i in sorted(list(self.classes.values()),key=lambda x: x.sortkey())])


            ## For some tags, Eagle generates empty tags when there's no contant
            ## rather than just leaving the tag out.  We mark these with
            ## Tag.requireTag in GenerateSwoop.py and force their generation
            ## here.



            ## add a map.

            if len(self.modules) is not 0:
                target = smartAddSubTags(r, "./drawing/schematic/modules/module")
                # add them in sorted order.  This gives us a simple canonicalization that makes it feasible to use diff to compare files.
                target.extend([i.get_et() for i in sorted(list(self.modules.values()),key=lambda x: x.sortkey())])


            ## For some tags, Eagle generates empty tags when there's no contant
            ## rather than just leaving the tag out.  We mark these with
            ## Tag.requireTag in GenerateSwoop.py and force their generation
            ## here.

            smartAddSubTags(r, "./drawing/schematic/parts/part")


            ## add a map.

            if len(self.parts) is not 0:
                target = smartAddSubTags(r, "./drawing/schematic/parts/part")
                # add them in sorted order.  This gives us a simple canonicalization that makes it feasible to use diff to compare files.
                target.extend([i.get_et() for i in sorted(list(self.parts.values()),key=lambda x: x.sortkey())])


            ## For some tags, Eagle generates empty tags when there's no contant
            ## rather than just leaving the tag out.  We mark these with
            ## Tag.requireTag in GenerateSwoop.py and force their generation
            ## here.



            ## add a list.

            if len(self.sheets) is not 0:
                target = smartAddSubTags(r, "./drawing/schematic/sheets/sheet")
                # add them in sorted order.  This gives us a simple canonicalization that makes it feasible to use diff to compare files.
                target.extend([i.get_et() for i in sorted(self.sheets,key=lambda x: x.sortkey())])


            ## For some tags, Eagle generates empty tags when there's no contant
            ## rather than just leaving the tag out.  We mark these with
            ## Tag.requireTag in GenerateSwoop.py and force their generation
            ## here.



            ## add a list.

            if len(self.approved_errors) is not 0:
                target = smartAddSubTags(r, "./drawing/schematic/errors/approved")
                # add them in sorted order.  This gives us a simple canonicalization that makes it feasible to use diff to compare files.
                target.extend([i.get_et() for i in sorted(self.approved_errors,key=lambda x: x.sortkey())])


            ## For some tags, Eagle generates empty tags when there's no contant
            ## rather than just leaving the tag out.  We mark these with
            ## Tag.requireTag in GenerateSwoop.py and force their generation
            ## here.



            ## or add a singleton.

            if self.compatibility is not None:
                target = smartAddSubTags(r, "./compatibility")
                target.append(self.compatibility.get_et())

            ## set the text, if its needed.

        except SwoopError as e:
            e.text = "{}:{}".format(self._get_error_name(), e.text)
            raise e
        return r

    def clone(self):
        """
        Recursively clone this :code:`SchematicFile`.  It will be identical to the original, but it's parent will be :code:`None`.
        
        :rtype: :class:`SchematicFile`
        """
        try:
            n = copy.copy(self)
            n.layers = {}
            for x in list(self.layers.values()):
                n.add_layer(x.clone())
            n.libraries = {}
            for x in list(self.libraries.values()):
                n.add_library(x.clone())
            n.attributes = {}
            for x in list(self.attributes.values()):
                n.add_attribute(x.clone())
            n.variantdefs = {}
            for x in list(self.variantdefs.values()):
                n.add_variantdef(x.clone())
            n.classes = {}
            for x in list(self.classes.values()):
                n.add_class(x.clone())
            n.modules = {}
            for x in list(self.modules.values()):
                n.add_module(x.clone())
            n.parts = {}
            for x in list(self.parts.values()):
                n.add_part(x.clone())
            n.settings = []
            for x in self.settings:
                n.add_setting(x.clone())
            n.sheets = []
            for x in self.sheets:
                n.add_sheet(x.clone())
            n.approved_errors = []
            for x in self.approved_errors:
                n.add_approved(x.clone())
            n.grid = None
            if self.grid is not None:
                n.set_grid(self.grid.clone())
            else:
                n.set_grid(None)
            n.schematic = None
            if self.schematic is not None:
                n.set_schematic(self.schematic.clone())
            else:
                n.set_schematic(None)
            n.description = None
            if self.description is not None:
                n.set_description(self.description.clone())
            else:
                n.set_description(None)
            n.compatibility = None
            if self.compatibility is not None:
                n.set_compatibility(self.compatibility.clone())
            else:
                n.set_compatibility(None)
            n.parent = None
        except SwoopError as e:
            e.text = "{}:{}".format(self._get_error_name(), e.text)
            raise e
        return n

    def accept_preorder_visitor(self, visitor):
        try:
            pre = getattr(visitor, "SchematicFile_pre")
            return pre(self)
        except AttributeError:
            return visitor.default_pre(self)
        
    def accept_postorder_visitor(self, visitor, context):
        try:
            post = getattr(visitor, "SchematicFile_post")
            post(self,context)
        except AttributeError:
            visitor.default_post(self,context)

    def is_equal(self, other):
        """
        Check whether two :code:`EagleFilePart` objects are identical.
        
        :param other: Object to compare to.
        :returns: :code:`True` if they are identical, otherwise, :code:`False`
        """
        return self.get_xml() == other.get_xml()
        
    ### Getters/Setters for attribute values

    def get_version(self):
        """ Return the value of :code:`version` for this :class:`SchematicFile`.  This corresponds to the :code:`version` attribute of a :code:`<eagle>` in an Eagle file.
        
        :rtype: :code:`str`
        """
        return self.version

    def set_version(self,v):
        """ Set the value of :code:`version` for this  :class:`SchematicFile`.  This corresponds to the :code:`version` attribute of a :code:`<eagle>` in an Eagle file.

        :param v: new value
        :rtype: :code:`self`
        """
                        
        if not typeCheck("str", v, True):
            raise SwoopError("Illegal value ({}) of type {} for attribute 'version' of SchematicFile object (should be str).".format(v, type(v)))
        self.version = v
        
        return self

    def with_version(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`version`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`version` equals :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_version()` is :code:`True`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """

        if type(v) in [str, int, float, bool]:
            return self if self.version == v else None
        elif callable(v):
            return self if v(self.version) else None
        else:
            raise SwoopError("Illegal type passed to with_version")

    def without_version(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`version`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`version` is not equal to :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_version()` is :code:`False`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """
        
        if type(v) in [str, int, float, bool]:
            return self if self.version != v else None
        elif callable(v):
            return self if not v(self.version) else None
        else:
            raise SwoopError("Illegal type passed to without_version")



    ##### Lookup functions that return EFPs instead of just attribute values.
    
    


    
    ### Adder/getter/lookup for lists
    
    def add_setting(self, s):
        """ Add a :class:`Setting` to the :code:`settings` of this :class:`SchematicFile`.

        :param s: The :class:`Setting` to add.
        :rtype: :code:`self`
        """
        if not any([
                isinstance(s, Setting),
            ]):
            raise SwoopError("Argument to SchematicFile.add_setting() should be of type Setting.  Got " + str(type(s).__name__) + ".")
        
        self.settings.append(s)
        if s.parent is not None and s.parent is not self:
            s.parent.remove_setting(s)

        s.parent = self
        return self

    def get_nth_setting(self, n):
        """ get then nth :class:`Setting` object from the :code:`settings` of this :class:`SchematicFile`.
        
        :param n: Index of the item to return.

        :rtype: :class:`Setting` object
        """
        return self.settings[n]

    def get_settings(self, attrs=None, type=None):
        """Return (and possibly filter) items in the the :code:`settings` list of :class:`Setting` objects for this :class:`SchematicFile`.
        
        This functions provides a mechanism for filtering the items as well.
        The keys in :code:`attrs` are taken as attributes names and the
        values are requested values.  Items in the list that have all the
        requested values for the corresponding attributes will be returned.  

        A if :code:`type` is not :code:`None`, the item will match if it is an
        instance of the type provided.
        
        :param attrs: A set of key-value pairs that represent a filter to apply to the item's attributes.
        :param type:  A type to filter on.  Only items that are an instance of this type will be returned.
        :returns: A List of :class:`Setting` objects
        :rtype: List of :class:`Setting` objects
        """
        if attrs is not None or type is not None:
            raise NotImplementedError("filtered get not implemented.")
        return self.settings

    def clear_settings(self):
        """
        Remove all the :class:`Setting` objects from the :code:`settings` of this :class:`SchematicFile`.
        
        :rtype: :code:`self`
        """
        for efp in self.settings:
            efp.parent = None
        self.settings = []
        return self

    def remove_setting(self, efp):
        """
        Remove a :class:`Setting` from the :code:`settings` of this :class:`SchematicFile`.
        
        :param efp: The :class:`Setting` object to remove.

        :rtype: :code:`self`
        """
        self.settings = [x for x in self.settings if x != efp]

        if efp.parent is self:
            efp.parent = None
        return self

    def add_sheet(self, s):
        """ Add a :class:`Sheet` to the :code:`sheets` of this :class:`SchematicFile`.

        :param s: The :class:`Sheet` to add.
        :rtype: :code:`self`
        """
        if not any([
                isinstance(s, Sheet),
            ]):
            raise SwoopError("Argument to SchematicFile.add_sheet() should be of type Sheet.  Got " + str(type(s).__name__) + ".")
        
        self.sheets.append(s)
        if s.parent is not None and s.parent is not self:
            s.parent.remove_sheet(s)

        s.parent = self
        return self

    def get_nth_sheet(self, n):
        """ get then nth :class:`Sheet` object from the :code:`sheets` of this :class:`SchematicFile`.
        
        :param n: Index of the item to return.

        :rtype: :class:`Sheet` object
        """
        return self.sheets[n]

    def get_sheets(self, attrs=None, type=None):
        """Return (and possibly filter) items in the the :code:`sheets` list of :class:`Sheet` objects for this :class:`SchematicFile`.
        
        This functions provides a mechanism for filtering the items as well.
        The keys in :code:`attrs` are taken as attributes names and the
        values are requested values.  Items in the list that have all the
        requested values for the corresponding attributes will be returned.  

        A if :code:`type` is not :code:`None`, the item will match if it is an
        instance of the type provided.
        
        :param attrs: A set of key-value pairs that represent a filter to apply to the item's attributes.
        :param type:  A type to filter on.  Only items that are an instance of this type will be returned.
        :returns: A List of :class:`Sheet` objects
        :rtype: List of :class:`Sheet` objects
        """
        if attrs is not None or type is not None:
            raise NotImplementedError("filtered get not implemented.")
        return self.sheets

    def clear_sheets(self):
        """
        Remove all the :class:`Sheet` objects from the :code:`sheets` of this :class:`SchematicFile`.
        
        :rtype: :code:`self`
        """
        for efp in self.sheets:
            efp.parent = None
        self.sheets = []
        return self

    def remove_sheet(self, efp):
        """
        Remove a :class:`Sheet` from the :code:`sheets` of this :class:`SchematicFile`.
        
        :param efp: The :class:`Sheet` object to remove.

        :rtype: :code:`self`
        """
        self.sheets = [x for x in self.sheets if x != efp]

        if efp.parent is self:
            efp.parent = None
        return self

    def add_approved(self, s):
        """ Add a :class:`Approved` to the :code:`approved_errors` of this :class:`SchematicFile`.

        :param s: The :class:`Approved` to add.
        :rtype: :code:`self`
        """
        if not any([
                isinstance(s, Approved),
            ]):
            raise SwoopError("Argument to SchematicFile.add_approved() should be of type Approved.  Got " + str(type(s).__name__) + ".")
        
        self.approved_errors.append(s)
        if s.parent is not None and s.parent is not self:
            s.parent.remove_approved(s)

        s.parent = self
        return self

    def get_nth_approved(self, n):
        """ get then nth :class:`Approved` object from the :code:`approved_errors` of this :class:`SchematicFile`.
        
        :param n: Index of the item to return.

        :rtype: :class:`Approved` object
        """
        return self.approved_errors[n]

    def get_approved_errors(self, attrs=None, type=None):
        """Return (and possibly filter) items in the the :code:`approved_errors` list of :class:`Approved` objects for this :class:`SchematicFile`.
        
        This functions provides a mechanism for filtering the items as well.
        The keys in :code:`attrs` are taken as attributes names and the
        values are requested values.  Items in the list that have all the
        requested values for the corresponding attributes will be returned.  

        A if :code:`type` is not :code:`None`, the item will match if it is an
        instance of the type provided.
        
        :param attrs: A set of key-value pairs that represent a filter to apply to the item's attributes.
        :param type:  A type to filter on.  Only items that are an instance of this type will be returned.
        :returns: A List of :class:`Approved` objects
        :rtype: List of :class:`Approved` objects
        """
        if attrs is not None or type is not None:
            raise NotImplementedError("filtered get not implemented.")
        return self.approved_errors

    def clear_approved_errors(self):
        """
        Remove all the :class:`Approved` objects from the :code:`approved_errors` of this :class:`SchematicFile`.
        
        :rtype: :code:`self`
        """
        for efp in self.approved_errors:
            efp.parent = None
        self.approved_errors = []
        return self

    def remove_approved(self, efp):
        """
        Remove a :class:`Approved` from the :code:`approved_errors` of this :class:`SchematicFile`.
        
        :param efp: The :class:`Approved` object to remove.

        :rtype: :code:`self`
        """
        self.approved_errors = [x for x in self.approved_errors if x != efp]

        if efp.parent is self:
            efp.parent = None
        return self



    ### Add, lookup, and get for maps
    def add_library(self, s):
        """ Add a :class:`Library` to the :code:`libraries` of this :class:`SchematicFile`.

        :param s: The :class:`Library` to add.
        :rtype: :code:`self`
        """
        if not any([
                isinstance(s, Library),
            ]):
            raise SwoopError("Argument to SchematicFile.add_library() should be of type Library.  Got " + str(type(s).__name__) + ".")
        

        self.libraries[s.get_name()] = s

        s.parent = self
        return self

    def get_nth_library(self, n):
        """ get then nth :class:`Library` object from the :code:`libraries` of this :class:`SchematicFile`.
        
        :param n: Index of the item to return.

        :rtype: :class:`Library` object
        """
        return list(self.libraries.values())[n]

    def get_library(self, key):
        """ Lookup and return a :class:`Library` from the :code:`libraries` of  this :class:`SchematicFile`.
        
        :param key: A :code:`str` to use for the lookup.  The lookup uses the :code:`name` of the :class:`Library` objects.

        :rtype: A :class:`Library` object or :code:`None`, if there is no such item.
        """
        return self.libraries.get(key)


    def get_libraries(self, attrs=None, type=None):
        """Return (and possibly filter) items in the the :code:`libraries` map of :class:`Library` objects for this :class:`SchematicFile`.
        
        This functions provides a mechanism for filtering the items as well.
        The keys in :code:`attrs` are taken as attributes names and the
        values are requested values.  Items in the list that have all the
        requested values for the corresponding attributes will be returned.  

        A if :code:`type` is not :code:`None`, the item will match if it is an
        instance of the type provided.
        
        :param attrs: A set of key-value pairs that represent a filter to apply to the item's attributes.
        :param type:  A type to filter on.  Only items that are an instance of this type will be returned.
        :returns: A List of :class:`Library` objects
        :rtype: List of :class:`Library` objects
        """
        if attrs is not None or type is not None:
            raise NotImplementedError("filtered get not implemented")
        return list(self.libraries.values())
        

    def clear_libraries(self):
        """
        Remove all the :class:`Library` objects from the :code:`libraries` of this :class:`SchematicFile`.
        
        :rtype: :code:`self`
        """
        for efp in list(self.libraries.values()):
            efp.parent = None
        self.libraries = {}
        return self

    def remove_library(self, efp):
        """
        Remove a :class:`Library` from the :code:`libraries` of this :class:`SchematicFile`.
        
        :param efp: The :class:`Library` object to remove.

        :rtype: :code:`self`
        """
        if self.libraries[efp.get_name()] == efp:
            del self.libraries[efp.get_name()]
            efp.parent = None
            return self
        else:
            raise SwoopError("Tried to use remove_library() to delete the wrong kind of child?: {}".format(str(efp)))
    
    def add_attribute(self, s):
        """ Add a :class:`Attribute` to the :code:`attributes` of this :class:`SchematicFile`.

        :param s: The :class:`Attribute` to add.
        :rtype: :code:`self`
        """
        if not any([
                isinstance(s, Attribute),
            ]):
            raise SwoopError("Argument to SchematicFile.add_attribute() should be of type Attribute.  Got " + str(type(s).__name__) + ".")
        

        self.attributes[s.get_name()] = s

        s.parent = self
        return self

    def get_nth_attribute(self, n):
        """ get then nth :class:`Attribute` object from the :code:`attributes` of this :class:`SchematicFile`.
        
        :param n: Index of the item to return.

        :rtype: :class:`Attribute` object
        """
        return list(self.attributes.values())[n]

    def get_attribute(self, key):
        """ Lookup and return a :class:`Attribute` from the :code:`attributes` of  this :class:`SchematicFile`.
        
        :param key: A :code:`str` to use for the lookup.  The lookup uses the :code:`name` of the :class:`Attribute` objects.

        :rtype: A :class:`Attribute` object or :code:`None`, if there is no such item.
        """
        return self.attributes.get(key)


    def get_attributes(self, attrs=None, type=None):
        """Return (and possibly filter) items in the the :code:`attributes` map of :class:`Attribute` objects for this :class:`SchematicFile`.
        
        This functions provides a mechanism for filtering the items as well.
        The keys in :code:`attrs` are taken as attributes names and the
        values are requested values.  Items in the list that have all the
        requested values for the corresponding attributes will be returned.  

        A if :code:`type` is not :code:`None`, the item will match if it is an
        instance of the type provided.
        
        :param attrs: A set of key-value pairs that represent a filter to apply to the item's attributes.
        :param type:  A type to filter on.  Only items that are an instance of this type will be returned.
        :returns: A List of :class:`Attribute` objects
        :rtype: List of :class:`Attribute` objects
        """
        if attrs is not None or type is not None:
            raise NotImplementedError("filtered get not implemented")
        return list(self.attributes.values())
        

    def clear_attributes(self):
        """
        Remove all the :class:`Attribute` objects from the :code:`attributes` of this :class:`SchematicFile`.
        
        :rtype: :code:`self`
        """
        for efp in list(self.attributes.values()):
            efp.parent = None
        self.attributes = {}
        return self

    def remove_attribute(self, efp):
        """
        Remove a :class:`Attribute` from the :code:`attributes` of this :class:`SchematicFile`.
        
        :param efp: The :class:`Attribute` object to remove.

        :rtype: :code:`self`
        """
        if self.attributes[efp.get_name()] == efp:
            del self.attributes[efp.get_name()]
            efp.parent = None
            return self
        else:
            raise SwoopError("Tried to use remove_attribute() to delete the wrong kind of child?: {}".format(str(efp)))
    
    def add_variantdef(self, s):
        """ Add a :class:`Variantdef` to the :code:`variantdefs` of this :class:`SchematicFile`.

        :param s: The :class:`Variantdef` to add.
        :rtype: :code:`self`
        """
        if not any([
                isinstance(s, Variantdef),
            ]):
            raise SwoopError("Argument to SchematicFile.add_variantdef() should be of type Variantdef.  Got " + str(type(s).__name__) + ".")
        

        self.variantdefs[s.get_name()] = s

        s.parent = self
        return self

    def get_nth_variantdef(self, n):
        """ get then nth :class:`Variantdef` object from the :code:`variantdefs` of this :class:`SchematicFile`.
        
        :param n: Index of the item to return.

        :rtype: :class:`Variantdef` object
        """
        return list(self.variantdefs.values())[n]

    def get_variantdef(self, key):
        """ Lookup and return a :class:`Variantdef` from the :code:`variantdefs` of  this :class:`SchematicFile`.
        
        :param key: A :code:`str` to use for the lookup.  The lookup uses the :code:`name` of the :class:`Variantdef` objects.

        :rtype: A :class:`Variantdef` object or :code:`None`, if there is no such item.
        """
        return self.variantdefs.get(key)


    def get_variantdefs(self, attrs=None, type=None):
        """Return (and possibly filter) items in the the :code:`variantdefs` map of :class:`Variantdef` objects for this :class:`SchematicFile`.
        
        This functions provides a mechanism for filtering the items as well.
        The keys in :code:`attrs` are taken as attributes names and the
        values are requested values.  Items in the list that have all the
        requested values for the corresponding attributes will be returned.  

        A if :code:`type` is not :code:`None`, the item will match if it is an
        instance of the type provided.
        
        :param attrs: A set of key-value pairs that represent a filter to apply to the item's attributes.
        :param type:  A type to filter on.  Only items that are an instance of this type will be returned.
        :returns: A List of :class:`Variantdef` objects
        :rtype: List of :class:`Variantdef` objects
        """
        if attrs is not None or type is not None:
            raise NotImplementedError("filtered get not implemented")
        return list(self.variantdefs.values())
        

    def clear_variantdefs(self):
        """
        Remove all the :class:`Variantdef` objects from the :code:`variantdefs` of this :class:`SchematicFile`.
        
        :rtype: :code:`self`
        """
        for efp in list(self.variantdefs.values()):
            efp.parent = None
        self.variantdefs = {}
        return self

    def remove_variantdef(self, efp):
        """
        Remove a :class:`Variantdef` from the :code:`variantdefs` of this :class:`SchematicFile`.
        
        :param efp: The :class:`Variantdef` object to remove.

        :rtype: :code:`self`
        """
        if self.variantdefs[efp.get_name()] == efp:
            del self.variantdefs[efp.get_name()]
            efp.parent = None
            return self
        else:
            raise SwoopError("Tried to use remove_variantdef() to delete the wrong kind of child?: {}".format(str(efp)))
    
    def add_class(self, s):
        """ Add a :class:`Class` to the :code:`classes` of this :class:`SchematicFile`.

        :param s: The :class:`Class` to add.
        :rtype: :code:`self`
        """
        if not any([
                isinstance(s, Class),
            ]):
            raise SwoopError("Argument to SchematicFile.add_class() should be of type Class.  Got " + str(type(s).__name__) + ".")
        

        self.classes[s.get_name()] = s

        s.parent = self
        return self

    def get_nth_class(self, n):
        """ get then nth :class:`Class` object from the :code:`classes` of this :class:`SchematicFile`.
        
        :param n: Index of the item to return.

        :rtype: :class:`Class` object
        """
        return list(self.classes.values())[n]

    def get_class(self, key):
        """ Lookup and return a :class:`Class` from the :code:`classes` of  this :class:`SchematicFile`.
        
        :param key: A :code:`str` to use for the lookup.  The lookup uses the :code:`name` of the :class:`Class` objects.

        :rtype: A :class:`Class` object or :code:`None`, if there is no such item.
        """
        return self.classes.get(key)


    def get_classes(self, attrs=None, type=None):
        """Return (and possibly filter) items in the the :code:`classes` map of :class:`Class` objects for this :class:`SchematicFile`.
        
        This functions provides a mechanism for filtering the items as well.
        The keys in :code:`attrs` are taken as attributes names and the
        values are requested values.  Items in the list that have all the
        requested values for the corresponding attributes will be returned.  

        A if :code:`type` is not :code:`None`, the item will match if it is an
        instance of the type provided.
        
        :param attrs: A set of key-value pairs that represent a filter to apply to the item's attributes.
        :param type:  A type to filter on.  Only items that are an instance of this type will be returned.
        :returns: A List of :class:`Class` objects
        :rtype: List of :class:`Class` objects
        """
        if attrs is not None or type is not None:
            raise NotImplementedError("filtered get not implemented")
        return list(self.classes.values())
        

    def clear_classes(self):
        """
        Remove all the :class:`Class` objects from the :code:`classes` of this :class:`SchematicFile`.
        
        :rtype: :code:`self`
        """
        for efp in list(self.classes.values()):
            efp.parent = None
        self.classes = {}
        return self

    def remove_class(self, efp):
        """
        Remove a :class:`Class` from the :code:`classes` of this :class:`SchematicFile`.
        
        :param efp: The :class:`Class` object to remove.

        :rtype: :code:`self`
        """
        if self.classes[efp.get_name()] == efp:
            del self.classes[efp.get_name()]
            efp.parent = None
            return self
        else:
            raise SwoopError("Tried to use remove_class() to delete the wrong kind of child?: {}".format(str(efp)))
    
    def add_module(self, s):
        """ Add a :class:`Module` to the :code:`modules` of this :class:`SchematicFile`.

        :param s: The :class:`Module` to add.
        :rtype: :code:`self`
        """
        if not any([
                isinstance(s, Module),
            ]):
            raise SwoopError("Argument to SchematicFile.add_module() should be of type Module.  Got " + str(type(s).__name__) + ".")
        

        self.modules[s.get_name()] = s

        s.parent = self
        return self

    def get_nth_module(self, n):
        """ get then nth :class:`Module` object from the :code:`modules` of this :class:`SchematicFile`.
        
        :param n: Index of the item to return.

        :rtype: :class:`Module` object
        """
        return list(self.modules.values())[n]

    def get_module(self, key):
        """ Lookup and return a :class:`Module` from the :code:`modules` of  this :class:`SchematicFile`.
        
        :param key: A :code:`str` to use for the lookup.  The lookup uses the :code:`name` of the :class:`Module` objects.

        :rtype: A :class:`Module` object or :code:`None`, if there is no such item.
        """
        return self.modules.get(key)


    def get_modules(self, attrs=None, type=None):
        """Return (and possibly filter) items in the the :code:`modules` map of :class:`Module` objects for this :class:`SchematicFile`.
        
        This functions provides a mechanism for filtering the items as well.
        The keys in :code:`attrs` are taken as attributes names and the
        values are requested values.  Items in the list that have all the
        requested values for the corresponding attributes will be returned.  

        A if :code:`type` is not :code:`None`, the item will match if it is an
        instance of the type provided.
        
        :param attrs: A set of key-value pairs that represent a filter to apply to the item's attributes.
        :param type:  A type to filter on.  Only items that are an instance of this type will be returned.
        :returns: A List of :class:`Module` objects
        :rtype: List of :class:`Module` objects
        """
        if attrs is not None or type is not None:
            raise NotImplementedError("filtered get not implemented")
        return list(self.modules.values())
        

    def clear_modules(self):
        """
        Remove all the :class:`Module` objects from the :code:`modules` of this :class:`SchematicFile`.
        
        :rtype: :code:`self`
        """
        for efp in list(self.modules.values()):
            efp.parent = None
        self.modules = {}
        return self

    def remove_module(self, efp):
        """
        Remove a :class:`Module` from the :code:`modules` of this :class:`SchematicFile`.
        
        :param efp: The :class:`Module` object to remove.

        :rtype: :code:`self`
        """
        if self.modules[efp.get_name()] == efp:
            del self.modules[efp.get_name()]
            efp.parent = None
            return self
        else:
            raise SwoopError("Tried to use remove_module() to delete the wrong kind of child?: {}".format(str(efp)))
    
    def add_part(self, s):
        """ Add a :class:`Part` to the :code:`parts` of this :class:`SchematicFile`.

        :param s: The :class:`Part` to add.
        :rtype: :code:`self`
        """
        if not any([
                isinstance(s, Part),
            ]):
            raise SwoopError("Argument to SchematicFile.add_part() should be of type Part.  Got " + str(type(s).__name__) + ".")
        

        self.parts[s.get_name()] = s

        s.parent = self
        return self

    def get_nth_part(self, n):
        """ get then nth :class:`Part` object from the :code:`parts` of this :class:`SchematicFile`.
        
        :param n: Index of the item to return.

        :rtype: :class:`Part` object
        """
        return list(self.parts.values())[n]

    def get_part(self, key):
        """ Lookup and return a :class:`Part` from the :code:`parts` of  this :class:`SchematicFile`.
        
        :param key: A :code:`str` to use for the lookup.  The lookup uses the :code:`name` of the :class:`Part` objects.

        :rtype: A :class:`Part` object or :code:`None`, if there is no such item.
        """
        return self.parts.get(key)


    def get_parts(self, attrs=None, type=None):
        """Return (and possibly filter) items in the the :code:`parts` map of :class:`Part` objects for this :class:`SchematicFile`.
        
        This functions provides a mechanism for filtering the items as well.
        The keys in :code:`attrs` are taken as attributes names and the
        values are requested values.  Items in the list that have all the
        requested values for the corresponding attributes will be returned.  

        A if :code:`type` is not :code:`None`, the item will match if it is an
        instance of the type provided.
        
        :param attrs: A set of key-value pairs that represent a filter to apply to the item's attributes.
        :param type:  A type to filter on.  Only items that are an instance of this type will be returned.
        :returns: A List of :class:`Part` objects
        :rtype: List of :class:`Part` objects
        """
        if attrs is not None or type is not None:
            raise NotImplementedError("filtered get not implemented")
        return list(self.parts.values())
        

    def clear_parts(self):
        """
        Remove all the :class:`Part` objects from the :code:`parts` of this :class:`SchematicFile`.
        
        :rtype: :code:`self`
        """
        for efp in list(self.parts.values()):
            efp.parent = None
        self.parts = {}
        return self

    def remove_part(self, efp):
        """
        Remove a :class:`Part` from the :code:`parts` of this :class:`SchematicFile`.
        
        :param efp: The :class:`Part` object to remove.

        :rtype: :code:`self`
        """
        if self.parts[efp.get_name()] == efp:
            del self.parts[efp.get_name()]
            efp.parent = None
            return self
        else:
            raise SwoopError("Tried to use remove_part() to delete the wrong kind of child?: {}".format(str(efp)))
    


    
    ### Getter/Setter for singletons.

    def set_grid(self, s):
        """ Set the :class:`Grid` for this  :class:`SchematicFile`.

        :param s: :class:`Grid` to set.
        :rtype: :code:`self`
        """
        if self.grid is not None:
            self.grid.parent = None
        self.grid = s
        if s is not None:
            s.parent = self
        return self

    def get_grid(self):
        """ Get the grid from this :class:`SchematicFile`.
        
        :rtype: :class:`Grid` object
        """
        return self.grid

    def set_schematic(self, s):
        """ Set the :class:`Schematic` for this  :class:`SchematicFile`.

        :param s: :class:`Schematic` to set.
        :rtype: :code:`self`
        """
        if self.schematic is not None:
            self.schematic.parent = None
        self.schematic = s
        if s is not None:
            s.parent = self
        return self

    def get_schematic(self):
        """ Get the schematic from this :class:`SchematicFile`.
        
        :rtype: :class:`Schematic` object
        """
        return self.schematic

    def set_description(self, s):
        """ Set the :class:`Description` for this  :class:`SchematicFile`.

        :param s: :class:`Description` to set.
        :rtype: :code:`self`
        """
        if self.description is not None:
            self.description.parent = None
        self.description = s
        if s is not None:
            s.parent = self
        return self

    def get_description(self):
        """ Get the description from this :class:`SchematicFile`.
        
        :rtype: :class:`Description` object
        """
        return self.description

    def set_compatibility(self, s):
        """ Set the :class:`Compatibility` for this  :class:`SchematicFile`.

        :param s: :class:`Compatibility` to set.
        :rtype: :code:`self`
        """
        if self.compatibility is not None:
            self.compatibility.parent = None
        self.compatibility = s
        if s is not None:
            s.parent = self
        return self

    def get_compatibility(self):
        """ Get the compatibility from this :class:`SchematicFile`.
        
        :rtype: :class:`Compatibility` object
        """
        return self.compatibility


    
    def get_children(self):
        """
        Get all the children of this :class:`EagleFilePart`.
        
        :rtype: List of :class:`EagleFilePart` objects
        """
        r = []

        r = r + self.settings
        r = r + self.sheets
        r = r + self.approved_errors

        r = r + list(self.layers.values())
        r = r + list(self.libraries.values())
        r = r + list(self.attributes.values())
        r = r + list(self.variantdefs.values())
        r = r + list(self.classes.values())
        r = r + list(self.modules.values())
        r = r + list(self.parts.values())

        if self.grid is not None:
            r = r + [self.grid]
        if self.schematic is not None:
            r = r + [self.schematic]
        if self.description is not None:
            r = r + [self.description]
        if self.compatibility is not None:
            r = r + [self.compatibility]

        return r

    def remove_child(self, efp):
        """
        Remove a child :class:`EagleFilePart` object.
        
        :param efp: the class:`EagleFilePart` object to remove.
        :return: Nothing
        """
        try:
            self.remove_layer(efp)
        except:
            pass
        try:
            self.remove_library(efp)
        except:
            pass
        try:
            self.remove_attribute(efp)
        except:
            pass
        try:
            self.remove_variantdef(efp)
        except:
            pass
        try:
            self.remove_class(efp)
        except:
            pass
        try:
            self.remove_module(efp)
        except:
            pass
        try:
            self.remove_part(efp)
        except:
            pass
        try:
            self.remove_setting(efp)
        except:
            pass
        try:
            self.remove_sheet(efp)
        except:
            pass
        try:
            self.remove_approved(efp)
        except:
            pass
        if self.get_grid() == efp:
            self.set_grid(None)
        if self.get_schematic() == efp:
            self.set_schematic(None)
        if self.get_description() == efp:
            self.set_description(None)
        if self.get_compatibility() == efp:
            self.set_compatibility(None)

    def _rekey_child(self, oldkey, efp):
        """
        Remove a child :class:`EagleFilePart` object.
        
        :param efp: the class:`EagleFilePart` object to remove.
        :return: Nothing
        """
        try:
            if self.get_layer(oldkey) == efp:
                del self.layers[oldkey]
                self.add_layer(efp)
        except SwoopError:
            pass
        try:
            if self.get_library(oldkey) == efp:
                del self.libraries[oldkey]
                self.add_library(efp)
        except SwoopError:
            pass
        try:
            if self.get_attribute(oldkey) == efp:
                del self.attributes[oldkey]
                self.add_attribute(efp)
        except SwoopError:
            pass
        try:
            if self.get_variantdef(oldkey) == efp:
                del self.variantdefs[oldkey]
                self.add_variantdef(efp)
        except SwoopError:
            pass
        try:
            if self.get_class(oldkey) == efp:
                del self.classes[oldkey]
                self.add_class(efp)
        except SwoopError:
            pass
        try:
            if self.get_module(oldkey) == efp:
                del self.modules[oldkey]
                self.add_module(efp)
        except SwoopError:
            pass
        try:
            if self.get_part(oldkey) == efp:
                del self.parts[oldkey]
                self.add_part(efp)
        except SwoopError:
            pass

    def check_sanity(self, visited_efps = None):
        EagleFile.check_sanity(self, visited_efps)

        # Check whether keys in our maps match the keys in our children
        for k in self.layers:
            if self.layers[k].get_number() != k:
                raise SwoopError("Child's number ('{}') doesn't match key in parent's map ('{}')".format(self.layers[k].get_number(),k))
        for k in self.libraries:
            if self.libraries[k].get_name() != k:
                raise SwoopError("Child's name ('{}') doesn't match key in parent's map ('{}')".format(self.libraries[k].get_name(),k))
        for k in self.attributes:
            if self.attributes[k].get_name() != k:
                raise SwoopError("Child's name ('{}') doesn't match key in parent's map ('{}')".format(self.attributes[k].get_name(),k))
        for k in self.variantdefs:
            if self.variantdefs[k].get_name() != k:
                raise SwoopError("Child's name ('{}') doesn't match key in parent's map ('{}')".format(self.variantdefs[k].get_name(),k))
        for k in self.classes:
            if self.classes[k].get_name() != k:
                raise SwoopError("Child's name ('{}') doesn't match key in parent's map ('{}')".format(self.classes[k].get_name(),k))
        for k in self.modules:
            if self.modules[k].get_name() != k:
                raise SwoopError("Child's name ('{}') doesn't match key in parent's map ('{}')".format(self.modules[k].get_name(),k))
        for k in self.parts:
            if self.parts[k].get_name() != k:
                raise SwoopError("Child's name ('{}') doesn't match key in parent's map ('{}')".format(self.parts[k].get_name(),k))

    def __str__(self):
        r = "["+repr(self)+" "
        r = r + "version:" + str(self.get_version()) + " "
        r = r + "]"
        return r
            
    def dump(self, indent="", increment="   "):
        """
        Recursive debug dump.
        
        :param indent:  Indentation string.  The output will be indented by this much.
        :param increment: This will be appendeded to :code:`indent` on recursive invocations.

        :rtype: :code:`None`
        """
        print(indent + str(self.__class__.__name__), end=' ')
        try:
            print(self.get_name())
        except:
            print()
            pass
        for c in self.get_children():
            c.dump(indent + "   ")

        
EagleFile.class_map["eagle"] = SchematicFile
         


class Element(EagleFilePart, OnePointGeometry, RotationGeometry):
    """
    Class representing the contents of a <element> tag in Eagle files.

    Attributes:

    * :code:`name`

    * :code:`library`

    * :code:`library_urn`

    * :code:`package`

    * :code:`package3d_urn`

    * :code:`value`

    * :code:`x`

    * :code:`y`

    * :code:`locked`

    * :code:`populate`

    * :code:`smashed`

    * :code:`rot`



    Collections:


    * :code:`attribute`: List of :class:`Attribute` objects.



    """
    def __init__(self):
        """
        Construct an empty :class:`Element` object.
        """
        EagleFilePart.__init__(self)
        OnePointGeometry.__init__(self)
        RotationGeometry.__init__(self)
        
        self.name=None
        self.library=None
        self.library_urn=None
        self.package=None
        self.package3d_urn=None
        self.value=None
        self.x=None
        self.y=None
        self.locked=None
        self.populate=None
        self.smashed=None
        self.rot=None
        self.attributes=[]


        
    @classmethod
    def _from_et(cls,root,parent):
        """
        Create a :class:`Element` from a :code:`element` element.
        
        :param root: The element tree tree to parse.
        :param parent: :class:`EagleFilePart` that should hold the resulting :class:`EagleFilePart`
        :rtype: :class:`Element`
        """
        ## Call the constructor
        n = cls()
        n._init_from_et(root,parent)
        return n

    def _get_error_name(self):
        if hasattr(self, "get_name"):
            return self.get_name();
        else:
            return "Element";
        
    def  _init_from_et(self, root, parent):
        """
        Initialized a :class:`Element` from a :code:`element` element.  This is useful if you have a subclass of :class:`Element` .
        
        :param root: The element tree tree to parse.
        :param parent: :class:`EagleFilePart` that will become the parent of :code:`this` .
        :rtype: :class:`Element`
        """
        try:
            self.root = root
            
            if root.tag != "element":
                raise EagleFormatError("Tried to create element from " + root.tag)

            self.name=parseByType(parent, "str", None, root.get("name"))
            self.library=parseByType(parent, "str", None, root.get("library"))
            self.library_urn=parseByType(parent, "str", None, root.get("library_urn"))
            self.package=parseByType(parent, "str", None, root.get("package"))
            self.package3d_urn=parseByType(parent, "str", None, root.get("package3d_urn"))
            self.value=parseByType(parent, "str", None, root.get("value"))
            self.x=parseByType(parent, "float", None, root.get("x"))
            self.y=parseByType(parent, "float", None, root.get("y"))
            self.locked=parseByType(parent, "locked_bool", None, root.get("locked"))
            self.populate=parseByType(parent, "bool", None, root.get("populate"))
            self.smashed=parseByType(parent, "str", None, root.get("smashed"))
            self.rot=parseByType(parent, "str", None, root.get("rot"))

            self.parent = parent

            ### populate the maps by searching for elements that match xpath and generating objects for them.


            ### Do the same for the lists

            for c in root.xpath("./attribute"):
                self.add_attribute(self.get_class_for_tag(c.tag)._from_et(c,self))

            ### Do the same for the attr lists


            ### And the singletons


            ### And, finally, if the objects wants the text from the tag.

        except SwoopError as e:
            e.text = "{}:{}".format(self._get_error_name(), e.text)
            raise e


    def sortkey(self):
        r = ""
        r = r + str(self.name)
        r = r + str(self.library)
        r = r + str(self.library_urn)
        r = r + str(self.package)
        r = r + str(self.package3d_urn)
        r = r + str(self.value)
        r = r + str(self.x)
        r = r + str(self.y)
        r = r + str(self.locked)
        r = r + str(self.populate)
        r = r + str(self.smashed)
        r = r + str(self.rot)
        return r

    def get_et(self):
        """
        Generate a <element> element tree for a :class:`Element`.
        
        :rtype:  :class:`ElementTree`.
        
        """
        try:
            r = ET.Element("element")

            ### Set the tag attributes 


            ## Unparse the values.

            v = unparseByType(self, "str", None,  self.name)

            ## For required attributes None becomes "".  For optional attributes, we just leave the attribute out.
            if not (isinstance(self.get_parent(), LibraryFile) and False):  # special case for the name of library.
                if v is not None:
                    r.set("name", v)
                else:
                    r.set("name", "")


            ## Unparse the values.

            v = unparseByType(self, "str", None,  self.library)

            ## For required attributes None becomes "".  For optional attributes, we just leave the attribute out.
            if not (isinstance(self.get_parent(), LibraryFile) and False):  # special case for the name of library.
                if v is not None:
                    r.set("library", v)
                else:
                    r.set("library", "")


            ## Unparse the values.

            v = unparseByType(self, "str", None,  self.library_urn)

            ## For required attributes None becomes "".  For optional attributes, we just leave the attribute out.
            if not (isinstance(self.get_parent(), LibraryFile) and False):  # special case for the name of library.
                if v is not None:
                    r.set("library_urn", v)


            ## Unparse the values.

            v = unparseByType(self, "str", None,  self.package)

            ## For required attributes None becomes "".  For optional attributes, we just leave the attribute out.
            if not (isinstance(self.get_parent(), LibraryFile) and False):  # special case for the name of library.
                if v is not None:
                    r.set("package", v)
                else:
                    r.set("package", "")


            ## Unparse the values.

            v = unparseByType(self, "str", None,  self.package3d_urn)

            ## For required attributes None becomes "".  For optional attributes, we just leave the attribute out.
            if not (isinstance(self.get_parent(), LibraryFile) and False):  # special case for the name of library.
                if v is not None:
                    r.set("package3d_urn", v)


            ## Unparse the values.

            v = unparseByType(self, "str", None,  self.value)

            ## For required attributes None becomes "".  For optional attributes, we just leave the attribute out.
            if not (isinstance(self.get_parent(), LibraryFile) and False):  # special case for the name of library.
                if v is not None:
                    r.set("value", v)
                else:
                    r.set("value", "")


            ## Unparse the values.

            v = unparseByType(self, "float", None,  self.x)

            ## For required attributes None becomes "".  For optional attributes, we just leave the attribute out.
            if not (isinstance(self.get_parent(), LibraryFile) and False):  # special case for the name of library.
                if v is not None:
                    r.set("x", v)
                else:
                    r.set("x", "")


            ## Unparse the values.

            v = unparseByType(self, "float", None,  self.y)

            ## For required attributes None becomes "".  For optional attributes, we just leave the attribute out.
            if not (isinstance(self.get_parent(), LibraryFile) and False):  # special case for the name of library.
                if v is not None:
                    r.set("y", v)
                else:
                    r.set("y", "")


            ## Unparse the values.

            v = unparseByType(self, "locked_bool", None,  self.locked)

            ## For required attributes None becomes "".  For optional attributes, we just leave the attribute out.
            if not (isinstance(self.get_parent(), LibraryFile) and False):  # special case for the name of library.
                if v is not None:
                    r.set("locked", v)


            ## Unparse the values.

            v = unparseByType(self, "bool", None,  self.populate)

            ## For required attributes None becomes "".  For optional attributes, we just leave the attribute out.
            if not (isinstance(self.get_parent(), LibraryFile) and False):  # special case for the name of library.
                if v is not None:
                    r.set("populate", v)


            ## Unparse the values.

            v = unparseByType(self, "str", None,  self.smashed)

            ## For required attributes None becomes "".  For optional attributes, we just leave the attribute out.
            if not (isinstance(self.get_parent(), LibraryFile) and False):  # special case for the name of library.
                if v is not None:
                    r.set("smashed", v)


            ## Unparse the values.

            v = unparseByType(self, "str", None,  self.rot)

            ## For required attributes None becomes "".  For optional attributes, we just leave the attribute out.
            if not (isinstance(self.get_parent(), LibraryFile) and False):  # special case for the name of library.
                if v is not None:
                    r.set("rot", v)


            ### process the sections in order.  They have to be in section order,
            ### because eagle files are order dependent.


            ## For some tags, Eagle generates empty tags when there's no contant
            ## rather than just leaving the tag out.  We mark these with
            ## Tag.requireTag in GenerateSwoop.py and force their generation
            ## here.

            smartAddSubTags(r, "./attribute")


            ## add a list.

            if len(self.attributes) is not 0:
                target = smartAddSubTags(r, "./attribute")
                # add them in sorted order.  This gives us a simple canonicalization that makes it feasible to use diff to compare files.
                target.extend([i.get_et() for i in sorted(self.attributes,key=lambda x: x.sortkey())])


            ## set the text, if its needed.

        except SwoopError as e:
            e.text = "{}:{}".format(self._get_error_name(), e.text)
            raise e
        return r

    def clone(self):
        """
        Recursively clone this :code:`Element`.  It will be identical to the original, but it's parent will be :code:`None`.
        
        :rtype: :class:`Element`
        """
        try:
            n = copy.copy(self)
            n.attributes = []
            for x in self.attributes:
                n.add_attribute(x.clone())
            n.parent = None
        except SwoopError as e:
            e.text = "{}:{}".format(self._get_error_name(), e.text)
            raise e
        return n

    def accept_preorder_visitor(self, visitor):
        try:
            pre = getattr(visitor, "Element_pre")
            return pre(self)
        except AttributeError:
            return visitor.default_pre(self)
        
    def accept_postorder_visitor(self, visitor, context):
        try:
            post = getattr(visitor, "Element_post")
            post(self,context)
        except AttributeError:
            visitor.default_post(self,context)

    def is_equal(self, other):
        """
        Check whether two :code:`EagleFilePart` objects are identical.
        
        :param other: Object to compare to.
        :returns: :code:`True` if they are identical, otherwise, :code:`False`
        """
        return self.get_xml() == other.get_xml()
        
    ### Getters/Setters for attribute values

    def get_name(self):
        """ Return the value of :code:`name` for this :class:`Element`.  This corresponds to the :code:`name` attribute of a :code:`<element>` in an Eagle file.
        
        :rtype: :code:`str`
        """
        return self.name

    def set_name(self,v):
        """ Set the value of :code:`name` for this  :class:`Element`.  This corresponds to the :code:`name` attribute of a :code:`<element>` in an Eagle file.

        :param v: new value
        :rtype: :code:`self`
        """
                        
        oldkey = self.name
        if not typeCheck("str", v, True):
            raise SwoopError("Illegal value ({}) of type {} for attribute 'name' of Element object (should be str).".format(v, type(v)))
        self.name = v
        
        if self.get_parent() is not None:
            self.get_parent()._rekey_child(oldkey, self);
        return self

    def with_name(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`name`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`name` equals :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_name()` is :code:`True`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """

        if type(v) in [str, int, float, bool]:
            return self if self.name == v else None
        elif callable(v):
            return self if v(self.name) else None
        else:
            raise SwoopError("Illegal type passed to with_name")

    def without_name(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`name`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`name` is not equal to :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_name()` is :code:`False`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """
        
        if type(v) in [str, int, float, bool]:
            return self if self.name != v else None
        elif callable(v):
            return self if not v(self.name) else None
        else:
            raise SwoopError("Illegal type passed to without_name")


    def get_library(self):
        """ Return the value of :code:`library` for this :class:`Element`.  This corresponds to the :code:`library` attribute of a :code:`<element>` in an Eagle file.
        
        :rtype: :code:`str`
        """
        return self.library

    def set_library(self,v):
        """ Set the value of :code:`library` for this  :class:`Element`.  This corresponds to the :code:`library` attribute of a :code:`<element>` in an Eagle file.

        :param v: new value
        :rtype: :code:`self`
        """
                        
        if not typeCheck("str", v, True):
            raise SwoopError("Illegal value ({}) of type {} for attribute 'library' of Element object (should be str).".format(v, type(v)))
        self.library = v
        
        return self

    def with_library(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`library`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`library` equals :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_library()` is :code:`True`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """

        if type(v) in [str, int, float, bool]:
            return self if self.library == v else None
        elif callable(v):
            return self if v(self.library) else None
        else:
            raise SwoopError("Illegal type passed to with_library")

    def without_library(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`library`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`library` is not equal to :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_library()` is :code:`False`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """
        
        if type(v) in [str, int, float, bool]:
            return self if self.library != v else None
        elif callable(v):
            return self if not v(self.library) else None
        else:
            raise SwoopError("Illegal type passed to without_library")


    def get_library_urn(self):
        """ Return the value of :code:`library_urn` for this :class:`Element`.  This corresponds to the :code:`library_urn` attribute of a :code:`<element>` in an Eagle file.
        
        :rtype: :code:`str`
        """
        return self.library_urn

    def set_library_urn(self,v):
        """ Set the value of :code:`library_urn` for this  :class:`Element`.  This corresponds to the :code:`library_urn` attribute of a :code:`<element>` in an Eagle file.

        :param v: new value
        :rtype: :code:`self`
        """
                        
        if not typeCheck("str", v, False):
            raise SwoopError("Illegal value ({}) of type {} for attribute 'library_urn' of Element object (should be str).".format(v, type(v)))
        self.library_urn = v
        
        return self

    def with_library_urn(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`library_urn`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`library_urn` equals :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_library_urn()` is :code:`True`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """

        if type(v) in [str, int, float, bool]:
            return self if self.library_urn == v else None
        elif callable(v):
            return self if v(self.library_urn) else None
        else:
            raise SwoopError("Illegal type passed to with_library_urn")

    def without_library_urn(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`library_urn`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`library_urn` is not equal to :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_library_urn()` is :code:`False`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """
        
        if type(v) in [str, int, float, bool]:
            return self if self.library_urn != v else None
        elif callable(v):
            return self if not v(self.library_urn) else None
        else:
            raise SwoopError("Illegal type passed to without_library_urn")


    def get_package(self):
        """ Return the value of :code:`package` for this :class:`Element`.  This corresponds to the :code:`package` attribute of a :code:`<element>` in an Eagle file.
        
        :rtype: :code:`str`
        """
        return self.package

    def set_package(self,v):
        """ Set the value of :code:`package` for this  :class:`Element`.  This corresponds to the :code:`package` attribute of a :code:`<element>` in an Eagle file.

        :param v: new value
        :rtype: :code:`self`
        """
                        
        if not typeCheck("str", v, True):
            raise SwoopError("Illegal value ({}) of type {} for attribute 'package' of Element object (should be str).".format(v, type(v)))
        self.package = v
        
        return self

    def with_package(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`package`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`package` equals :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_package()` is :code:`True`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """

        if type(v) in [str, int, float, bool]:
            return self if self.package == v else None
        elif callable(v):
            return self if v(self.package) else None
        else:
            raise SwoopError("Illegal type passed to with_package")

    def without_package(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`package`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`package` is not equal to :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_package()` is :code:`False`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """
        
        if type(v) in [str, int, float, bool]:
            return self if self.package != v else None
        elif callable(v):
            return self if not v(self.package) else None
        else:
            raise SwoopError("Illegal type passed to without_package")


    def get_package3d_urn(self):
        """ Return the value of :code:`package3d_urn` for this :class:`Element`.  This corresponds to the :code:`package3d_urn` attribute of a :code:`<element>` in an Eagle file.
        
        :rtype: :code:`str`
        """
        return self.package3d_urn

    def set_package3d_urn(self,v):
        """ Set the value of :code:`package3d_urn` for this  :class:`Element`.  This corresponds to the :code:`package3d_urn` attribute of a :code:`<element>` in an Eagle file.

        :param v: new value
        :rtype: :code:`self`
        """
                        
        if not typeCheck("str", v, False):
            raise SwoopError("Illegal value ({}) of type {} for attribute 'package3d_urn' of Element object (should be str).".format(v, type(v)))
        self.package3d_urn = v
        
        return self

    def with_package3d_urn(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`package3d_urn`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`package3d_urn` equals :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_package3d_urn()` is :code:`True`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """

        if type(v) in [str, int, float, bool]:
            return self if self.package3d_urn == v else None
        elif callable(v):
            return self if v(self.package3d_urn) else None
        else:
            raise SwoopError("Illegal type passed to with_package3d_urn")

    def without_package3d_urn(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`package3d_urn`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`package3d_urn` is not equal to :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_package3d_urn()` is :code:`False`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """
        
        if type(v) in [str, int, float, bool]:
            return self if self.package3d_urn != v else None
        elif callable(v):
            return self if not v(self.package3d_urn) else None
        else:
            raise SwoopError("Illegal type passed to without_package3d_urn")


    def get_value(self):
        """ Return the value of :code:`value` for this :class:`Element`.  This corresponds to the :code:`value` attribute of a :code:`<element>` in an Eagle file.
        
        :rtype: :code:`str`
        """
        return self.value

    def set_value(self,v):
        """ Set the value of :code:`value` for this  :class:`Element`.  This corresponds to the :code:`value` attribute of a :code:`<element>` in an Eagle file.

        :param v: new value
        :rtype: :code:`self`
        """
                        
        if not typeCheck("str", v, True):
            raise SwoopError("Illegal value ({}) of type {} for attribute 'value' of Element object (should be str).".format(v, type(v)))
        self.value = v
        
        return self

    def with_value(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`value`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`value` equals :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_value()` is :code:`True`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """

        if type(v) in [str, int, float, bool]:
            return self if self.value == v else None
        elif callable(v):
            return self if v(self.value) else None
        else:
            raise SwoopError("Illegal type passed to with_value")

    def without_value(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`value`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`value` is not equal to :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_value()` is :code:`False`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """
        
        if type(v) in [str, int, float, bool]:
            return self if self.value != v else None
        elif callable(v):
            return self if not v(self.value) else None
        else:
            raise SwoopError("Illegal type passed to without_value")


    def get_x(self):
        """ Return the value of :code:`x` for this :class:`Element`.  This corresponds to the :code:`x` attribute of a :code:`<element>` in an Eagle file.
        
        :rtype: :code:`float`
        """
        return self.x

    def set_x(self,v):
        """ Set the value of :code:`x` for this  :class:`Element`.  This corresponds to the :code:`x` attribute of a :code:`<element>` in an Eagle file.

        :param v: new value
        :rtype: :code:`self`
        """
                        
        if not typeCheck("float", v, True):
            raise SwoopError("Illegal value ({}) of type {} for attribute 'x' of Element object (should be float).".format(v, type(v)))
        self.x = v
        
        return self

    def with_x(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`x`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`x` equals :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_x()` is :code:`True`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """

        if type(v) in [str, int, float, bool]:
            return self if self.x == v else None
        elif callable(v):
            return self if v(self.x) else None
        else:
            raise SwoopError("Illegal type passed to with_x")

    def without_x(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`x`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`x` is not equal to :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_x()` is :code:`False`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """
        
        if type(v) in [str, int, float, bool]:
            return self if self.x != v else None
        elif callable(v):
            return self if not v(self.x) else None
        else:
            raise SwoopError("Illegal type passed to without_x")


    def get_y(self):
        """ Return the value of :code:`y` for this :class:`Element`.  This corresponds to the :code:`y` attribute of a :code:`<element>` in an Eagle file.
        
        :rtype: :code:`float`
        """
        return self.y

    def set_y(self,v):
        """ Set the value of :code:`y` for this  :class:`Element`.  This corresponds to the :code:`y` attribute of a :code:`<element>` in an Eagle file.

        :param v: new value
        :rtype: :code:`self`
        """
                        
        if not typeCheck("float", v, True):
            raise SwoopError("Illegal value ({}) of type {} for attribute 'y' of Element object (should be float).".format(v, type(v)))
        self.y = v
        
        return self

    def with_y(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`y`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`y` equals :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_y()` is :code:`True`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """

        if type(v) in [str, int, float, bool]:
            return self if self.y == v else None
        elif callable(v):
            return self if v(self.y) else None
        else:
            raise SwoopError("Illegal type passed to with_y")

    def without_y(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`y`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`y` is not equal to :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_y()` is :code:`False`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """
        
        if type(v) in [str, int, float, bool]:
            return self if self.y != v else None
        elif callable(v):
            return self if not v(self.y) else None
        else:
            raise SwoopError("Illegal type passed to without_y")


    def get_locked(self):
        """ Return the value of :code:`locked` for this :class:`Element`.  This corresponds to the :code:`locked` attribute of a :code:`<element>` in an Eagle file.
        
        :rtype: :code:`locked_bool`
        """
        return self.locked

    def set_locked(self,v):
        """ Set the value of :code:`locked` for this  :class:`Element`.  This corresponds to the :code:`locked` attribute of a :code:`<element>` in an Eagle file.

        :param v: new value
        :rtype: :code:`self`
        """
                        
        if not typeCheck("locked_bool", v, False):
            raise SwoopError("Illegal value ({}) of type {} for attribute 'locked' of Element object (should be locked_bool).".format(v, type(v)))
        self.locked = v
        
        return self

    def with_locked(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`locked`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`locked` equals :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_locked()` is :code:`True`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """

        if type(v) in [str, int, float, bool]:
            return self if self.locked == v else None
        elif callable(v):
            return self if v(self.locked) else None
        else:
            raise SwoopError("Illegal type passed to with_locked")

    def without_locked(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`locked`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`locked` is not equal to :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_locked()` is :code:`False`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """
        
        if type(v) in [str, int, float, bool]:
            return self if self.locked != v else None
        elif callable(v):
            return self if not v(self.locked) else None
        else:
            raise SwoopError("Illegal type passed to without_locked")


    def get_populate(self):
        """ Return the value of :code:`populate` for this :class:`Element`.  This corresponds to the :code:`populate` attribute of a :code:`<element>` in an Eagle file.
        
        :rtype: :code:`bool`
        """
        return self.populate

    def set_populate(self,v):
        """ Set the value of :code:`populate` for this  :class:`Element`.  This corresponds to the :code:`populate` attribute of a :code:`<element>` in an Eagle file.

        :param v: new value
        :rtype: :code:`self`
        """
                        
        if not typeCheck("bool", v, False):
            raise SwoopError("Illegal value ({}) of type {} for attribute 'populate' of Element object (should be bool).".format(v, type(v)))
        self.populate = v
        
        return self

    def with_populate(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`populate`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`populate` equals :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_populate()` is :code:`True`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """

        if type(v) in [str, int, float, bool]:
            return self if self.populate == v else None
        elif callable(v):
            return self if v(self.populate) else None
        else:
            raise SwoopError("Illegal type passed to with_populate")

    def without_populate(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`populate`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`populate` is not equal to :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_populate()` is :code:`False`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """
        
        if type(v) in [str, int, float, bool]:
            return self if self.populate != v else None
        elif callable(v):
            return self if not v(self.populate) else None
        else:
            raise SwoopError("Illegal type passed to without_populate")


    def get_smashed(self):
        """ Return the value of :code:`smashed` for this :class:`Element`.  This corresponds to the :code:`smashed` attribute of a :code:`<element>` in an Eagle file.
        
        :rtype: :code:`str`
        """
        return self.smashed

    def set_smashed(self,v):
        """ Set the value of :code:`smashed` for this  :class:`Element`.  This corresponds to the :code:`smashed` attribute of a :code:`<element>` in an Eagle file.

        :param v: new value
        :rtype: :code:`self`
        """
                        
        if not typeCheck("str", v, False):
            raise SwoopError("Illegal value ({}) of type {} for attribute 'smashed' of Element object (should be str).".format(v, type(v)))
        self.smashed = v
        
        return self

    def with_smashed(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`smashed`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`smashed` equals :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_smashed()` is :code:`True`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """

        if type(v) in [str, int, float, bool]:
            return self if self.smashed == v else None
        elif callable(v):
            return self if v(self.smashed) else None
        else:
            raise SwoopError("Illegal type passed to with_smashed")

    def without_smashed(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`smashed`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`smashed` is not equal to :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_smashed()` is :code:`False`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """
        
        if type(v) in [str, int, float, bool]:
            return self if self.smashed != v else None
        elif callable(v):
            return self if not v(self.smashed) else None
        else:
            raise SwoopError("Illegal type passed to without_smashed")


    def get_rot(self):
        """ Return the value of :code:`rot` for this :class:`Element`.  This corresponds to the :code:`rot` attribute of a :code:`<element>` in an Eagle file.
        
        :rtype: :code:`str`
        """
        return self.rot

    def set_rot(self,v):
        """ Set the value of :code:`rot` for this  :class:`Element`.  This corresponds to the :code:`rot` attribute of a :code:`<element>` in an Eagle file.

        :param v: new value
        :rtype: :code:`self`
        """
                        
        if not typeCheck("str", v, False):
            raise SwoopError("Illegal value ({}) of type {} for attribute 'rot' of Element object (should be str).".format(v, type(v)))
        self.rot = v
        
        return self

    def with_rot(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`rot`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`rot` equals :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_rot()` is :code:`True`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """

        if type(v) in [str, int, float, bool]:
            return self if self.rot == v else None
        elif callable(v):
            return self if v(self.rot) else None
        else:
            raise SwoopError("Illegal type passed to with_rot")

    def without_rot(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`rot`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`rot` is not equal to :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_rot()` is :code:`False`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """
        
        if type(v) in [str, int, float, bool]:
            return self if self.rot != v else None
        elif callable(v):
            return self if not v(self.rot) else None
        else:
            raise SwoopError("Illegal type passed to without_rot")



    ##### Lookup functions that return EFPs instead of just attribute values.
    
    def find_library(self):
        """Find the :class:`Library` object refered to by the :code:`library` attribute of this object.  This is like
        :meth:`get_library`, except it returns the :class:`Library` object instead of its name.
        
        :returns: The object
        :rtype: :class:`Library`

        """
        f = lambda efp, key: efp.get_parent().get_library(key)
        return f(self, self.library)
    def find_package(self):
        """Find the :class:`Package` object refered to by the :code:`package` attribute of this object.  This is like
        :meth:`get_package`, except it returns the :class:`Package` object instead of its name.
        
        :returns: The object
        :rtype: :class:`Package`

        """
        f = lambda efp, key: efp.find_library().get_package(key)
        return f(self, self.package)
    


    
    ### Adder/getter/lookup for lists
    
    def add_attribute(self, s):
        """ Add a :class:`Attribute` to the :code:`attributes` of this :class:`Element`.

        :param s: The :class:`Attribute` to add.
        :rtype: :code:`self`
        """
        if not any([
                isinstance(s, Attribute),
            ]):
            raise SwoopError("Argument to Element.add_attribute() should be of type Attribute.  Got " + str(type(s).__name__) + ".")
        
        self.attributes.append(s)
        if s.parent is not None and s.parent is not self:
            s.parent.remove_attribute(s)

        s.parent = self
        return self

    def get_nth_attribute(self, n):
        """ get then nth :class:`Attribute` object from the :code:`attributes` of this :class:`Element`.
        
        :param n: Index of the item to return.

        :rtype: :class:`Attribute` object
        """
        return self.attributes[n]

    def get_attributes(self, attrs=None, type=None):
        """Return (and possibly filter) items in the the :code:`attributes` list of :class:`Attribute` objects for this :class:`Element`.
        
        This functions provides a mechanism for filtering the items as well.
        The keys in :code:`attrs` are taken as attributes names and the
        values are requested values.  Items in the list that have all the
        requested values for the corresponding attributes will be returned.  

        A if :code:`type` is not :code:`None`, the item will match if it is an
        instance of the type provided.
        
        :param attrs: A set of key-value pairs that represent a filter to apply to the item's attributes.
        :param type:  A type to filter on.  Only items that are an instance of this type will be returned.
        :returns: A List of :class:`Attribute` objects
        :rtype: List of :class:`Attribute` objects
        """
        if attrs is not None or type is not None:
            raise NotImplementedError("filtered get not implemented.")
        return self.attributes

    def clear_attributes(self):
        """
        Remove all the :class:`Attribute` objects from the :code:`attributes` of this :class:`Element`.
        
        :rtype: :code:`self`
        """
        for efp in self.attributes:
            efp.parent = None
        self.attributes = []
        return self

    def remove_attribute(self, efp):
        """
        Remove a :class:`Attribute` from the :code:`attributes` of this :class:`Element`.
        
        :param efp: The :class:`Attribute` object to remove.

        :rtype: :code:`self`
        """
        self.attributes = [x for x in self.attributes if x != efp]

        if efp.parent is self:
            efp.parent = None
        return self



    ### Add, lookup, and get for maps


    
    ### Getter/Setter for singletons.


    
    def get_children(self):
        """
        Get all the children of this :class:`EagleFilePart`.
        
        :rtype: List of :class:`EagleFilePart` objects
        """
        r = []

        r = r + self.attributes



        return r

    def remove_child(self, efp):
        """
        Remove a child :class:`EagleFilePart` object.
        
        :param efp: the class:`EagleFilePart` object to remove.
        :return: Nothing
        """
        try:
            self.remove_attribute(efp)
        except:
            pass

    def _rekey_child(self, oldkey, efp):
        """
        Remove a child :class:`EagleFilePart` object.
        
        :param efp: the class:`EagleFilePart` object to remove.
        :return: Nothing
        """


    def __str__(self):
        r = "["+repr(self)+" "
        r = r + "name:" + str(self.get_name()) + " "
        r = r + "library:" + str(self.get_library()) + " "
        r = r + "library_urn:" + str(self.get_library_urn()) + " "
        r = r + "package:" + str(self.get_package()) + " "
        r = r + "package3d_urn:" + str(self.get_package3d_urn()) + " "
        r = r + "value:" + str(self.get_value()) + " "
        r = r + "x:" + str(self.get_x()) + " "
        r = r + "y:" + str(self.get_y()) + " "
        r = r + "locked:" + str(self.get_locked()) + " "
        r = r + "populate:" + str(self.get_populate()) + " "
        r = r + "smashed:" + str(self.get_smashed()) + " "
        r = r + "rot:" + str(self.get_rot()) + " "
        r = r + "]"
        return r
            
    def dump(self, indent="", increment="   "):
        """
        Recursive debug dump.
        
        :param indent:  Indentation string.  The output will be indented by this much.
        :param increment: This will be appendeded to :code:`indent` on recursive invocations.

        :rtype: :code:`None`
        """
        print(indent + str(self.__class__.__name__), end=' ')
        try:
            print(self.get_name())
        except:
            print()
            pass
        for c in self.get_children():
            c.dump(indent + "   ")

        
EagleFile.class_map["element"] = Element
         


class Base_LibraryFile(EagleFile):
    """
    Class representing the contents of a <eagle> tag in Eagle files.

    Attributes:

    * :code:`version`



    Collections:

    * :code:`grid`: Singleton :class:`Grid` object. 

    * :code:`library`: Singleton :class:`Library` object. 

    * :code:`compatibility`: Singleton :class:`Compatibility` object. 


    * :code:`setting`: List of :class:`Setting` objects.


    * :code:`layer`: Map of :class:`Layer` objects indexed by their :code:`number`.



    """
    def __init__(self):
        """
        Construct an empty :class:`Base_LibraryFile` object.
        """
        EagleFile.__init__(self)
        
        self.version=None
        self.settings=[]
        self.layers={} #tecollections.OrderedDict()  For unclear reasons, this caused ordering to become more unpredictable, rather than less.
        self.grid=None
        self.library=None
        self.compatibility=None


        
    @classmethod
    def _from_et(cls,root,parent):
        """
        Create a :class:`LibraryFile` from a :code:`eagle` element.
        
        :param root: The element tree tree to parse.
        :param parent: :class:`EagleFilePart` that should hold the resulting :class:`EagleFilePart`
        :rtype: :class:`LibraryFile`
        """
        ## Call the constructor
        n = cls()
        n._init_from_et(root,parent)
        return n

    def _get_error_name(self):
        if hasattr(self, "get_name"):
            return self.get_name();
        else:
            return "LibraryFile";
        
    def  _init_from_et(self, root, parent):
        """
        Initialized a :class:`LibraryFile` from a :code:`eagle` element.  This is useful if you have a subclass of :class:`LibraryFile` .
        
        :param root: The element tree tree to parse.
        :param parent: :class:`EagleFilePart` that will become the parent of :code:`this` .
        :rtype: :class:`LibraryFile`
        """
        try:
            self.root = root
            
            if root.tag != "eagle":
                raise EagleFormatError("Tried to create eagle from " + root.tag)

            self.version=parseByType(parent, "str", None, root.get("version"))

            self.parent = parent

            ### populate the maps by searching for elements that match xpath and generating objects for them.

            for c in root.xpath("./drawing/layers/layer"):
                self.add_layer(self.get_class_for_tag(c.tag)._from_et(c, self))

            ### Do the same for the lists

            for c in root.xpath("./drawing/settings/setting"):
                self.add_setting(self.get_class_for_tag(c.tag)._from_et(c,self))

            ### Do the same for the attr lists


            ### And the singletons

            x = root.xpath("./drawing/grid")
            if len(x) is not 0:
                self.set_grid(self.get_class_for_tag(x[0].tag)._from_et(x[0],self))
            x = root.xpath("./drawing/library")
            if len(x) is not 0:
                self.set_library(self.get_class_for_tag(x[0].tag)._from_et(x[0],self))
            x = root.xpath("./compatibility")
            if len(x) is not 0:
                self.set_compatibility(self.get_class_for_tag(x[0].tag)._from_et(x[0],self))

            ### And, finally, if the objects wants the text from the tag.

        except SwoopError as e:
            e.text = "{}:{}".format(self._get_error_name(), e.text)
            raise e


    def sortkey(self):
        r = ""
        r = r + str(self.version)
        return r

    def get_et(self):
        """
        Generate a <eagle> element tree for a :class:`LibraryFile`.
        
        :rtype:  :class:`ElementTree`.
        
        """
        try:
            r = ET.Element("eagle")

            ### Set the tag attributes 


            ## Unparse the values.

            v = unparseByType(self, "str", None,  self.version)

            ## For required attributes None becomes "".  For optional attributes, we just leave the attribute out.
            if not (isinstance(self.get_parent(), LibraryFile) and False):  # special case for the name of library.
                if v is not None:
                    r.set("version", v)
                else:
                    r.set("version", "")


            ### process the sections in order.  They have to be in section order,
            ### because eagle files are order dependent.


            ## For some tags, Eagle generates empty tags when there's no contant
            ## rather than just leaving the tag out.  We mark these with
            ## Tag.requireTag in GenerateSwoop.py and force their generation
            ## here.

            smartAddSubTags(r, "./drawing/settings/setting")


            ## add a list.

            if len(self.settings) is not 0:
                target = smartAddSubTags(r, "./drawing/settings/setting")
                # add them in sorted order.  This gives us a simple canonicalization that makes it feasible to use diff to compare files.
                target.extend([i.get_et() for i in sorted(self.settings,key=lambda x: x.sortkey())])


            ## For some tags, Eagle generates empty tags when there's no contant
            ## rather than just leaving the tag out.  We mark these with
            ## Tag.requireTag in GenerateSwoop.py and force their generation
            ## here.



            ## or add a singleton.

            if self.grid is not None:
                target = smartAddSubTags(r, "./drawing/grid")
                target.append(self.grid.get_et())

            ## For some tags, Eagle generates empty tags when there's no contant
            ## rather than just leaving the tag out.  We mark these with
            ## Tag.requireTag in GenerateSwoop.py and force their generation
            ## here.



            ## add a map.

            if len(self.layers) is not 0:
                target = smartAddSubTags(r, "./drawing/layers/layer")
                # add them in sorted order.  This gives us a simple canonicalization that makes it feasible to use diff to compare files.
                target.extend([i.get_et() for i in sorted(list(self.layers.values()),key=lambda x: x.sortkey())])


            ## For some tags, Eagle generates empty tags when there's no contant
            ## rather than just leaving the tag out.  We mark these with
            ## Tag.requireTag in GenerateSwoop.py and force their generation
            ## here.



            ## or add a singleton.

            if self.library is not None:
                target = smartAddSubTags(r, "./drawing/library")
                target.append(self.library.get_et())

            ## For some tags, Eagle generates empty tags when there's no contant
            ## rather than just leaving the tag out.  We mark these with
            ## Tag.requireTag in GenerateSwoop.py and force their generation
            ## here.



            ## or add a singleton.

            if self.compatibility is not None:
                target = smartAddSubTags(r, "./compatibility")
                target.append(self.compatibility.get_et())

            ## set the text, if its needed.

        except SwoopError as e:
            e.text = "{}:{}".format(self._get_error_name(), e.text)
            raise e
        return r

    def clone(self):
        """
        Recursively clone this :code:`LibraryFile`.  It will be identical to the original, but it's parent will be :code:`None`.
        
        :rtype: :class:`LibraryFile`
        """
        try:
            n = copy.copy(self)
            n.layers = {}
            for x in list(self.layers.values()):
                n.add_layer(x.clone())
            n.settings = []
            for x in self.settings:
                n.add_setting(x.clone())
            n.grid = None
            if self.grid is not None:
                n.set_grid(self.grid.clone())
            else:
                n.set_grid(None)
            n.library = None
            if self.library is not None:
                n.set_library(self.library.clone())
            else:
                n.set_library(None)
            n.compatibility = None
            if self.compatibility is not None:
                n.set_compatibility(self.compatibility.clone())
            else:
                n.set_compatibility(None)
            n.parent = None
        except SwoopError as e:
            e.text = "{}:{}".format(self._get_error_name(), e.text)
            raise e
        return n

    def accept_preorder_visitor(self, visitor):
        try:
            pre = getattr(visitor, "LibraryFile_pre")
            return pre(self)
        except AttributeError:
            return visitor.default_pre(self)
        
    def accept_postorder_visitor(self, visitor, context):
        try:
            post = getattr(visitor, "LibraryFile_post")
            post(self,context)
        except AttributeError:
            visitor.default_post(self,context)

    def is_equal(self, other):
        """
        Check whether two :code:`EagleFilePart` objects are identical.
        
        :param other: Object to compare to.
        :returns: :code:`True` if they are identical, otherwise, :code:`False`
        """
        return self.get_xml() == other.get_xml()
        
    ### Getters/Setters for attribute values

    def get_version(self):
        """ Return the value of :code:`version` for this :class:`LibraryFile`.  This corresponds to the :code:`version` attribute of a :code:`<eagle>` in an Eagle file.
        
        :rtype: :code:`str`
        """
        return self.version

    def set_version(self,v):
        """ Set the value of :code:`version` for this  :class:`LibraryFile`.  This corresponds to the :code:`version` attribute of a :code:`<eagle>` in an Eagle file.

        :param v: new value
        :rtype: :code:`self`
        """
                        
        if not typeCheck("str", v, True):
            raise SwoopError("Illegal value ({}) of type {} for attribute 'version' of LibraryFile object (should be str).".format(v, type(v)))
        self.version = v
        
        return self

    def with_version(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`version`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`version` equals :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_version()` is :code:`True`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """

        if type(v) in [str, int, float, bool]:
            return self if self.version == v else None
        elif callable(v):
            return self if v(self.version) else None
        else:
            raise SwoopError("Illegal type passed to with_version")

    def without_version(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`version`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`version` is not equal to :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_version()` is :code:`False`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """
        
        if type(v) in [str, int, float, bool]:
            return self if self.version != v else None
        elif callable(v):
            return self if not v(self.version) else None
        else:
            raise SwoopError("Illegal type passed to without_version")



    ##### Lookup functions that return EFPs instead of just attribute values.
    
    


    
    ### Adder/getter/lookup for lists
    
    def add_setting(self, s):
        """ Add a :class:`Setting` to the :code:`settings` of this :class:`LibraryFile`.

        :param s: The :class:`Setting` to add.
        :rtype: :code:`self`
        """
        if not any([
                isinstance(s, Setting),
            ]):
            raise SwoopError("Argument to Base_LibraryFile.add_setting() should be of type Setting.  Got " + str(type(s).__name__) + ".")
        
        self.settings.append(s)
        if s.parent is not None and s.parent is not self:
            s.parent.remove_setting(s)

        s.parent = self
        return self

    def get_nth_setting(self, n):
        """ get then nth :class:`Setting` object from the :code:`settings` of this :class:`LibraryFile`.
        
        :param n: Index of the item to return.

        :rtype: :class:`Setting` object
        """
        return self.settings[n]

    def get_settings(self, attrs=None, type=None):
        """Return (and possibly filter) items in the the :code:`settings` list of :class:`Setting` objects for this :class:`LibraryFile`.
        
        This functions provides a mechanism for filtering the items as well.
        The keys in :code:`attrs` are taken as attributes names and the
        values are requested values.  Items in the list that have all the
        requested values for the corresponding attributes will be returned.  

        A if :code:`type` is not :code:`None`, the item will match if it is an
        instance of the type provided.
        
        :param attrs: A set of key-value pairs that represent a filter to apply to the item's attributes.
        :param type:  A type to filter on.  Only items that are an instance of this type will be returned.
        :returns: A List of :class:`Setting` objects
        :rtype: List of :class:`Setting` objects
        """
        if attrs is not None or type is not None:
            raise NotImplementedError("filtered get not implemented.")
        return self.settings

    def clear_settings(self):
        """
        Remove all the :class:`Setting` objects from the :code:`settings` of this :class:`LibraryFile`.
        
        :rtype: :code:`self`
        """
        for efp in self.settings:
            efp.parent = None
        self.settings = []
        return self

    def remove_setting(self, efp):
        """
        Remove a :class:`Setting` from the :code:`settings` of this :class:`LibraryFile`.
        
        :param efp: The :class:`Setting` object to remove.

        :rtype: :code:`self`
        """
        self.settings = [x for x in self.settings if x != efp]

        if efp.parent is self:
            efp.parent = None
        return self



    ### Add, lookup, and get for maps


    
    ### Getter/Setter for singletons.

    def set_grid(self, s):
        """ Set the :class:`Grid` for this  :class:`LibraryFile`.

        :param s: :class:`Grid` to set.
        :rtype: :code:`self`
        """
        if self.grid is not None:
            self.grid.parent = None
        self.grid = s
        if s is not None:
            s.parent = self
        return self

    def get_grid(self):
        """ Get the grid from this :class:`LibraryFile`.
        
        :rtype: :class:`Grid` object
        """
        return self.grid

    def set_library(self, s):
        """ Set the :class:`Library` for this  :class:`LibraryFile`.

        :param s: :class:`Library` to set.
        :rtype: :code:`self`
        """
        if self.library is not None:
            self.library.parent = None
        self.library = s
        if s is not None:
            s.parent = self
        return self

    def get_library(self):
        """ Get the library from this :class:`LibraryFile`.
        
        :rtype: :class:`Library` object
        """
        return self.library

    def set_compatibility(self, s):
        """ Set the :class:`Compatibility` for this  :class:`LibraryFile`.

        :param s: :class:`Compatibility` to set.
        :rtype: :code:`self`
        """
        if self.compatibility is not None:
            self.compatibility.parent = None
        self.compatibility = s
        if s is not None:
            s.parent = self
        return self

    def get_compatibility(self):
        """ Get the compatibility from this :class:`LibraryFile`.
        
        :rtype: :class:`Compatibility` object
        """
        return self.compatibility


    
    def get_children(self):
        """
        Get all the children of this :class:`EagleFilePart`.
        
        :rtype: List of :class:`EagleFilePart` objects
        """
        r = []

        r = r + self.settings

        r = r + list(self.layers.values())

        if self.grid is not None:
            r = r + [self.grid]
        if self.library is not None:
            r = r + [self.library]
        if self.compatibility is not None:
            r = r + [self.compatibility]

        return r

    def remove_child(self, efp):
        """
        Remove a child :class:`EagleFilePart` object.
        
        :param efp: the class:`EagleFilePart` object to remove.
        :return: Nothing
        """
        try:
            self.remove_layer(efp)
        except:
            pass
        try:
            self.remove_setting(efp)
        except:
            pass
        if self.get_grid() == efp:
            self.set_grid(None)
        if self.get_library() == efp:
            self.set_library(None)
        if self.get_compatibility() == efp:
            self.set_compatibility(None)

    def _rekey_child(self, oldkey, efp):
        """
        Remove a child :class:`EagleFilePart` object.
        
        :param efp: the class:`EagleFilePart` object to remove.
        :return: Nothing
        """
        try:
            if self.get_layer(oldkey) == efp:
                del self.layers[oldkey]
                self.add_layer(efp)
        except SwoopError:
            pass

    def check_sanity(self, visited_efps = None):
        EagleFile.check_sanity(self, visited_efps)

        # Check whether keys in our maps match the keys in our children
        for k in self.layers:
            if self.layers[k].get_number() != k:
                raise SwoopError("Child's number ('{}') doesn't match key in parent's map ('{}')".format(self.layers[k].get_number(),k))

    def __str__(self):
        r = "["+repr(self)+" "
        r = r + "version:" + str(self.get_version()) + " "
        r = r + "]"
        return r
            
    def dump(self, indent="", increment="   "):
        """
        Recursive debug dump.
        
        :param indent:  Indentation string.  The output will be indented by this much.
        :param increment: This will be appendeded to :code:`indent` on recursive invocations.

        :rtype: :code:`None`
        """
        print(indent + str(self.__class__.__name__), end=' ')
        try:
            print(self.get_name())
        except:
            print()
            pass
        for c in self.get_children():
            c.dump(indent + "   ")

        
EagleFile.class_map["eagle"] = Base_LibraryFile
         


class Compatibility(EagleFilePart):
    """
    Class representing the contents of a <compatibility> tag in Eagle files.

    Attributes:



    Collections:


    * :code:`note`: List of :class:`Note` objects.



    """
    def __init__(self):
        """
        Construct an empty :class:`Compatibility` object.
        """
        EagleFilePart.__init__(self)
        
        self.notes=[]


        
    @classmethod
    def _from_et(cls,root,parent):
        """
        Create a :class:`Compatibility` from a :code:`compatibility` element.
        
        :param root: The element tree tree to parse.
        :param parent: :class:`EagleFilePart` that should hold the resulting :class:`EagleFilePart`
        :rtype: :class:`Compatibility`
        """
        ## Call the constructor
        n = cls()
        n._init_from_et(root,parent)
        return n

    def _get_error_name(self):
        if hasattr(self, "get_name"):
            return self.get_name();
        else:
            return "Compatibility";
        
    def  _init_from_et(self, root, parent):
        """
        Initialized a :class:`Compatibility` from a :code:`compatibility` element.  This is useful if you have a subclass of :class:`Compatibility` .
        
        :param root: The element tree tree to parse.
        :param parent: :class:`EagleFilePart` that will become the parent of :code:`this` .
        :rtype: :class:`Compatibility`
        """
        try:
            self.root = root
            
            if root.tag != "compatibility":
                raise EagleFormatError("Tried to create compatibility from " + root.tag)


            self.parent = parent

            ### populate the maps by searching for elements that match xpath and generating objects for them.


            ### Do the same for the lists

            for c in root.xpath("./note"):
                self.add_note(self.get_class_for_tag(c.tag)._from_et(c,self))

            ### Do the same for the attr lists


            ### And the singletons


            ### And, finally, if the objects wants the text from the tag.

        except SwoopError as e:
            e.text = "{}:{}".format(self._get_error_name(), e.text)
            raise e


    def sortkey(self):
        r = ""
        return r

    def get_et(self):
        """
        Generate a <compatibility> element tree for a :class:`Compatibility`.
        
        :rtype:  :class:`ElementTree`.
        
        """
        try:
            r = ET.Element("compatibility")

            ### Set the tag attributes 


            ### process the sections in order.  They have to be in section order,
            ### because eagle files are order dependent.


            ## For some tags, Eagle generates empty tags when there's no contant
            ## rather than just leaving the tag out.  We mark these with
            ## Tag.requireTag in GenerateSwoop.py and force their generation
            ## here.



            ## add a list.

            if len(self.notes) is not 0:
                target = smartAddSubTags(r, "./note")
                # add them in sorted order.  This gives us a simple canonicalization that makes it feasible to use diff to compare files.
                target.extend([i.get_et() for i in sorted(self.notes,key=lambda x: x.sortkey())])


            ## set the text, if its needed.

        except SwoopError as e:
            e.text = "{}:{}".format(self._get_error_name(), e.text)
            raise e
        return r

    def clone(self):
        """
        Recursively clone this :code:`Compatibility`.  It will be identical to the original, but it's parent will be :code:`None`.
        
        :rtype: :class:`Compatibility`
        """
        try:
            n = copy.copy(self)
            n.notes = []
            for x in self.notes:
                n.add_note(x.clone())
            n.parent = None
        except SwoopError as e:
            e.text = "{}:{}".format(self._get_error_name(), e.text)
            raise e
        return n

    def accept_preorder_visitor(self, visitor):
        try:
            pre = getattr(visitor, "Compatibility_pre")
            return pre(self)
        except AttributeError:
            return visitor.default_pre(self)
        
    def accept_postorder_visitor(self, visitor, context):
        try:
            post = getattr(visitor, "Compatibility_post")
            post(self,context)
        except AttributeError:
            visitor.default_post(self,context)

    def is_equal(self, other):
        """
        Check whether two :code:`EagleFilePart` objects are identical.
        
        :param other: Object to compare to.
        :returns: :code:`True` if they are identical, otherwise, :code:`False`
        """
        return self.get_xml() == other.get_xml()
        
    ### Getters/Setters for attribute values


    ##### Lookup functions that return EFPs instead of just attribute values.
    
    


    
    ### Adder/getter/lookup for lists
    
    def add_note(self, s):
        """ Add a :class:`Note` to the :code:`notes` of this :class:`Compatibility`.

        :param s: The :class:`Note` to add.
        :rtype: :code:`self`
        """
        if not any([
                isinstance(s, Note),
            ]):
            raise SwoopError("Argument to Compatibility.add_note() should be of type Note.  Got " + str(type(s).__name__) + ".")
        
        self.notes.append(s)
        if s.parent is not None and s.parent is not self:
            s.parent.remove_note(s)

        s.parent = self
        return self

    def get_nth_note(self, n):
        """ get then nth :class:`Note` object from the :code:`notes` of this :class:`Compatibility`.
        
        :param n: Index of the item to return.

        :rtype: :class:`Note` object
        """
        return self.notes[n]

    def get_notes(self, attrs=None, type=None):
        """Return (and possibly filter) items in the the :code:`notes` list of :class:`Note` objects for this :class:`Compatibility`.
        
        This functions provides a mechanism for filtering the items as well.
        The keys in :code:`attrs` are taken as attributes names and the
        values are requested values.  Items in the list that have all the
        requested values for the corresponding attributes will be returned.  

        A if :code:`type` is not :code:`None`, the item will match if it is an
        instance of the type provided.
        
        :param attrs: A set of key-value pairs that represent a filter to apply to the item's attributes.
        :param type:  A type to filter on.  Only items that are an instance of this type will be returned.
        :returns: A List of :class:`Note` objects
        :rtype: List of :class:`Note` objects
        """
        if attrs is not None or type is not None:
            raise NotImplementedError("filtered get not implemented.")
        return self.notes

    def clear_notes(self):
        """
        Remove all the :class:`Note` objects from the :code:`notes` of this :class:`Compatibility`.
        
        :rtype: :code:`self`
        """
        for efp in self.notes:
            efp.parent = None
        self.notes = []
        return self

    def remove_note(self, efp):
        """
        Remove a :class:`Note` from the :code:`notes` of this :class:`Compatibility`.
        
        :param efp: The :class:`Note` object to remove.

        :rtype: :code:`self`
        """
        self.notes = [x for x in self.notes if x != efp]

        if efp.parent is self:
            efp.parent = None
        return self



    ### Add, lookup, and get for maps


    
    ### Getter/Setter for singletons.


    
    def get_children(self):
        """
        Get all the children of this :class:`EagleFilePart`.
        
        :rtype: List of :class:`EagleFilePart` objects
        """
        r = []

        r = r + self.notes



        return r

    def remove_child(self, efp):
        """
        Remove a child :class:`EagleFilePart` object.
        
        :param efp: the class:`EagleFilePart` object to remove.
        :return: Nothing
        """
        try:
            self.remove_note(efp)
        except:
            pass

    def _rekey_child(self, oldkey, efp):
        """
        Remove a child :class:`EagleFilePart` object.
        
        :param efp: the class:`EagleFilePart` object to remove.
        :return: Nothing
        """


    def __str__(self):
        r = "["+repr(self)+" "
        r = r + "]"
        return r
            
    def dump(self, indent="", increment="   "):
        """
        Recursive debug dump.
        
        :param indent:  Indentation string.  The output will be indented by this much.
        :param increment: This will be appendeded to :code:`indent` on recursive invocations.

        :rtype: :code:`None`
        """
        print(indent + str(self.__class__.__name__), end=' ')
        try:
            print(self.get_name())
        except:
            print()
            pass
        for c in self.get_children():
            c.dump(indent + "   ")

        
EagleFile.class_map["compatibility"] = Compatibility
         


class Clearance(EagleFilePart):
    """
    Class representing the contents of a <clearance> tag in Eagle files.

    Attributes:

    * :code:`class`

    * :code:`value`


    """
    def __init__(self):
        """
        Construct an empty :class:`Clearance` object.
        """
        EagleFilePart.__init__(self)
        
        self.netclass=None
        self.value=None


        
    @classmethod
    def _from_et(cls,root,parent):
        """
        Create a :class:`Clearance` from a :code:`clearance` element.
        
        :param root: The element tree tree to parse.
        :param parent: :class:`EagleFilePart` that should hold the resulting :class:`EagleFilePart`
        :rtype: :class:`Clearance`
        """
        ## Call the constructor
        n = cls()
        n._init_from_et(root,parent)
        return n

    def _get_error_name(self):
        if hasattr(self, "get_name"):
            return self.get_name();
        else:
            return "Clearance";
        
    def  _init_from_et(self, root, parent):
        """
        Initialized a :class:`Clearance` from a :code:`clearance` element.  This is useful if you have a subclass of :class:`Clearance` .
        
        :param root: The element tree tree to parse.
        :param parent: :class:`EagleFilePart` that will become the parent of :code:`this` .
        :rtype: :class:`Clearance`
        """
        try:
            self.root = root
            
            if root.tag != "clearance":
                raise EagleFormatError("Tried to create clearance from " + root.tag)

            self.netclass=parseByType(parent, "str", None, root.get("class"))
            self.value=parseByType(parent, "float", None, root.get("value"))

            self.parent = parent

            ### populate the maps by searching for elements that match xpath and generating objects for them.


            ### Do the same for the lists


            ### Do the same for the attr lists


            ### And the singletons


            ### And, finally, if the objects wants the text from the tag.

        except SwoopError as e:
            e.text = "{}:{}".format(self._get_error_name(), e.text)
            raise e


    def sortkey(self):
        r = ""
        r = r + str(self.netclass)
        r = r + str(self.value)
        return r

    def get_et(self):
        """
        Generate a <clearance> element tree for a :class:`Clearance`.
        
        :rtype:  :class:`ElementTree`.
        
        """
        try:
            r = ET.Element("clearance")

            ### Set the tag attributes 


            ## Unparse the values.

            v = unparseByType(self, "str", None,  self.netclass)

            ## For required attributes None becomes "".  For optional attributes, we just leave the attribute out.
            if not (isinstance(self.get_parent(), LibraryFile) and False):  # special case for the name of library.
                if v is not None:
                    r.set("class", v)
                else:
                    r.set("class", "")


            ## Unparse the values.

            v = unparseByType(self, "float", None,  self.value)

            ## For required attributes None becomes "".  For optional attributes, we just leave the attribute out.
            if not (isinstance(self.get_parent(), LibraryFile) and False):  # special case for the name of library.
                if v is not None:
                    r.set("value", v)


            ### process the sections in order.  They have to be in section order,
            ### because eagle files are order dependent.


            ## set the text, if its needed.

        except SwoopError as e:
            e.text = "{}:{}".format(self._get_error_name(), e.text)
            raise e
        return r

    def clone(self):
        """
        Recursively clone this :code:`Clearance`.  It will be identical to the original, but it's parent will be :code:`None`.
        
        :rtype: :class:`Clearance`
        """
        try:
            n = copy.copy(self)
            n.parent = None
        except SwoopError as e:
            e.text = "{}:{}".format(self._get_error_name(), e.text)
            raise e
        return n

    def accept_preorder_visitor(self, visitor):
        try:
            pre = getattr(visitor, "Clearance_pre")
            return pre(self)
        except AttributeError:
            return visitor.default_pre(self)
        
    def accept_postorder_visitor(self, visitor, context):
        try:
            post = getattr(visitor, "Clearance_post")
            post(self,context)
        except AttributeError:
            visitor.default_post(self,context)

    def is_equal(self, other):
        """
        Check whether two :code:`EagleFilePart` objects are identical.
        
        :param other: Object to compare to.
        :returns: :code:`True` if they are identical, otherwise, :code:`False`
        """
        return self.get_xml() == other.get_xml()
        
    ### Getters/Setters for attribute values

    def get_class(self):
        """ Return the value of :code:`netclass` for this :class:`Clearance`.  This corresponds to the :code:`netclass` attribute of a :code:`<clearance>` in an Eagle file.
        
        :rtype: :code:`str`
        """
        return self.netclass

    def set_class(self,v):
        """ Set the value of :code:`netclass` for this  :class:`Clearance`.  This corresponds to the :code:`netclass` attribute of a :code:`<clearance>` in an Eagle file.

        :param v: new value
        :rtype: :code:`self`
        """
                        
        oldkey = self.netclass
        if not typeCheck("str", v, True):
            raise SwoopError("Illegal value ({}) of type {} for attribute 'netclass' of Clearance object (should be str).".format(v, type(v)))
        self.netclass = v
        
        if self.get_parent() is not None:
            self.get_parent()._rekey_child(oldkey, self);
        return self

    def with_class(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`netclass`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`netclass` equals :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_class()` is :code:`True`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """

        if type(v) in [str, int, float, bool]:
            return self if self.netclass == v else None
        elif callable(v):
            return self if v(self.netclass) else None
        else:
            raise SwoopError("Illegal type passed to with_class")

    def without_class(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`netclass`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`netclass` is not equal to :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_class()` is :code:`False`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """
        
        if type(v) in [str, int, float, bool]:
            return self if self.netclass != v else None
        elif callable(v):
            return self if not v(self.netclass) else None
        else:
            raise SwoopError("Illegal type passed to without_class")


    def get_value(self):
        """ Return the value of :code:`value` for this :class:`Clearance`.  This corresponds to the :code:`value` attribute of a :code:`<clearance>` in an Eagle file.
        
        :rtype: :code:`float`
        """
        return self.value

    def set_value(self,v):
        """ Set the value of :code:`value` for this  :class:`Clearance`.  This corresponds to the :code:`value` attribute of a :code:`<clearance>` in an Eagle file.

        :param v: new value
        :rtype: :code:`self`
        """
                        
        if not typeCheck("float", v, False):
            raise SwoopError("Illegal value ({}) of type {} for attribute 'value' of Clearance object (should be float).".format(v, type(v)))
        self.value = v
        
        return self

    def with_value(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`value`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`value` equals :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_value()` is :code:`True`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """

        if type(v) in [str, int, float, bool]:
            return self if self.value == v else None
        elif callable(v):
            return self if v(self.value) else None
        else:
            raise SwoopError("Illegal type passed to with_value")

    def without_value(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`value`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`value` is not equal to :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_value()` is :code:`False`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """
        
        if type(v) in [str, int, float, bool]:
            return self if self.value != v else None
        elif callable(v):
            return self if not v(self.value) else None
        else:
            raise SwoopError("Illegal type passed to without_value")



    ##### Lookup functions that return EFPs instead of just attribute values.
    
    def find_class(self):
        """Find the :class:`Class` object refered to by the :code:`netclass` attribute of this object.  This is like
        :meth:`get_netclass`, except it returns the :class:`Class` object instead of its name.
        
        :returns: The object
        :rtype: :class:`Class`

        """
        f = lambda efp, key: NotImplemented('Lookup of class from clearance not implemented.')
        return f(self, self.netclass)
    


    
    ### Adder/getter/lookup for lists
    


    ### Add, lookup, and get for maps


    
    ### Getter/Setter for singletons.


    
    def get_children(self):
        """
        Get all the children of this :class:`EagleFilePart`.
        
        :rtype: List of :class:`EagleFilePart` objects
        """
        r = []




        return r

    def remove_child(self, efp):
        """
        Remove a child :class:`EagleFilePart` object.
        
        :param efp: the class:`EagleFilePart` object to remove.
        :return: Nothing
        """

    def _rekey_child(self, oldkey, efp):
        """
        Remove a child :class:`EagleFilePart` object.
        
        :param efp: the class:`EagleFilePart` object to remove.
        :return: Nothing
        """


    def __str__(self):
        r = "["+repr(self)+" "
        r = r + "netclass:" + str(self.get_class()) + " "
        r = r + "value:" + str(self.get_value()) + " "
        r = r + "]"
        return r
            
    def dump(self, indent="", increment="   "):
        """
        Recursive debug dump.
        
        :param indent:  Indentation string.  The output will be indented by this much.
        :param increment: This will be appendeded to :code:`indent` on recursive invocations.

        :rtype: :code:`None`
        """
        print(indent + str(self.__class__.__name__), end=' ')
        try:
            print(self.get_name())
        except:
            print()
            pass
        for c in self.get_children():
            c.dump(indent + "   ")

        
EagleFile.class_map["clearance"] = Clearance
         


class Dimension(EagleFilePart, MeasureGeometry):
    """
    Class representing the contents of a <dimension> tag in Eagle files.

    Attributes:

    * :code:`x1`

    * :code:`y1`

    * :code:`x2`

    * :code:`y2`

    * :code:`x3`

    * :code:`y3`

    * :code:`layer`

    * :code:`dtype`

    * :code:`width`

    * :code:`extwidth`

    * :code:`extlength`

    * :code:`extoffset`

    * :code:`textsize`

    * :code:`textratio`

    * :code:`unit`

    * :code:`precision`

    * :code:`visible`


    """
    def __init__(self):
        """
        Construct an empty :class:`Dimension` object.
        """
        EagleFilePart.__init__(self)
        MeasureGeometry.__init__(self)
        
        self.x1=None
        self.y1=None
        self.x2=None
        self.y2=None
        self.x3=None
        self.y3=None
        self.layer=None
        self.dtype=None
        self.width=None
        self.extwidth=None
        self.extlength=None
        self.extoffset=None
        self.textsize=None
        self.textratio=None
        self.unit=None
        self.precision=None
        self.visible=None


        
    @classmethod
    def _from_et(cls,root,parent):
        """
        Create a :class:`Dimension` from a :code:`dimension` element.
        
        :param root: The element tree tree to parse.
        :param parent: :class:`EagleFilePart` that should hold the resulting :class:`EagleFilePart`
        :rtype: :class:`Dimension`
        """
        ## Call the constructor
        n = cls()
        n._init_from_et(root,parent)
        return n

    def _get_error_name(self):
        if hasattr(self, "get_name"):
            return self.get_name();
        else:
            return "Dimension";
        
    def  _init_from_et(self, root, parent):
        """
        Initialized a :class:`Dimension` from a :code:`dimension` element.  This is useful if you have a subclass of :class:`Dimension` .
        
        :param root: The element tree tree to parse.
        :param parent: :class:`EagleFilePart` that will become the parent of :code:`this` .
        :rtype: :class:`Dimension`
        """
        try:
            self.root = root
            
            if root.tag != "dimension":
                raise EagleFormatError("Tried to create dimension from " + root.tag)

            self.x1=parseByType(parent, "float", None, root.get("x1"))
            self.y1=parseByType(parent, "float", None, root.get("y1"))
            self.x2=parseByType(parent, "float", None, root.get("x2"))
            self.y2=parseByType(parent, "float", None, root.get("y2"))
            self.x3=parseByType(parent, "float", None, root.get("x3"))
            self.y3=parseByType(parent, "float", None, root.get("y3"))
            self.layer=parseByType(parent, "layer_string", None, root.get("layer"))
            self.dtype=parseByType(parent, "str", None, root.get("dtype"))
            self.width=parseByType(parent, "float", None, root.get("width"))
            self.extwidth=parseByType(parent, "float", None, root.get("extwidth"))
            self.extlength=parseByType(parent, "float", None, root.get("extlength"))
            self.extoffset=parseByType(parent, "float", None, root.get("extoffset"))
            self.textsize=parseByType(parent, "float", None, root.get("textsize"))
            self.textratio=parseByType(parent, "int", None, root.get("textratio"))
            self.unit=parseByType(parent, "str", None, root.get("unit"))
            self.precision=parseByType(parent, "int", None, root.get("precision"))
            self.visible=parseByType(parent, "bool", None, root.get("visible"))

            self.parent = parent

            ### populate the maps by searching for elements that match xpath and generating objects for them.


            ### Do the same for the lists


            ### Do the same for the attr lists


            ### And the singletons


            ### And, finally, if the objects wants the text from the tag.

        except SwoopError as e:
            e.text = "{}:{}".format(self._get_error_name(), e.text)
            raise e


    def sortkey(self):
        r = ""
        r = r + str(self.x1)
        r = r + str(self.y1)
        r = r + str(self.x2)
        r = r + str(self.y2)
        r = r + str(self.x3)
        r = r + str(self.y3)
        r = r + str(self.layer)
        r = r + str(self.dtype)
        r = r + str(self.width)
        r = r + str(self.extwidth)
        r = r + str(self.extlength)
        r = r + str(self.extoffset)
        r = r + str(self.textsize)
        r = r + str(self.textratio)
        r = r + str(self.unit)
        r = r + str(self.precision)
        r = r + str(self.visible)
        return r

    def get_et(self):
        """
        Generate a <dimension> element tree for a :class:`Dimension`.
        
        :rtype:  :class:`ElementTree`.
        
        """
        try:
            r = ET.Element("dimension")

            ### Set the tag attributes 


            ## Unparse the values.

            v = unparseByType(self, "float", None,  self.x1)

            ## For required attributes None becomes "".  For optional attributes, we just leave the attribute out.
            if not (isinstance(self.get_parent(), LibraryFile) and False):  # special case for the name of library.
                if v is not None:
                    r.set("x1", v)
                else:
                    r.set("x1", "")


            ## Unparse the values.

            v = unparseByType(self, "float", None,  self.y1)

            ## For required attributes None becomes "".  For optional attributes, we just leave the attribute out.
            if not (isinstance(self.get_parent(), LibraryFile) and False):  # special case for the name of library.
                if v is not None:
                    r.set("y1", v)
                else:
                    r.set("y1", "")


            ## Unparse the values.

            v = unparseByType(self, "float", None,  self.x2)

            ## For required attributes None becomes "".  For optional attributes, we just leave the attribute out.
            if not (isinstance(self.get_parent(), LibraryFile) and False):  # special case for the name of library.
                if v is not None:
                    r.set("x2", v)
                else:
                    r.set("x2", "")


            ## Unparse the values.

            v = unparseByType(self, "float", None,  self.y2)

            ## For required attributes None becomes "".  For optional attributes, we just leave the attribute out.
            if not (isinstance(self.get_parent(), LibraryFile) and False):  # special case for the name of library.
                if v is not None:
                    r.set("y2", v)
                else:
                    r.set("y2", "")


            ## Unparse the values.

            v = unparseByType(self, "float", None,  self.x3)

            ## For required attributes None becomes "".  For optional attributes, we just leave the attribute out.
            if not (isinstance(self.get_parent(), LibraryFile) and False):  # special case for the name of library.
                if v is not None:
                    r.set("x3", v)
                else:
                    r.set("x3", "")


            ## Unparse the values.

            v = unparseByType(self, "float", None,  self.y3)

            ## For required attributes None becomes "".  For optional attributes, we just leave the attribute out.
            if not (isinstance(self.get_parent(), LibraryFile) and False):  # special case for the name of library.
                if v is not None:
                    r.set("y3", v)
                else:
                    r.set("y3", "")


            ## Unparse the values.

            v = unparseByType(self, "layer_string", None,  self.layer)

            ## For required attributes None becomes "".  For optional attributes, we just leave the attribute out.
            if not (isinstance(self.get_parent(), LibraryFile) and False):  # special case for the name of library.
                if v is not None:
                    r.set("layer", v)
                else:
                    r.set("layer", "")


            ## Unparse the values.

            v = unparseByType(self, "str", None,  self.dtype)

            ## For required attributes None becomes "".  For optional attributes, we just leave the attribute out.
            if not (isinstance(self.get_parent(), LibraryFile) and False):  # special case for the name of library.
                if v is not None:
                    r.set("dtype", v)


            ## Unparse the values.

            v = unparseByType(self, "float", None,  self.width)

            ## For required attributes None becomes "".  For optional attributes, we just leave the attribute out.
            if not (isinstance(self.get_parent(), LibraryFile) and False):  # special case for the name of library.
                if v is not None:
                    r.set("width", v)


            ## Unparse the values.

            v = unparseByType(self, "float", None,  self.extwidth)

            ## For required attributes None becomes "".  For optional attributes, we just leave the attribute out.
            if not (isinstance(self.get_parent(), LibraryFile) and False):  # special case for the name of library.
                if v is not None:
                    r.set("extwidth", v)


            ## Unparse the values.

            v = unparseByType(self, "float", None,  self.extlength)

            ## For required attributes None becomes "".  For optional attributes, we just leave the attribute out.
            if not (isinstance(self.get_parent(), LibraryFile) and False):  # special case for the name of library.
                if v is not None:
                    r.set("extlength", v)


            ## Unparse the values.

            v = unparseByType(self, "float", None,  self.extoffset)

            ## For required attributes None becomes "".  For optional attributes, we just leave the attribute out.
            if not (isinstance(self.get_parent(), LibraryFile) and False):  # special case for the name of library.
                if v is not None:
                    r.set("extoffset", v)


            ## Unparse the values.

            v = unparseByType(self, "float", None,  self.textsize)

            ## For required attributes None becomes "".  For optional attributes, we just leave the attribute out.
            if not (isinstance(self.get_parent(), LibraryFile) and False):  # special case for the name of library.
                if v is not None:
                    r.set("textsize", v)
                else:
                    r.set("textsize", "")


            ## Unparse the values.

            v = unparseByType(self, "int", None,  self.textratio)

            ## For required attributes None becomes "".  For optional attributes, we just leave the attribute out.
            if not (isinstance(self.get_parent(), LibraryFile) and False):  # special case for the name of library.
                if v is not None:
                    r.set("textratio", v)


            ## Unparse the values.

            v = unparseByType(self, "str", None,  self.unit)

            ## For required attributes None becomes "".  For optional attributes, we just leave the attribute out.
            if not (isinstance(self.get_parent(), LibraryFile) and False):  # special case for the name of library.
                if v is not None:
                    r.set("unit", v)


            ## Unparse the values.

            v = unparseByType(self, "int", None,  self.precision)

            ## For required attributes None becomes "".  For optional attributes, we just leave the attribute out.
            if not (isinstance(self.get_parent(), LibraryFile) and False):  # special case for the name of library.
                if v is not None:
                    r.set("precision", v)


            ## Unparse the values.

            v = unparseByType(self, "bool", None,  self.visible)

            ## For required attributes None becomes "".  For optional attributes, we just leave the attribute out.
            if not (isinstance(self.get_parent(), LibraryFile) and False):  # special case for the name of library.
                if v is not None:
                    r.set("visible", v)


            ### process the sections in order.  They have to be in section order,
            ### because eagle files are order dependent.


            ## set the text, if its needed.

        except SwoopError as e:
            e.text = "{}:{}".format(self._get_error_name(), e.text)
            raise e
        return r

    def clone(self):
        """
        Recursively clone this :code:`Dimension`.  It will be identical to the original, but it's parent will be :code:`None`.
        
        :rtype: :class:`Dimension`
        """
        try:
            n = copy.copy(self)
            n.parent = None
        except SwoopError as e:
            e.text = "{}:{}".format(self._get_error_name(), e.text)
            raise e
        return n

    def accept_preorder_visitor(self, visitor):
        try:
            pre = getattr(visitor, "Dimension_pre")
            return pre(self)
        except AttributeError:
            return visitor.default_pre(self)
        
    def accept_postorder_visitor(self, visitor, context):
        try:
            post = getattr(visitor, "Dimension_post")
            post(self,context)
        except AttributeError:
            visitor.default_post(self,context)

    def is_equal(self, other):
        """
        Check whether two :code:`EagleFilePart` objects are identical.
        
        :param other: Object to compare to.
        :returns: :code:`True` if they are identical, otherwise, :code:`False`
        """
        return self.get_xml() == other.get_xml()
        
    ### Getters/Setters for attribute values

    def get_x1(self):
        """ Return the value of :code:`x1` for this :class:`Dimension`.  This corresponds to the :code:`x1` attribute of a :code:`<dimension>` in an Eagle file.
        
        :rtype: :code:`float`
        """
        return self.x1

    def set_x1(self,v):
        """ Set the value of :code:`x1` for this  :class:`Dimension`.  This corresponds to the :code:`x1` attribute of a :code:`<dimension>` in an Eagle file.

        :param v: new value
        :rtype: :code:`self`
        """
                        
        if not typeCheck("float", v, True):
            raise SwoopError("Illegal value ({}) of type {} for attribute 'x1' of Dimension object (should be float).".format(v, type(v)))
        self.x1 = v
        
        return self

    def with_x1(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`x1`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`x1` equals :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_x1()` is :code:`True`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """

        if type(v) in [str, int, float, bool]:
            return self if self.x1 == v else None
        elif callable(v):
            return self if v(self.x1) else None
        else:
            raise SwoopError("Illegal type passed to with_x1")

    def without_x1(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`x1`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`x1` is not equal to :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_x1()` is :code:`False`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """
        
        if type(v) in [str, int, float, bool]:
            return self if self.x1 != v else None
        elif callable(v):
            return self if not v(self.x1) else None
        else:
            raise SwoopError("Illegal type passed to without_x1")


    def get_y1(self):
        """ Return the value of :code:`y1` for this :class:`Dimension`.  This corresponds to the :code:`y1` attribute of a :code:`<dimension>` in an Eagle file.
        
        :rtype: :code:`float`
        """
        return self.y1

    def set_y1(self,v):
        """ Set the value of :code:`y1` for this  :class:`Dimension`.  This corresponds to the :code:`y1` attribute of a :code:`<dimension>` in an Eagle file.

        :param v: new value
        :rtype: :code:`self`
        """
                        
        if not typeCheck("float", v, True):
            raise SwoopError("Illegal value ({}) of type {} for attribute 'y1' of Dimension object (should be float).".format(v, type(v)))
        self.y1 = v
        
        return self

    def with_y1(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`y1`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`y1` equals :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_y1()` is :code:`True`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """

        if type(v) in [str, int, float, bool]:
            return self if self.y1 == v else None
        elif callable(v):
            return self if v(self.y1) else None
        else:
            raise SwoopError("Illegal type passed to with_y1")

    def without_y1(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`y1`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`y1` is not equal to :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_y1()` is :code:`False`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """
        
        if type(v) in [str, int, float, bool]:
            return self if self.y1 != v else None
        elif callable(v):
            return self if not v(self.y1) else None
        else:
            raise SwoopError("Illegal type passed to without_y1")


    def get_x2(self):
        """ Return the value of :code:`x2` for this :class:`Dimension`.  This corresponds to the :code:`x2` attribute of a :code:`<dimension>` in an Eagle file.
        
        :rtype: :code:`float`
        """
        return self.x2

    def set_x2(self,v):
        """ Set the value of :code:`x2` for this  :class:`Dimension`.  This corresponds to the :code:`x2` attribute of a :code:`<dimension>` in an Eagle file.

        :param v: new value
        :rtype: :code:`self`
        """
                        
        if not typeCheck("float", v, True):
            raise SwoopError("Illegal value ({}) of type {} for attribute 'x2' of Dimension object (should be float).".format(v, type(v)))
        self.x2 = v
        
        return self

    def with_x2(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`x2`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`x2` equals :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_x2()` is :code:`True`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """

        if type(v) in [str, int, float, bool]:
            return self if self.x2 == v else None
        elif callable(v):
            return self if v(self.x2) else None
        else:
            raise SwoopError("Illegal type passed to with_x2")

    def without_x2(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`x2`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`x2` is not equal to :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_x2()` is :code:`False`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """
        
        if type(v) in [str, int, float, bool]:
            return self if self.x2 != v else None
        elif callable(v):
            return self if not v(self.x2) else None
        else:
            raise SwoopError("Illegal type passed to without_x2")


    def get_y2(self):
        """ Return the value of :code:`y2` for this :class:`Dimension`.  This corresponds to the :code:`y2` attribute of a :code:`<dimension>` in an Eagle file.
        
        :rtype: :code:`float`
        """
        return self.y2

    def set_y2(self,v):
        """ Set the value of :code:`y2` for this  :class:`Dimension`.  This corresponds to the :code:`y2` attribute of a :code:`<dimension>` in an Eagle file.

        :param v: new value
        :rtype: :code:`self`
        """
                        
        if not typeCheck("float", v, True):
            raise SwoopError("Illegal value ({}) of type {} for attribute 'y2' of Dimension object (should be float).".format(v, type(v)))
        self.y2 = v
        
        return self

    def with_y2(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`y2`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`y2` equals :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_y2()` is :code:`True`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """

        if type(v) in [str, int, float, bool]:
            return self if self.y2 == v else None
        elif callable(v):
            return self if v(self.y2) else None
        else:
            raise SwoopError("Illegal type passed to with_y2")

    def without_y2(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`y2`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`y2` is not equal to :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_y2()` is :code:`False`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """
        
        if type(v) in [str, int, float, bool]:
            return self if self.y2 != v else None
        elif callable(v):
            return self if not v(self.y2) else None
        else:
            raise SwoopError("Illegal type passed to without_y2")


    def get_x3(self):
        """ Return the value of :code:`x3` for this :class:`Dimension`.  This corresponds to the :code:`x3` attribute of a :code:`<dimension>` in an Eagle file.
        
        :rtype: :code:`float`
        """
        return self.x3

    def set_x3(self,v):
        """ Set the value of :code:`x3` for this  :class:`Dimension`.  This corresponds to the :code:`x3` attribute of a :code:`<dimension>` in an Eagle file.

        :param v: new value
        :rtype: :code:`self`
        """
                        
        if not typeCheck("float", v, True):
            raise SwoopError("Illegal value ({}) of type {} for attribute 'x3' of Dimension object (should be float).".format(v, type(v)))
        self.x3 = v
        
        return self

    def with_x3(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`x3`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`x3` equals :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_x3()` is :code:`True`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """

        if type(v) in [str, int, float, bool]:
            return self if self.x3 == v else None
        elif callable(v):
            return self if v(self.x3) else None
        else:
            raise SwoopError("Illegal type passed to with_x3")

    def without_x3(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`x3`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`x3` is not equal to :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_x3()` is :code:`False`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """
        
        if type(v) in [str, int, float, bool]:
            return self if self.x3 != v else None
        elif callable(v):
            return self if not v(self.x3) else None
        else:
            raise SwoopError("Illegal type passed to without_x3")


    def get_y3(self):
        """ Return the value of :code:`y3` for this :class:`Dimension`.  This corresponds to the :code:`y3` attribute of a :code:`<dimension>` in an Eagle file.
        
        :rtype: :code:`float`
        """
        return self.y3

    def set_y3(self,v):
        """ Set the value of :code:`y3` for this  :class:`Dimension`.  This corresponds to the :code:`y3` attribute of a :code:`<dimension>` in an Eagle file.

        :param v: new value
        :rtype: :code:`self`
        """
                        
        if not typeCheck("float", v, True):
            raise SwoopError("Illegal value ({}) of type {} for attribute 'y3' of Dimension object (should be float).".format(v, type(v)))
        self.y3 = v
        
        return self

    def with_y3(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`y3`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`y3` equals :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_y3()` is :code:`True`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """

        if type(v) in [str, int, float, bool]:
            return self if self.y3 == v else None
        elif callable(v):
            return self if v(self.y3) else None
        else:
            raise SwoopError("Illegal type passed to with_y3")

    def without_y3(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`y3`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`y3` is not equal to :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_y3()` is :code:`False`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """
        
        if type(v) in [str, int, float, bool]:
            return self if self.y3 != v else None
        elif callable(v):
            return self if not v(self.y3) else None
        else:
            raise SwoopError("Illegal type passed to without_y3")


    def get_layer(self):
        """ Return the value of :code:`layer` for this :class:`Dimension`.  This corresponds to the :code:`layer` attribute of a :code:`<dimension>` in an Eagle file.
        
        :rtype: :code:`layer_string`
        """
        return self.layer

    def set_layer(self,v):
        """ Set the value of :code:`layer` for this  :class:`Dimension`.  This corresponds to the :code:`layer` attribute of a :code:`<dimension>` in an Eagle file.

        :param v: new value
        :rtype: :code:`self`
        """
                        
        if not typeCheck("layer_string", v, True):
            raise SwoopError("Illegal value ({}) of type {} for attribute 'layer' of Dimension object (should be layer_string).".format(v, type(v)))
        self.layer = v
        
        return self

    def with_layer(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`layer`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`layer` equals :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_layer()` is :code:`True`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """

        if type(v) in [str, int, float, bool]:
            return self if self.layer == v else None
        elif callable(v):
            return self if v(self.layer) else None
        else:
            raise SwoopError("Illegal type passed to with_layer")

    def without_layer(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`layer`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`layer` is not equal to :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_layer()` is :code:`False`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """
        
        if type(v) in [str, int, float, bool]:
            return self if self.layer != v else None
        elif callable(v):
            return self if not v(self.layer) else None
        else:
            raise SwoopError("Illegal type passed to without_layer")


    def get_dtype(self):
        """ Return the value of :code:`dtype` for this :class:`Dimension`.  This corresponds to the :code:`dtype` attribute of a :code:`<dimension>` in an Eagle file.
        
        :rtype: :code:`str`
        """
        return self.dtype

    def set_dtype(self,v):
        """ Set the value of :code:`dtype` for this  :class:`Dimension`.  This corresponds to the :code:`dtype` attribute of a :code:`<dimension>` in an Eagle file.

        :param v: new value
        :rtype: :code:`self`
        """
                        
        if not typeCheck("str", v, False):
            raise SwoopError("Illegal value ({}) of type {} for attribute 'dtype' of Dimension object (should be str).".format(v, type(v)))
        self.dtype = v
        
        return self

    def with_dtype(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`dtype`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`dtype` equals :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_dtype()` is :code:`True`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """

        if type(v) in [str, int, float, bool]:
            return self if self.dtype == v else None
        elif callable(v):
            return self if v(self.dtype) else None
        else:
            raise SwoopError("Illegal type passed to with_dtype")

    def without_dtype(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`dtype`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`dtype` is not equal to :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_dtype()` is :code:`False`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """
        
        if type(v) in [str, int, float, bool]:
            return self if self.dtype != v else None
        elif callable(v):
            return self if not v(self.dtype) else None
        else:
            raise SwoopError("Illegal type passed to without_dtype")


    def get_width(self):
        """ Return the value of :code:`width` for this :class:`Dimension`.  This corresponds to the :code:`width` attribute of a :code:`<dimension>` in an Eagle file.
        
        :rtype: :code:`float`
        """
        return self.width

    def set_width(self,v):
        """ Set the value of :code:`width` for this  :class:`Dimension`.  This corresponds to the :code:`width` attribute of a :code:`<dimension>` in an Eagle file.

        :param v: new value
        :rtype: :code:`self`
        """
                        
        if not typeCheck("float", v, False):
            raise SwoopError("Illegal value ({}) of type {} for attribute 'width' of Dimension object (should be float).".format(v, type(v)))
        self.width = v
        
        return self

    def with_width(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`width`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`width` equals :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_width()` is :code:`True`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """

        if type(v) in [str, int, float, bool]:
            return self if self.width == v else None
        elif callable(v):
            return self if v(self.width) else None
        else:
            raise SwoopError("Illegal type passed to with_width")

    def without_width(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`width`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`width` is not equal to :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_width()` is :code:`False`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """
        
        if type(v) in [str, int, float, bool]:
            return self if self.width != v else None
        elif callable(v):
            return self if not v(self.width) else None
        else:
            raise SwoopError("Illegal type passed to without_width")


    def get_extwidth(self):
        """ Return the value of :code:`extwidth` for this :class:`Dimension`.  This corresponds to the :code:`extwidth` attribute of a :code:`<dimension>` in an Eagle file.
        
        :rtype: :code:`float`
        """
        return self.extwidth

    def set_extwidth(self,v):
        """ Set the value of :code:`extwidth` for this  :class:`Dimension`.  This corresponds to the :code:`extwidth` attribute of a :code:`<dimension>` in an Eagle file.

        :param v: new value
        :rtype: :code:`self`
        """
                        
        if not typeCheck("float", v, False):
            raise SwoopError("Illegal value ({}) of type {} for attribute 'extwidth' of Dimension object (should be float).".format(v, type(v)))
        self.extwidth = v
        
        return self

    def with_extwidth(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`extwidth`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`extwidth` equals :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_extwidth()` is :code:`True`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """

        if type(v) in [str, int, float, bool]:
            return self if self.extwidth == v else None
        elif callable(v):
            return self if v(self.extwidth) else None
        else:
            raise SwoopError("Illegal type passed to with_extwidth")

    def without_extwidth(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`extwidth`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`extwidth` is not equal to :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_extwidth()` is :code:`False`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """
        
        if type(v) in [str, int, float, bool]:
            return self if self.extwidth != v else None
        elif callable(v):
            return self if not v(self.extwidth) else None
        else:
            raise SwoopError("Illegal type passed to without_extwidth")


    def get_extlength(self):
        """ Return the value of :code:`extlength` for this :class:`Dimension`.  This corresponds to the :code:`extlength` attribute of a :code:`<dimension>` in an Eagle file.
        
        :rtype: :code:`float`
        """
        return self.extlength

    def set_extlength(self,v):
        """ Set the value of :code:`extlength` for this  :class:`Dimension`.  This corresponds to the :code:`extlength` attribute of a :code:`<dimension>` in an Eagle file.

        :param v: new value
        :rtype: :code:`self`
        """
                        
        if not typeCheck("float", v, False):
            raise SwoopError("Illegal value ({}) of type {} for attribute 'extlength' of Dimension object (should be float).".format(v, type(v)))
        self.extlength = v
        
        return self

    def with_extlength(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`extlength`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`extlength` equals :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_extlength()` is :code:`True`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """

        if type(v) in [str, int, float, bool]:
            return self if self.extlength == v else None
        elif callable(v):
            return self if v(self.extlength) else None
        else:
            raise SwoopError("Illegal type passed to with_extlength")

    def without_extlength(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`extlength`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`extlength` is not equal to :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_extlength()` is :code:`False`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """
        
        if type(v) in [str, int, float, bool]:
            return self if self.extlength != v else None
        elif callable(v):
            return self if not v(self.extlength) else None
        else:
            raise SwoopError("Illegal type passed to without_extlength")


    def get_extoffset(self):
        """ Return the value of :code:`extoffset` for this :class:`Dimension`.  This corresponds to the :code:`extoffset` attribute of a :code:`<dimension>` in an Eagle file.
        
        :rtype: :code:`float`
        """
        return self.extoffset

    def set_extoffset(self,v):
        """ Set the value of :code:`extoffset` for this  :class:`Dimension`.  This corresponds to the :code:`extoffset` attribute of a :code:`<dimension>` in an Eagle file.

        :param v: new value
        :rtype: :code:`self`
        """
                        
        if not typeCheck("float", v, False):
            raise SwoopError("Illegal value ({}) of type {} for attribute 'extoffset' of Dimension object (should be float).".format(v, type(v)))
        self.extoffset = v
        
        return self

    def with_extoffset(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`extoffset`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`extoffset` equals :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_extoffset()` is :code:`True`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """

        if type(v) in [str, int, float, bool]:
            return self if self.extoffset == v else None
        elif callable(v):
            return self if v(self.extoffset) else None
        else:
            raise SwoopError("Illegal type passed to with_extoffset")

    def without_extoffset(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`extoffset`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`extoffset` is not equal to :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_extoffset()` is :code:`False`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """
        
        if type(v) in [str, int, float, bool]:
            return self if self.extoffset != v else None
        elif callable(v):
            return self if not v(self.extoffset) else None
        else:
            raise SwoopError("Illegal type passed to without_extoffset")


    def get_textsize(self):
        """ Return the value of :code:`textsize` for this :class:`Dimension`.  This corresponds to the :code:`textsize` attribute of a :code:`<dimension>` in an Eagle file.
        
        :rtype: :code:`float`
        """
        return self.textsize

    def set_textsize(self,v):
        """ Set the value of :code:`textsize` for this  :class:`Dimension`.  This corresponds to the :code:`textsize` attribute of a :code:`<dimension>` in an Eagle file.

        :param v: new value
        :rtype: :code:`self`
        """
                        
        if not typeCheck("float", v, True):
            raise SwoopError("Illegal value ({}) of type {} for attribute 'textsize' of Dimension object (should be float).".format(v, type(v)))
        self.textsize = v
        
        return self

    def with_textsize(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`textsize`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`textsize` equals :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_textsize()` is :code:`True`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """

        if type(v) in [str, int, float, bool]:
            return self if self.textsize == v else None
        elif callable(v):
            return self if v(self.textsize) else None
        else:
            raise SwoopError("Illegal type passed to with_textsize")

    def without_textsize(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`textsize`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`textsize` is not equal to :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_textsize()` is :code:`False`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """
        
        if type(v) in [str, int, float, bool]:
            return self if self.textsize != v else None
        elif callable(v):
            return self if not v(self.textsize) else None
        else:
            raise SwoopError("Illegal type passed to without_textsize")


    def get_textratio(self):
        """ Return the value of :code:`textratio` for this :class:`Dimension`.  This corresponds to the :code:`textratio` attribute of a :code:`<dimension>` in an Eagle file.
        
        :rtype: :code:`int`
        """
        return self.textratio

    def set_textratio(self,v):
        """ Set the value of :code:`textratio` for this  :class:`Dimension`.  This corresponds to the :code:`textratio` attribute of a :code:`<dimension>` in an Eagle file.

        :param v: new value
        :rtype: :code:`self`
        """
                        
        if not typeCheck("int", v, False):
            raise SwoopError("Illegal value ({}) of type {} for attribute 'textratio' of Dimension object (should be int).".format(v, type(v)))
        self.textratio = v
        
        return self

    def with_textratio(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`textratio`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`textratio` equals :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_textratio()` is :code:`True`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """

        if type(v) in [str, int, float, bool]:
            return self if self.textratio == v else None
        elif callable(v):
            return self if v(self.textratio) else None
        else:
            raise SwoopError("Illegal type passed to with_textratio")

    def without_textratio(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`textratio`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`textratio` is not equal to :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_textratio()` is :code:`False`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """
        
        if type(v) in [str, int, float, bool]:
            return self if self.textratio != v else None
        elif callable(v):
            return self if not v(self.textratio) else None
        else:
            raise SwoopError("Illegal type passed to without_textratio")


    def get_unit(self):
        """ Return the value of :code:`unit` for this :class:`Dimension`.  This corresponds to the :code:`unit` attribute of a :code:`<dimension>` in an Eagle file.
        
        :rtype: :code:`str`
        """
        return self.unit

    def set_unit(self,v):
        """ Set the value of :code:`unit` for this  :class:`Dimension`.  This corresponds to the :code:`unit` attribute of a :code:`<dimension>` in an Eagle file.

        :param v: new value
        :rtype: :code:`self`
        """
                        
        if not typeCheck("str", v, False):
            raise SwoopError("Illegal value ({}) of type {} for attribute 'unit' of Dimension object (should be str).".format(v, type(v)))
        self.unit = v
        
        return self

    def with_unit(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`unit`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`unit` equals :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_unit()` is :code:`True`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """

        if type(v) in [str, int, float, bool]:
            return self if self.unit == v else None
        elif callable(v):
            return self if v(self.unit) else None
        else:
            raise SwoopError("Illegal type passed to with_unit")

    def without_unit(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`unit`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`unit` is not equal to :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_unit()` is :code:`False`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """
        
        if type(v) in [str, int, float, bool]:
            return self if self.unit != v else None
        elif callable(v):
            return self if not v(self.unit) else None
        else:
            raise SwoopError("Illegal type passed to without_unit")


    def get_precision(self):
        """ Return the value of :code:`precision` for this :class:`Dimension`.  This corresponds to the :code:`precision` attribute of a :code:`<dimension>` in an Eagle file.
        
        :rtype: :code:`int`
        """
        return self.precision

    def set_precision(self,v):
        """ Set the value of :code:`precision` for this  :class:`Dimension`.  This corresponds to the :code:`precision` attribute of a :code:`<dimension>` in an Eagle file.

        :param v: new value
        :rtype: :code:`self`
        """
                        
        if not typeCheck("int", v, False):
            raise SwoopError("Illegal value ({}) of type {} for attribute 'precision' of Dimension object (should be int).".format(v, type(v)))
        self.precision = v
        
        return self

    def with_precision(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`precision`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`precision` equals :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_precision()` is :code:`True`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """

        if type(v) in [str, int, float, bool]:
            return self if self.precision == v else None
        elif callable(v):
            return self if v(self.precision) else None
        else:
            raise SwoopError("Illegal type passed to with_precision")

    def without_precision(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`precision`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`precision` is not equal to :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_precision()` is :code:`False`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """
        
        if type(v) in [str, int, float, bool]:
            return self if self.precision != v else None
        elif callable(v):
            return self if not v(self.precision) else None
        else:
            raise SwoopError("Illegal type passed to without_precision")


    def get_visible(self):
        """ Return the value of :code:`visible` for this :class:`Dimension`.  This corresponds to the :code:`visible` attribute of a :code:`<dimension>` in an Eagle file.
        
        :rtype: :code:`bool`
        """
        return self.visible

    def set_visible(self,v):
        """ Set the value of :code:`visible` for this  :class:`Dimension`.  This corresponds to the :code:`visible` attribute of a :code:`<dimension>` in an Eagle file.

        :param v: new value
        :rtype: :code:`self`
        """
                        
        if not typeCheck("bool", v, False):
            raise SwoopError("Illegal value ({}) of type {} for attribute 'visible' of Dimension object (should be bool).".format(v, type(v)))
        self.visible = v
        
        return self

    def with_visible(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`visible`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`visible` equals :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_visible()` is :code:`True`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """

        if type(v) in [str, int, float, bool]:
            return self if self.visible == v else None
        elif callable(v):
            return self if v(self.visible) else None
        else:
            raise SwoopError("Illegal type passed to with_visible")

    def without_visible(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`visible`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`visible` is not equal to :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_visible()` is :code:`False`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """
        
        if type(v) in [str, int, float, bool]:
            return self if self.visible != v else None
        elif callable(v):
            return self if not v(self.visible) else None
        else:
            raise SwoopError("Illegal type passed to without_visible")



    ##### Lookup functions that return EFPs instead of just attribute values.
    
    


    
    ### Adder/getter/lookup for lists
    


    ### Add, lookup, and get for maps


    
    ### Getter/Setter for singletons.


    
    def get_children(self):
        """
        Get all the children of this :class:`EagleFilePart`.
        
        :rtype: List of :class:`EagleFilePart` objects
        """
        r = []




        return r

    def remove_child(self, efp):
        """
        Remove a child :class:`EagleFilePart` object.
        
        :param efp: the class:`EagleFilePart` object to remove.
        :return: Nothing
        """

    def _rekey_child(self, oldkey, efp):
        """
        Remove a child :class:`EagleFilePart` object.
        
        :param efp: the class:`EagleFilePart` object to remove.
        :return: Nothing
        """


    def __str__(self):
        r = "["+repr(self)+" "
        r = r + "x1:" + str(self.get_x1()) + " "
        r = r + "y1:" + str(self.get_y1()) + " "
        r = r + "x2:" + str(self.get_x2()) + " "
        r = r + "y2:" + str(self.get_y2()) + " "
        r = r + "x3:" + str(self.get_x3()) + " "
        r = r + "y3:" + str(self.get_y3()) + " "
        r = r + "layer:" + str(self.get_layer()) + " "
        r = r + "dtype:" + str(self.get_dtype()) + " "
        r = r + "width:" + str(self.get_width()) + " "
        r = r + "extwidth:" + str(self.get_extwidth()) + " "
        r = r + "extlength:" + str(self.get_extlength()) + " "
        r = r + "extoffset:" + str(self.get_extoffset()) + " "
        r = r + "textsize:" + str(self.get_textsize()) + " "
        r = r + "textratio:" + str(self.get_textratio()) + " "
        r = r + "unit:" + str(self.get_unit()) + " "
        r = r + "precision:" + str(self.get_precision()) + " "
        r = r + "visible:" + str(self.get_visible()) + " "
        r = r + "]"
        return r
            
    def dump(self, indent="", increment="   "):
        """
        Recursive debug dump.
        
        :param indent:  Indentation string.  The output will be indented by this much.
        :param increment: This will be appendeded to :code:`indent` on recursive invocations.

        :rtype: :code:`None`
        """
        print(indent + str(self.__class__.__name__), end=' ')
        try:
            print(self.get_name())
        except:
            print()
            pass
        for c in self.get_children():
            c.dump(indent + "   ")

        
EagleFile.class_map["dimension"] = Dimension
         

class Instance (Base_Instance):
    """ 
    Extra functions for Intsances.
    """
    def __init__(self):
        Base_Instance.__init__(self)

    def find_part(self):
        """
        Get the :class:`Part` object this :class:`Instance` belongs to.
        """
        return self.get_root().parts[self.part]

EagleFile.class_map["instance"] = Instance

class Part (Base_Part):
    """Extra functions for Parts.  Sanity checks, and facilities for find the
    symbols, devices, etc. for a part.

    """
    def __init__(self):
        Base_Part.__init__(self)


    def check_sanity(self, visited_efps = None):
        #assert self.get_device() is not None

        try:
            assert self.find_library() is not None
        except Exception as e:
            raise SwoopError("Library '" + self.library +  "' missing for '" + str(self.name) + "'")
        
        try:
            assert self.find_deviceset() is not None
        except Exception as e:
            raise SwoopError("DeviceSet '" + self.find_library().name + ":" + self.deviceset + "' missing for '" + str(self.name) + "'")

        try:
            assert self.find_device() is not None
        except Exception as e:
            raise SwoopError("Device '" + self.find_library().name + ":" + self.find_deviceset().name + ":" + self.device + "' missing for '" + str(self.name) + "'")
        
        Base_Part.check_sanity(self, visited_efps)
        
         
    def find_library(self):
        """
        Get the library that contains this part
        """
        lib = self.get_root().libraries.get(self.library)
        return lib

    def find_deviceset(self):
        """
        Get the deviceset for this part.
        """
        lib = self.find_library();
        if lib is None:
            return None;
        deviceset = lib.devicesets.get(self.deviceset)
        return deviceset
        
    def find_device(self):
        """
        Get the library entry for this part
        """
        deviceset = self.find_deviceset()
        if deviceset is None:
            return None;
        assert self.device is not None
        device = deviceset.devices.get(self.device)
        return device

    def find_technology(self):
        """
        Get the library entry for this part
        """
        device = self.find_device()
        if device is None:
            return None;
        tech = device.technologies.get(self.technology)
        return tech

        
    def find_package(self):
        """
        Get the library entry for this part
        """
        device = self.find_device();
        lib = self.find_library();
        if device.package is not None:
            package = lib.packages.get(device.package);
        else:
            package = None
        return package
    

    def get_all_attributes(self):
        """Return a map of attribute names to values.  These include attributes
        defined in the library as well as those defined for this part.
        Modifying the map has no effect on the :code:`Part`.

        """
        r = {x.get_name(): x.get_value() for x in self.find_technology().get_attributes()}
        r.update({x.get_name(): x.get_value() for x in self.get_attributes()})
        return r
        
    def set_attribute(self,name, value):
        """Set an attribute on a part, creating it if necessary.

        If the attribute exists in the library, and is marked as constant, then raise a :code:`SwoopError`.
        """

        tech_attribute = self.find_technology().get_attribute(name)

        if tech_attribute is None or (tech_attribute is not None and not tech_attribute.get_constant()):
            if name in self.attributes:
                self.attributes[name].set_value(value)
            else:
                self.add_attribute(Attribute().
                                   set_name(name).
                                   set_value(value))
        else:
            raise SwoopError("Setting attribute value on part {}, but attribute '{}' is marked constant in library ({}:{}:{}:{}).".format(tech_attribute, tech_attribute.get_constant(), self.get_name(), name, self.get_library(), self.get_deviceset(), self.get_device(), self.get_technology()))

        return self


EagleFile.class_map["part"] = Part


class Attribute (Base_Attribute):

    """Extra functionality for Attributes.  Attributes are used in many places in
    eagle files and they require different attributes in some cases.

    """
    def __init__(self):
        Base_Attribute.__init__(self)

    def __str__(self):
        return self.name + " = '" + str(self.value) + "' [const=" + str(self.constant) + "]";

    def get_in_library(self):
        if isinstance(self.get_parent(), Technology):
            return True;
        elif isinstance(self.get_parent(), Part):
            return False
        elif isinstance(self.get_parent(), Instance):
            return False
        elif isinstance(self.get_parent(), Element):
            return False
        elif isinstance(self.get_parent(), EagleFile):
            return False
        elif isinstance(self.get_parent(), Moduleinst):
            return False
        else:
            raise SwoopError("Unexpectedly found attribute with parent of type '{}'".format(type(self.get_parent())))

    @classmethod
    def _from_et (cls, attribute_root, parent):
        n = Attribute()
        n. _init_from_et(attribute_root, parent)
        
        return n

    def get_et (self):
        n = Base_Attribute.get_et(self)
        
        if not self.get_in_library():
            if "constant" in n.attrib:
                del n.attrib["constant"]

        return n

EagleFile.class_map["attribute"] = Attribute

#### Extra methods for DeviceSets

def convertToExternal(self):
    """
    This converts the :class:`Deviceset` into an external deviceset.  This means that it
    has no associated package.  It can, however, have attributes, and those
    are stored in the "" device.  You can't just delete all the packages,
    since you'd lose the attributes.  This copies them from the first
    package.
    """
    if len(self.get_devices()) > 0:
        d = self.get_devices()[0]
        self.clear_devices()
        d.set_name("").set_package(None).clear_connects()
    else:
        d = (Device().
             set_name("").
             set_package(None).
             add_technology(Technology().
                            set_name("")))
    self.add_device(d)

    From(d).get_technologies().add_attribute(Attribute().set_name("_EXTERNAL_"))

setattr(Deviceset, "convertToExternal", convertToExternal)
        
class LibraryFile(Base_LibraryFile):
    def __init__(self):
        Base_LibraryFile.__init__(self)
        
    @classmethod
    def _from_et (cls,et, parent, filename):
        """
        Loads a Library file from an ElementTree.Element representation.
        """
        r = cls()
        r._init_from_et(et, parent)
        if r.get_library().name is None: 
            r.get_library().set_name(os.path.basename(filename)[:-4])
        return r

    # def get_library_copy(self):
    #     return copy.deepcopy(self.library)

    
#print EagleFile.class_map
class LibraryCache(object):
    """
    A library file cache.  Save the time of opening libraries repeatedly.  
    
    An instance of this is available as :code:`Swoop.library_cache`, but you may build your own, if you want.
    """
    
    def __init__(self):
        self.libfile_to_lib = {}
        self.libname_to_path = {}

    def register_library(self, path):
        """
        
        Register a library file with the cache.  This allows you to later
        request the library by name.  For instance if you register
        :code:`foo.lbr` you can ask for :code:`foo'. 

        :param path: The path to the lbr file.  The path is canonicalized internally (and made absolute) so if :code:`bar/foo.lbr` is the same as :code:`bar/../bar/foo.lbr`.

        """
        cpath = os.path.realpath(path)
        libname = os.path.split(cpath)[1].replace(".lbr","").upper()
        log.debug("Registered library {} as {}".format(path, libname))
        self.libname_to_path[libname] = cpath

    def load_library_by_path(self, path):
        """ 
        Load a library using a path to file.

        :param path: The path to the lbr file.  The path is canonicalized internally (and made absolute) so if :code:`bar/foo.lbr` is the same as :code:`bar/../bar/foo.lbr`.
        """
        
        cpath = os.path.realpath(path)
        self.register_library(path) # make sure we can find it later via load_library_by_name
        if cpath not in self.libfile_to_lib:
            log.debug("LibraryCache miss: {}".format(path))
            self.libfile_to_lib[cpath] = LibraryFile.open(cpath)
        else:
            log.debug("LibraryCache hit: {}".format(path))
        return self.libfile_to_lib[cpath]

    def load_library_by_name(self, name):
        """
        Load a library by (case insensitive) name.  If you haven't registered the path to the library or accessed it previously via :code:`load_library_by_path`, it will raise an exception.

        :param name: Library name (case insensitive)
        """

        if name.upper() in self.libname_to_path:
            r = self.load_library_by_path(self.libname_to_path[name.upper()])
            log.debug("Returning {} for libname '{}'".format(r, name))
            return r
        else:
            raise SwoopError("Unknwon library name {} (did you register the file?)")
    
library_cache = LibraryCache()
