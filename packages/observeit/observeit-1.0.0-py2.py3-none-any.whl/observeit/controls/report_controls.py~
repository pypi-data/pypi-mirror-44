"""ObserveIT REST API Client"""

from abc import ABC
import calendar
from datetime import datetime
import logging
try:
    # Python 3
    import urllib.parse as urllib_parse
except:
    # Python 2
    import urllib as urllib_parse
import os
from string import Template
import time
import traceback
import requests
from requests.adapters import HTTPAdapter
from requests.packages.urllib3.util.retry import Retry

LOG = logging.getLogger(__name__)


class ObserveITBase(ABC):
    RESPONSE_TYPES =  { "json": "application/json",
                        "jsonl": "application/jsonl",
                        "csv": "text/csv"
                        }
    def __init__(self, host, api_version="v2", verify=True, cafile=None, connect_timeout=None):
        self.host = host
        self.api_version = api_version
        self.verify = verify
        self.cafile = cafile
        self.connect_timeout = connect_timeout
        self.session = self.connect()
    # end __init__

    def create_rql(self, rql_template, **kwargs):
        """urlencode params before rendering them into template"""
        query_values = {}
        for key, value in kwargs.items():
            query_values[key] = urllib_parse.quote(value)

        template = Template(rql_template)
        return template.safe_substitute(query_values)
    #end create_rql

    def convert_observeit_datetime(self, timestamp):
        # YYYY-MM-DDTHH:MM:SS.mmm+00:00
        """Convert timestamp like 2017-11-15T20:06:16.150Z to epoch in ms"""
        ts = timestamp.replace("Z", "GMT")
        ms = int(ts[-6:-3])
        ts_format = "%Y-%m-%dT%H:%M:%S.%f%Z"
        dt = datetime.strptime(ts, ts_format)
        return int(calendar.timegm(dt.timetuple()) * 1000) + ms
    # end _convert_observeit_datetime

    @abstractmethod
    def connect(self):
        """Establish authenticated session to ObserveIT REST API"""
        pass
    
    def retryable_session(self, session, retries=3, backoff_factor=0.3):
        """ Automatically retry session requests for certain failures """
        retry = Retry(
            total=retries,
            read=retries,
            connect=retries,
            method_whitelist=False, # this will force retry on POST/PATCH/DELETE as well as GET/PUT
            backoff_factor=backoff_factor)
        adapter = HTTPAdapter(max_retries=retry)
        session.mount('http://', adapter)
        session.mount('https://', adapter)
        return session

    def make_request(self, endpoint, method="get", data=None, headers=None, params=None):
        """Make ObserveIT REST Request and Return JSON Response"""
        response = None
        method = method.lower()
        url = "%s/%s/apis/%s" % (self.host, self.api_version, endpoint)
        LOG.debug("%s REQUEST TO %s?%s", method.upper(), endpoint,
                  "&".join([tag+"="+value for tag, value in params.items()]))
        try:
            if method == "get":
                response = self.session.get(url, headers=headers, params=params, verify=self.verify)
            elif method == "post":
                response = self.session.post(url, data=data, headers=headers, params=params, verify=self.verify)
            elif method == "put":
                response = self.session.put(url, data=data, headers=headers, params=params, verify=self.verify)
            elif method == "patch":
                response = self.session.patch(url, data=data, headers=headers, params=params, verify=self.verify)
            elif method == "delete":
                response = self.session.delete(url, headers=headers, params=params, verify=self.verify)
            else:
                raise ValueError("Method '%s' not currently supported" % method)
            response.raise_for_status()
            content_type = response.headers.get("content-type", "")
            if "json" not in content_type and "csv" not in content_type:
                # Not a response we were expecting, probably an IIS error.
                msg = "Unexpected Response content-type: %s" % content_type
                LOG.error(msg)
                LOG.error("ObserveIT Response %s: %s" % (response.status_code, response.text))
                raise RuntimeError(msg)

            return response
        except TokenExpiredError as e:
            # Token expired, refresh token and retry
            LOG.info("Token Expired. Refreshing..")
            self.session = self.connect()
            return self.make_request(endpoint, method=method, data=data,
                                     headers=headers, params=params)
        except Exception as e:
            LOG.error("Unexpected Error: %s", e)
            LOG.debug(traceback.format_exc())
            raise
    # end make_request

    def get_streaming_report(self, report_id, limit=None, since=None, fields=None, realm="observeit", response_type="json"):
        url = "report;realm=%s/reports/%s/stream" % (realm, report_id)
        query_params = {}
        if response_type not in self.RESPONSE_TYPES:
            raise ValueError("response_type '%s' should be one of: %s" % (response_type, str(RESPONSE_TYPES)))
        if limit:
            query_params['limit'] = limit
        if since:
            if isinstance(since, datetime):
                # format like 2018-05-05T14:49:08.522Z
                formatted_since = since.strftime("%Y-%m-%dT:%H:%M:%S.000Z")
            else:
                formatted_since = since
            query_params['since'] = formatted_since

        try:
            return self.make_request(url, params=query_params,
                                     headers = {"accept": response_types[response_type]})
        except Exception as e:
            LOG.error("Failed to get report from ObserveIT!")
            LOG.debug(traceback.format_exc())
            raise
    # end get_streaming_report

    def get_report(self, report_id, rql=None, realm="observeit", response_type="json"):
        url = "report;realm=%s/reports/%s/data" % (realm, report_id)
        query_params = {}
        if response_type not in self.RESPONSE_TYPES:
            raise ValueError("response_type '%s' should be one of: %s" % (response_type, str(RESPONSE_TYPES)))
        if rql:
            query_params['rql'] = rql
        try:
            return self.make_request(url, params=query_params,
                                     headers = {"accept": response_types[response_type]})
        except Exception as e:
            LOG.error("Failed to get report from ObserveIT!")
            LOG.debug(traceback.format_exc())
            raise
    # end get_report
