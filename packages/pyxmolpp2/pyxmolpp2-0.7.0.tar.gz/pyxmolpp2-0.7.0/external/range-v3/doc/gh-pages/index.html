<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Range-v3: User Manual</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(initResizable);
/* @license-end */</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(function() { init_search(); });
/* @license-end */
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Range-v3
   </div>
   <div id="projectbrief">Range algorithms, views, and actions for the Standard Library</div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('index.html','');});
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">User Manual </div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#tutorial-preface">Preface</a><ul><li class="level2"><a href="#tutorial-installation">Installation</a></li>
<li class="level2"><a href="#tutorial-license">License</a></li>
<li class="level2"><a href="#tutorial-compilers">Supported Compilers</a></li>
</ul>
</li>
<li class="level1"><a href="#tutorial-quick-start">Quick Start</a></li>
<li class="level1"><a href="#range-views">Range Views</a></li>
<li class="level1"><a href="#range-actions">Range Actions</a></li>
<li class="level1"><a href="#example-section">Examples</a><ul><li class="level2"><a href="#example-hello">hello ranges</a></li>
<li class="level2"><a href="#example-any-all-none">any_of, all_of, none_of</a></li>
<li class="level2"><a href="#example-count">count</a></li>
<li class="level2"><a href="#example-count_if">count_if</a></li>
<li class="level2"><a href="#example-find">find, find_if, find_if_not on sequence containers</a></li>
<li class="level2"><a href="#example-for_each-seq">for_each on sequence containers</a></li>
<li class="level2"><a href="#example-for_each-assoc">for_each on associative containers</a></li>
<li class="level2"><a href="#example-is_sorted">is_sorted</a></li>
</ul>
</li>
</ul>
</div>
<div class="textblock"><h1><a class="anchor" id="tutorial-preface"></a>
Preface</h1>
<hr/>
<p> Range library for C++11/14/17. This code is the basis of <a href="https://ericniebler.github.io/std/wg21/D4128.html">a formal proposal</a> to add range support to the C++ standard library.</p>
<p><b>Development Status:</b></p>
<p>This code is fairly stable, well-tested, and suitable for casual use, although currently lacking documentation. No promise is made about support or long-term stability. This code <em>will</em> evolve without regard to backwards compatibility.</p>
<h2><a class="anchor" id="tutorial-installation"></a>
Installation</h2>
<hr/>
<p> This library is header-only. You can get the source code from the <a href="https://github.com/ericniebler/range-v3">range-v3 repository</a> on github. To compile with Range-v3, you can either <code>#include</code> the entire library:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="all_8hpp.html">range/v3/all.hpp</a>&gt;</span></div></div><!-- fragment --><p>Or you can <code>#include</code> only the core, and then the individual headers you want:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="core_8hpp.html">range/v3/core.hpp</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;range/v3/....</span></div></div><!-- fragment --><h2><a class="anchor" id="tutorial-license"></a>
License</h2>
<hr/>
<p> Most of the source code in this project are mine, and those are under the Boost Software License. Parts are taken from Alex Stepanov's Elements of Programming, Howard Hinnant's libc++, and from the SGI STL. Please see the attached LICENSE file and the CREDITS file for the licensing and acknowledgements.</p>
<h2><a class="anchor" id="tutorial-compilers"></a>
Supported Compilers</h2>
<hr/>
<p> The code is known to work on the following compilers:</p>
<ul>
<li>clang 3.6.2</li>
<li>GCC 4.9.1</li>
</ul>
<h1><a class="anchor" id="tutorial-quick-start"></a>
Quick Start</h1>
<hr/>
<p> Range v3 is a generic library that augments the existing standard library with facilities for working with <em>ranges</em>. A range can be loosely thought of a pair of iterators, although they need not be implemented that way. Bundling begin/end iterators into a single object brings several benefits.</p>
<h2>Why Use Ranges?</h2>
<h3>Convenience</h3>
<p>It's more convenient to pass a single range object to an algorithm than separate begin/end iterators. Compare:</p>
<div class="fragment"><div class="line">std::vector&lt;int&gt; v{<span class="comment">/*...*/</span>};</div><div class="line"><a class="code" href="group__transformation.html#ga01e9a0330388c41cc77d4eed9af9c3d5">std::sort</a>( v.begin(), v.end() );</div></div><!-- fragment --><p>with</p>
<div class="fragment"><div class="line">std::vector&lt;int&gt; v{<span class="comment">/*...*/</span>};</div><div class="line"><a class="code" href="group__transformation.html#ga01e9a0330388c41cc77d4eed9af9c3d5">ranges::sort</a>( v );</div></div><!-- fragment --><p>Range v3 contains a full implementation of all the standard algorithms with range-based overloads for convenience.</p>
<h3>Composability</h3>
<p>Having a single range object permits <em>pipelines</em> of operations. In a pipeline, a range is lazily adapted or eagerly mutated in some way, with the result immediately available for further adaptation or mutation. Lazy adaption is handled by <em>views</em>, and eager mutation is handled by <em>actions</em>.</p>
<h4>Views</h4>
<p>A view is a lightweight wrapper that presents a view of an underlying sequence of elements in some custom way without mutating or copying it. Views are cheap to create and copy, and have non-owning reference semantics. Below are some examples:</p>
<p>Filter a container using a predicate and transform it.</p>
<div class="fragment"><div class="line">std::vector&lt;int&gt; vi{1,2,3,4,5,6,7,8,9,10};</div><div class="line"><span class="keyword">using namespace </span><a class="code" href="namespaceranges.html">ranges</a>;</div><div class="line"><span class="keyword">auto</span> rng = vi | <a class="code" href="group__group-actions.html#ga673f1edcd5ad49303d37605d71b52e0e">view::remove_if</a>([](<span class="keywordtype">int</span> i){<span class="keywordflow">return</span> i % 2 == 1;})</div><div class="line">              | <a class="code" href="group__transformation.html#ga24923725e5aa3cc7ee73367935437a1c">view::transform</a>([](<span class="keywordtype">int</span> i){<span class="keywordflow">return</span> std::to_string(i);});</div><div class="line"><span class="comment">// rng == {&quot;2&quot;,&quot;4&quot;,&quot;6&quot;,&quot;8&quot;,&quot;10&quot;};</span></div></div><!-- fragment --><p>Generate an infinite list of integers starting at 1, square them, take the first 10, and sum them:</p>
<div class="fragment"><div class="line"><span class="keyword">using namespace </span><a class="code" href="namespaceranges.html">ranges</a>;</div><div class="line"><span class="keywordtype">int</span> sum = <a class="code" href="group__transformation.html#ga9ca974f63ad4bb43802cf68d3c83bb8f">accumulate</a>(view::ints(1)</div><div class="line">                   | <a class="code" href="group__transformation.html#ga24923725e5aa3cc7ee73367935437a1c">view::transform</a>([](<span class="keywordtype">int</span> i){<span class="keywordflow">return</span> i*i;})</div><div class="line">                   | view::take(10), 0);</div></div><!-- fragment --><p>Generate a sequence on the fly with a range comprehension and initialize a vector with it:</p>
<div class="fragment"><div class="line"><span class="keyword">using namespace </span><a class="code" href="namespaceranges.html">ranges</a>;</div><div class="line">std::vector&lt;int&gt; vi =</div><div class="line">    <a class="code" href="group__runtime.html#ga8beaba5ae537715c97e180b05160cc03">view::for_each</a>(view::ints(1,10), [](<span class="keywordtype">int</span> i){</div><div class="line">        <span class="keywordflow">return</span> yield_from(<a class="code" href="group__list.html#gab4b5da3947303335fc4139f163ed4748">view::repeat_n</a>(i,i));</div><div class="line">    });</div><div class="line"><span class="comment">// vi == {1,2,2,3,3,3,4,4,4,4,5,5,5,5,5,...}</span></div></div><!-- fragment --><h4>Actions</h4>
<p>When you want to mutate a container in-place, or forward it through a chain of mutating operations, you can use actions. The following examples should make it clear.</p>
<p>Read data into a vector, sort it, and make it unique.</p>
<div class="fragment"><div class="line"><span class="keyword">extern</span> std::vector&lt;int&gt; read_data();</div><div class="line"><span class="keyword">using namespace </span><a class="code" href="namespaceranges.html">ranges</a>;</div><div class="line">std::vector&lt;int&gt; vi = read_data() | <a class="code" href="group__transformation.html#ga01e9a0330388c41cc77d4eed9af9c3d5">action::sort</a> | <a class="code" href="group__transformation.html#ga690f11e9772207d140458abd33af908d">action::unique</a>;</div></div><!-- fragment --><p>Do the same to a <code>vector</code> that already contains some data:</p>
<div class="fragment"><div class="line">vi = <a class="code" href="group__group-algorithms.html#gad3830f80a601a6a46958ca50ef2e34c5">std::move</a>(vi) | <a class="code" href="group__transformation.html#ga01e9a0330388c41cc77d4eed9af9c3d5">action::sort</a> | <a class="code" href="group__transformation.html#ga690f11e9772207d140458abd33af908d">action::unique</a>;</div></div><!-- fragment --><p>Mutate the container in-place:</p>
<div class="fragment"><div class="line">vi |= <a class="code" href="group__transformation.html#ga01e9a0330388c41cc77d4eed9af9c3d5">action::sort</a> | <a class="code" href="group__transformation.html#ga690f11e9772207d140458abd33af908d">action::unique</a>;</div></div><!-- fragment --><p>Same as above, but with function-call syntax instead of pipe syntax:</p>
<div class="fragment"><div class="line"><a class="code" href="group__transformation.html#ga690f11e9772207d140458abd33af908d">action::unique</a>(<a class="code" href="group__transformation.html#ga01e9a0330388c41cc77d4eed9af9c3d5">action::sort</a>(vi));</div></div><!-- fragment --><h2>Create Custom Ranges</h2>
<p>Range v3 provides a utility for easily creating your own range types, called <a class="el" href="structranges_1_1v3_1_1view__facade.html"><code>ranges::view_facade</code></a>. The code below uses <code>view_facade</code> to create a range that traverses a null-terminated string:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="all_8hpp.html">range/v3/all.hpp</a>&gt;</span></div><div class="line"></div><div class="line"><span class="comment">// A range that iterates over all the characters in a</span></div><div class="line"><span class="comment">// null-terminated string.</span></div><div class="line"><span class="keyword">class </span>c_string_range</div><div class="line">  : <span class="keyword">public</span> ranges::view_facade&lt;c_string_range&gt;</div><div class="line">{</div><div class="line">    <span class="keyword">friend</span> ranges::range_access;</div><div class="line">    <span class="keywordtype">char</span> <span class="keyword">const</span> * sz_ = <span class="stringliteral">&quot;&quot;</span>;</div><div class="line">    <span class="keywordtype">char</span> <span class="keyword">const</span> &amp; read()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> *sz_; }</div><div class="line">    <span class="keywordtype">bool</span> <a class="code" href="group__group-algorithms.html#ga231cf1ea1874a1589423358592df426d">equal</a>(ranges::default_sentinel)<span class="keyword"> const </span>{ <span class="keywordflow">return</span> *sz_ == <span class="charliteral">&#39;\0&#39;</span>; }</div><div class="line">    <span class="keywordtype">void</span> <a class="code" href="group__group-utility.html#ga70320521358b8e16455a2931d524bab9">next</a>() { ++sz_; }</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    c_string_range() = <span class="keywordflow">default</span>;</div><div class="line">    <span class="keyword">explicit</span> c_string_range(<span class="keywordtype">char</span> <span class="keyword">const</span> *sz) : sz_(sz)</div><div class="line">    {</div><div class="line">        assert(sz != <span class="keyword">nullptr</span>);</div><div class="line">    }</div><div class="line">};</div></div><!-- fragment --><p>The <code>view_facade</code> class generates an iterator and begin/end member functions from the minimal interface provided by <code>c_string_range</code>. This is an example of a very simple range for which it is not necessary to separate the range itself from the thing that iterates the range. Future examples will show examples of more sophisticated ranges.</p>
<p>With <code>c_string_range</code>, you can now use algorithms to operate on null-terminated strings, as below:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main()</div><div class="line">{</div><div class="line">    c_string_range r(<span class="stringliteral">&quot;hello world&quot;</span>);</div><div class="line">    <span class="comment">// Iterate over all the characters and print them out</span></div><div class="line">    <a class="code" href="group__runtime.html#ga8beaba5ae537715c97e180b05160cc03">ranges::for_each</a>(r, [](<span class="keywordtype">char</span> ch){</div><div class="line">        std::cout &lt;&lt; ch &lt;&lt; <span class="charliteral">&#39; &#39;</span>;</div><div class="line">    });</div><div class="line">    <span class="comment">// prints: h e l l o   w o r l d</span></div><div class="line">}</div></div><!-- fragment --><h2>Adapting Ranges</h2>
<p>Often, a new range type is most easily expressed by adapting an existing range type. That's the case for many of the range views provided by the Range v3 library; for example, the <code>view::remove_if</code> and <code>view::transform</code> views. These are rich types with many moving parts, but thanks to a helper class called <a class="el" href="structranges_1_1v3_1_1view__adaptor.html"><code>ranges::view_adaptor</code></a>, they aren't hard to write.</p>
<p>Below in roughly 2 dozen lines of code is the <code>transform</code> view, which takes one range and transforms all the elements with a unary function.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="all_8hpp.html">range/v3/all.hpp</a>&gt;</span></div><div class="line"></div><div class="line"><span class="comment">// A class that adapts an existing range with a function</span></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> Rng, <span class="keyword">class</span> Fun&gt;</div><div class="line"><span class="keyword">class </span>transform_view</div><div class="line">  : <span class="keyword">public</span> ranges::view_adaptor&lt;transform_view&lt;Rng, Fun&gt;, Rng&gt;</div><div class="line">{</div><div class="line">    <span class="keyword">friend</span> ranges::range_access;</div><div class="line">    ranges::semiregular_t&lt;Fun&gt; fun_; <span class="comment">// Make Fun model SemiRegular if it doesn&#39;t</span></div><div class="line">    <span class="keyword">class </span>adaptor : <span class="keyword">public</span> ranges::adaptor_base</div><div class="line">    {</div><div class="line">        ranges::semiregular_t&lt;Fun&gt; fun_;</div><div class="line">    <span class="keyword">public</span>:</div><div class="line">        adaptor() = <span class="keywordflow">default</span>;</div><div class="line">        adaptor(ranges::semiregular_t&lt;Fun&gt; <span class="keyword">const</span> &amp;fun) : fun_(fun) {}</div><div class="line">        <span class="comment">// Here is where we apply Fun to the elements:</span></div><div class="line">        <span class="keyword">auto</span> read(ranges::iterator_t&lt;Rng&gt; it) <span class="keyword">const</span> -&gt; decltype(fun_(*it))</div><div class="line">        {</div><div class="line">            <span class="keywordflow">return</span> fun_(*it);</div><div class="line">        }</div><div class="line">    };</div><div class="line">    adaptor begin_adaptor()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> {fun_}; }</div><div class="line">    adaptor end_adaptor()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> {fun_}; }</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    transform_view() = <span class="keywordflow">default</span>;</div><div class="line">    transform_view(Rng &amp;&amp; rng, Fun fun)</div><div class="line">      : transform_view::view_adaptor{std::forward&lt;Rng&gt;(rng)}</div><div class="line">      , fun_(<a class="code" href="group__group-algorithms.html#gad3830f80a601a6a46958ca50ef2e34c5">std::move</a>(fun))</div><div class="line">    {}</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> Rng, <span class="keyword">class</span> Fun&gt;</div><div class="line">transform_view&lt;Rng, Fun&gt; <a class="code" href="group__group-actions.html#gaf9135baba87fb451e6e904428239ad19">transform</a>(Rng &amp;&amp; rng, Fun fun)</div><div class="line">{</div><div class="line">    <span class="keywordflow">return</span> {std::forward&lt;Rng&gt;(rng), <a class="code" href="group__group-algorithms.html#gad3830f80a601a6a46958ca50ef2e34c5">std::move</a>(fun)};</div><div class="line">}</div></div><!-- fragment --><p>Range transformation is achieved by defining a nested <code>adaptor</code> class that handles the transformation, and then defining <code>begin_adaptor</code> and <code>end_adaptor</code> members that return adaptors for the begin iterator and the end sentinel, respectively. The <code>adaptor</code> class has a <code>read</code> member that performs the transformation. It is passed an iterator to the current element. Other members are available for customization: <code>equal</code>, <code>next</code>, <code>prev</code>, <code>advance</code>, and <code>distance_to</code>; but the transform adaptor accepts the defaults defined in <a class="el" href="structranges_1_1v3_1_1adaptor__base.html"><code>ranges::adaptor_base</code></a>.</p>
<p>With <code>transform_view</code>, we can print out the first 20 squares:</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> main()</div><div class="line">{</div><div class="line">    <span class="keyword">auto</span> squares = <a class="code" href="group__group-actions.html#gaf9135baba87fb451e6e904428239ad19">::transform</a>(view::ints(1), [](<span class="keywordtype">int</span> i){<span class="keywordflow">return</span> i*i;});</div><div class="line">    <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i : squares | view::take(20))</div><div class="line">        std::cout &lt;&lt; i &lt;&lt; <span class="charliteral">&#39; &#39;</span>;</div><div class="line">    std::cout &lt;&lt; <span class="charliteral">&#39;\n&#39;</span>;</div><div class="line">    <span class="comment">// prints 1 4 9 16 25 36 49 64 81 100 121 144 169 196 225 256 289 324 361 400</span></div><div class="line">}</div></div><!-- fragment --><p>The <code>transform_view</code> defined above is an InputRange when it's wrapping an InputRange, a ForwardRange when it's wrapping a ForwardRange, etc. That happens because of smart defaults defined in the <code>adaptor_base</code> class. That frees you from having to deal with a host of niggly detail when implementing iterators.</p>
<p>*(Note: the above <code>transform_view</code> always stores a copy of the function in the sentinel. That is only necessary if the underlying range's sentinel type models BidirectionalIterator. That's a finer point that you shouldn't worry about right now.)*</p>
<h2>Create Custom Iterators</h2>
<p>Here is an example of Range v3 compatible RandomAccess proxy iterator. The iterator returns a key/value pair, like the <code>zip</code> view.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="basic__iterator_8hpp.html">range/v3/utility/basic_iterator.hpp</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="common__tuple_8hpp.html">range/v3/utility/common_tuple.hpp</a>&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">using</span> KeyIter   = <span class="keyword">typename</span> std::vector&lt;Key&gt;::iterator;</div><div class="line"><span class="keyword">using</span> ValueIter = <span class="keyword">typename</span> std::vector&lt;Value&gt;::iterator;</div><div class="line"></div><div class="line"><span class="keyword">struct </span>cursor {</div><div class="line"></div><div class="line">    <span class="comment">// basic_iterator derives from &quot;mixin&quot;, if present, so it can be used</span></div><div class="line">    <span class="comment">// to inject things into the public interface of the iterator</span></div><div class="line">    <span class="keyword">struct </span>mixin;</div><div class="line"></div><div class="line">    <span class="comment">// This is for dereference operator.      </span></div><div class="line">    <span class="keyword">using</span> value_type = std::pair&lt;Key, Value&gt;; </div><div class="line">    ranges::common_pair&lt;Key&amp;, Value&amp;&gt; read()<span class="keyword"> const </span>{</div><div class="line">        <span class="keywordflow">return</span> { *key_iterator, *value_iterator };</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keywordtype">bool</span> <a class="code" href="group__group-algorithms.html#ga231cf1ea1874a1589423358592df426d">equal</a>(<span class="keyword">const</span> cursor&amp; other)<span class="keyword"> const </span>{</div><div class="line">        <span class="keywordflow">return</span> key_iterator == other.key_iterator;</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keywordtype">void</span> <a class="code" href="group__group-utility.html#ga70320521358b8e16455a2931d524bab9">next</a>() { </div><div class="line">        ++key_iterator;</div><div class="line">        ++value_iterator;</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">// prev optional. Required for Bidirectional iterator</span></div><div class="line">    <span class="keywordtype">void</span> <a class="code" href="group__group-utility.html#ga93ed84b86d8219a3018f2f5605c2492c">prev</a>() { </div><div class="line">        --key_iterator;</div><div class="line">        --value_iterator;</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">// advance and distance_to are optional. Required for RandomAcess iterator</span></div><div class="line">    <span class="keywordtype">void</span> advance(std::ptrdiff_t n) { </div><div class="line">        key_iterator   += n;</div><div class="line">        value_iterator += n;</div><div class="line">    }</div><div class="line">    std::ptrdiff_t distance_to(<span class="keyword">const</span> cursor&amp; other)<span class="keyword"> const </span>{</div><div class="line">        <span class="keywordflow">return</span> other.key_iterator - this-&gt;key_iterator;</div><div class="line">    }</div><div class="line"></div><div class="line">    cursor() = <span class="keywordflow">default</span>;</div><div class="line">    cursor(KeyIter key_iterator, ValueIter value_iterator)</div><div class="line">        : key_iterator(key_iterator)</div><div class="line">        , value_iterator(value_iterator)</div><div class="line">    {}</div><div class="line"></div><div class="line">    KeyIter   key_iterator;</div><div class="line">    ValueIter value_iterator;</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keyword">struct </span>cursor::mixin : ranges::basic_mixin&lt;cursor&gt;</div><div class="line">{</div><div class="line">  <span class="keyword">using</span> ranges::basic_mixin&lt;cursor&gt;::basic_mixin;</div><div class="line"></div><div class="line">  <span class="comment">// It is necessary to expose constructor in this way</span></div><div class="line">  mixin(KeyIter key_iterator, ValueIter value_iterator)</div><div class="line">    : mixin{ cursor(key_iterator, value_iterator) }</div><div class="line">  {}</div><div class="line"></div><div class="line">  KeyIter key_iterator() {</div><div class="line">    <span class="keywordflow">return</span> this-&gt;<span class="keyword">get</span>().key_iterator;</div><div class="line">  }</div><div class="line">  ValueIter value_iterator() {</div><div class="line">    <span class="keywordflow">return</span> this-&gt;<span class="keyword">get</span>().value_iterator;</div><div class="line">  }</div><div class="line">};    </div><div class="line"></div><div class="line"><span class="keyword">using</span> iterator = ranges::basic_iterator&lt;cursor&gt;;</div><div class="line"></div><div class="line"><span class="keywordtype">void</span> test(){</div><div class="line">  std::vector&lt;Key&gt;   keys   = {1};</div><div class="line">  std::vector&lt;Value&gt; values = {10};</div><div class="line"></div><div class="line">  iterator iter(keys.begin(), values.begin());</div><div class="line">  ranges::common_pair&lt;Key&amp;, Value&amp;&gt; <a class="code" href="group__list.html#gafd1e131e4e3ae4b0ae9bd3d2ec3a5f74">pair</a> = *iter;</div><div class="line">  Key&amp;   key   = <a class="code" href="group__list.html#gafd1e131e4e3ae4b0ae9bd3d2ec3a5f74">pair</a>.first;</div><div class="line">  Value&amp; value = <a class="code" href="group__list.html#gafd1e131e4e3ae4b0ae9bd3d2ec3a5f74">pair</a>.second;</div><div class="line"></div><div class="line">  assert(&amp;key   == &amp;keys[0]);</div><div class="line">  assert(&amp;value == &amp;values[0]);      </div><div class="line"></div><div class="line">  <span class="keyword">auto</span> key_iter = iter.key_iterator();</div><div class="line">  assert(key_iter == keys.begin());</div><div class="line">}</div></div><!-- fragment --><p><code>read()</code> returns references. So, we explicitly specify <code>value_type</code>. <br />
 <code>ranges::common_pair</code> has conversions: <br />
<code>ranges::common_pair&lt;Key&amp;, Value&amp;&gt;</code> &lt;=&gt; <code>ranges::common_pair&lt;Key, Value&gt;</code>. <br />
All <code>ranges::common_pair</code>s converts to their <code>std::pair</code> equivalents, also.</p>
<p>For more information, see <a href="http://wg21.link/P0186#basic-iterators-iterators.basic">http://wg21.link/P0186#basic-iterators-iterators.basic</a></p>
<h2>Constrain Functions with Concepts</h2>
<p>The Range v3 library makes heavy use of concepts to constrain functions, control overloading, and check type constraints at compile-time. It achieves this with the help of a Concepts Lite emulation layer that works on any standard-conforming C++11 compiler. The library provides many useful concepts, both for the core language and for iterators and ranges. You can use the concepts framework to constrain your own code.</p>
<p>For instance, if you would like to write a function that takes an iterator/sentinel pair, you can write it like this:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">class </span>Iter, <span class="keyword">class </span>Sent, <span class="keyword">class </span>Comp = <span class="comment">/*...some_default..*/</span>,</div><div class="line">    CONCEPT_REQUIRES_(Sentinel&lt;Sent, Iter&gt;())&gt;</div><div class="line"><span class="keywordtype">void</span> my_algorithm(Iter <a class="code" href="group__list.html#ga68418643d5aacd0ec2afe5a0e933ccf3">first</a>, Sent last, Comp comp = Comp{})</div><div class="line">{</div><div class="line">    <span class="comment">// ...</span></div><div class="line">}</div></div><!-- fragment --><p>You can then add an overload that take a Range:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">class </span>Rng, <span class="keyword">class </span>Comp = <span class="comment">/*...some_default..*/</span>,</div><div class="line">    CONCEPT_REQUIRES_(Range&lt;Rng&gt;())&gt;</div><div class="line"><span class="keywordtype">void</span> my_algorithm(Rng &amp;&amp; rng, Comp comp = Comp{})</div><div class="line">{</div><div class="line">    <span class="keywordflow">return</span> my_algorithm(ranges::begin(rng), ranges::end(rng));</div><div class="line">}</div></div><!-- fragment --><p>With the type constraints expressed with the <code>CONCEPTS_REQUIRES_</code> macro, these two overloads are guaranteed to not be ambiguous.</p>
<h2>Range v3 and the Future</h2>
<p>Range v3 forms the basis for a proposal to add ranges to the standard library (<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4128.html">N4128</a>), and is also be the basis for a Technical Specification on Ranges. The Technical Specification contains many of Range v3's concept definitions (translated into the actual syntax of C++20 Concepts) in addition to constrained versions of the STL algorithms overloaded both for iterator/sentinel pairs and for ranges. The Ranges TS has already been sent to ISO for publication.</p>
<p>The views and actions, as well as various utilities, have not yet been reviewed by the committee, although the basic direction has already passed an initial review. A proposal to add a subset of the views to the Ranges TS is in the early stages.</p>
<h1><a class="anchor" id="range-views"></a>
Range Views</h1>
<hr/>
<p> The big advantage of ranges over iterators is their <em>composability</em>. They permit a functional style of programming where data is manipulated by passing it through a series of combinators. In addition, the combinators can be <em>lazy</em>, only doing work when the answer is requested, and <em>purely functional</em>, without mutating the original data. This makes it easier to reason about your code, especially when writing concurrent programs.</p>
<p>Below is a list of the lazy range combinators, or <em>views</em>, that Range v3 provides, and a blurb about how each is intended to be used.</p>
<dl>
<dt><a class="el" href="structranges_1_1v3_1_1view_1_1adjacent__filter__fn.html"><code>view::adjacent_filter</code></a> </dt>
<dd>For each pair of adjacent elements in a source range, evaluate the specified binary predicate. If the predicate evaluates to false, the second element of the pair is removed from the result range; otherwise, it is included. The first element in the source range is always included. (For instance, <code>adjacent_filter</code> with <code>std::not_equal_to</code> filters out all the non-unique elements.) </dd>
<dt><a class="el" href="structranges_1_1v3_1_1view_1_1adjacent__remove__if__fn.html"><code>view::adjacent_remove_if</code></a> </dt>
<dd>For each pair of adjacent elements in a source range, evaluate the specified binary predicate. If the predicate evaluates to true, the first element of the pair is removed from the result range; otherwise, it is included. The last element in the source range is always included. </dd>
<dt><a class="el" href="structranges_1_1v3_1_1view_1_1all__fn.html"><code>view::all</code></a> </dt>
<dd>Return a range containing all the elements in the source. Useful for converting containers to ranges. </dd>
<dt><a class="el" href="structranges_1_1v3_1_1any__view.html"><code>any_view&lt;T&gt;(rng)</code></a> </dt>
<dd>Type-erased range of elements with value type <code>T</code>; can store <em>any</em> range with this value type. </dd>
<dt><a class="el" href="structranges_1_1v3_1_1view_1_1bounded__fn.html"><code>view::bounded</code></a> </dt>
<dd>Convert the source range to a <em>bounded</em> range, where the type of the <code>end</code> is the same as the <code>begin</code>. Useful for iterating over a range with C++'s range-based <code>for</code> loop. </dd>
<dt><a class="el" href="structranges_1_1v3_1_1view_1_1cartesian__product__fn.html"><code>view::cartesian_product</code></a> </dt>
<dd>Enumerates the n-ary cartesian product of <code>n</code> ranges, i.e., generates all <code>n</code>-tuples <code>(e1, e2, ... , en)</code> where <code>e1</code> is an element of the first range, <code>e2</code> is an element of the second range, etc. </dd>
<dt><a class="el" href="structranges_1_1v3_1_1view_1_1chunk__fn.html"><code>view::chunk</code></a> </dt>
<dd>Given a source range and an integer <em>N</em>, produce a range of contiguous ranges where each inner range has <em>N</em> contiguous elements. The final range may have fewer than <em>N</em> elements. </dd>
<dt><a class="el" href="structranges_1_1v3_1_1view_1_1concat__fn.html"><code>view::concat</code></a> </dt>
<dd>Given <em>N</em> source ranges, produce a result range that is the concatenation of all of them. </dd>
<dt><a class="el" href="structranges_1_1v3_1_1view_1_1const__fn.html"><code>view::const_</code></a> </dt>
<dd>Present a <code>const</code> view of a source range. </dd>
<dt><a class="el" href="structranges_1_1v3_1_1view_1_1counted__fn.html"><code>view::counted</code></a> </dt>
<dd>Given an iterator <code>it</code> and a count <code>n</code>, create a range that starts at <code>it</code> and includes the next <code>n</code> elements. </dd>
<dt><a class="el" href="structranges_1_1v3_1_1view_1_1cycle__fn.html"><code>view::cycle</code></a> </dt>
<dd>Returns an infinite range that endlessly repeats the source range. </dd>
<dt><a class="el" href="structranges_1_1v3_1_1view_1_1c__str__fn.html"><code>view::c_str</code></a> </dt>
<dd>View a <code>\0</code>-terminated C string (e.g. from a <code>const char*</code>) as a range. </dd>
<dt><a class="el" href="structranges_1_1v3_1_1view_1_1delimit__fn.html"><code>view::delimit</code></a> </dt>
<dd>Given a source range and a value, return a new range that ends either at the end of the source or at the first occurrence of the value, whichever comes first. Alternatively, <code>view::delimit</code> can be called with an iterator and a value, in which case it returns a range that starts at the specified position and ends at the first occurrence of the value. </dd>
<dt><a class="el" href="structranges_1_1v3_1_1view_1_1drop__fn.html"><code>view::drop</code></a> </dt>
<dd>Given a source range and an integral count, return a range consisting of all but the first <em>count</em> elements from the source range, or an empty range if it has fewer elements. </dd>
<dt><a class="el" href="structranges_1_1v3_1_1view_1_1drop__exactly__fn.html"><code>view::drop_exactly</code></a> </dt>
<dd>Given a source range and an integral count, return a range consisting of all but the first <em>count</em> elements from the source range. The source range must have at least that many elements. </dd>
<dt><a class="el" href="structranges_1_1v3_1_1view_1_1drop__while__fn.html"><code>view::drop_while</code></a> </dt>
<dd>Remove elements from the front of a range that satisfy a unary predicate. </dd>
<dt><a class="el" href="group__list.html#gada7280d87ece1a3dc6b203ee0e86e71c"><code>view::empty</code></a> </dt>
<dd>Create an empty range with a given value type. </dd>
<dt><a class="el" href="group__group-core.html#gaea4cba33b3f10f828c5c3418a6b271a7"><code>view::enumerate</code></a> </dt>
<dd>Pair each element of a range with its index. </dd>
<dt><a class="el" href="structranges_1_1v3_1_1view_1_1filter__fn.html"><code>view::filter</code></a> </dt>
<dd>Given a source range and a unary predicate, filter the elements that satisfy the predicate. (For users of Boost.Range, this is like the <code>filter</code> adaptor.) </dd>
<dt><a class="el" href="structranges_1_1v3_1_1view_1_1for__each__fn.html"><code>view::for_each</code></a> </dt>
<dd>Lazily applies an unary function to each element in the source range that returns another range (possibly empty), flattening the result. </dd>
<dt><a class="el" href="structranges_1_1v3_1_1view_1_1generate__fn.html"><code>view::generate</code></a> </dt>
<dd>Given a nullary function, return an infinite range whose elements are generated with the function. </dd>
<dt><a class="el" href="structranges_1_1v3_1_1view_1_1generate__n__fn.html"><code>view::generate_n</code></a> </dt>
<dd>Given a nullary function and a count, return a range that generates the requested number of elements by calling the function. </dd>
<dt><a class="el" href="structranges_1_1v3_1_1view_1_1group__by__fn.html"><code>view::group_by</code></a> </dt>
<dd>Given a source range and a binary predicate, return a range of ranges where each range contains contiguous elements from the source range such that the following condition holds: for each element in the range apart from the first, when that element and the first element are passed to the binary predicate, the result is true. In essence, <code>view::group_by</code> <em>groups</em> contiguous elements together with a binary predicate. </dd>
<dt><a class="el" href="structranges_1_1v3_1_1view_1_1indirect__fn.html"><code>view::indirect</code></a> </dt>
<dd>Given a source range of readable values (e.g. pointers or iterators), return a new view that is the result of dereferencing each. </dd>
<dt><a class="el" href="structranges_1_1v3_1_1view_1_1intersperse__fn.html"><code>view::intersperse</code></a> </dt>
<dd>Given a source range and a value, return a new range where the value is inserted between contiguous elements from the source. </dd>
<dt><a class="el" href="structranges_1_1v3_1_1view_1_1ints__fn.html"><code>view::ints</code></a> </dt>
<dd>Generate a range of monotonically increasing <code>int</code>s. When used without arguments, it generates the quasi-infinite range [0,1,2,3...]. It can also be called with a lower bound, or with a lower and upper bound (exclusive). An inclusive version is provided by <code>closed_ints</code>. </dd>
<dt><a class="el" href="structranges_1_1v3_1_1view_1_1iota__fn.html"><code>view::iota</code></a> </dt>
<dd>A generalization of <code>view::ints</code> that generates a sequence of monotonically increasing values of any incrementable type. When specified with a single argument, the result is an infinite range beginning at the specified value. With two arguments, the values are assumed to denote a half-open range. </dd>
<dt><a class="el" href="structranges_1_1v3_1_1view_1_1join__fn.html"><code>view::join</code></a> </dt>
<dd>Given a range of ranges, join them into a flattened sequence of elements. Optionally, you can specify a value or a range to be inserted between each source range. </dd>
<dt><a class="el" href="structranges_1_1v3_1_1view_1_1keys__fn.html"><code>view::keys</code></a> </dt>
<dd>Given a range of <code>pair</code>s (like a <code>std::map</code>), return a new range consisting of just the first element of the <code>pair</code>. </dd>
<dt><a class="el" href="structranges_1_1v3_1_1view_1_1linear__distribute__fn.html"><code>view::linear_distribute</code></a> </dt>
<dd>Distributes <code>n</code> values linearly in the closed interval <code>[from, to]</code> (the end points are always included). If <code>from == to</code>, returns <code>n</code>-times <code>to</code>, and if <code>n == 1</code> it returns <code>to</code>. </dd>
<dt><a class="el" href="structranges_1_1v3_1_1view_1_1move__fn.html"><code>view::move</code></a> </dt>
<dd>Given a source range, return a new range where each element has been has been cast to an rvalue reference. </dd>
<dt><a class="el" href="structranges_1_1v3_1_1view_1_1partial__sum__fn.html"><code>view::partial_sum</code></a> </dt>
<dd>Given a range and a binary function, return a new range where the <em>N</em><sup>th</sup> element is the result of applying the function to the <em>N</em><sup>th</sup> element from the source range and the (N-1)th element from the result range. </dd>
<dt><a class="el" href="structranges_1_1v3_1_1view_1_1remove__if__fn.html"><code>view::remove_if</code></a> </dt>
<dd>Given a source range and a unary predicate, filter out those elements that do not satisfy the predicate. (For users of Boost.Range, this is like the <code>filter</code> adaptor with the predicate negated.) </dd>
<dt><a class="el" href="structranges_1_1v3_1_1view_1_1repeat__fn.html"><code>view::repeat</code></a> </dt>
<dd>Given a value, create a range that is that value repeated infinitely. </dd>
<dt><a class="el" href="structranges_1_1v3_1_1view_1_1repeat__n__fn.html"><code>view::repeat_n</code></a> </dt>
<dd>Given a value and a count, create a range that is that value repeated <em>count</em> number of times. </dd>
<dt><a class="el" href="structranges_1_1v3_1_1view_1_1replace__fn.html"><code>view::replace</code></a> </dt>
<dd>Given a source range, a source value and a target value, create a new range where all elements equal to the source value are replaced with the target value. </dd>
<dt><a class="el" href="structranges_1_1v3_1_1view_1_1replace__if__fn.html"><code>view::replace_if</code></a> </dt>
<dd>Given a source range, a unary predicate and a target value, create a new range where all elements that satisfy the predicate are replaced with the target value. </dd>
<dt><a class="el" href="structranges_1_1v3_1_1view_1_1reverse__fn.html"><code>view::reverse</code></a> </dt>
<dd>Create a new range that traverses the source range in reverse order. </dd>
<dt><a class="el" href="classranges_1_1v3_1_1view_1_1sample__fn.html"><code>view::sample</code></a> </dt>
<dd>Returns a random sample of a range of length <code>size(range)</code>. </dd>
<dt><a class="el" href="structranges_1_1v3_1_1view_1_1single__fn.html"><code>view::single</code></a> </dt>
<dd>Given a value, create a range with exactly one element. </dd>
<dt><a class="el" href="structranges_1_1v3_1_1view_1_1slice__fn.html"><code>view::slice</code></a> </dt>
<dd>Give a source range a lower bound (inclusive) and an upper bound (exclusive), create a new range that begins and ends at the specified offsets. Both the begin and the end can be integers relative to the front, or relative to the end with "`end-2`" syntax. </dd>
<dt><a class="el" href="structranges_1_1v3_1_1view_1_1sliding__fn.html"><code>view::sliding</code></a> </dt>
<dd>Given a range and a count <code>n</code>, place a window over the first <code>n</code> elements of the underlying range. Return the contents of that window as the first element of the adapted range, then slide the window forward one element at a time until hitting the end of the underlying range. </dd>
<dt><a class="el" href="structranges_1_1v3_1_1view_1_1split__fn.html"><code>view::split</code></a> </dt>
<dd>Given a source range and a delimiter specifier, split the source range into a range of ranges using the delimiter specifier to find the boundaries. The delimiter specifier can be a value, a subrange, a predicate, or a function. The predicate should take an single argument of the range's reference type and return true if and only if the element is part of a delimiter. The function should accept current/end iterators into the source range and return <code>make_pair(true, iterator_past_the_delimiter)</code> if the current position is a boundary; otherwise, <code>make_pair(false, cur)</code>. The delimiter character(s) are excluded from the resulting range of ranges. </dd>
<dt><a class="el" href="structranges_1_1v3_1_1view_1_1stride__fn.html"><code>view::stride</code></a> </dt>
<dd>Given a source range and an integral stride value, return a range consisting of every <em>N</em><sup>th</sup> element, starting with the first. </dd>
<dt><a class="el" href="structranges_1_1v3_1_1view_1_1tail__fn.html"><code>view::tail</code></a> </dt>
<dd>Given a source range, return a new range without the first element. The range must have at least one element. </dd>
<dt><a class="el" href="structranges_1_1v3_1_1view_1_1take__fn.html"><code>view::take</code></a> </dt>
<dd>Given a source range and an integral count, return a range consisting of the first <em>count</em> elements from the source range, or the complete range if it has fewer elements. (The result of <code>view::take</code> is not a <code>SizedRange</code>.) </dd>
<dt><a class="el" href="structranges_1_1v3_1_1view_1_1take__exactly__fn.html"><code>view::take_exactly</code></a> </dt>
<dd>Given a source range and an integral count, return a range consisting of the first <em>count</em> elements from the source range. The source range must have at least that many elements. (The result of <code>view::take_exactly</code> is a <code>SizedRange</code>.) </dd>
<dt><a class="el" href="structranges_1_1v3_1_1view_1_1take__while__fn.html"><code>view::take_while</code></a> </dt>
<dd>Given a source range and a unary predicate, return a new range consisting of the elements from the front that satisfy the predicate. </dd>
<dt><a class="el" href="structranges_1_1v3_1_1view_1_1tokenize__fn.html"><code>view::tokenize</code></a> </dt>
<dd>Given a source range and optionally a submatch specifier and a <code>std::regex_constants::match_flag_type</code>, return a <code>std::regex_token_iterator</code> to step through the regex submatches of the source range. The submatch specifier may be either a plain <code>int</code>, a <code>std::vector&lt;int&gt;</code>, or a <code>std::initializer_list&lt;int&gt;</code>. </dd>
<dt><a class="el" href="structranges_1_1v3_1_1view_1_1transform__fn.html"><code>view::transform</code></a> </dt>
<dd>Given a source range and a unary function, return a new range where each result element is the result of applying the unary function to a source element. </dd>
<dt><a class="el" href="structranges_1_1v3_1_1view_1_1unbounded__fn.html"><code>view::unbounded</code></a> </dt>
<dd>Given an iterator, return an infinite range that begins at that position. </dd>
<dt><a class="el" href="structranges_1_1v3_1_1view_1_1unique__fn.html"><code>view::unique</code></a> </dt>
<dd>Given a range, return a new range where all consecutive elements that compare equal save the first have been filtered out. </dd>
<dt><a class="el" href="structranges_1_1v3_1_1view_1_1values__fn.html"><code>view::values</code></a> </dt>
<dd>Given a range of <code>pair</code>s (like a <code>std::map</code>), return a new range consisting of just the second element of the <code>pair</code>. </dd>
<dt><a class="el" href="structranges_1_1v3_1_1view_1_1zip__fn.html"><code>view::zip</code></a> </dt>
<dd>Given <em>N</em> ranges, return a new range where <em>M</em><sup>th</sup> element is the result of calling <code>make_tuple</code> on the <em>M</em><sup>th</sup> elements of all <em>N</em> ranges. </dd>
<dt><a class="el" href="structranges_1_1v3_1_1view_1_1zip__with__fn.html"><code>view::zip_with</code></a> </dt>
<dd>Given <em>N</em> ranges and a <em>N</em>-ary function, return a new range where <em>M</em><sup>th</sup> element is the result of calling the function on the <em>M</em><sup>th</sup> elements of all <em>N</em> ranges. </dd>
</dl>
<h1><a class="anchor" id="range-actions"></a>
Range Actions</h1>
<hr/>
<p>Below is a list of the eager range combinators, or <em>actions</em>, that Range v3 provides, and a blurb about how each is intended to be used.</p>
<dl>
<dt><a class="el" href="structranges_1_1v3_1_1action_1_1drop__fn.html"><code>action::drop</code></a> </dt>
<dd>Removes the first <code>N</code> elements of the source range. </dd>
<dt><a class="el" href="structranges_1_1v3_1_1action_1_1drop__while__fn.html"><code>action::drop_while</code></a> </dt>
<dd>Removes the first elements of the source range that satisfy the unary predicate. </dd>
<dt><code>action::erase</code> </dt>
<dd>Removes all elements in the sub-range of the source (range version) or all elements after position. </dd>
<dt><code>action::insert</code> </dt>
<dd>Inserts all elements of the range into the source at position. </dd>
<dt><a class="el" href="structranges_1_1v3_1_1action_1_1join__fn.html"><code>action::join</code></a> </dt>
<dd>Flattens a range of ranges. </dd>
<dt><code>action::push_back</code> </dt>
<dd>Appends elements to the tail of the source. </dd>
<dt><code>action::push_front</code> </dt>
<dd>Appends elements before the head of the source. </dd>
<dt><a class="el" href="structranges_1_1v3_1_1action_1_1remove__if__fn.html"><code>action::remove_if</code></a> </dt>
<dd>Removes all elements from the source that satisfy the predicate. </dd>
<dt><a class="el" href="structranges_1_1v3_1_1action_1_1shuffle__fn.html"><code>action::shuffle</code></a> </dt>
<dd>Shuffles the source range. </dd>
<dt><a class="el" href="structranges_1_1v3_1_1action_1_1slice__fn.html"><code>action::slice</code></a> </dt>
<dd>Removes all elements from the source that are not part of the sub-range. </dd>
<dt><a class="el" href="structranges_1_1v3_1_1action_1_1sort__fn.html"><code>action::sort</code></a> </dt>
<dd>Sorts the source range (unstable). </dd>
<dt><a class="el" href="structranges_1_1v3_1_1action_1_1split__fn.html"><code>action::split</code></a> </dt>
<dd>Split a range into a sequence of subranges using a delimiter (a value, a sequence of values, a predicate, or a binary function returning a <code>pair&lt;bool, N&gt;</code>). </dd>
<dt><a class="el" href="structranges_1_1v3_1_1action_1_1stable__sort__fn.html"><code>action::stable_sort</code></a> </dt>
<dd>Sorts the source range (stable). </dd>
<dt><a class="el" href="structranges_1_1v3_1_1action_1_1stride__fn.html"><code>action::stride</code></a> </dt>
<dd>Removes all elements whose position does not match the stride. </dd>
<dt><a class="el" href="structranges_1_1v3_1_1action_1_1take__fn.html"><code>action::take</code></a> </dt>
<dd>Keeps the first <code>N</code>-th elements of the range, removes the rest. </dd>
<dt><a class="el" href="structranges_1_1v3_1_1action_1_1take__while__fn.html"><code>action::take_while</code></a> </dt>
<dd>Keeps the first elements that satisfy the predicate, removes the rest. </dd>
<dt><a class="el" href="structranges_1_1v3_1_1action_1_1transform__fn.html"><code>action::transform</code></a> </dt>
<dd>Replaces elements of the source with the result of the unary function. </dd>
<dt><code>action::unique</code> </dt>
<dd>Removes adjacent elements of the source that compare equal. If the source is sorted, removes all duplicate elements. </dd>
</dl>
<h1><a class="anchor" id="example-section"></a>
Examples</h1>
<h2><a class="anchor" id="example-hello"></a>
hello ranges</h2>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="all_8hpp.html">range/v3/all.hpp</a>&gt;</span> <span class="comment">// get everything</span></div><div class="line"><span class="preprocessor">#include &lt;string&gt;</span></div><div class="line"><span class="keyword">using</span> std::cout;</div><div class="line"></div><div class="line"><span class="keywordtype">int</span></div><div class="line">main()</div><div class="line">{</div><div class="line">    std::string s{<span class="stringliteral">&quot;hello&quot;</span>};</div><div class="line"></div><div class="line">    <span class="comment">// output: h e l l o</span></div><div class="line">    <a class="code" href="group__runtime.html#ga8beaba5ae537715c97e180b05160cc03">ranges::for_each</a>(s, [](<span class="keywordtype">char</span> c) { cout &lt;&lt; c &lt;&lt; <span class="charliteral">&#39; &#39;</span>; });</div><div class="line">    cout &lt;&lt; <span class="charliteral">&#39;\n&#39;</span>;</div><div class="line">}</div></div><!-- fragment --> <h2><a class="anchor" id="example-any-all-none"></a>
any_of, all_of, none_of</h2>
<div class="fragment"><div class="line"><span class="comment">// Demonstrates any_of, all_of, none_of</span></div><div class="line"><span class="comment">// output</span></div><div class="line"><span class="comment">// vector: [6,2,3,4,5,6]</span></div><div class="line"><span class="comment">// vector any_of is_six: true</span></div><div class="line"><span class="comment">// vector all_of is_six: false</span></div><div class="line"><span class="comment">// vector none_of is_six: false</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="all__of_8hpp.html">range/v3/algorithm/all_of.hpp</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="any__of_8hpp.html">range/v3/algorithm/any_of.hpp</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="algorithm_2for__each_8hpp.html">range/v3/algorithm/for_each.hpp</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="none__of_8hpp.html">range/v3/algorithm/none_of.hpp</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="view_2all_8hpp.html">range/v3/view/all.hpp</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;vector&gt;</span></div><div class="line"><span class="keyword">using</span> std::cout;</div><div class="line"></div><div class="line"><span class="keyword">auto</span> is_six = [](<span class="keywordtype">int</span> i) { <span class="keywordflow">return</span> i == 6; };</div><div class="line"></div><div class="line"><span class="keywordtype">int</span></div><div class="line">main()</div><div class="line">{</div><div class="line">    std::vector&lt;int&gt; v{6, 2, 3, 4, 5, 6};</div><div class="line">    cout &lt;&lt; std::boolalpha;</div><div class="line">    cout &lt;&lt; <span class="stringliteral">&quot;vector: &quot;</span> &lt;&lt; ranges::view::all(v) &lt;&lt; <span class="charliteral">&#39;\n&#39;</span>;</div><div class="line"></div><div class="line">    cout &lt;&lt; <span class="stringliteral">&quot;vector any_of is_six: &quot;</span> &lt;&lt; <a class="code" href="group__query.html#gab3e0a5185f49046bc33e0fb3e277c2d3">ranges::any_of</a>(v, is_six) &lt;&lt; <span class="charliteral">&#39;\n&#39;</span>;</div><div class="line">    cout &lt;&lt; <span class="stringliteral">&quot;vector all_of is_six: &quot;</span> &lt;&lt; <a class="code" href="group__query.html#ga405b36a9521bcad7b682c0e2eac0ed2c">ranges::all_of</a>(v, is_six) &lt;&lt; <span class="charliteral">&#39;\n&#39;</span>;</div><div class="line">    cout &lt;&lt; <span class="stringliteral">&quot;vector none_of is_six: &quot;</span> &lt;&lt; <a class="code" href="group__query.html#ga031bcd90a3a1b48791d0e4657cc0584a">ranges::none_of</a>(v, is_six) &lt;&lt; <span class="charliteral">&#39;\n&#39;</span>;</div><div class="line">}</div></div><!-- fragment --> <h2><a class="anchor" id="example-count"></a>
count</h2>
<div class="fragment"><div class="line"><span class="comment">// This example demonstrates counting the number of</span></div><div class="line"><span class="comment">// elements that match a given value.</span></div><div class="line"><span class="comment">// output...</span></div><div class="line"><span class="comment">// vector:   2</span></div><div class="line"><span class="comment">// array:    2</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="count_8hpp.html">range/v3/algorithm/count.hpp</a>&gt;</span> <span class="comment">// specific includes</span></div><div class="line"><span class="preprocessor">#include &lt;vector&gt;</span></div><div class="line"><span class="keyword">using</span> std::cout;</div><div class="line"></div><div class="line"><span class="keywordtype">int</span></div><div class="line">main()</div><div class="line">{</div><div class="line">    std::vector&lt;int&gt; v{6, 2, 3, 4, 5, 6};</div><div class="line">    <span class="comment">// note the count return is a numeric type</span></div><div class="line">    <span class="comment">// like int or long -- auto below make sure</span></div><div class="line">    <span class="comment">// it matches the implementation</span></div><div class="line">    <span class="keyword">auto</span> c = <a class="code" href="group__query.html#ga4848df7ba99543f67c99b394d933d3ca">ranges::count</a>(v, 6);</div><div class="line">    cout &lt;&lt; <span class="stringliteral">&quot;vector:   &quot;</span> &lt;&lt; c &lt;&lt; <span class="charliteral">&#39;\n&#39;</span>;</div><div class="line"></div><div class="line">    std::array&lt;int, 6&gt; a{6, 2, 3, 4, 5, 6};</div><div class="line">    c = <a class="code" href="group__query.html#ga4848df7ba99543f67c99b394d933d3ca">ranges::count</a>(a, 6);</div><div class="line">    cout &lt;&lt; <span class="stringliteral">&quot;array:    &quot;</span> &lt;&lt; c &lt;&lt; <span class="charliteral">&#39;\n&#39;</span>;</div><div class="line">}</div><div class="line"></div></div><!-- fragment --> <h2><a class="anchor" id="example-count_if"></a>
count_if</h2>
<div class="fragment"><div class="line"><span class="comment">// This example counts element of a range that match a supplied predicate.</span></div><div class="line"><span class="comment">// output</span></div><div class="line"><span class="comment">// vector:   2</span></div><div class="line"><span class="comment">// array:    2</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;array&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="count__if_8hpp.html">range/v3/algorithm/count_if.hpp</a>&gt;</span> <span class="comment">// specific includes</span></div><div class="line"><span class="preprocessor">#include &lt;vector&gt;</span></div><div class="line"><span class="keyword">using</span> std::cout;</div><div class="line"></div><div class="line"><span class="keyword">auto</span> is_six = [](<span class="keywordtype">int</span> i) -&gt; <span class="keywordtype">bool</span> { <span class="keywordflow">return</span> i == 6; };</div><div class="line"></div><div class="line"><span class="keywordtype">int</span></div><div class="line">main()</div><div class="line">{</div><div class="line">    std::vector&lt;int&gt; v{6, 2, 3, 4, 5, 6};</div><div class="line">    <span class="keyword">auto</span> c = <a class="code" href="group__query.html#gaa05d678299baae3495fc15bb04f98788">ranges::count_if</a>(v, is_six);</div><div class="line">    cout &lt;&lt; <span class="stringliteral">&quot;vector:   &quot;</span> &lt;&lt; c &lt;&lt; <span class="charliteral">&#39;\n&#39;</span>; <span class="comment">// 2</span></div><div class="line"></div><div class="line">    std::array&lt;int, 6&gt; a{6, 2, 3, 4, 5, 6};</div><div class="line">    c = <a class="code" href="group__query.html#gaa05d678299baae3495fc15bb04f98788">ranges::count_if</a>(a, is_six);</div><div class="line">    cout &lt;&lt; <span class="stringliteral">&quot;array:    &quot;</span> &lt;&lt; c &lt;&lt; <span class="charliteral">&#39;\n&#39;</span>; <span class="comment">// 2</span></div><div class="line">}</div></div><!-- fragment --> <h2><a class="anchor" id="example-find"></a>
find, find_if, find_if_not on sequence containers</h2>
<div class="fragment"><div class="line"><span class="comment">// vector:   *i: 6</span></div><div class="line"><span class="comment">// didn&#39;t find 10</span></div><div class="line"><span class="comment">// *i: 6</span></div><div class="line"><span class="comment">// *i: 2</span></div><div class="line"><span class="comment">// *i after ++ (2 expected): 2</span></div><div class="line"><span class="comment">// array:    *i: 6</span></div><div class="line"><span class="comment">// list:     *i: 6</span></div><div class="line"><span class="comment">// fwd_list: *i: 4</span></div><div class="line"><span class="comment">// deque:    *i: 6</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;array&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deque&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;forward_list&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;list&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="all_8hpp.html">range/v3/all.hpp</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;vector&gt;</span></div><div class="line"><span class="keyword">using</span> std::cout;</div><div class="line"></div><div class="line"><span class="keyword">auto</span> is_six = [](<span class="keywordtype">int</span> i) -&gt; <span class="keywordtype">bool</span> { <span class="keywordflow">return</span> i == 6; };</div><div class="line"></div><div class="line"><span class="keywordtype">int</span></div><div class="line">main()</div><div class="line">{</div><div class="line">    cout &lt;&lt; <span class="stringliteral">&quot;vector:   &quot;</span>;</div><div class="line"></div><div class="line">    std::vector&lt;int&gt; v{6, 2, 6, 4, 6, 1};</div><div class="line">    {</div><div class="line">        <span class="keyword">auto</span> i = <a class="code" href="group__query.html#gabbc02ff93c48f94e03cfc4978bc377e1">ranges::find</a>(v, 6); <span class="comment">// 1 2 3 4 5 6</span></div><div class="line">        cout &lt;&lt; <span class="stringliteral">&quot;*i: &quot;</span> &lt;&lt; *i &lt;&lt; <span class="charliteral">&#39;\n&#39;</span>;</div><div class="line">    }</div><div class="line">    {</div><div class="line">        <span class="keyword">auto</span> i = <a class="code" href="group__query.html#gabbc02ff93c48f94e03cfc4978bc377e1">ranges::find</a>(v, 10); <span class="comment">// 1 2 3 4 5 6</span></div><div class="line">        <span class="keywordflow">if</span>(i == ranges::end(v))</div><div class="line">        {</div><div class="line">            cout &lt;&lt; <span class="stringliteral">&quot;didn&#39;t find 10\n&quot;</span>;</div><div class="line">        }</div><div class="line">    }</div><div class="line">    {</div><div class="line">        <span class="keyword">auto</span> i = <a class="code" href="group__query.html#ga0e1a6c503843d75130b3320dc3012fb7">ranges::find_if</a>(v, is_six);</div><div class="line">        <span class="keywordflow">if</span>(i != ranges::end(v))</div><div class="line">        {</div><div class="line">            cout &lt;&lt; <span class="stringliteral">&quot;*i: &quot;</span> &lt;&lt; *i &lt;&lt; <span class="charliteral">&#39;\n&#39;</span>;</div><div class="line">        }</div><div class="line">    }</div><div class="line">    {</div><div class="line">        <span class="keyword">auto</span> i = <a class="code" href="group__group-algorithms.html#ga08bc30fd08f204302b337ce54b3b07fd">ranges::find_if_not</a>(v, is_six);</div><div class="line">        <span class="keywordflow">if</span>(i != ranges::end(v))</div><div class="line">        {</div><div class="line">            cout &lt;&lt; <span class="stringliteral">&quot;*i: &quot;</span> &lt;&lt; *i &lt;&lt; <span class="charliteral">&#39;\n&#39;</span>;</div><div class="line">        }</div><div class="line">    }</div><div class="line">    {</div><div class="line">        <span class="keyword">auto</span> i = <a class="code" href="group__query.html#gabbc02ff93c48f94e03cfc4978bc377e1">ranges::find</a>(v, 6);</div><div class="line">        i++;</div><div class="line">        <span class="keywordflow">if</span>(i != ranges::end(v))</div><div class="line">        {</div><div class="line">            cout &lt;&lt; <span class="stringliteral">&quot;*i after ++ (2 expected): &quot;</span> &lt;&lt; *i;</div><div class="line">        }</div><div class="line">    }</div><div class="line"></div><div class="line">    cout &lt;&lt; <span class="stringliteral">&quot;\narray:    &quot;</span>;</div><div class="line"></div><div class="line">    std::array&lt;int, 6&gt; a{6, 2, 3, 4, 5, 1};</div><div class="line">    {</div><div class="line">        <span class="keyword">auto</span> i = <a class="code" href="group__query.html#gabbc02ff93c48f94e03cfc4978bc377e1">ranges::find</a>(a, 6);</div><div class="line">        <span class="keywordflow">if</span>(i != ranges::end(a))</div><div class="line">        {</div><div class="line">            cout &lt;&lt; <span class="stringliteral">&quot;*i: &quot;</span> &lt;&lt; *i;</div><div class="line">        }</div><div class="line">    }</div><div class="line">    cout &lt;&lt; <span class="stringliteral">&quot;\nlist:     &quot;</span>;</div><div class="line"></div><div class="line">    std::list&lt;int&gt; li{6, 2, 3, 4, 5, 1};</div><div class="line">    {</div><div class="line">        <span class="keyword">auto</span> i = <a class="code" href="group__query.html#gabbc02ff93c48f94e03cfc4978bc377e1">ranges::find</a>(li, 6);</div><div class="line">        <span class="keywordflow">if</span>(i != ranges::end(li))</div><div class="line">        {</div><div class="line">            cout &lt;&lt; <span class="stringliteral">&quot;*i: &quot;</span> &lt;&lt; *i;</div><div class="line">        }</div><div class="line">    }</div><div class="line"></div><div class="line">    cout &lt;&lt; <span class="stringliteral">&quot;\nfwd_list: &quot;</span>;</div><div class="line"></div><div class="line">    std::forward_list&lt;int&gt; fl{6, 2, 3, 4, 5, 1};</div><div class="line">    {</div><div class="line">        <span class="keyword">auto</span> i = <a class="code" href="group__query.html#gabbc02ff93c48f94e03cfc4978bc377e1">ranges::find</a>(fl, 4);</div><div class="line">        <span class="keywordflow">if</span>(i != ranges::end(fl))</div><div class="line">        {</div><div class="line">            cout &lt;&lt; <span class="stringliteral">&quot;*i: &quot;</span> &lt;&lt; *i;</div><div class="line">        }</div><div class="line">    }</div><div class="line">    cout &lt;&lt; <span class="stringliteral">&quot;\ndeque:    &quot;</span>;</div><div class="line"></div><div class="line">    std::deque&lt;int&gt; d{6, 2, 3, 4, 5, 1};</div><div class="line">    {</div><div class="line">        <span class="keyword">auto</span> i = <a class="code" href="group__query.html#gabbc02ff93c48f94e03cfc4978bc377e1">ranges::find</a>(d, 6);</div><div class="line">        <span class="keywordflow">if</span>(i != ranges::end(d))</div><div class="line">        {</div><div class="line">            cout &lt;&lt; <span class="stringliteral">&quot;*i: &quot;</span> &lt;&lt; *i;</div><div class="line">        }</div><div class="line">    }</div><div class="line">    cout &lt;&lt; <span class="charliteral">&#39;\n&#39;</span>;</div><div class="line">}</div></div><!-- fragment --> <h2><a class="anchor" id="example-for_each-seq"></a>
for_each on sequence containers</h2>
<div class="fragment"><div class="line"><span class="comment">// Use the for_each to print from various containers</span></div><div class="line"><span class="comment">// output</span></div><div class="line"><span class="comment">// vector:   1 2 3 4 5 6</span></div><div class="line"><span class="comment">// array:    1 2 3 4 5 6</span></div><div class="line"><span class="comment">// list:     1 2 3 4 5 6</span></div><div class="line"><span class="comment">// fwd_list: 1 2 3 4 5 6</span></div><div class="line"><span class="comment">// deque:    1 2 3 4 5 6</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;array&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deque&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;forward_list&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;list&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;queue&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="algorithm_2for__each_8hpp.html">range/v3/algorithm/for_each.hpp</a>&gt;</span> <span class="comment">// specific includes</span></div><div class="line"><span class="preprocessor">#include &lt;stack&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;vector&gt;</span></div><div class="line"><span class="keyword">using</span> std::cout;</div><div class="line"></div><div class="line"><span class="keyword">auto</span> print = [](<span class="keywordtype">int</span> i) { cout &lt;&lt; i &lt;&lt; <span class="charliteral">&#39; &#39;</span>; };</div><div class="line"></div><div class="line"><span class="keywordtype">int</span></div><div class="line">main()</div><div class="line">{</div><div class="line">    cout &lt;&lt; <span class="stringliteral">&quot;vector:   &quot;</span>;</div><div class="line">    std::vector&lt;int&gt; v{1, 2, 3, 4, 5, 6};</div><div class="line">    <a class="code" href="group__runtime.html#ga8beaba5ae537715c97e180b05160cc03">ranges::for_each</a>(v, print); <span class="comment">// 1 2 3 4 5 6</span></div><div class="line"></div><div class="line">    cout &lt;&lt; <span class="stringliteral">&quot;\narray:    &quot;</span>;</div><div class="line">    std::array&lt;int, 6&gt; a{1, 2, 3, 4, 5, 6};</div><div class="line">    <a class="code" href="group__runtime.html#ga8beaba5ae537715c97e180b05160cc03">ranges::for_each</a>(a, print);</div><div class="line"></div><div class="line">    cout &lt;&lt; <span class="stringliteral">&quot;\nlist:     &quot;</span>;</div><div class="line">    std::list&lt;int&gt; ll{1, 2, 3, 4, 5, 6};</div><div class="line">    <a class="code" href="group__runtime.html#ga8beaba5ae537715c97e180b05160cc03">ranges::for_each</a>(ll, print);</div><div class="line"></div><div class="line">    cout &lt;&lt; <span class="stringliteral">&quot;\nfwd_list: &quot;</span>;</div><div class="line">    std::forward_list&lt;int&gt; fl{1, 2, 3, 4, 5, 6};</div><div class="line">    <a class="code" href="group__runtime.html#ga8beaba5ae537715c97e180b05160cc03">ranges::for_each</a>(fl, print);</div><div class="line"></div><div class="line">    cout &lt;&lt; <span class="stringliteral">&quot;\ndeque:    &quot;</span>;</div><div class="line">    std::deque&lt;int&gt; d{1, 2, 3, 4, 5, 6};</div><div class="line">    <a class="code" href="group__runtime.html#ga8beaba5ae537715c97e180b05160cc03">ranges::for_each</a>(d, print);</div><div class="line">    cout &lt;&lt; <span class="charliteral">&#39;\n&#39;</span>;</div><div class="line">}</div></div><!-- fragment --> <h2><a class="anchor" id="example-for_each-assoc"></a>
for_each on associative containers</h2>
<div class="fragment"><div class="line"><span class="comment">// for_each with associative containers</span></div><div class="line"><span class="comment">// output</span></div><div class="line"><span class="comment">// set:           1 2 3 4 5 6</span></div><div class="line"><span class="comment">// map:           one:1 three:3 two:2</span></div><div class="line"><span class="comment">// unordered_map: three:3 one:1 two:2</span></div><div class="line"><span class="comment">// unordered_set: 6 5 4 3 2 1</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;map&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="algorithm_2for__each_8hpp.html">range/v3/algorithm/for_each.hpp</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;set&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;string&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;unordered_map&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;unordered_set&gt;</span></div><div class="line"><span class="keyword">using</span> std::cout;</div><div class="line"><span class="keyword">using</span> std::string;</div><div class="line"></div><div class="line"><span class="keyword">auto</span> print = [](<span class="keywordtype">int</span> i) { cout &lt;&lt; i &lt;&lt; <span class="charliteral">&#39; &#39;</span>; };</div><div class="line"><span class="comment">// must take a pair for map types</span></div><div class="line"><span class="keyword">auto</span> printm = [](std::pair&lt;string, int&gt; p) {</div><div class="line">    cout &lt;&lt; p.first &lt;&lt; <span class="stringliteral">&quot;:&quot;</span> &lt;&lt; p.second &lt;&lt; <span class="charliteral">&#39; &#39;</span>;</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keywordtype">int</span></div><div class="line">main()</div><div class="line">{</div><div class="line">    cout &lt;&lt; <span class="stringliteral">&quot;set:           &quot;</span>;</div><div class="line">    std::set&lt;int&gt; si{1, 2, 3, 4, 5, 6};</div><div class="line">    <a class="code" href="group__runtime.html#ga8beaba5ae537715c97e180b05160cc03">ranges::for_each</a>(si, print);</div><div class="line"></div><div class="line">    cout &lt;&lt; <span class="stringliteral">&quot;\nmap:           &quot;</span>;</div><div class="line">    std::map&lt;string, int&gt; msi{{<span class="stringliteral">&quot;one&quot;</span>, 1}, {<span class="stringliteral">&quot;two&quot;</span>, 2}, {<span class="stringliteral">&quot;three&quot;</span>, 3}};</div><div class="line">    <a class="code" href="group__runtime.html#ga8beaba5ae537715c97e180b05160cc03">ranges::for_each</a>(msi, printm);</div><div class="line"></div><div class="line">    cout &lt;&lt; <span class="stringliteral">&quot;\nunordered map: &quot;</span>;</div><div class="line">    std::unordered_map&lt;string, int&gt; umsi{{<span class="stringliteral">&quot;one&quot;</span>, 1}, {<span class="stringliteral">&quot;two&quot;</span>, 2}, {<span class="stringliteral">&quot;three&quot;</span>, 3}};</div><div class="line">    <a class="code" href="group__runtime.html#ga8beaba5ae537715c97e180b05160cc03">ranges::for_each</a>(umsi, printm);</div><div class="line"></div><div class="line">    cout &lt;&lt; <span class="stringliteral">&quot;\nunordered set: &quot;</span>;</div><div class="line">    std::unordered_set&lt;int&gt; usi{1, 2, 3, 4, 5, 6};</div><div class="line">    <a class="code" href="group__runtime.html#ga8beaba5ae537715c97e180b05160cc03">ranges::for_each</a>(usi, print);</div><div class="line">    cout &lt;&lt; <span class="charliteral">&#39;\n&#39;</span>;</div><div class="line">}</div></div><!-- fragment --> <h2><a class="anchor" id="example-is_sorted"></a>
is_sorted</h2>
<div class="fragment"><div class="line"><span class="comment">// Check if a container is sorted</span></div><div class="line"><span class="comment">// output</span></div><div class="line"><span class="comment">// vector:   true</span></div><div class="line"><span class="comment">// array:    false</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;array&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="is__sorted_8hpp.html">range/v3/algorithm/is_sorted.hpp</a>&gt;</span> <span class="comment">// specific includes</span></div><div class="line"><span class="preprocessor">#include &lt;vector&gt;</span></div><div class="line"><span class="keyword">using</span> std::cout;</div><div class="line"></div><div class="line"><span class="keywordtype">int</span></div><div class="line">main()</div><div class="line">{</div><div class="line">    cout &lt;&lt; std::boolalpha;</div><div class="line">    std::vector&lt;int&gt; v{1, 2, 3, 4, 5, 6};</div><div class="line">    cout &lt;&lt; <span class="stringliteral">&quot;vector:   &quot;</span> &lt;&lt; <a class="code" href="group__group-algorithms.html#ga0732f80413cd845b6f4d8a3e79a30a72">ranges::is_sorted</a>(v) &lt;&lt; <span class="charliteral">&#39;\n&#39;</span>;</div><div class="line"></div><div class="line">    std::array&lt;int, 6&gt; a{6, 2, 3, 4, 5, 6};</div><div class="line">    cout &lt;&lt; <span class="stringliteral">&quot;array:    &quot;</span> &lt;&lt; <a class="code" href="group__group-algorithms.html#ga0732f80413cd845b6f4d8a3e79a30a72">ranges::is_sorted</a>(a) &lt;&lt; <span class="charliteral">&#39;\n&#39;</span>;</div><div class="line">}</div></div><!-- fragment --></div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.14 </li>
  </ul>
</div>
</body>
</html>
